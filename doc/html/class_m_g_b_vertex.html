<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGBVertex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>MGBVertex Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGBVertex" --><!-- doxytag: inherits="MGCellNB" -->
<p><a class="el" href="class_m_g_b_vertex.html" title="MGBVertex is 0 manifold dimension binder cell, is an point.">MGBVertex</a> is 0 manifold dimension binder cell, is an point.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;BVertex.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGBVertex:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_b_vertex__inherit__graph.png" border="0" usemap="#_m_g_b_vertex_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_b_vertex_inherit__map" id="_m_g_b_vertex_inherit__map">
<area shape="rect" id="node2" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="17,392,100,421"/><area shape="rect" id="node4" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="12,315,105,344"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="12,237,105,267"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGBVertex:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_b_vertex__coll__graph.png" border="0" usemap="#_m_g_b_vertex_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_b_vertex_coll__map" id="_m_g_b_vertex_coll__map">
<area shape="rect" id="node2" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="196,677,279,707"/><area shape="rect" id="node4" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="276,773,369,803"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="303,485,396,515"/><area shape="rect" id="node32" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="225,581,319,611"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="112,373,192,403"/><area shape="rect" id="node23" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="103,581,201,611"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,85,112,115"/><area shape="rect" id="node16" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="113,181,191,211"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node14" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="96,261,208,291"/><area shape="rect" id="node19" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="136,85,269,115"/><area shape="rect" id="node26" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="212,485,279,515"/><area shape="rect" id="node28" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="223,373,305,403"/><area shape="rect" id="node30" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="232,261,309,291"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_b_vertex-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a17db11b6a25dd906e243c868dce3e"></a><!-- doxytag: member="MGBVertex::MGBVertex" ref="a77a17db11b6a25dd906e243c868dce3e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a77a17db11b6a25dd906e243c868dce3e">MGBVertex</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a44c8ad2051bcbacbf6306398ff25a942">MGBVertex</a> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> *geo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a44c8ad2051bcbacbf6306398ff25a942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd963fcc91ba9c809ffc629e1e2767f2"></a><!-- doxytag: member="MGBVertex::MGBVertex" ref="abd963fcc91ba9c809ffc629e1e2767f2" args="(const MGPosition &amp;V)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#abd963fcc91ba9c809ffc629e1e2767f2">MGBVertex</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;V)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeed4594466d6d80589be3f3fe5edda3"></a><!-- doxytag: member="MGBVertex::‾MGBVertex" ref="afeed4594466d6d80589be3f3fe5edda3" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGBVertex</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a90dbf196cc939aafd478ade710431a7e">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a90dbf196cc939aafd478ade710431a7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe38b4d6c9d4f961ee327fa7bcce4a93"></a><!-- doxytag: member="MGBVertex::operator=" ref="abe38b4d6c9d4f961ee327fa7bcce4a93" args="(const MGBVertex &amp;gel2)" -->
<a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e4bc122596e7334b4b5b3f51817ef15"></a><!-- doxytag: member="MGBVertex::operator&lt;" ref="a3e4bc122596e7334b4b5b3f51817ef15" args="(const MGBVertex &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a3e4bc122596e7334b4b5b3f51817ef15">operator&lt;</a> (const <a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab982781cee1b36e2c38ef54c05c6e136"></a><!-- doxytag: member="MGBVertex::operator&lt;" ref="ab982781cee1b36e2c38ef54c05c6e136" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e4fca456c8a31d67210d9ce2ad1e21c"></a><!-- doxytag: member="MGBVertex::box" ref="a3e4fca456c8a31d67210d9ce2ad1e21c" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a3e4fca456c8a31d67210d9ce2ad1e21c">box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the box into which the topology is included. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2f6f516aeaff088ca8cd552e62aa4ef"></a><!-- doxytag: member="MGBVertex::center_param" ref="ab2f6f516aeaff088ca8cd552e62aa4ef" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#ab2f6f516aeaff088ca8cd552e62aa4ef">center_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the center parameter value of this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a071181c849f97528ad6bf498fb5f8b14">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of the cell.  <a href="#a071181c849f97528ad6bf498fb5f8b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a48dce5ebbf6d35b532038dc386b411e6">clone_without_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of the cell without boundaries.  <a href="#a48dce5ebbf6d35b532038dc386b411e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a50ddc2bd32fc64d36129e3dfa35a98a8">clone_binder</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of this(this is a binder), and set binder and member partner relation between the new binder and the cell c.  <a href="#a50ddc2bd32fc64d36129e3dfa35a98a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a60759cb685da4d28bf145ffbbcd08ceb">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#a60759cb685da4d28bf145ffbbcd08ceb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a79806eb152bb0dbf49b14053f49e5d69">draw3DVertex</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D point(vertex) in world coordinates.  <a href="#a79806eb152bb0dbf49b14053f49e5d69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de0033f424d719370aaeb5d9362df85"></a><!-- doxytag: member="MGBVertex::free_neighbourhood" ref="a3de0033f424d719370aaeb5d9362df85" args="(size_t i, size_t j=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a3de0033f424d719370aaeb5d9362df85">free_neighbourhood</a> (size_t i, size_t j=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free neighbourhood relation at j-th boundary's i-th pcell of this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeec570a91b3f8eaabef413b96424f41"></a><!-- doxytag: member="MGBVertex::identify_type" ref="aaeec570a91b3f8eaabef413b96424f41" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#aaeec570a91b3f8eaabef413b96424f41">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a8823245c4ef44186aecc572be43138e0">make_binder</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a binder cell of this cell.  <a href="#a8823245c4ef44186aecc572be43138e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad64885669605f3ebf1ffeeda3d61ed50"></a><!-- doxytag: member="MGBVertex::manifold_dimension" ref="ad64885669605f3ebf1ffeeda3d61ed50" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#ad64885669605f3ebf1ffeeda3d61ed50">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8566d731b6fab50a8dcfa96284765c18"></a><!-- doxytag: member="MGBVertex::member_partner_vertex" ref="a8566d731b6fab50a8dcfa96284765c18" args="(size_t i) const " -->
const <a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a8566d731b6fab50a8dcfa96284765c18">member_partner_vertex</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the i-th member partner PVertex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a7174de979bda6728787372c0d5950433">neighbours</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the neighbours.  <a href="#a7174de979bda6728787372c0d5950433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa7b5cf6b323a19485b435310aa66fa1"></a><!-- doxytag: member="MGBVertex::out" ref="aaa7b5cf6b323a19485b435310aa66fa1" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#aaa7b5cf6b323a19485b435310aa66fa1">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac12a7140ffb6f619b6fe82768192eba1"></a><!-- doxytag: member="MGBVertex::parameter_error" ref="ac12a7140ffb6f619b6fe82768192eba1" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#ac12a7140ffb6f619b6fe82768192eba1">parameter_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter space error of the cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a4f2eb1b7389bc3ebf37525797aec58ff">pick_closest</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parameter value of the closest point from the straight to this object.  <a href="#a4f2eb1b7389bc3ebf37525797aec58ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acad19d56d7c70d99f971fae18010943e"></a><!-- doxytag: member="MGBVertex::point" ref="acad19d56d7c70d99f971fae18010943e" args="() const " -->
const <a class="el" href="class_m_g_point.html">MGPoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#acad19d56d7c70d99f971fae18010943e">point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return extent data(i.e. MGPoint*), which may be null if this has no extent. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#ab98a3b664a7dfdbf505175835c6f00e2">position</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the position data of this vertex.  <a href="#ab98a3b664a7dfdbf505175835c6f00e2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a99b83a4f4cd9d058f7fa056a3d7e79cf">bn_binder_tr</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform the boundary binders.  <a href="#a99b83a4f4cd9d058f7fa056a3d7e79cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbf34f74e8ef1483e80b2c6881080a39"></a><!-- doxytag: member="MGBVertex::bn_binder_tr" ref="acbf34f74e8ef1483e80b2c6881080a39" args="(double s)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bn_binder_tr</b> (double s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a3d25e94bcb1bd8282bed75fce0dc2"></a><!-- doxytag: member="MGBVertex::bn_binder_tr" ref="a50a3d25e94bcb1bd8282bed75fce0dc2" args="(const MGMatrix &amp;mat)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bn_binder_tr</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cf83c17120ae065b022a9d15ae5a81c"></a><!-- doxytag: member="MGBVertex::bn_binder_tr" ref="a4cf83c17120ae065b022a9d15ae5a81c" args="(const MGTransf &amp;tr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>bn_binder_tr</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0ea9d10383cc90b413db451d14cf0bc"></a><!-- doxytag: member="MGBVertex::set_box_as_null" ref="ae0ea9d10383cc90b413db451d14cf0bc" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#ae0ea9d10383cc90b413db451d14cf0bc">set_box_as_null</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the box data as null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a13a59895e6cfe95bc1811ee35b02e1a8">clone</a> (MGCellMap &amp;cmap) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a new <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a> pointer by newing the original <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a>.  <a href="#a13a59895e6cfe95bc1811ee35b02e1a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5258b379f4f800320c442130e97d38"></a><!-- doxytag: member="MGBVertex::compute_box" ref="aaa5258b379f4f800320c442130e97d38" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#aaa5258b379f4f800320c442130e97d38">compute_box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute box of the cell in m_box. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a993fd007a4c01ec65231efdbd11bae22"></a><!-- doxytag: member="MGBVertex::copy_all_boundaries" ref="a993fd007a4c01ec65231efdbd11bae22" args="(const MGCellBase &amp;cell2)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a993fd007a4c01ec65231efdbd11bae22">copy_all_boundaries</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy boundary data of cell2 into this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#af17b6a0fd98b48c9578b318d30957009">copy_all_boundaries</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2, MGCellMap &amp;cmap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all boundaries of cell into this, and binders association of the boundaries in the cmap.  <a href="#af17b6a0fd98b48c9578b318d30957009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca74d3ab0392e1c6e8a0c19bdb7f7ed7"></a><!-- doxytag: member="MGBVertex::copy_box" ref="aca74d3ab0392e1c6e8a0c19bdb7f7ed7" args="(const MGCellBase &amp;cell2) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#aca74d3ab0392e1c6e8a0c19bdb7f7ed7">copy_box</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy m_box data of cell2 into this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60a3d0ca39361cd2e8159f28ece1f8a9"></a><!-- doxytag: member="MGBVertex::copy_perror" ref="a60a3d0ca39361cd2e8159f28ece1f8a9" args="(const MGCellBase &amp;cell2) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a60a3d0ca39361cd2e8159f28ece1f8a9">copy_perror</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy m_perror data of cell2 into this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#ad596a17ccbdf9473c144b2bbbf52f8b6">get_all_boundary_binders</a> (std::vector&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt; &amp;cvec) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get boundary biders of all the boundaries.  <a href="#ad596a17ccbdf9473c144b2bbbf52f8b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f4062ed30f555a5fdb0e6c324a2de67"></a><!-- doxytag: member="MGBVertex::negate_boundary" ref="a1f4062ed30f555a5fdb0e6c324a2de67" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a1f4062ed30f555a5fdb0e6c324a2de67">negate_boundary</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb85a52966e08dbe75221fb151df2e66"></a><!-- doxytag: member="MGBVertex::whoami" ref="abb85a52966e08dbe75221fb151df2e66" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a701245d9c3397ec6e425f9b3f40e0bfa"></a><!-- doxytag: member="MGBVertex::ReadMembers" ref="a701245d9c3397ec6e425f9b3f40e0bfa" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a701245d9c3397ec6e425f9b3f40e0bfa">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5232746c707270a3560fbf143106f1c0"></a><!-- doxytag: member="MGBVertex::WriteMembers" ref="a5232746c707270a3560fbf143106f1c0" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_vertex.html#a5232746c707270a3560fbf143106f1c0">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_b_vertex.html" title="MGBVertex is 0 manifold dimension binder cell, is an point.">MGBVertex</a> is 0 manifold dimension binder cell, is an point. </p>
<p><a class="el" href="class_m_g_b_vertex.html" title="MGBVertex is 0 manifold dimension binder cell, is an point.">MGBVertex</a> is a binder cell of <a class="el" href="class_m_g_p_vertex.html" title="MGPVertex is a parameter cell of the manifold dimension 0.">MGPVertex</a>, and has manifold dimension 0. <a class="el" href="class_m_g_b_vertex.html" title="MGBVertex is 0 manifold dimension binder cell, is an point.">MGBVertex</a> is not used as a parameter cell(boundary of an edge). Since MGBVertex's manifold dimension is 0, <a class="el" href="class_m_g_b_vertex.html" title="MGBVertex is 0 manifold dimension binder cell, is an point.">MGBVertex</a> does not have boundaries. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a44c8ad2051bcbacbf6306398ff25a942"></a><!-- doxytag: member="MGBVertex::MGBVertex" ref="a44c8ad2051bcbacbf6306398ff25a942" args="(MGGeometry *geo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBVertex::MGBVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_geometry.html">MGGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>geo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>MGBVertex(const MGBVertex&amp;v); Fundamental constructor. Construct a BVertex from geometry of manifold dimension 0 (MGPoint*, may be null). The constructor takes the ownership of geo. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a99b83a4f4cd9d058f7fa056a3d7e79cf"></a><!-- doxytag: member="MGBVertex::bn_binder_tr" ref="a99b83a4f4cd9d058f7fa056a3d7e79cf" args="(const MGVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBVertex::bn_binder_tr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the boundary binders. </p>
<p>Since a vertex has no boundary, no process is done. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a071181c849f97528ad6bf498fb5f8b14"></a><!-- doxytag: member="MGBVertex::clone" ref="a071181c849f97528ad6bf498fb5f8b14" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a>* MGBVertex::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of the cell. </p>
<p><a class="el" href="class_m_g_b_vertex.html#a071181c849f97528ad6bf498fb5f8b14" title="Make a clone of the cell.">clone()</a>, <a class="el" href="class_m_g_b_vertex.html#a48dce5ebbf6d35b532038dc386b411e6" title="Make a clone of the cell without boundaries.">clone_without_boundaries()</a> does not copy the binder cell relation. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a735842331fa8e53bdc26fee5d50df7ab">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a13a59895e6cfe95bc1811ee35b02e1a8"></a><!-- doxytag: member="MGBVertex::clone" ref="a13a59895e6cfe95bc1811ee35b02e1a8" args="(MGCellMap &amp;cmap) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a>* MGBVertex::clone </td>
          <td>(</td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a new <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a> pointer by newing the original <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a>. </p>
<p>This is a proprietry routine of <a class="el" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells.">MGComplex</a> copy. Copy all boundary data, (but does not copy own binder cell relation) and register boundary binder association of new and old into cmap. </p>

<p>Reimplemented from <a class="el" href="class_m_g_cell_n_b.html#a8071eedf119853d20f8fbe7ccb407f30">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a50ddc2bd32fc64d36129e3dfa35a98a8"></a><!-- doxytag: member="MGBVertex::clone_binder" ref="a50ddc2bd32fc64d36129e3dfa35a98a8" args="(const MGCellBase &amp;c) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a>* MGBVertex::clone_binder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of this(this is a binder), and set binder and member partner relation between the new binder and the cell c. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#ac17dacc0a49fb6084ab04736f31d99b9">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a48dce5ebbf6d35b532038dc386b411e6"></a><!-- doxytag: member="MGBVertex::clone_without_boundaries" ref="a48dce5ebbf6d35b532038dc386b411e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a>* MGBVertex::clone_without_boundaries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of the cell without boundaries. </p>
<p><a class="el" href="class_m_g_b_vertex.html#a48dce5ebbf6d35b532038dc386b411e6" title="Make a clone of the cell without boundaries.">clone_without_boundaries()</a> does not copy the binder cell relation. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a7f2987e98eaa1221a993c5bd37b0836f">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="af17b6a0fd98b48c9578b318d30957009"></a><!-- doxytag: member="MGBVertex::copy_all_boundaries" ref="af17b6a0fd98b48c9578b318d30957009" args="(const MGCellBase &amp;cell2, MGCellMap &amp;cmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBVertex::copy_all_boundaries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cell2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all boundaries of cell into this, and binders association of the boundaries in the cmap. </p>
<p>Binder cells of cell will be registered in cmap. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a79806eb152bb0dbf49b14053f49e5d69"></a><!-- doxytag: member="MGBVertex::draw3DVertex" ref="a79806eb152bb0dbf49b14053f49e5d69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBVertex::draw3DVertex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D point(vertex) in world coordinates. </p>
<p>The object is converted to point(s) and is drawn. This is valid only for topology objects or <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a893bb5e4f0fcfe2bab43b413a9b57d53">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a60759cb685da4d28bf145ffbbcd08ceb"></a><!-- doxytag: member="MGBVertex::drawWire" ref="a60759cb685da4d28bf145ffbbcd08ceb" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBVertex::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_object.html#ad422cfd57a3a6daedd7762001cb04a8f">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="ad596a17ccbdf9473c144b2bbbf52f8b6"></a><!-- doxytag: member="MGBVertex::get_all_boundary_binders" ref="ad596a17ccbdf9473c144b2bbbf52f8b6" args="(std::vector&lt; MGCellNB * &gt; &amp;cvec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBVertex::get_all_boundary_binders </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get boundary biders of all the boundaries. </p>
<p>Binders will be appended to cvec. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a8823245c4ef44186aecc572be43138e0"></a><!-- doxytag: member="MGBVertex::make_binder" ref="a8823245c4ef44186aecc572be43138e0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>* MGBVertex::make_binder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a binder cell of this cell. </p>
<p>Returned is the binder pointer newed. The binder has no geometry, only has binder and partner member relationship. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a660e0dcb574bbd92a34075412ea8c9bb">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a7174de979bda6728787372c0d5950433"></a><!-- doxytag: member="MGBVertex::neighbours" ref="a7174de979bda6728787372c0d5950433" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>*&gt; MGBVertex::neighbours </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain all the neighbours. </p>
<p>The neighbours do not contain this cell except when this cell is connected to this cell itself(closed cell). A vertex has no boundaries, and has no neighbours. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a7b2d010eda4c20b53714e3341abde288">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a90dbf196cc939aafd478ade710431a7e"></a><!-- doxytag: member="MGBVertex::operator=" ref="a90dbf196cc939aafd478ade710431a7e" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a>&amp; MGBVertex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and cell2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2eb1b7389bc3ebf37525797aec58ff"></a><!-- doxytag: member="MGBVertex::pick_closest" ref="a4f2eb1b7389bc3ebf37525797aec58ff" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGBVertex::pick_closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parameter value of the closest point from the straight to this object. </p>
<p>sl is the eye projection line whose direction is from yon to hither, and if sl had multiple intersection points, The closest point to the eye will be selected. This will be never invoked. </p>

<p>Reimplemented from <a class="el" href="class_m_g_object.html#afad70053cb311ff1a2a7ab86b9a4e1a7">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="ab98a3b664a7dfdbf505175835c6f00e2"></a><!-- doxytag: member="MGBVertex::position" ref="ab98a3b664a7dfdbf505175835c6f00e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGBVertex::position </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the position data of this vertex. </p>
<p>Returns <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a> data if this has extent. Otherwise obtain from partner's star edge by evaluating the edge's data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>BVertex.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:18 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

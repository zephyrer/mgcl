<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGCL Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>MGCL Namespace Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>,&nbsp;<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a> namespace defines varialbes without prefix mg or MG.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceae">fan_kind</a> { <a class="el" href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceaeaf590c6bc2055e2934d615e8bb9c2e570">SINGLE_TRIANGLE</a>, 
<a class="el" href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceaea4adb92b3f0d7df644cde57cc2f0f26d8">MULTIPLE_TRIANGLES</a>, 
<a class="el" href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceaea2ae42f9c0cadd2a1aae6a918fbaef4a2">SINGLE_TRIANGLE_NO_STRIP</a>, 
<a class="el" href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceaeabb4d1919fad42d06d5beee95a5a0651a">MULTIPLE_TRIANGLES_NO_STRIP</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Tessellation parameter to select fan kind for the tessellation. </p>
 <a href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceae">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#aad8db2e49f590d48bc4f5d8d746afb8f">SURFACE_CURVATURE_KIND</a> { <a class="el" href="namespace_m_g_c_l.html#aad8db2e49f590d48bc4f5d8d746afb8fa56045c9068ca96344240621ec1f03417">GAUSSIAN_CURVATURE</a> =  0, 
<a class="el" href="namespace_m_g_c_l.html#aad8db2e49f590d48bc4f5d8d746afb8fadfd58ea5888d44044eea76b6855d44e0">MEAN_CURVATURE</a> =  1, 
<a class="el" href="namespace_m_g_c_l.html#aad8db2e49f590d48bc4f5d8d746afb8fa88255051007a4f54bcb713c9453e5262">MINIMUM_CURVATURE</a> =  2, 
<a class="el" href="namespace_m_g_c_l.html#aad8db2e49f590d48bc4f5d8d746afb8fa1068c61de6391dc0767ad3d7280160a2">MAXIMUM_CURVATURE</a> =  3
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a05e665eb14aefe878f5e9246ff35fdf4">VIEWMODE</a> { <a class="el" href="namespace_m_g_c_l.html#a05e665eb14aefe878f5e9246ff35fdf4ac8e70b29ff7b0581be9c4a3d69187728">WIRE</a> = 0, 
<a class="el" href="namespace_m_g_c_l.html#a05e665eb14aefe878f5e9246ff35fdf4a4dc386c70d6ea8f615152a417ba8f9e5">SHADING</a> = 1, 
<a class="el" href="namespace_m_g_c_l.html#a05e665eb14aefe878f5e9246ff35fdf4adcafa7f392746ab8ca8a4383b7e2b8da">WIRE_AND_SHADING</a> = 2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Display mode of <a class="el" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology.">MGObject</a>. </p>
 <a href="namespace_m_g_c_l.html#a05e665eb14aefe878f5e9246ff35fdf4">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#aa63f0f5e22d58cf03bded3036790846a">convert_to_rational</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a curve that has weight.  <a href="#aa63f0f5e22d58cf03bded3036790846a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c7f920fedc923eaf58ad5a4718d52d"></a><!-- doxytag: member="MGCL::degree_to_radian" ref="ae5c7f920fedc923eaf58ad5a4718d52d" args="(double degree)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#ae5c7f920fedc923eaf58ad5a4718d52d">degree_to_radian</a> (double degree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert the angel unit from degree to radian. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cde077a27f84785ecd2159bd0588152"></a><!-- doxytag: member="MGCL::radian_to_degree" ref="a2cde077a27f84785ecd2159bd0588152" args="(double radian)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a2cde077a27f84785ecd2159bd0588152">radian_to_degree</a> (double radian)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert the angel unit from radian to degree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#ad36d800a6c89006d8f70c3f723ec0f8e">start_up</a> (bool need_to_GdiStartUp=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start up the <a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a>.  <a href="#ad36d800a6c89006d8f70c3f723ec0f8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9efac6eb2f3e3bc87294ff536f04f4f5"></a><!-- doxytag: member="MGCL::shut_down" ref="a9efac6eb2f3e3bc87294ff536f04f4f5" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a9efac6eb2f3e3bc87294ff536f04f4f5">shut_down</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the <a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0743f6a1bab6471d199a28fec6965c5a"></a><!-- doxytag: member="MGCL::Max3" ref="a0743f6a1bab6471d199a28fec6965c5a" args="(double a1, double a2, double a3)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a0743f6a1bab6471d199a28fec6965c5a">Max3</a> (double a1, double a2, double a3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the difference of min and max of the three doubles a1, a2, and a3. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a2e372c94c68b5a226c1a2200c67ab91a">createSurfaceFromRibs</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;curves, bool direction_adjustment=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リブ曲線列から面を作成する リブ曲線の全てのノットが同じスプラインの時MGSBRepかMGRSBRepが返却される それ以外の場合は、曲線をLBRepで再構成して面を作成するのでMGSBRepが返却される 作成する面のノットベクトルはリブ曲線の向きをu,リブ列方向をvとする curves[i] must have the same direction.  <a href="#a2e372c94c68b5a226c1a2200c67ab91a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#ac4079d9450905c7fc991a3d8c07bd04e">createSurfaceFromRibs</a> (const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;curves, bool direction_adjustment=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a73e383543fa8df813b0727e53187d085">create_ruled_surface</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;cross1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;cross2, bool direction_adjustment=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a ruled surface.  <a href="#a73e383543fa8df813b0727e53187d085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html#a33e6bd4b6081e938b15cabe6d83ec674">create_revolved_surface</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;axis, double angle=<a class="el" href="group___b_a_s_e.html#ga2ab7c015a009fa7d1fc3386171e60f08">mgDBLPAI</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a surface of revolution.  <a href="#a33e6bd4b6081e938b15cabe6d83ec674"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a> namespace defines varialbes without prefix mg or MG. </p>
<p>From historical reasons, varialbes with prefix mg or MG are not included in <a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a> namespace. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a165560a05da967ee71b8291d766bceae"></a><!-- doxytag: member="MGCL::fan_kind" ref="a165560a05da967ee71b8291d766bceae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_m_g_c_l.html#a165560a05da967ee71b8291d766bceae">MGCL::fan_kind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tessellation parameter to select fan kind for the tessellation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a165560a05da967ee71b8291d766bceaeaf590c6bc2055e2934d615e8bb9c2e570"></a><!-- doxytag: member="SINGLE_TRIANGLE" ref="a165560a05da967ee71b8291d766bceaeaf590c6bc2055e2934d615e8bb9c2e570" args="" -->SINGLE_TRIANGLE</em>&nbsp;</td><td>
<p>1 triangle/FAN(default) and STRIP for as many as posible triangles, </p>
<p>STRIP triangles may cover multiple rectangles. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a165560a05da967ee71b8291d766bceaea4adb92b3f0d7df644cde57cc2f0f26d8"></a><!-- doxytag: member="MULTIPLE_TRIANGLES" ref="a165560a05da967ee71b8291d766bceaea4adb92b3f0d7df644cde57cc2f0f26d8" args="" -->MULTIPLE_TRIANGLES</em>&nbsp;</td><td>
<p>as many triangles as possible/FAN and STRIP for as many as posible triangles, </p>
<p>STRIP triangles may cover multiple rectangles. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a165560a05da967ee71b8291d766bceaea2ae42f9c0cadd2a1aae6a918fbaef4a2"></a><!-- doxytag: member="SINGLE_TRIANGLE_NO_STRIP" ref="a165560a05da967ee71b8291d766bceaea2ae42f9c0cadd2a1aae6a918fbaef4a2" args="" -->SINGLE_TRIANGLE_NO_STRIP</em>&nbsp;</td><td>
<p>SINGLE_TRIANGLE, but STRIP triangles cover only one tessellated rectagle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a165560a05da967ee71b8291d766bceaeabb4d1919fad42d06d5beee95a5a0651a"></a><!-- doxytag: member="MULTIPLE_TRIANGLES_NO_STRIP" ref="a165560a05da967ee71b8291d766bceaeabb4d1919fad42d06d5beee95a5a0651a" args="" -->MULTIPLE_TRIANGLES_NO_STRIP</em>&nbsp;</td><td>
<p>MULTIPLE_TRIANGLES, but STRIP triangles cover only one tessellated rectagle. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aad8db2e49f590d48bc4f5d8d746afb8f"></a><!-- doxytag: member="MGCL::SURFACE_CURVATURE_KIND" ref="aad8db2e49f590d48bc4f5d8d746afb8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_m_g_c_l.html#aad8db2e49f590d48bc4f5d8d746afb8f">MGCL::SURFACE_CURVATURE_KIND</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aad8db2e49f590d48bc4f5d8d746afb8fa56045c9068ca96344240621ec1f03417"></a><!-- doxytag: member="GAUSSIAN_CURVATURE" ref="aad8db2e49f590d48bc4f5d8d746afb8fa56045c9068ca96344240621ec1f03417" args="" -->GAUSSIAN_CURVATURE</em>&nbsp;</td><td>
<p>Gaussian curvature. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad8db2e49f590d48bc4f5d8d746afb8fadfd58ea5888d44044eea76b6855d44e0"></a><!-- doxytag: member="MEAN_CURVATURE" ref="aad8db2e49f590d48bc4f5d8d746afb8fadfd58ea5888d44044eea76b6855d44e0" args="" -->MEAN_CURVATURE</em>&nbsp;</td><td>
<p>mean curvature </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad8db2e49f590d48bc4f5d8d746afb8fa88255051007a4f54bcb713c9453e5262"></a><!-- doxytag: member="MINIMUM_CURVATURE" ref="aad8db2e49f590d48bc4f5d8d746afb8fa88255051007a4f54bcb713c9453e5262" args="" -->MINIMUM_CURVATURE</em>&nbsp;</td><td>
<p>the minimum curvature </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aad8db2e49f590d48bc4f5d8d746afb8fa1068c61de6391dc0767ad3d7280160a2"></a><!-- doxytag: member="MAXIMUM_CURVATURE" ref="aad8db2e49f590d48bc4f5d8d746afb8fa1068c61de6391dc0767ad3d7280160a2" args="" -->MAXIMUM_CURVATURE</em>&nbsp;</td><td>
<p>the maximum curvature </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a05e665eb14aefe878f5e9246ff35fdf4"></a><!-- doxytag: member="MGCL::VIEWMODE" ref="a05e665eb14aefe878f5e9246ff35fdf4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_m_g_c_l.html#a05e665eb14aefe878f5e9246ff35fdf4">MGCL::VIEWMODE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display mode of <a class="el" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology.">MGObject</a>. </p>
<p>SHADING and WIRE_AND_SHADING are valid only for <a class="el" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology.">MGObject</a> of manifold dimension 2. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a05e665eb14aefe878f5e9246ff35fdf4ac8e70b29ff7b0581be9c4a3d69187728"></a><!-- doxytag: member="WIRE" ref="a05e665eb14aefe878f5e9246ff35fdf4ac8e70b29ff7b0581be9c4a3d69187728" args="" -->WIRE</em>&nbsp;</td><td>
<p>wire frame mode </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a05e665eb14aefe878f5e9246ff35fdf4a4dc386c70d6ea8f615152a417ba8f9e5"></a><!-- doxytag: member="SHADING" ref="a05e665eb14aefe878f5e9246ff35fdf4a4dc386c70d6ea8f615152a417ba8f9e5" args="" -->SHADING</em>&nbsp;</td><td>
<p>surface mode </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a05e665eb14aefe878f5e9246ff35fdf4adcafa7f392746ab8ca8a4383b7e2b8da"></a><!-- doxytag: member="WIRE_AND_SHADING" ref="a05e665eb14aefe878f5e9246ff35fdf4adcafa7f392746ab8ca8a4383b7e2b8da" args="" -->WIRE_AND_SHADING</em>&nbsp;</td><td>
<p>wire and surface mode </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa63f0f5e22d58cf03bded3036790846a"></a><!-- doxytag: member="MGCL::convert_to_rational" ref="aa63f0f5e22d58cf03bded3036790846a" args="(const MGCurve &amp;curve)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>* MGCL::convert_to_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a curve that has weight. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>曲線オブジェクト Returned object is a newed object. User must delete it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33e6bd4b6081e938b15cabe6d83ec674"></a><!-- doxytag: member="MGCL::create_revolved_surface" ref="a33e6bd4b6081e938b15cabe6d83ec674" args="(const MGCurve &amp;curve, const MGStraight &amp;axis, double angle=mgDBLPAI)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGCL::create_revolved_surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em> = <code><a class="el" href="group___b_a_s_e.html#ga2ab7c015a009fa7d1fc3386171e60f08">mgDBLPAI</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a surface of revolution. </p>
<p>Parameterization of the surface is: u=const parameter line generates given curve(when u=0.). v=const parameter line generates a circle whose center is axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>generatrix curve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>revolution axis </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>revolution angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73e383543fa8df813b0727e53187d085"></a><!-- doxytag: member="MGCL::create_ruled_surface" ref="a73e383543fa8df813b0727e53187d085" args="(const MGCurve &amp;cross1, const MGCurve &amp;cross2, bool direction_adjustment=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGCL::create_ruled_surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cross1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cross2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>direction_adjustment</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a ruled surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cross1</em>&nbsp;</td><td>a curve as Edge No.1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cross2</em>&nbsp;</td><td>another curve as Edge No.2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4079d9450905c7fc991a3d8c07bd04e"></a><!-- doxytag: member="MGCL::createSurfaceFromRibs" ref="ac4079d9450905c7fc991a3d8c07bd04e" args="(const std::vector&lt; const MGCurve * &gt; &amp;curves, bool direction_adjustment=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGCL::createSurfaceFromRibs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>direction_adjustment</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curves</em>&nbsp;</td><td>リブ曲線列 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e372c94c68b5a226c1a2200c67ab91a"></a><!-- doxytag: member="MGCL::createSurfaceFromRibs" ref="a2e372c94c68b5a226c1a2200c67ab91a" args="(const MGPvector&lt; MGCurve &gt; &amp;curves, bool direction_adjustment=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGCL::createSurfaceFromRibs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>direction_adjustment</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>リブ曲線列から面を作成する リブ曲線の全てのノットが同じスプラインの時MGSBRepかMGRSBRepが返却される それ以外の場合は、曲線をLBRepで再構成して面を作成するのでMGSBRepが返却される 作成する面のノットベクトルはリブ曲線の向きをu,リブ列方向をvとする curves[i] must have the same direction. </p>
<p>Let v0=start parameter value, v1=terminate parameter value along v, then v=v0 const parameter line is curves[0], and v=v1 const parameter line is curves[n-1], where n=curves.size(). n must be greater or equal to 2. When n==2, the surface is a ruled surface(that is, order_u() is 2). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curves</em>&nbsp;</td><td>リブ曲線列 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad36d800a6c89006d8f70c3f723ec0f8e"></a><!-- doxytag: member="MGCL::start_up" ref="ad36d800a6c89006d8f70c3f723ec0f8e" args="(bool need_to_GdiStartUp=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCL::start_up </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>need_to_GdiStartUp</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start up the <a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a>. </p>
<p>This is necessary only when MGIgesxxxx class or <a class="el" href="class_m_g_image.html" title="Define MGImage Class.">MGImage</a> or MGTexturexxxxx class is to use. Before use of GDIplus, GdiStartUp is necessary, this start_up will do it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>need_to_GdiStartUp</em>&nbsp;</td><td>True if GdiplusStartUp is necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:31 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGRSBRep Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGRSBRep Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGRSBRep" --><!-- doxytag: inherits="MGSurface" -->
<p>Defines Surface B-Representation of rational form.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;RSBRep.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGRSBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_r_s_b_rep__inherit__graph.png" border="0" usemap="#_m_g_r_s_b_rep_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_r_s_b_rep_inherit__map" id="_m_g_r_s_b_rep_inherit__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="76,315,161,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node12" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="132,237,225,267"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGRSBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_r_s_b_rep__coll__graph.png" border="0" usemap="#_m_g_r_s_b_rep_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_r_s_b_rep_coll__map" id="_m_g_r_s_b_rep_coll__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="264,581,349,611"/><area shape="rect" id="node28" href="class_m_g_s_b_rep.html" title="Defines Surface B&#45;Representation, that is , B&#45;Spline surface." alt="" coords="155,693,237,723"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="257,501,356,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="204,405,284,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="200,85,307,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="109,181,187,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="223,5,284,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="92,293,204,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="43,85,176,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="308,405,375,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="300,293,383,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="303,181,380,211"/><area shape="rect" id="node26" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="380,501,473,531"/><area shape="rect" id="node31" href="class_m_g_s_point_seq.html" title="Defines Spoint seq of a space dimension and of a size." alt="" coords="5,581,109,611"/><area shape="rect" id="node33" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="133,581,240,611"/><area shape="rect" id="node35" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="132,501,233,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_r_s_b_rep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add3e77a284a9bc1181573662995cd7f5"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="add3e77a284a9bc1181573662995cd7f5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#add3e77a284a9bc1181573662995cd7f5">MGRSBRep</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor(dummy surface brep). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a0dfa6b65a51fe18b9b307a5c499f4dda">MGRSBRep</a> (const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;bcoef, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv, int homogeneous=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> from the raw data.  <a href="#a0dfa6b65a51fe18b9b307a5c499f4dda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#acaf653772fb7e44e2605747be7dd610f">MGRSBRep</a> (const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;bcoef, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;weights, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> from the raw data.  <a href="#acaf653772fb7e44e2605747be7dd610f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a72ac15d370f2202cb774f5f404c18e4d">MGRSBRep</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;rlb, const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, double angle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct surface of revolution, given planar <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> and rotation axis sl.  <a href="#a72ac15d370f2202cb774f5f404c18e4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a2580b172befad53f0e002996392bcf26">MGRSBRep</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;rlbrep, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> by sweep NURBS and sweep length.  <a href="#a2580b172befad53f0e002996392bcf26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ad59fdfbb69a2520f4e98240663c002f0">MGRSBRep</a> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;old, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;ut, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;vt, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate an original B-Rep by a new knot configuration.  <a href="#ad59fdfbb69a2520f4e98240663c002f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a2f4e9bb48a4db90639a8037629fcd3d2">MGRSBRep</a> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;brep, int homogeneous=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert from Non ratoinal form to Rational form.  <a href="#a2f4e9bb48a4db90639a8037629fcd3d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aeb866f1c2a5d7fc9c6a2d24b8a114ea3">MGRSBRep</a> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;old, const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;uknots, const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;vknots)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new B-Rep by adding knots to an original B-Rep.  <a href="#aeb866f1c2a5d7fc9c6a2d24b8a114ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a26a06abd32351eb916c3929bb73fb430">MGRSBRep</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange, const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;old, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new NURBS Surface by computing a part of the original.  <a href="#a26a06abd32351eb916c3929bb73fb430"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ac589936cc3a056c91ba67af081e887a1">MGRSBRep</a> (size_t dim, const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;sbrep, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Surface B-Rep by changing space dimension and ordering of coordinates.  <a href="#ac589936cc3a056c91ba67af081e887a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ac9661e09b7ea4f89247265cedff0f059">MGRSBRep</a> (const std::vector&lt; const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> * &gt; &amp;vecPtrRibRLBReps, bool direction_adjustment=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リブ曲線列から面を作成する 作成する面のノットベクトルはリブ曲線の向きをu,リブ列方向をvとする This constructor only generates <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> even if curves are <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> of the same knot configuration.  <a href="#ac9661e09b7ea4f89247265cedff0f059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aa2ec6a3e6c503b21278e2b4f7a98a179">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MGRSBRep(const MGRSBRep&amp;); ///Copy constructor.  <a href="#aa2ec6a3e6c503b21278e2b4f7a98a179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa83eeae116b49bf878e41d6000b218fa"></a><!-- doxytag: member="MGRSBRep::operator=" ref="aa83eeae116b49bf878e41d6000b218fa" args="(const MGRSBRep &amp;gel2)" -->
<a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a4bdfff8ed10e8461a22b2106e4589586">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面の平行移動を行いオブジェクトを生成する。 Translation.  <a href="#a4bdfff8ed10e8461a22b2106e4589586"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ab049fdb46c797de831b1f84eeca92970">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面の逆方向に平行移動を行いオブジェクトを生成する。 Translation.  <a href="#ab049fdb46c797de831b1f84eeca92970"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a05fd2542604899f960a8cdcc9c16efeb">operator*</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling.  <a href="#a05fd2542604899f960a8cdcc9c16efeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a9ce2628b0057cef3da39db711bc7477e">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲面の変換を行いオブジェクトを生成する。 Matrix transformation.  <a href="#a9ce2628b0057cef3da39db711bc7477e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a83774f1072c917f59e90bd78fedc6b94">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲面のトランスフォームを行いオブジェクトを生成する。 General transformation.  <a href="#a83774f1072c917f59e90bd78fedc6b94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a484a0aea8c1310d02549381ecb66b1f8"></a><!-- doxytag: member="MGRSBRep::operator+=" ref="a484a0aea8c1310d02549381ecb66b1f8" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a484a0aea8c1310d02549381ecb66b1f8">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bdf821d46d18f9fa3489f3d417ce5fa"></a><!-- doxytag: member="MGRSBRep::operator&#45;=" ref="a3bdf821d46d18f9fa3489f3d417ce5fa" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc402dd98c2afc45f9374d18946e3281"></a><!-- doxytag: member="MGRSBRep::operator*=" ref="adc402dd98c2afc45f9374d18946e3281" args="(double scale)" -->
<a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5baaf43181e3826b4aae3e5316c8c6c4"></a><!-- doxytag: member="MGRSBRep::operator*=" ref="a5baaf43181e3826b4aae3e5316c8c6c4" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa14bafd9d7604fcd79f7a88c42d5c6da"></a><!-- doxytag: member="MGRSBRep::operator*=" ref="aa14bafd9d7604fcd79f7a88c42d5c6da" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a246c3de268d06972978f70f0e767b382"></a><!-- doxytag: member="MGRSBRep::operator==" ref="a246c3de268d06972978f70f0e767b382" args="(const MGRSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a246c3de268d06972978f70f0e767b382">operator==</a> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99daf23782b44a2f9060060c4b63b827"></a><!-- doxytag: member="MGRSBRep::operator==" ref="a99daf23782b44a2f9060060c4b63b827" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a99daf23782b44a2f9060060c4b63b827">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34e71a15c4b9a9ab981d5b1ff7617c89"></a><!-- doxytag: member="MGRSBRep::operator&lt;" ref="a34e71a15c4b9a9ab981d5b1ff7617c89" args="(const MGRSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada91a4d5572375205c4905a6deea632a"></a><!-- doxytag: member="MGRSBRep::operator&lt;" ref="ada91a4d5572375205c4905a6deea632a" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ceee49cb7524206b821b13682d553be"></a><!-- doxytag: member="MGRSBRep::operator!=" ref="a4ceee49cb7524206b821b13682d553be" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b9ca17ec5387bd60dbddf62472758a0"></a><!-- doxytag: member="MGRSBRep::operator!=" ref="a2b9ca17ec5387bd60dbddf62472758a0" args="(const MGRSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae297622e363f26a2c92ba748ed9cf49d"></a><!-- doxytag: member="MGRSBRep::operator==" ref="ae297622e363f26a2c92ba748ed9cf49d" args="(const MGSBRep &amp;sb) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;sb) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ae688636cf961e27fc18765ccf25941e5">bdim_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身の曲面の全体の面積を返却する。 Compute total surface area.  <a href="#ae688636cf961e27fc18765ccf25941e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a759653f317665b6603ddbb0ba20ccd66"></a><!-- doxytag: member="MGRSBRep::bdim_v" ref="a759653f317665b6603ddbb0ba20ccd66" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a759653f317665b6603ddbb0ba20ccd66">bdim_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension of v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ad9b96b65fb806fd86cbeaf69743c0cbd">box_limitted</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;bx) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力のパラメータ範囲の曲面部分を囲むボックスを返す。 Compute minimum box that includes the surface.  <a href="#ad9b96b65fb806fd86cbeaf69743c0cbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a23a5d4c1c4d767c962618d645bb33ec9">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limited surface be the parameter box.  <a href="#a23a5d4c1c4d767c962618d645bb33ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a00f76b01674e6b7daf29dab5542613fe">change_range</a> (int is_u, double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a00f76b01674e6b7daf29dab5542613fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a0fd1808d139c525502a749aa90bae5a5">coef</a> (size_t i, size_t j, size_t k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef.  <a href="#a0fd1808d139c525502a749aa90bae5a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a89983887a18135675c16fddaef0e6cc2">coef</a> (size_t i, size_t j, size_t k) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef.  <a href="#a89983887a18135675c16fddaef0e6cc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e8343ddc814a581f045abdbc65c92d"></a><!-- doxytag: member="MGRSBRep::coef" ref="ab9e8343ddc814a581f045abdbc65c92d" args="(size_t i, size_t j) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ab9e8343ddc814a581f045abdbc65c92d">coef</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract (i,j,k) elements for 0&lt;=k&lt;<a class="el" href="class_m_g_r_s_b_rep.html#afb21bb3ad9e11aab7483fe65f255265d" title="Returns the space dimension.">sdim()</a> as a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27e716eda7eb263bc763830a57610505"></a><!-- doxytag: member="MGRSBRep::coef_data" ref="a27e716eda7eb263bc763830a57610505" args="(size_t i=0, size_t j=0, size_t k=0) const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a27e716eda7eb263bc763830a57610505">coef_data</a> (size_t i=0, size_t j=0, size_t k=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the surface b-coef data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ad46f96a1b5ea7e4284e2f025dcf5aeda">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#ad46f96a1b5ea7e4284e2f025dcf5aeda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#af6b3c3235fabba9e03cce44f2a956b58">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#af6b3c3235fabba9e03cce44f2a956b58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af59c202fc2eb6bf8c77fae0440b0ab8e"></a><!-- doxytag: member="MGRSBRep::display_control_polygon" ref="af59c202fc2eb6bf8c77fae0440b0ab8e" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#af59c202fc2eb6bf8c77fae0440b0ab8e">display_control_polygon</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display control polygons using mgGDL::MGDrawPointSeq(sp). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ab1e9d580381ad44cc19ff8713494063c">divide_multi_knot</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt; &amp;srfl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uまたはv方向に折れ(マルチノット)があるとき面を分割する 戻り値は、分割数を返却する  <a href="#ab1e9d580381ad44cc19ff8713494063c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a01bf003a29ccd6bdc004ca3028506f96">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous ndu'th and ndv'th derivative data.  <a href="#a01bf003a29ccd6bdc004ca3028506f96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a6ad9b9fbb8558192e37e71308ff691bd">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a6ad9b9fbb8558192e37e71308ff691bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a28e1cae47b5ca6f0af8abbb211c70f3e">eval_all</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#a28e1cae47b5ca6f0af8abbb211c70f3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#abd926289c9511293793dbe2638f0c00c">eval_all</a> (double u, double v, size_t ndu, size_t ndv, double *deriv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate all of i and j'th derivative data for 0&lt;=i&lt;=ndu, 0&lt;=j&lt;=ndv.  <a href="#abd926289c9511293793dbe2638f0c00c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26799ea4729ed4e7c00f3033ece99a92"></a><!-- doxytag: member="MGRSBRep::exchange_uv" ref="a26799ea4729ed4e7c00f3033ece99a92" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a26799ea4729ed4e7c00f3033ece99a92">exchange_uv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange parameter u and v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ad2cac4895eceb7725f54115cb5fa6aad">extend</a> (int perimeter, double param, double length, double dk=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original Surface by extrapolating the specified perimeter.  <a href="#ad2cac4895eceb7725f54115cb5fa6aad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d6fa66ce2e8c2f2dbf9b0d0eeb9e5e"></a><!-- doxytag: member="MGRSBRep::homogeneous" ref="a24d6fa66ce2e8c2f2dbf9b0d0eeb9e5e" args="() const " -->
const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a24d6fa66ce2e8c2f2dbf9b0d0eeb9e5e">homogeneous</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return homogeneous Surface B-Representation of the rational B-Spline. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b73c9c60eb2ced96e0ce436f03d9a45"></a><!-- doxytag: member="MGRSBRep::identify_type" ref="a1b73c9c60eb2ced96e0ce436f03d9a45" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a1b73c9c60eb2ced96e0ce436f03d9a45">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8695633b6c2e70258d78e82595085d0e"></a><!-- doxytag: member="MGRSBRep::in_range" ref="a8695633b6c2e70258d78e82595085d0e" args="(double u, double v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a8695633b6c2e70258d78e82595085d0e">in_range</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input parameter value is inside parameter range of the surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12cdae77b9a72c4be237777207102cbe"></a><!-- doxytag: member="MGRSBRep::in_range" ref="a12cdae77b9a72c4be237777207102cbe" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ba47ec07226f8cbe09d48319398e785"></a><!-- doxytag: member="MGRSBRep::isect" ref="a5ba47ec07226f8cbe09d48319398e785" args="(const MGCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a5ba47ec07226f8cbe09d48319398e785">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Curve の交点を求める。 Compute curve and surface intersection point(s). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95fb051eebb22d4594608f22a48b8156"></a><!-- doxytag: member="MGRSBRep::isect" ref="a95fb051eebb22d4594608f22a48b8156" args="(const MGStraight &amp;sl) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef0f1dba538eb3b7dd1be6836b2becfb"></a><!-- doxytag: member="MGRSBRep::isect" ref="aef0f1dba538eb3b7dd1be6836b2becfb" args="(const MGRLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae143cb730d1b1d4ca9439d6f59f25c37"></a><!-- doxytag: member="MGRSBRep::isect" ref="ae143cb730d1b1d4ca9439d6f59f25c37" args="(const MGEllipse &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad82fde3a20ccfb7f284c7aab5128b71"></a><!-- doxytag: member="MGRSBRep::isect" ref="aad82fde3a20ccfb7f284c7aab5128b71" args="(const MGLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafc483c9a911e5a2f5bb0751e08fb938"></a><!-- doxytag: member="MGRSBRep::isect" ref="aafc483c9a911e5a2f5bb0751e08fb938" args="(const MGSurfCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6b2844add62d4502dbeac9d491270f6"></a><!-- doxytag: member="MGRSBRep::isect" ref="aa6b2844add62d4502dbeac9d491270f6" args="(const MGBSumCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a581c8af06058ceebb4dee58f53af2193">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Surface の交線を求める。 Surface and Surface intersection.  <a href="#a581c8af06058ceebb4dee58f53af2193"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a852714e65fbf087ee8feed9ae8f2ed22"></a><!-- doxytag: member="MGRSBRep::isect" ref="a852714e65fbf087ee8feed9ae8f2ed22" args="(const MGPlane &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a872c90ec5624532dbe46dd9f40edcb00"></a><!-- doxytag: member="MGRSBRep::isect" ref="a872c90ec5624532dbe46dd9f40edcb00" args="(const MGSphere &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae97688fb183f0c2be943515146bffbfd"></a><!-- doxytag: member="MGRSBRep::isect" ref="ae97688fb183f0c2be943515146bffbfd" args="(const MGCylinder &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c57681919ab39755c8024a8a1b75b30"></a><!-- doxytag: member="MGRSBRep::isect" ref="a1c57681919ab39755c8024a8a1b75b30" args="(const MGSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e24405ce86a14d836c603164c0add6b"></a><!-- doxytag: member="MGRSBRep::isect" ref="a0e24405ce86a14d836c603164c0add6b" args="(const MGRSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c506e5da24d8d06649227350b36cd9a"></a><!-- doxytag: member="MGRSBRep::isect" ref="a6c506e5da24d8d06649227350b36cd9a" args="(const MGBSumSurf &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77811cd7ef85e3519f2246dd815351b6"></a><!-- doxytag: member="MGRSBRep::knot_u" ref="a77811cd7ef85e3519f2246dd815351b6" args="(size_t i)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a77811cd7ef85e3519f2246dd815351b6">knot_u</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot ( left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c53b1932bdd59ae7af9df666382b16e"></a><!-- doxytag: member="MGRSBRep::knot_u" ref="a3c53b1932bdd59ae7af9df666382b16e" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a3c53b1932bdd59ae7af9df666382b16e">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot (right-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a807fe4eeeeefd9d85cbae0af739c8a34"></a><!-- doxytag: member="MGRSBRep::knot_v" ref="a807fe4eeeeefd9d85cbae0af739c8a34" args="(size_t i)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_v</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3843f525343d46b4c378501b579e84e9"></a><!-- doxytag: member="MGRSBRep::knot_v" ref="a3843f525343d46b4c378501b579e84e9" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a3843f525343d46b4c378501b579e84e9">knot_v</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot (right-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa3dc772e4f863496afc3f04301ca834"></a><!-- doxytag: member="MGRSBRep::knot_data_u" ref="aaa3dc772e4f863496afc3f04301ca834" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aaa3dc772e4f863496afc3f04301ca834">knot_data_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the u knot vector data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a566053b26642dd0a11a040a1da9dc33f"></a><!-- doxytag: member="MGRSBRep::knot_data_v" ref="a566053b26642dd0a11a040a1da9dc33f" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a566053b26642dd0a11a040a1da9dc33f">knot_data_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the v knot vector data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0a7726be900610343169337d67ac1de"></a><!-- doxytag: member="MGRSBRep::knot_vector_u" ref="ad0a7726be900610343169337d67ac1de" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ad0a7726be900610343169337d67ac1de">knot_vector_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867910041cd2f9dda1cc29f721c05346"></a><!-- doxytag: member="MGRSBRep::knot_vector_u" ref="a867910041cd2f9dda1cc29f721c05346" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b7de7ac40ecb6328c1f3d0e22e0e55f"></a><!-- doxytag: member="MGRSBRep::knot_vector_v" ref="a8b7de7ac40ecb6328c1f3d0e22e0e55f" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a8b7de7ac40ecb6328c1f3d0e22e0e55f">knot_vector_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419ddb698294bfd59b3135a22dfdafde"></a><!-- doxytag: member="MGRSBRep::knot_vector_v" ref="a419ddb698294bfd59b3135a22dfdafde" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a094d8848d132d9c3004508982d933e0d">less_than</a> (size_t i, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two parameter values.  <a href="#a094d8848d132d9c3004508982d933e0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a6c317fc7fda0d82a3bdccc22cac5e536">limit</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身に指定したパラメータ範囲のlimitをつける。 Update this by limitting the parameter range.  <a href="#a6c317fc7fda0d82a3bdccc22cac5e536"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a049b5b0cf90939ad6877a97c33d6f043">negate</a> (int is_u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change direction of the surface.  <a href="#a049b5b0cf90939ad6877a97c33d6f043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#abb74e9b308cccb80b662a6542b070516">negate_param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int is_u=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this surface is negated by "negate()".  <a href="#abb74e9b308cccb80b662a6542b070516"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a8cf6b96bf67bd3b9ad74a55d047332fc">non_homogeneous_bcoef</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return non_homogeneous B-Coefficients with weights of the rational Surface B-Spline.  <a href="#a8cf6b96bf67bd3b9ad74a55d047332fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ac5971a305244eef04ea488337f565471">non_rational</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is actually non_rational, i.e.  <a href="#ac5971a305244eef04ea488337f565471"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad90f4e95f371a8c53bbd8a0369a4ac7c"></a><!-- doxytag: member="MGRSBRep::order_u" ref="ad90f4e95f371a8c53bbd8a0369a4ac7c" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ad90f4e95f371a8c53bbd8a0369a4ac7c">order_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-Rep order(u-direction). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eec153ce51965c16a6eb42ca3d7faaf"></a><!-- doxytag: member="MGRSBRep::order_v" ref="a6eec153ce51965c16a6eb42ca3d7faaf" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a6eec153ce51965c16a6eb42ca3d7faaf">order_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-Rep order(v-direction). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca0db3704e4626abdbf4936e9f221ecd"></a><!-- doxytag: member="MGRSBRep::param_e" ref="aca0db3704e4626abdbf4936e9f221ecd" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aca0db3704e4626abdbf4936e9f221ecd">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76b03f72444dea4d35ff603c4b062746"></a><!-- doxytag: member="MGRSBRep::param_e_u" ref="a76b03f72444dea4d35ff603c4b062746" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a76b03f72444dea4d35ff603c4b062746">param_e_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e29020624fe46a388efd10fffee389f"></a><!-- doxytag: member="MGRSBRep::param_e_v" ref="a7e29020624fe46a388efd10fffee389f" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ac8dc0427d76fb4ca91b2ca01ac0d1796">parameter_curve</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter curve.  <a href="#ac8dc0427d76fb4ca91b2ca01ac0d1796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a38a45012a34e0b6946d06a87c2c9a46d">parameter_line</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter line.  <a href="#a38a45012a34e0b6946d06a87c2c9a46d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a16e184aac814e3be6f0c2b08d53d3e3d">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range.  <a href="#a16e184aac814e3be6f0c2b08d53d3e3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacd0bfb627392db364d1b0e8f8c74c28"></a><!-- doxytag: member="MGRSBRep::param_s" ref="aacd0bfb627392db364d1b0e8f8c74c28" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aacd0bfb627392db364d1b0e8f8c74c28">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae965c3b334cb290a0afe67f4222361cc"></a><!-- doxytag: member="MGRSBRep::param_s_u" ref="ae965c3b334cb290a0afe67f4222361cc" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ae965c3b334cb290a0afe67f4222361cc">param_s_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae05f16697f31feee2998d4e79296a17d"></a><!-- doxytag: member="MGRSBRep::param_s_v" ref="ae05f16697f31feee2998d4e79296a17d" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a8f016a068895c9d063444428fc919f5a">part</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;bx, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of the surface limitted by the parameter range bx.  <a href="#a8f016a068895c9d063444428fc919f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a3888527c5f7208fe5af5f69859b0f10b">perimeter</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve perimeter i of this surface.  <a href="#a3888527c5f7208fe5af5f69859b0f10b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a1dbb8c28adef0d3d17f98b1715392eeb">perimeter_curve</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve perimeter i of this surface.  <a href="#a1dbb8c28adef0d3d17f98b1715392eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39a2db214c73393aea2d6e4e3952fbf5"></a><!-- doxytag: member="MGRSBRep::perimeter_num" ref="a39a2db214c73393aea2d6e4e3952fbf5" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a39a2db214c73393aea2d6e4e3952fbf5">perimeter_num</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many perimeters this surface has. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a766687be9e278e7ab59145e91c537f3a">planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, double &amp;deviation) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the RSBRep is planar or not.  <a href="#a766687be9e278e7ab59145e91c537f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#af20061ebef92bf343aa51550d44406d2">planar</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox, double tol, int *divideU=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if part of the surface is planar or not within the tolerance tol.  <a href="#af20061ebef92bf343aa51550d44406d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a545928d1e952ea264a6ef83f9a43359e">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力パラメータをパラメータ範囲でまるめて返却する。 Round the input parameter value uv into the parameter range of the surface.  <a href="#a545928d1e952ea264a6ef83f9a43359e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a9f4dda595b5b4e418898e6e28b0eeb8e">reduce</a> (int is_u, int ndec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the B-Rep by decreasing B-Rep dimension by ndec.  <a href="#a9f4dda595b5b4e418898e6e28b0eeb8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a9f2fc2da406ece9e847b91f885641881">refine</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;uknot, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;vknot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change an original B-Rep to new one with subdivided knot configuration.  <a href="#a9f2fc2da406ece9e847b91f885641881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a8a18a4494af9d5965668233bbf9de922">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot.  <a href="#a8a18a4494af9d5965668233bbf9de922"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb21bb3ad9e11aab7483fe65f255265d"></a><!-- doxytag: member="MGRSBRep::sdim" ref="afb21bb3ad9e11aab7483fe65f255265d" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#afb21bb3ad9e11aab7483fe65f255265d">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a47a54710c09c12e586688107f1a5baa0">shrink_to_knot</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbx, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shrink this surface to the part limitted by the parameter range of uvbx.  <a href="#a47a54710c09c12e586688107f1a5baa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ae6d05a4dbbffdb57f603c5c8a874765f">surface_bcoef</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's.  <a href="#ae6d05a4dbbffdb57f603c5c8a874765f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a472f06c362f5c8eb74684baf29384983">surface_bcoef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's.  <a href="#a472f06c362f5c8eb74684baf29384983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a8d5a8c2c6fae8edd18644569ae9462a7">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute surface integral of the 1st two coordinates.  <a href="#a8d5a8c2c6fae8edd18644569ae9462a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a2764e5b0995ea66f691ec9a4a9a3cfa0">unlimit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ｌｉｍｉｔをはずす。 Unlimit the parameter range.  <a href="#a2764e5b0995ea66f691ec9a4a9a3cfa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef97a2936145d17b7628f7233f49f36c"></a><!-- doxytag: member="MGRSBRep::out_to_IGES" ref="aef97a2936145d17b7628f7233f49f36c" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aef97a2936145d17b7628f7233f49f36c">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">output to IGES, PD128 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abac0a7fec985c239a4fa584e112ae23d"></a><!-- doxytag: member="MGRSBRep::out" ref="abac0a7fec985c239a4fa584e112ae23d" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#abac0a7fec985c239a4fa584e112ae23d">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f66f48012448db7aeda1cd6052148e8"></a><!-- doxytag: member="MGRSBRep::whoami" ref="a7f66f48012448db7aeda1cd6052148e8" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#ae943ed583a8321c45864651089a97723">isectSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox=mgNULL_BOX) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Surface and a straight line.  <a href="#ae943ed583a8321c45864651089a97723"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab0445229336d0d7a6f5b2ae49af81aa"></a><!-- doxytag: member="MGRSBRep::ReadMembers" ref="aab0445229336d0d7a6f5b2ae49af81aa" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#aab0445229336d0d7a6f5b2ae49af81aa">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 戻り値boolは正常に読み出しが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87957cff2b06eb3bbbecfd60deceaf64"></a><!-- doxytag: member="MGRSBRep::WriteMembers" ref="a87957cff2b06eb3bbbecfd60deceaf64" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#a87957cff2b06eb3bbbecfd60deceaf64">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 戻り値boolは正常に書き込みが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html#abdf6e537c45be650c153179c34e28d18">operator*</a> (double scale, const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;sb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling.  <a href="#abdf6e537c45be650c153179c34e28d18"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines Surface B-Representation of rational form. </p>
<p>This NURBS is of homogeneous form, i.e., B-Coefficients have weight included values. When usual(non-homogeneous) NURBS form is (xij, yij, zij, wij) , <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> form is (xij*wij, yij*wij, zij*wij, wij) for i=0,..., m-1, and j=0,..., n-1. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0dfa6b65a51fe18b9b307a5c499f4dda"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="a0dfa6b65a51fe18b9b307a5c499f4dda" args="(const MGSPointSeq &amp;bcoef, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv, int homogeneous=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bcoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>homogeneous</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> from the raw data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bcoef</em>&nbsp;</td><td>Control Vertex of rational surface B-Rep that includes weight multiplied when homogeneous=true(1), and not includes when homogeneous =false. Mximum space dimension id of bcoef is for weight of the rational. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acaf653772fb7e44e2605747be7dd610f"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="acaf653772fb7e44e2605747be7dd610f" args="(const MGSPointSeq &amp;bcoef, const MGSPointSeq &amp;weights, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bcoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> from the raw data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bcoef</em>&nbsp;</td><td>Control Vertex of rational surface B-Rep that does not includes weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>weights, weights(i,j,0) is for bcoef(i,j,.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72ac15d370f2202cb774f5f404c18e4d"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="a72ac15d370f2202cb774f5f404c18e4d" args="(const MGRLBRep &amp;rlb, const MGStraight &amp;sl, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct surface of revolution, given planar <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> and rotation axis sl. </p>
<p>Parameterization of the surface is: u=const parameter line generates given rlb(when u=0.). v=const parameter line generates a circle whose center is sl. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rlb</em>&nbsp;</td><td>Planar <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sl</em>&nbsp;</td><td>Rotation axis. This is treated as infinite one, even if it is not. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>Rotation angle in radian, -2*pai&lt;=angle&lt;=2*pai, If angle is positive, circle is anti-clockwise around direction Vector N of sl. If negative, circle is clockwise around N. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2580b172befad53f0e002996392bcf26"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="a2580b172befad53f0e002996392bcf26" args="(const MGRLBRep &amp;rlbrep, const MGUnit_vector &amp;uvec, double start_dist, double end_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rlbrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> by sweep NURBS and sweep length. </p>
<p>The sweep surface is defined as: rlbrep(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rlbrep</em>&nbsp;</td><td>Sweep crv. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59fdfbb69a2520f4e98240663c002f0"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="ad59fdfbb69a2520f4e98240663c002f0" args="(const MGRSBRep &amp;old, const MGKnotVector &amp;ut, const MGKnotVector &amp;vt, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate an original B-Rep by a new knot configuration. </p>
<p>The new knot config must be inside the range of the original B-Rep parameter. However new knots may be coarse or fine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ut</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vt</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f4e9bb48a4db90639a8037629fcd3d2"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="a2f4e9bb48a4db90639a8037629fcd3d2" args="(const MGSBRep &amp;brep, int homogeneous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>homogeneous</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert from Non ratoinal form to Rational form. </p>
<p>When homogeneous==true(non zero), brep is homogeneous form <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a>. When homogeneous==false(zero), brep is ordinary <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> and will be converted to <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a>. That is, weight=1 elements will be added to the last space dimension element. This is the fundamental constructor when homogeneous==1. ***** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brep</em>&nbsp;</td><td>Original SBRep. This can be ordinary SBRep, or homogeneous form of <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a>. When homogeneous form, the last space dimension elements are weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>homogeneous</em>&nbsp;</td><td>true(non zero): homogeneous form, false(zero):ordinary SBRep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb866f1c2a5d7fc9c6a2d24b8a114ea3"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="aeb866f1c2a5d7fc9c6a2d24b8a114ea3" args="(const MGRSBRep &amp;old, const MGKnotArray &amp;uknots, const MGKnotArray &amp;vknots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uknots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vknots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new B-Rep by adding knots to an original B-Rep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uknots</em>&nbsp;</td><td>Knots to add for u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vknots</em>&nbsp;</td><td>Knots to add for v-direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26a06abd32351eb916c3929bb73fb430"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="a26a06abd32351eb916c3929bb73fb430" args="(const MGBox &amp;uvrange, const MGRSBRep &amp;old, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new NURBS Surface by computing a part of the original. </p>
<p>New one is exactly the same as the original except that it is partial. If multiple==true(!=0), knot_u(i)=t1 and knot_u(n+i)=t2 for i=0,..., k-1 will be guaranteed. Here, n=bdim_u(), k=order_u(), t1=uvrange(0).low_point(), and t2=uvrange(0).high_point(). About knot_v(j), the same. Both u-range and v-range must be inside the range of old. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvrange</em>&nbsp;</td><td>u and v parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac589936cc3a056c91ba67af081e887a1"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="ac589936cc3a056c91ba67af081e887a1" args="(size_t dim, const MGRSBRep &amp;sbrep, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sbrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Surface B-Rep by changing space dimension and ordering of coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sbrep</em>&nbsp;</td><td>Original Surface B-rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new Surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of original Surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9661e09b7ea4f89247265cedff0f059"></a><!-- doxytag: member="MGRSBRep::MGRSBRep" ref="ac9661e09b7ea4f89247265cedff0f059" args="(const std::vector&lt; const MGRLBRep * &gt; &amp;vecPtrRibRLBReps, bool direction_adjustment=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRSBRep::MGRSBRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vecPtrRibRLBReps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>direction_adjustment</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>リブ曲線列から面を作成する 作成する面のノットベクトルはリブ曲線の向きをu,リブ列方向をvとする This constructor only generates <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> even if curves are <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> of the same knot configuration. </p>
<p>To avoid this, use createSurfaceFromRibs() that generates <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> when curves are <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> of the same knot configuration. Let v0=start parameter value, v1=terminate parameter value along v, then v=v0 const parameter line is curves[0], and v=v1 const parameter line is curves[n-1], where n=curves.size(). n must be greater or equal to 2. When n==2, the surface is a ruled surface(that is, this-&gt;<a class="el" href="class_m_g_r_s_b_rep.html#ad90f4e95f371a8c53bbd8a0369a4ac7c" title="Returns the B-Rep order(u-direction).">order_u()</a> is 2).</p>
<p>If MGRLBRep's in vecPtrRibRLBReps may have different knot configurations, use the global function createSurfaceFromRibs(declared in MGSBRep.h). </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae688636cf961e27fc18765ccf25941e5"></a><!-- doxytag: member="MGRSBRep::bdim_u" ref="ae688636cf961e27fc18765ccf25941e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGRSBRep::bdim_u </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身の曲面の全体の面積を返却する。 Compute total surface area. </p>
<p>double area() const; 与えられたパラメータ範囲の曲面の面積を返す。 Compute surface area limitted by parameter range box. double area(const MGBox&amp; box) const; Returns B-Rep Dimension of u. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad9b96b65fb806fd86cbeaf69743c0cbd"></a><!-- doxytag: member="MGRSBRep::box_limitted" ref="ad9b96b65fb806fd86cbeaf69743c0cbd" args="(const MGBox &amp;bx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGRSBRep::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力のパラメータ範囲の曲面部分を囲むボックスを返す。 Compute minimum box that includes the surface. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a9182844563218c392ef526d29e5bfb7e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a23a5d4c1c4d767c962618d645bb33ec9"></a><!-- doxytag: member="MGRSBRep::change_dimension" ref="a23a5d4c1c4d767c962618d645bb33ec9" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&amp; MGRSBRep::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Limited surface be the parameter box. </p>
<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ab37b86c29caed93258a98d7e70459d4e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a00f76b01674e6b7daf29dab5542613fe"></a><!-- doxytag: member="MGRSBRep::change_range" ref="a00f76b01674e6b7daf29dab5542613fe" args="(int is_u, double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&amp; MGRSBRep::change_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, (t1,t2) are u-value. if not, v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a1d4365d58c465f916b2fb038ef896b2d">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad46f96a1b5ea7e4284e2f025dcf5aeda"></a><!-- doxytag: member="MGRSBRep::clone" ref="ad46f96a1b5ea7e4284e2f025dcf5aeda" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>* MGRSBRep::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a55ce6580673b46480f6ae5a8d2117c17">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a0fd1808d139c525502a749aa90bae5a5"></a><!-- doxytag: member="MGRSBRep::coef" ref="a0fd1808d139c525502a749aa90bae5a5" args="(size_t i, size_t j, size_t k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; MGRSBRep::coef </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access to (i,j)th element of coef. </p>
<p>Left-hand side version. </p>

</div>
</div>
<a class="anchor" id="a89983887a18135675c16fddaef0e6cc2"></a><!-- doxytag: member="MGRSBRep::coef" ref="a89983887a18135675c16fddaef0e6cc2" args="(size_t i, size_t j, size_t k) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGRSBRep::coef </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access to (i,j)th element of coef. </p>
<p>(right-hand side version). </p>

</div>
</div>
<a class="anchor" id="af6b3c3235fabba9e03cce44f2a956b58"></a><!-- doxytag: member="MGRSBRep::copy_change_dimension" ref="af6b3c3235fabba9e03cce44f2a956b58" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>* MGRSBRep::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a0cf87d2f42a919c9f5bc44cc406ea0fd">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab1e9d580381ad44cc19ff8713494063c"></a><!-- doxytag: member="MGRSBRep::divide_multi_knot" ref="ab1e9d580381ad44cc19ff8713494063c" args="(MGPvector&lt; MGSurface &gt; &amp;srfl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRSBRep::divide_multi_knot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srfl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>uまたはv方向に折れ(マルチノット)があるとき面を分割する 戻り値は、分割数を返却する </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srfl</em>&nbsp;</td><td>分割した曲面リスト </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a27fdd1ff58f14d6ee6691f711d3bd039">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a01bf003a29ccd6bdc004ca3028506f96"></a><!-- doxytag: member="MGRSBRep::eval" ref="a01bf003a29ccd6bdc004ca3028506f96" args="(double u, double v, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGRSBRep::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous ndu'th and ndv'th derivative data. </p>
<p>Function's return value is (d(ndu+ndv)f(u,v))/(du**ndu*dv**ndv). ndu=0 and ndv=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of Derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of Derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad9b9fbb8558192e37e71308ff691bd"></a><!-- doxytag: member="MGRSBRep::eval" ref="a6ad9b9fbb8558192e37e71308ff691bd" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGRSBRep::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a28e1cae47b5ca6f0af8abbb211c70f3e"></a><!-- doxytag: member="MGRSBRep::eval_all" ref="a28e1cae47b5ca6f0af8abbb211c70f3e" args="(double u, double v, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRSBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data and 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8153b4db02d3056377d79f43254d11e5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="abd926289c9511293793dbe2638f0c00c"></a><!-- doxytag: member="MGRSBRep::eval_all" ref="abd926289c9511293793dbe2638f0c00c" args="(double u, double v, size_t ndu, size_t ndv, double *deriv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRSBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate all of i and j'th derivative data for 0&lt;=i&lt;=ndu, 0&lt;=j&lt;=ndv. </p>
<p>Output. (d(i+j)f(u,v))/(du**i*dv**j) in deriv[r+j*dim+i*ndv*dim] for 0&lt;=r&lt;dim=sdim(), 0&lt;=i&lt;=nderiv and 0&lt;=j&lt;<a class="el" href="class_m_g_r_s_b_rep.html#afb21bb3ad9e11aab7483fe65f255265d" title="Returns the space dimension.">sdim()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value to evaluate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of Derivative along u and v direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deriv</em>&nbsp;</td><td>Output. (d(i+j)f(u,v))/(du**i*dv**j) in deriv[r+j*dim+i*(ndv+1)*dim] for 0&lt;=r&lt;dim=sdim(). for 0&lt;=i&lt;=ndu and 0&lt;=j&lt;=ndv. deriv is an array of deriv[ndu+1][ndv+1][r]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2cac4895eceb7725f54115cb5fa6aad"></a><!-- doxytag: member="MGRSBRep::extend" ref="ad2cac4895eceb7725f54115cb5fa6aad" args="(int perimeter, double param, double length, double dk=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&amp; MGRSBRep::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>perimeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original Surface by extrapolating the specified perimeter. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. The extrapolation is done so that extrapolating length is "length" at the position of the parameter value "param" of the perimeter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perimeter</em>&nbsp;</td><td>perimeter number of the Surface, =0:v=min, =1:u=max, =2:v=max, =3:u=min. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of above perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend at the parameter param of the perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at extrapolation start point. When dk=0, curvature keeps same, i.e., dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point, (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ab52fd64da1afa26965f381962edf0f75">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a581c8af06058ceebb4dee58f53af2193"></a><!-- doxytag: member="MGRSBRep::isect" ref="a581c8af06058ceebb4dee58f53af2193" args="(const MGSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGRSBRep::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Surface の交線を求める。 Surface and Surface intersection. </p>
<p>Compute intersectio line(s) of two surface. Restriction:Currently if two surface do not have intersection on any of 4 perimeters, this function does not compute surface to surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a3d84645dc04d80bb2ff1df214f3a3b9b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae943ed583a8321c45864651089a97723"></a><!-- doxytag: member="MGRSBRep::isectSl" ref="ae943ed583a8321c45864651089a97723" args="(const MGStraight &amp;sl, const MGBox &amp;uvbox=mgNULL_BOX) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGRSBRep::isectSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em> = <code>mgNULL_BOX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Surface and a straight line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>indicates if this surface is restrictied to the parameter range of uvbox. If uvbox.is_null(), no restriction. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aa0bd5720dfdbf979fa89054b785014ce">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a094d8848d132d9c3004508982d933e0d"></a><!-- doxytag: member="MGRSBRep::less_than" ref="a094d8848d132d9c3004508982d933e0d" args="(size_t i, const MGPosition &amp;uv1, const MGPosition &amp;uv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGRSBRep::less_than </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two parameter values. </p>
<p>If uv1 is less than uv2, return true. Comparison is done after prjected to i-th perimeter of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>perimeter number. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ae1325fe2f42237e3348d410e5de8c700">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6c317fc7fda0d82a3bdccc22cac5e536"></a><!-- doxytag: member="MGRSBRep::limit" ref="a6c317fc7fda0d82a3bdccc22cac5e536" args="(const MGBox &amp;uvrange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&amp; MGRSBRep::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身に指定したパラメータ範囲のlimitをつける。 Update this by limitting the parameter range. </p>
<p>uvrange is parameter value range of (umin, vmin) to (umax, vmax). </p>

</div>
</div>
<a class="anchor" id="a049b5b0cf90939ad6877a97c33d6f043"></a><!-- doxytag: member="MGRSBRep::negate" ref="a049b5b0cf90939ad6877a97c33d6f043" args="(int is_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRSBRep::negate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change direction of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Negate along u-direction if is_u is ture, else along v-direction. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a5f1ebb47122de32a0f5702f160a51d2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="abb74e9b308cccb80b662a6542b070516"></a><!-- doxytag: member="MGRSBRep::negate_param" ref="abb74e9b308cccb80b662a6542b070516" args="(const MGPosition &amp;uv, int is_u=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGRSBRep::negate_param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter value if this surface is negated by "negate()". </p>
<p>Negate along u-direction if is_u is ture, else along v-direction. </p>

</div>
</div>
<a class="anchor" id="a8cf6b96bf67bd3b9ad74a55d047332fc"></a><!-- doxytag: member="MGRSBRep::non_homogeneous_bcoef" ref="a8cf6b96bf67bd3b9ad74a55d047332fc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> MGRSBRep::non_homogeneous_bcoef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return non_homogeneous B-Coefficients with weights of the rational Surface B-Spline. </p>
<p>This <a class="el" href="class_m_g_s_point_seq.html" title="Defines Spoint seq of a space dimension and of a size.">MGSPointSeq</a> includes weights. </p>

</div>
</div>
<a class="anchor" id="ac5971a305244eef04ea488337f565471"></a><!-- doxytag: member="MGRSBRep::non_rational" ref="ac5971a305244eef04ea488337f565471" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRSBRep::non_rational </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this is actually non_rational, i.e. </p>
<p>, all of the weights are same values. </p>

</div>
</div>
<a class="anchor" id="a05fd2542604899f960a8cdcc9c16efeb"></a><!-- doxytag: member="MGRSBRep::operator*" ref="a05fd2542604899f960a8cdcc9c16efeb" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> MGRSBRep::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling. </p>

</div>
</div>
<a class="anchor" id="a9ce2628b0057cef3da39db711bc7477e"></a><!-- doxytag: member="MGRSBRep::operator*" ref="a9ce2628b0057cef3da39db711bc7477e" args="(const MGMatrix &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> MGRSBRep::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲面の変換を行いオブジェクトを生成する。 Matrix transformation. </p>

</div>
</div>
<a class="anchor" id="a83774f1072c917f59e90bd78fedc6b94"></a><!-- doxytag: member="MGRSBRep::operator*" ref="a83774f1072c917f59e90bd78fedc6b94" args="(const MGTransf &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> MGRSBRep::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲面のトランスフォームを行いオブジェクトを生成する。 General transformation. </p>

</div>
</div>
<a class="anchor" id="a4bdfff8ed10e8461a22b2106e4589586"></a><!-- doxytag: member="MGRSBRep::operator+" ref="a4bdfff8ed10e8461a22b2106e4589586" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> MGRSBRep::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面の平行移動を行いオブジェクトを生成する。 Translation. </p>

</div>
</div>
<a class="anchor" id="ab049fdb46c797de831b1f84eeca92970"></a><!-- doxytag: member="MGRSBRep::operator&#45;" ref="ab049fdb46c797de831b1f84eeca92970" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> MGRSBRep::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面の逆方向に平行移動を行いオブジェクトを生成する。 Translation. </p>

</div>
</div>
<a class="anchor" id="aa2ec6a3e6c503b21278e2b4f7a98a179"></a><!-- doxytag: member="MGRSBRep::operator=" ref="aa2ec6a3e6c503b21278e2b4f7a98a179" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&amp; MGRSBRep::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MGRSBRep(const MGRSBRep&amp;); ///Copy constructor. </p>
<p>We can use default copy constructor. Destructor ‾MGRSBRep(); ///We can use default destructor. Assignment. When the leaf object of this and srf2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a16e184aac814e3be6f0c2b08d53d3e3d"></a><!-- doxytag: member="MGRSBRep::param_range" ref="a16e184aac814e3be6f0c2b08d53d3e3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGRSBRep::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ac8dc0427d76fb4ca91b2ca01ac0d1796"></a><!-- doxytag: member="MGRSBRep::parameter_curve" ref="ac8dc0427d76fb4ca91b2ca01ac0d1796" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGRSBRep::parameter_curve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter curve. </p>
<p>Returned is newed area pointer, and must be freed by delete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a470c01ec42c6e71b6c34601cc558ec96">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a38a45012a34e0b6946d06a87c2c9a46d"></a><!-- doxytag: member="MGRSBRep::parameter_line" ref="a38a45012a34e0b6946d06a87c2c9a46d" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> MGRSBRep::parameter_line </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f016a068895c9d063444428fc919f5a"></a><!-- doxytag: member="MGRSBRep::part" ref="a8f016a068895c9d063444428fc919f5a" args="(const MGBox &amp;bx, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>* MGRSBRep::part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of the surface limitted by the parameter range bx. </p>
<p>bx(0) is the parameter (us,vs) and bx(1) is (ue,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a7a924b141ca6ea037545953c5e00d682">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a3888527c5f7208fe5af5f69859b0f10b"></a><!-- doxytag: member="MGRSBRep::perimeter" ref="a3888527c5f7208fe5af5f69859b0f10b" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> MGRSBRep::perimeter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve perimeter i of this surface. </p>
<p>Compute perimeter Rational line B-Rep. i is perimeter number: =0: v=min line, =1: u=max line, =2: v=max line, =3: u=min line </p>

</div>
</div>
<a class="anchor" id="a1dbb8c28adef0d3d17f98b1715392eeb"></a><!-- doxytag: member="MGRSBRep::perimeter_curve" ref="a1dbb8c28adef0d3d17f98b1715392eeb" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGRSBRep::perimeter_curve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve perimeter i of this surface. </p>
<p>i must be &lt; <a class="el" href="class_m_g_r_s_b_rep.html#a39a2db214c73393aea2d6e4e3952fbf5" title="Return how many perimeters this surface has.">perimeter_num()</a>. When <a class="el" href="class_m_g_r_s_b_rep.html#a39a2db214c73393aea2d6e4e3952fbf5" title="Return how many perimeters this surface has.">perimeter_num()</a>==0, this function is undefined. Retured is newed object, must be deleted. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a57c8bffdb617cf4ff7c654e2b080200c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="af20061ebef92bf343aa51550d44406d2"></a><!-- doxytag: member="MGRSBRep::planar" ref="af20061ebef92bf343aa51550d44406d2" args="(const MGBox &amp;uvbox, double tol, int *divideU=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRSBRep::planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>divideU</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if part of the surface is planar or not within the tolerance tol. </p>
<p>The part of the surface is input by the surface parameter range uvbox. Returned is 0(false) if this is not planar, 1(true) if planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>This surface parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>maximum deviation allowed to regard the sub surface as a plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>divideU</em>&nbsp;</td><td>Direction to subdivide will be output, if this was not planar, =1: u direction, =0: v direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a766687be9e278e7ab59145e91c537f3a"></a><!-- doxytag: member="MGRSBRep::planar" ref="a766687be9e278e7ab59145e91c537f3a" args="(MGPlane &amp;plane, double &amp;deviation) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRSBRep::planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>deviation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the RSBRep is planar or not. </p>
<p>Returned is 0(false) if this is not planar, 1(true) if this planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Plane that might be closest to this. Plane is always output even if not planar. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>maximum deviation of this from the output plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a545928d1e952ea264a6ef83f9a43359e"></a><!-- doxytag: member="MGRSBRep::range" ref="a545928d1e952ea264a6ef83f9a43359e" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGRSBRep::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力パラメータをパラメータ範囲でまるめて返却する。 Round the input parameter value uv into the parameter range of the surface. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8966c7e15642175de66afee13234dfc5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4dda595b5b4e418898e6e28b0eeb8e"></a><!-- doxytag: member="MGRSBRep::reduce" ref="a9f4dda595b5b4e418898e6e28b0eeb8e" args="(int is_u, int ndec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRSBRep::reduce </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the B-Rep by decreasing B-Rep dimension by ndec. </p>
<p>This is an approximation of the origimal B-Rep. Return value is error flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, reduce b-rep dimension of u-direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndec</em>&nbsp;</td><td>Number of B-rep dimension to decrease . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f2fc2da406ece9e847b91f885641881"></a><!-- doxytag: member="MGRSBRep::refine" ref="a9f2fc2da406ece9e847b91f885641881" args="(const MGKnotVector &amp;uknot, const MGKnotVector &amp;vknot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a>&amp; MGRSBRep::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uknot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vknot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change an original B-Rep to new one with subdivided knot configuration. </p>
<p>Knots t must be subdivided knots. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uknot</em>&nbsp;</td><td>new knot of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vknot</em>&nbsp;</td><td>new knot of v-direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a18a4494af9d5965668233bbf9de922"></a><!-- doxytag: member="MGRSBRep::remove_knot" ref="a8a18a4494af9d5965668233bbf9de922" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRSBRep::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot. </p>
<p>line_zero tolerance is used. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a168a7c2b0732dc2d6e4f534371e4b12b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a47a54710c09c12e586688107f1a5baa0"></a><!-- doxytag: member="MGRSBRep::shrink_to_knot" ref="a47a54710c09c12e586688107f1a5baa0" args="(const MGBox &amp;uvbx, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRSBRep::shrink_to_knot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrink this surface to the part limitted by the parameter range of uvbx. </p>
<p>New parameter range uvbx2 is so determined that uvbx2 is the smallest box tha includes uvbx, and all of the u or v values of uvbx2 is one of the values of u or v knots of the surface knotvector. uvbx(0) is the parameter (us,ue) and uvbx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a7bb84fd8e6434c9eabccd05675ddf2b5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a472f06c362f5c8eb74684baf29384983"></a><!-- doxytag: member="MGRSBRep::surface_bcoef" ref="a472f06c362f5c8eb74684baf29384983" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a>&amp; MGRSBRep::surface_bcoef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the B-coef's. </p>
<p>Left hand side version. </p>

</div>
</div>
<a class="anchor" id="ae6d05a4dbbffdb57f603c5c8a874765f"></a><!-- doxytag: member="MGRSBRep::surface_bcoef" ref="ae6d05a4dbbffdb57f603c5c8a874765f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a>&amp; MGRSBRep::surface_bcoef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the B-coef's. </p>
<p>Right hand side version. </p>

</div>
</div>
<a class="anchor" id="a8d5a8c2c6fae8edd18644569ae9462a7"></a><!-- doxytag: member="MGRSBRep::type" ref="a8d5a8c2c6fae8edd18644569ae9462a7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a> MGRSBRep::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute surface integral of the 1st two coordinates. </p>
<p>(面積分）を求める。 This integral can be used to compute volume sorounded by the surface. double surface_integral(const MGBox&amp;) const; 曲面のタイプをを返す。 Return the surface type. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a83ad0b3f99b05d775a1d4d7352baf9d0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a2764e5b0995ea66f691ec9a4a9a3cfa0"></a><!-- doxytag: member="MGRSBRep::unlimit" ref="a2764e5b0995ea66f691ec9a4a9a3cfa0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGRSBRep::unlimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ｌｉｍｉｔをはずす。 Unlimit the parameter range. </p>
<p>Return the same. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="abdf6e537c45be650c153179c34e28d18"></a><!-- doxytag: member="MGRSBRep::operator*" ref="abdf6e537c45be650c153179c34e28d18" args="(double scale, const MGRSBRep &amp;sb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>RSBRep.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:28 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

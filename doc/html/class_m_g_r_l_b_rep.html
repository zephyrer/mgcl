<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGRLBRep Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGRLBRep Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGRLBRep" --><!-- doxytag: inherits="MGCurve" -->
<p>Defines Rational Line B-Representation.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;RLBRep.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGRLBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_r_l_b_rep__inherit__graph.png" border="0" usemap="#_m_g_r_l_b_rep_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_r_l_b_rep_inherit__map" id="_m_g_r_l_b_rep_inherit__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="21,315,96,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGRLBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_r_l_b_rep__coll__graph.png" border="0" usemap="#_m_g_r_l_b_rep_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_r_l_b_rep_coll__map" id="_m_g_r_l_b_rep_coll__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="280,581,355,611"/><area shape="rect" id="node26" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B&#45;SPline representation." alt="" coords="161,677,244,707"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="268,501,367,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="221,405,301,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="217,85,324,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="127,181,204,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="240,5,301,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="109,293,221,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="60,85,193,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="325,405,392,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="317,293,400,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="320,181,397,211"/><area shape="rect" id="node29" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity." alt="" coords="5,581,109,611"/><area shape="rect" id="node31" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="133,581,240,611"/><area shape="rect" id="node33" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="136,501,237,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_r_l_b_rep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a6b7e127356f181662172e9bd061e5a"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a3a6b7e127356f181662172e9bd061e5a" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a3a6b7e127356f181662172e9bd061e5a">MGRLBRep</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default(dummy) constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#abb6fd79914c0de6bce466fbdf4bf2ec9">MGRLBRep</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bcoef, int homogeneous=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line NURBS, providing all the member data.  <a href="#abb6fd79914c0de6bce466fbdf4bf2ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9b89617a0872d310ad9a25725dbb0b07">MGRLBRep</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bcoef, const std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line NURBS, providing all the member data.  <a href="#a9b89617a0872d310ad9a25725dbb0b07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a306b01206e7a73965f9c8e07bb4c7"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="ac7a306b01206e7a73965f9c8e07bb4c7" args="(const MGEllipse &amp;ellipse)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ac7a306b01206e7a73965f9c8e07bb4c7">MGRLBRep</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;ellipse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct ellipse NURBS. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a196d9df99eda6fde1059fc8ed4cf1d4b">MGRLBRep</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P0, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;T0, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P2, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;T2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Original ellipse.  <a href="#a196d9df99eda6fde1059fc8ed4cf1d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aff58107d9ded2a43eda9b697d7efbb06">MGRLBRep</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;old_brep, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate an original NURBS by a new knot configuration.  <a href="#aff58107d9ded2a43eda9b697d7efbb06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a957e9617c6720b776e5bc7621690362c">MGRLBRep</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep, int homogeneous=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">**** Conversion Constructor.****  <a href="#a957e9617c6720b776e5bc7621690362c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a1a39aa95ded41669a862beaf5c009359">MGRLBRep</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;old_brep, const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;knots)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new NURBS by adding knots to an original NURBS.  <a href="#a1a39aa95ded41669a862beaf5c009359"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#adbe51824fd9239d700a66d83abd728ad">MGRLBRep</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;brep1, int continuity, int which, const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;brep2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new NURBS by connecting two NURBS to one.  <a href="#adbe51824fd9239d700a66d83abd728ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a03fdcc0adfcc334f8cc309ceb09ac05c">MGRLBRep</a> (double t1, double t2, const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;old_brep, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new NURBS by computing a part of the original.  <a href="#a03fdcc0adfcc334f8cc309ceb09ac05c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a1e8ff320ea3aa55b9daebfdc5158021b">MGRLBRep</a> (size_t dim, const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;lbrep, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Line NURBS by changing space dimension and ordering of coordinates.  <a href="#a1e8ff320ea3aa55b9daebfdc5158021b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ac238e27e1aedf07c033c4ec7a496f3cb">MGRLBRep</a> (double a, double b, double angle1, double angle2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 2D ellipse RLBRep, whose center is origin.  <a href="#ac238e27e1aedf07c033c4ec7a496f3cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ae306d5af9f9b247b387398448a02018c">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MGRLBRep(const MGRLBRep&amp;); ///Copy constructor.  <a href="#ae306d5af9f9b247b387398448a02018c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee654a1235814c28908719e1b0adb814"></a><!-- doxytag: member="MGRLBRep::operator=" ref="aee654a1235814c28908719e1b0adb814" args="(const MGRLBRep &amp;gel2)" -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1881307a296e114b2668f7e27d825811"></a><!-- doxytag: member="MGRLBRep::operator+" ref="a1881307a296e114b2668f7e27d825811" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a1881307a296e114b2668f7e27d825811">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation object construction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad55e11c57a15770dd4ad7a8929bf9689"></a><!-- doxytag: member="MGRLBRep::operator&#45;" ref="ad55e11c57a15770dd4ad7a8929bf9689" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38c87a3b5ebd0df06dcd423b34999c18"></a><!-- doxytag: member="MGRLBRep::operator*" ref="a38c87a3b5ebd0df06dcd423b34999c18" args="(double) const " -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cc0bfe406b57b63ba294294cf20dec0"></a><!-- doxytag: member="MGRLBRep::operator*" ref="a8cc0bfe406b57b63ba294294cf20dec0" args="(const MGMatrix &amp;) const " -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3977cfab8c3523f370f6e09bbb8b35b4"></a><!-- doxytag: member="MGRLBRep::operator*" ref="a3977cfab8c3523f370f6e09bbb8b35b4" args="(const MGTransf &amp;) const " -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3437cc03bdf1c61fafd0594f0381e0a4"></a><!-- doxytag: member="MGRLBRep::operator+=" ref="a3437cc03bdf1c61fafd0594f0381e0a4" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a3437cc03bdf1c61fafd0594f0381e0a4">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2026bff028c04196d069e8b087342664"></a><!-- doxytag: member="MGRLBRep::operator&#45;=" ref="a2026bff028c04196d069e8b087342664" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a4616d14714c880b581b39bd80c2b6"></a><!-- doxytag: member="MGRLBRep::operator*=" ref="a81a4616d14714c880b581b39bd80c2b6" args="(double scale)" -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d456744a5ec06dfda4511a534a92351"></a><!-- doxytag: member="MGRLBRep::operator*=" ref="a9d456744a5ec06dfda4511a534a92351" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a808956237d06707a144df280e8c8fdb3"></a><!-- doxytag: member="MGRLBRep::operator*=" ref="a808956237d06707a144df280e8c8fdb3" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6cd84b4a7da906b1e380be243f8f5a4"></a><!-- doxytag: member="MGRLBRep::operator==" ref="ac6cd84b4a7da906b1e380be243f8f5a4" args="(const MGRLBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ac6cd84b4a7da906b1e380be243f8f5a4">operator==</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea117dd2f70209b5bcd13c1a4028cbb2"></a><!-- doxytag: member="MGRLBRep::operator==" ref="aea117dd2f70209b5bcd13c1a4028cbb2" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aea117dd2f70209b5bcd13c1a4028cbb2">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a155a424e651e97e4c255d93045707fdf"></a><!-- doxytag: member="MGRLBRep::operator&lt;" ref="a155a424e651e97e4c255d93045707fdf" args="(const MGRLBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac231762bd2bfb1ad7fe69118f1c50185"></a><!-- doxytag: member="MGRLBRep::operator&lt;" ref="ac231762bd2bfb1ad7fe69118f1c50185" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cd8e0b948f497719e83674b8c2eb57d"></a><!-- doxytag: member="MGRLBRep::operator==" ref="a2cd8e0b948f497719e83674b8c2eb57d" args="(const MGLBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abec00ea9ed49970254543da010f28a29"></a><!-- doxytag: member="MGRLBRep::bdim" ref="abec00ea9ed49970254543da010f28a29" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#abec00ea9ed49970254543da010f28a29">bdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns NURBS Dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a4513b9b24aaf53cecf6a2608a5b599ae">box_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;l) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Return minimum box that includes the partial line.  <a href="#a4513b9b24aaf53cecf6a2608a5b599ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e1f325c3b3a9c40f3c14bc854aa707e"></a><!-- doxytag: member="MGRLBRep::box_unlimit" ref="a0e1f325c3b3a9c40f3c14bc854aa707e" args="() const " -->
<a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a0e1f325c3b3a9c40f3c14bc854aa707e">box_unlimit</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum box that includes the whole line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a1afea2f961097ac0a4e65bf572f39d28">change_range</a> (double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a1afea2f961097ac0a4e65bf572f39d28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a2b1980a4b10f69e1af0c6c638416fb78">change_dimension</a> (size_t dim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#a2b1980a4b10f69e1af0c6c638416fb78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aca9a4c1c6bda750aa5e760aad9ee0bfe">change_order</a> (unsigned order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change order of the NURBS.  <a href="#aca9a4c1c6bda750aa5e760aad9ee0bfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac7a55d0d529eed00037ad8ecd4a984"></a><!-- doxytag: member="MGRLBRep::coef" ref="a4ac7a55d0d529eed00037ad8ecd4a984" args="(size_t i, size_t j)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a4ac7a55d0d529eed00037ad8ecd4a984">coef</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef ( left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c470558609ee7b4e700f2624456072e"></a><!-- doxytag: member="MGRLBRep::coef" ref="a2c470558609ee7b4e700f2624456072e" args="(size_t i, size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a2c470558609ee7b4e700f2624456072e">coef</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef (right hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a75ca7ca132edc7460682dfd88e159a6e">coef</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract (i,j)elements for 0&lt;=j&lt;=sdim() as a vector of (<a class="el" href="class_m_g_r_l_b_rep.html#a9782a3b0d6a799172aa342240200d44e" title="Returns the space dimension.">sdim()</a>+1) space dimension.  <a href="#a75ca7ca132edc7460682dfd88e159a6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a129abe60c6fb4ee772c1fb49b1e140e6"></a><!-- doxytag: member="MGRLBRep::coef_data" ref="a129abe60c6fb4ee772c1fb49b1e140e6" args="(size_t i=0, size_t j=0) const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a129abe60c6fb4ee772c1fb49b1e140e6">coef_data</a> (size_t i=0, size_t j=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the line b-coef data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a23ce7d53635834554bd6b8b2246586ea">connect</a> (int continuity, int which, const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;brep2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect brep2 to this brep to make one B-Representation.  <a href="#a23ce7d53635834554bd6b8b2246586ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a15d629900d62422e99219a7b0d67c4c0">continuity</a> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;brep2, int &amp;which, double &amp;ratio) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute continuity with brep2.  <a href="#a15d629900d62422e99219a7b0d67c4c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a98a30b40e27d9b539c1d43d359c4fed2">coordinate_exchange</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange ordering of the coordinates.  <a href="#a98a30b40e27d9b539c1d43d359c4fed2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#af0e21bb30673cd52a8f4549db6918b19">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area.  <a href="#af0e21bb30673cd52a8f4549db6918b19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aa2c781b05b7d3c7bc34a1520013187f6">copy_as_nurbs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy as a newed curve.  <a href="#aa2c781b05b7d3c7bc34a1520013187f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a70ca358a3433b03ec0bb968291aef239">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by changing the original object's space dimension.  <a href="#a70ca358a3433b03ec0bb968291aef239"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ae19db276b94803492d1c8c78f4d8b1bd">copy_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;prange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area, and limitting the parameter range to prange.  <a href="#ae19db276b94803492d1c8c78f4d8b1bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a13bea2ebbe9e284031f5ad5f9e0ec0d3">divide_multi</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;crv_list, int multiplicity=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide this curve at the designated knot multiplicity point.  <a href="#a13bea2ebbe9e284031f5ad5f9e0ec0d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e35fb76e2e2afacd0e51be0f8c87307"></a><!-- doxytag: member="MGRLBRep::display_control_polygon" ref="a9e35fb76e2e2afacd0e51be0f8c87307" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9e35fb76e2e2afacd0e51be0f8c87307">display_control_polygon</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display control polygons using <a class="el" href="namespacemg_g_d_l.html#a737cd10d927fbfafda983392deabb6b2" title="Draw a control polygon.">mgGDL::MGDrawPointSeq()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ad367fc367cfe8cd6ceaa5b58dcd48336">draw_2D</a> (void(*moveto)(int, int), void(*lineto)(int, int), const double wind[4], size_t ynum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw this line's 1st and 2nd coordinates in 2D space using drawing function moveto( , ) and lineto( , ).  <a href="#ad367fc367cfe8cd6ceaa5b58dcd48336"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a3b6c6bb90b391ecb1ec56da31b8a23b1">draw_2D</a> (void(*moveto)(float, float), void(*lineto)(float, float), const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a84a06868905636541620a6ec7e73c1f3">draw_2D</a> (void(*moveto)(double, double), void(*lineto)(double, double), const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a099bc672335a06c605bb86b8fc49067b">draw_1D</a> (void(*moveto)(int, int), void(*lineto)(int, int), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw this line's coordinate'th coordinate in 2D space as (t, LBRep(coordinate)) when t_is_x is true, or as ( LBRep(coordinate),t) when t_is_x is false, Here t is the parameter of the LBRep.  <a href="#a099bc672335a06c605bb86b8fc49067b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a70dba68c10d9dbd960a51cba9f721718">draw_1D</a> (void(*moveto)(float, float), void(*lineto)(float, float), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a73af488197088f7137d87c387f56e073">draw_1D</a> (void(*moveto)(double, double), void(*lineto)(double, double), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#abf9d2a88d59cf71c8c76d75f6f383541">drawSE</a> (double span_length, double t0, double t1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ac892bfc228d273051f911216e68ce803">eval</a> (double t, size_t nderiv=0, int left=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous n'th derivative data.  <a href="#ac892bfc228d273051f911216e68ce803"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a0e3b290b0584debdf0b1664796eb7484">eval_all</a> (double tau, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V1, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute position, 1st and 2nd derivatives.  <a href="#a0e3b290b0584debdf0b1664796eb7484"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ac6159f651c702908488affdd89faaa3c">eval_all</a> (double tau, size_t nderiv, double *deriv, int left=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate all of i'th derivative data for 0&lt;=i&lt;=nderiv.  <a href="#ac6159f651c702908488affdd89faaa3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#af0b37e783673e32f09e422fbe14de441">extend</a> (double length, bool start=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate this curve by an (approximate) chord length.  <a href="#af0b37e783673e32f09e422fbe14de441"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a633b84e8d9c319bd753569e247488836">extend</a> (int start, double length, double dk=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original NURBS by extrapolating the specified perimeter.  <a href="#a633b84e8d9c319bd753569e247488836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a2564b4ecf078872a082cd1bd23242d1a">extend_with_parameter</a> (double tau, double dk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate the curve by the parameter value.  <a href="#a2564b4ecf078872a082cd1bd23242d1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a2db3d688dd1211a90d157782f56e355e">get_control_points</a> (<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;cpoints) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts control points.  <a href="#a2db3d688dd1211a90d157782f56e355e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef22a0b3a53d8670885661d66023737f"></a><!-- doxytag: member="MGRLBRep::homogeneous" ref="aef22a0b3a53d8670885661d66023737f" args="() const " -->
const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aef22a0b3a53d8670885661d66023737f">homogeneous</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return homogeneous Line B-Representation of the rational B-Spline. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21464255451a3a33533f41f3ce177ff"></a><!-- doxytag: member="MGRLBRep::homogeneous" ref="ac21464255451a3a33533f41f3ce177ff" args="()" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>homogeneous</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7574a8bf4d1fd378551fcc011c11460"></a><!-- doxytag: member="MGRLBRep::identify_type" ref="ab7574a8bf4d1fd378551fcc011c11460" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ab7574a8bf4d1fd378551fcc011c11460">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bf6c4d414ca7db1361541d7b06778a2"></a><!-- doxytag: member="MGRLBRep::intersect_dnum" ref="a8bf6c4d414ca7db1361541d7b06778a2" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a8bf6c4d414ca7db1361541d7b06778a2">intersect_dnum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide divide number of curve span for function intersect. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#af19428e9123d5a96e53aab4880b43413">is_coplanar</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is co-planar with the 2nd curve curve2.  <a href="#af19428e9123d5a96e53aab4880b43413"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#abc88d73f88250959329b252198fb12b1">is_planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is planar or not.  <a href="#abc88d73f88250959329b252198fb12b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#af0002a2943f4718f2b75198a111e0fbd">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spline と Curve の交点を求める。 Intersection point of spline and curve.  <a href="#af0002a2943f4718f2b75198a111e0fbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17390e861478dbe9363e1a7e4ea75d83"></a><!-- doxytag: member="MGRLBRep::isect" ref="a17390e861478dbe9363e1a7e4ea75d83" args="(const MGStraight &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd3aa28e1141b752ed671b28ab41ab7"></a><!-- doxytag: member="MGRLBRep::isect" ref="addd3aa28e1141b752ed671b28ab41ab7" args="(const MGSurfCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb87204df7e99ebe6f05b77937b79d5f"></a><!-- doxytag: member="MGRLBRep::isect" ref="abb87204df7e99ebe6f05b77937b79d5f" args="(const MGBSumCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a7ab1313b0b09eae154a485754a3dff4a">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Spline and Surface.  <a href="#a7ab1313b0b09eae154a485754a3dff4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af759c88eb6856d540beb87f048a454c5"></a><!-- doxytag: member="MGRLBRep::isect" ref="af759c88eb6856d540beb87f048a454c5" args="(const MGPlane &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca6da3c607c53a303ac9df663d08ac73"></a><!-- doxytag: member="MGRLBRep::isect" ref="aca6da3c607c53a303ac9df663d08ac73" args="(const MGSphere &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a423bf380c8d92b61f459345ce8e378e0"></a><!-- doxytag: member="MGRLBRep::isect" ref="a423bf380c8d92b61f459345ce8e378e0" args="(const MGCylinder &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac53f4d224239c3afaf5d66d50b1ba51c"></a><!-- doxytag: member="MGRLBRep::isect" ref="ac53f4d224239c3afaf5d66d50b1ba51c" args="(const MGSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfab3fdae2b4ecbb1b322f401ade66a5"></a><!-- doxytag: member="MGRLBRep::isect" ref="acfab3fdae2b4ecbb1b322f401ade66a5" args="(const MGRSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb420332ee274e65d2ec09d20703321"></a><!-- doxytag: member="MGRLBRep::isect" ref="a5eb420332ee274e65d2ec09d20703321" args="(const MGBSumSurf &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a50f41ec1265ea9e4dd23e8ff52855a0d">isect_2D</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection point of 2D sub NURBS of original B-rep.  <a href="#a50f41ec1265ea9e4dd23e8ff52855a0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a5bbbb06e2209e52822fdebfa64017701">isect_3D</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of 3D sub NURBS of original B-rep.  <a href="#a5bbbb06e2209e52822fdebfa64017701"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd96f844839236c6dedf2e1df5f0c6ea"></a><!-- doxytag: member="MGRLBRep::knot" ref="abd96f844839236c6dedf2e1df5f0c6ea" args="(size_t i)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#abd96f844839236c6dedf2e1df5f0c6ea">knot</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot ( left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75b93e4feb82e0629d06cce5457d0b67"></a><!-- doxytag: member="MGRLBRep::knot" ref="a75b93e4feb82e0629d06cce5457d0b67" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a75b93e4feb82e0629d06cce5457d0b67">knot</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot (right hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dc56d73497b02e00723b8e8a3372bb1"></a><!-- doxytag: member="MGRLBRep::knot_data" ref="a9dc56d73497b02e00723b8e8a3372bb1" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9dc56d73497b02e00723b8e8a3372bb1">knot_data</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the knot vector data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ad45a21e8d95e3a80d990870cb0b53783">knot_vector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector.  <a href="#ad45a21e8d95e3a80d990870cb0b53783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a68ed2a1e306ba106b677c867069de633">knot_vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector.  <a href="#a68ed2a1e306ba106b677c867069de633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9ba74256cfa8bd870e9c8471df266ebb">limit</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;itvl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身に指定したパラメータ範囲のlimitをつける。 Get the sub interval line of the original line.  <a href="#a9ba74256cfa8bd870e9c8471df266ebb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#afdacbe34b22baade77555b962d596972">line_bcoef</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's.  <a href="#afdacbe34b22baade77555b962d596972"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a720d484e639be2885caeda33a63fe9a4">line_bcoef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's.  <a href="#a720d484e639be2885caeda33a63fe9a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f4ee8827c9b326be3276d7fd20ab311"></a><!-- doxytag: member="MGRLBRep::negate" ref="a5f4ee8827c9b326be3276d7fd20ab311" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a5f4ee8827c9b326be3276d7fd20ab311">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change direction of the line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cfafa472f772943e817fdac900ecf22"></a><!-- doxytag: member="MGRLBRep::negate_param" ref="a9cfafa472f772943e817fdac900ecf22" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9cfafa472f772943e817fdac900ecf22">negate_param</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this curve is negated by "negate()". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a99a0eaca0e8eae63074d4305f74817fc">non_homogeneous_bcoef</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return non_homogeneous B-Coefficients with weights of the rational B-Spline.  <a href="#a99a0eaca0e8eae63074d4305f74817fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a2d94a3c0591043be21ce905f3b3c7fbb">non_rational</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is actually non_rational, i.e.  <a href="#a2d94a3c0591043be21ce905f3b3c7fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82c73d30c6e8d5c94319c98718f1dec3"></a><!-- doxytag: member="MGRLBRep::order" ref="a82c73d30c6e8d5c94319c98718f1dec3" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a82c73d30c6e8d5c94319c98718f1dec3">order</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1347fac4bf573b6c764005048d1059fd"></a><!-- doxytag: member="MGRLBRep::param_e" ref="a1347fac4bf573b6c764005048d1059fd" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a1347fac4bf573b6c764005048d1059fd">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a7cd7adeb85fef88b47ae7ad99de0d6f5">param_normalize</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize parameter value t to the nearest knot if their distance is within tolerance.  <a href="#a7cd7adeb85fef88b47ae7ad99de0d6f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4a7800ef6396a09ed87b1f0f7564f60"></a><!-- doxytag: member="MGRLBRep::param_s" ref="ab4a7800ef6396a09ed87b1f0f7564f60" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ab4a7800ef6396a09ed87b1f0f7564f60">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a18885b819cf4f01225b363fb5ae2a6b1">part</a> (double t1, double t2, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of this curve from parameter t1 to t2.  <a href="#a18885b819cf4f01225b363fb5ae2a6b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a42d26d183568e3982302e94ce41a98a4">perps</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the perpendicular points of this curve and the second one.  <a href="#a42d26d183568e3982302e94ce41a98a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3a5f2bdf92211229402dc44fd0b2a4"></a><!-- doxytag: member="MGRLBRep::perps" ref="a5c3a5f2bdf92211229402dc44fd0b2a4" args="(const MGStraight &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#accbf515dd2c383b15b962158fce22d32">planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;line, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the line B-rep is planar.  <a href="#accbf515dd2c383b15b962158fce22d32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aa48bd02ee4b5b83610bbbbbc7d0af7e9">reduce</a> (int ndec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the NURBS by decreasing B-Rep dimension by ndec.  <a href="#aa48bd02ee4b5b83610bbbbbc7d0af7e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9c90fbd486a60dac8e7e54a7874f8140">refine</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change an original NURBS to new one with subdivided knot configuration.  <a href="#a9c90fbd486a60dac8e7e54a7874f8140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#afefcb8967b95d87d6fb3464c0c1441a4">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot.  <a href="#afefcb8967b95d87d6fb3464c0c1441a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9782a3b0d6a799172aa342240200d44e"></a><!-- doxytag: member="MGRLBRep::sdim" ref="a9782a3b0d6a799172aa342240200d44e" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a9782a3b0d6a799172aa342240200d44e">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a6b5168b1d7a6cbc610134ccdee172f57">sweep</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sweep surface from crv Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted.  <a href="#a6b5168b1d7a6cbc610134ccdee172f57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#af78176beb1185058b7af73bc7bdb0ff4">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線のタイプをを返す。 Return the curve type.  <a href="#af78176beb1185058b7af73bc7bdb0ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a8334cd756aeba48b159ef0f88792dee9">unlimit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">limitをはずす。 unlimit this line.  <a href="#a8334cd756aeba48b159ef0f88792dee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89d676c9e9de22e25a26cd0d12a6c71"></a><!-- doxytag: member="MGRLBRep::unlimit_end" ref="af89d676c9e9de22e25a26cd0d12a6c71" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#af89d676c9e9de22e25a26cd0d12a6c71">unlimit_end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the end point direction (終点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81dfd2e6377e2282dfa98b4134fe0bf0"></a><!-- doxytag: member="MGRLBRep::unlimit_start" ref="a81dfd2e6377e2282dfa98b4134fe0bf0" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a81dfd2e6377e2282dfa98b4134fe0bf0">unlimit_start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the start point direction (始点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a6b90e729511e9bec4a8390a68868bc27">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector.  <a href="#a6b90e729511e9bec4a8390a68868bc27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47a2ef5599cb880e39ac669c63bc2d38"></a><!-- doxytag: member="MGRLBRep::out" ref="a47a2ef5599cb880e39ac669c63bc2d38" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a47a2ef5599cb880e39ac669c63bc2d38">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aeccb25cc040074dfe3883585c6e2a523">intersect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection point of 1D sub NURBS of original B-rep.  <a href="#aeccb25cc040074dfe3883585c6e2a523"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a5ade0e6171293ed3d4f2848934f767c1">oneD</a> (const double g[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve.  <a href="#a5ade0e6171293ed3d4f2848934f767c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a642e5373e1c618e8a28717ae689a3d94"></a><!-- doxytag: member="MGRLBRep::ReadMembers" ref="a642e5373e1c618e8a28717ae689a3d94" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#a642e5373e1c618e8a28717ae689a3d94">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 戻り値boolは正常に読み出しが出来ればtrue、失敗すればfalseになる <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba3aa7e0c417eb961ef7191e4a9ec992"></a><!-- doxytag: member="MGRLBRep::WriteMembers" ref="aba3aa7e0c417eb961ef7191e4a9ec992" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#aba3aa7e0c417eb961ef7191e4a9ec992">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 戻り値boolは正常に書き込みが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f96d6a17dd9bc2c6d06a87738dd8211"></a><!-- doxytag: member="MGRLBRep::whoami" ref="a9f96d6a17dd9bc2c6d06a87738dd8211" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae648bf81dfb960c379bd3371dedb3454"></a><!-- doxytag: member="MGRLBRep::operator+" ref="ae648bf81dfb960c379bd3371dedb3454" args="(const MGVector &amp;v, const MGRLBRep &amp;lb)" -->
MGDECL friend <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html#ae648bf81dfb960c379bd3371dedb3454">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;lb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Friend Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2603323d34b8c0f1b8a86cd6be993f"></a><!-- doxytag: member="MGRLBRep::operator*" ref="a8b2603323d34b8c0f1b8a86cd6be993f" args="(double scale, const MGRLBRep &amp;)" -->
MGDECL friend <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale, const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines Rational Line B-Representation. </p>
<p>This NURBS is a homogeneous form, i.e., B-Coefficients have weight included values. When usual NURBS form is (xi, yi, zi, wi) , <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> form is (xi*wi, yi*wi, zi*wi, wi) for i=0,..., n-1. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abb6fd79914c0de6bce466fbdf4bf2ec9"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="abb6fd79914c0de6bce466fbdf4bf2ec9" args="(const MGKnotVector &amp;t, const MGBPointSeq &amp;bcoef, int homogeneous=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bcoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>homogeneous</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line NURBS, providing all the member data. </p>
<p>This is the fundamental constructor(when homogeneous=1).***** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Knot Vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bcoef</em>&nbsp;</td><td>Line B-Coef, each of coefficients includes weight multiplied when homogeneous=true(1), and not includes when homogeneous =false. Mximum space dimension id of bcoef is for weight of the rational. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b89617a0872d310ad9a25725dbb0b07"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a9b89617a0872d310ad9a25725dbb0b07" args="(const MGKnotVector &amp;t, const MGBPointSeq &amp;bcoef, const std::vector&lt; double &gt; &amp;weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bcoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line NURBS, providing all the member data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Knot Vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bcoef</em>&nbsp;</td><td>Line B-Coef, each of coefficients does not include weights data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a196d9df99eda6fde1059fc8ed4cf1d4b"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a196d9df99eda6fde1059fc8ed4cf1d4b" args="(const MGPosition &amp;P0, const MGVector &amp;T0, const MGPosition &amp;P, const MGPosition &amp;P2, const MGVector &amp;T2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Original ellipse. </p>
<p>Construct a conic section NURBS. This conic is defined by ths start and end point, and each tangent, and mid-point of the conic. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T0</em>&nbsp;</td><td>Start point and its tangent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Mid point of the conic section </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T2</em>&nbsp;</td><td>End point and its tangent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff58107d9ded2a43eda9b697d7efbb06"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="aff58107d9ded2a43eda9b697d7efbb06" args="(const MGRLBRep &amp;old_brep, const MGKnotVector &amp;t, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate an original NURBS by a new knot configuration. </p>
<p>The new knot config must be inside the range of the original NURBS parameter. However new knots may be coarse or fine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original NURBS. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a957e9617c6720b776e5bc7621690362c"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a957e9617c6720b776e5bc7621690362c" args="(const MGLBRep &amp;brep, int homogeneous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>homogeneous</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>**** Conversion Constructor.**** </p>
<p>Convert from Non ratoinal form to Rational form. When homogeneous==true(non zero), brep is homogeneous form <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. When homogeneous==false(zero), brep is ordinary <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> and will be converted to <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. That is, weight=1 elements will be added as last space dimension element. This is the fundamental constructor. ***** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brep</em>&nbsp;</td><td>Original LBRep. This can be ordinary LBRep, or homogeneous form of <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. When homogeneous form, the last space dimension elements are weights. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>homogeneous</em>&nbsp;</td><td>true(non zero): homogeneous form, false(zero):ordinary LBRep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a39aa95ded41669a862beaf5c009359"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a1a39aa95ded41669a862beaf5c009359" args="(const MGRLBRep &amp;old_brep, const MGKnotArray &amp;knots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>knots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new NURBS by adding knots to an original NURBS. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original NURBS. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>knots</em>&nbsp;</td><td>Knots to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbe51824fd9239d700a66d83abd728ad"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="adbe51824fd9239d700a66d83abd728ad" args="(const MGRLBRep &amp;brep1, int continuity, int which, const MGRLBRep &amp;brep2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>continuity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new NURBS by connecting two NURBS to one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brep1</em>&nbsp;</td><td>NURBS 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>continuity</em>&nbsp;</td><td>continuity. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>which point of brep1 to which of brep2, meaingfull when continuity&gt;=0, =0: start of this and start of brep1, =1: start of this and end of brep1, =2: end of this and start of brep1, =3: end of this and end of brep1, continuity and which can be obtained using <a class="el" href="class_m_g_r_l_b_rep.html#a15d629900d62422e99219a7b0d67c4c0" title="Compute continuity with brep2.">continuity()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>NURBS 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03fdcc0adfcc334f8cc309ceb09ac05c"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a03fdcc0adfcc334f8cc309ceb09ac05c" args="(double t1, double t2, const MGRLBRep &amp;old_brep, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new NURBS by computing a part of the original. </p>
<p>New one is exactly the same as the original except that it is partial. If multiple==true(!=0), knot(i)=t1 and knot(n+i)=t2 for i=0,..., k-1 will be guaranteed. Here, n=bdim() and k=order(). Both t1 and t2 must be inside te range of old_brep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>New parameter range. t1 must be less than t2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original NURBS. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e8ff320ea3aa55b9daebfdc5158021b"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="a1e8ff320ea3aa55b9daebfdc5158021b" args="(size_t dim, const MGRLBRep &amp;lbrep, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lbrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Line NURBS by changing space dimension and ordering of coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lbrep</em>&nbsp;</td><td>Original Line B-rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of original line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac238e27e1aedf07c033c4ec7a496f3cb"></a><!-- doxytag: member="MGRLBRep::MGRLBRep" ref="ac238e27e1aedf07c033c4ec7a496f3cb" args="(double a, double b, double angle1, double angle2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGRLBRep::MGRLBRep </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct 2D ellipse RLBRep, whose center is origin. </p>
<p>The ellipse is expressed as below using parameter t. x(t)=a*cos(t), y(t)=b*sin(t), angle1&lt;=t&lt;=angle2 </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4513b9b24aaf53cecf6a2608a5b599ae"></a><!-- doxytag: member="MGRLBRep::box_limitted" ref="a4513b9b24aaf53cecf6a2608a5b599ae" args="(const MGInterval &amp;l) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGRLBRep::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Return minimum box that includes the partial line. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a680d824802125a83533362f05ee84b71">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a2b1980a4b10f69e1af0c6c638416fb78"></a><!-- doxytag: member="MGRLBRep::change_dimension" ref="a2b1980a4b10f69e1af0c6c638416fb78" args="(size_t dim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac83a24a002d65e6339859e51321fff57">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aca9a4c1c6bda750aa5e760aad9ee0bfe"></a><!-- doxytag: member="MGRLBRep::change_order" ref="aca9a4c1c6bda750aa5e760aad9ee0bfe" args="(unsigned order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::change_order </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>order</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change order of the NURBS. </p>
<p>When new order is greater than the original, new B-rep is guaranteed to be the same line as the original. However, if new order is less than the original one, new line is not the same in general. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>New order number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1afea2f961097ac0a4e65bf572f39d28"></a><!-- doxytag: member="MGRLBRep::change_range" ref="a1afea2f961097ac0a4e65bf572f39d28" args="(double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::change_range </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a260ff34df53249e6887a09553f84058b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af0e21bb30673cd52a8f4549db6918b19"></a><!-- doxytag: member="MGRLBRep::clone" ref="af0e21bb30673cd52a8f4549db6918b19" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>* MGRLBRep::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae85e37def31262577515e70078fb92e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a75ca7ca132edc7460682dfd88e159a6e"></a><!-- doxytag: member="MGRLBRep::coef" ref="a75ca7ca132edc7460682dfd88e159a6e" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGRLBRep::coef </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract (i,j)elements for 0&lt;=j&lt;=sdim() as a vector of (<a class="el" href="class_m_g_r_l_b_rep.html#a9782a3b0d6a799172aa342240200d44e" title="Returns the space dimension.">sdim()</a>+1) space dimension. </p>
<p>The last elemnt is weight. </p>

</div>
</div>
<a class="anchor" id="a23ce7d53635834554bd6b8b2246586ea"></a><!-- doxytag: member="MGRLBRep::connect" ref="a23ce7d53635834554bd6b8b2246586ea" args="(int continuity, int which, const MGRLBRep &amp;brep2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::connect </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>continuity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect brep2 to this brep to make one B-Representation. </p>
<p>This parameter range will not be changed, instead brep2's range will be so changed that brep2 has the same 1st derivative magnitude as the original this brep's at the connecting point(start or end point of this). continuity and which can be obtained using the fucntion <a class="el" href="class_m_g_r_l_b_rep.html#a15d629900d62422e99219a7b0d67c4c0" title="Compute continuity with brep2.">continuity()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>continuity</em>&nbsp;</td><td>continuity. must be&gt;=0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>which point of this to which of brep2. =0: start of this and start of brep2. =1: start of this and end of brep2. =2: end of this and start of brep2. =3: end of this and end of brep2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>B-Rep 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15d629900d62422e99219a7b0d67c4c0"></a><!-- doxytag: member="MGRLBRep::continuity" ref="a15d629900d62422e99219a7b0d67c4c0" args="(const MGRLBRep &amp;brep2, int &amp;which, double &amp;ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRLBRep::continuity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute continuity with brep2. </p>
<p>Function's return value is: -1: G(-1) continuity, i.e. two lines are discontinuous. 0: G0 continuity, i.e. two lines are connected, but tangents are discontinuous 1: C1 continuity, i.e. 1st deriv's are also continuous, when weights are so arranged. 2: C2 continuity, i.e. 2nd deriv's are also continuous, when weights are so arranged. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>Indicates which point of this is connected to which of brep2, is meaingfull when continuity&gt;=0, =0: start of this to start of brep2, =1: start of this to end of brep2, =2: end of this to start of brep2, =3: end of this to end of brep2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio</em>&nbsp;</td><td>Ratio of 1st derivatives of the two line will be returned, ratio= d2/d1, where d1=1st deriv of this and d2=of brep2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98a30b40e27d9b539c1d43d359c4fed2"></a><!-- doxytag: member="MGRLBRep::coordinate_exchange" ref="a98a30b40e27d9b539c1d43d359c4fed2" args="(size_t i, size_t j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::coordinate_exchange </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange ordering of the coordinates. </p>
<p>Exchange coordinates (i) and (j). </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae8c6cb11b641e5b6f596867672bfda66">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa2c781b05b7d3c7bc34a1520013187f6"></a><!-- doxytag: member="MGRLBRep::copy_as_nurbs" ref="aa2c781b05b7d3c7bc34a1520013187f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGRLBRep::copy_as_nurbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy as a newed curve. </p>
<p>The new curve will be <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> or <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. When original curve was a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>, the new curve will be a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. Otherwise, the new curve will be a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. Returned object must be deleted. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a9ef3806ddfd62edf9b7b9c59626caf5a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a70ca358a3433b03ec0bb968291aef239"></a><!-- doxytag: member="MGRLBRep::copy_change_dimension" ref="a70ca358a3433b03ec0bb968291aef239" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>* MGRLBRep::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a84add0aaacbc189dd584dbf9f5670d99">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ae19db276b94803492d1c8c78f4d8b1bd"></a><!-- doxytag: member="MGRLBRep::copy_limitted" ref="ae19db276b94803492d1c8c78f4d8b1bd" args="(const MGInterval &amp;prange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGRLBRep::copy_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area, and limitting the parameter range to prange. </p>
<p>Returned is newed object and must be deleted. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a45bda2b85297af3d92a32f23e011682f">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a13bea2ebbe9e284031f5ad5f9e0ec0d3"></a><!-- doxytag: member="MGRLBRep::divide_multi" ref="a13bea2ebbe9e284031f5ad5f9e0ec0d3" args="(MGPvector&lt; MGCurve &gt; &amp;crv_list, int multiplicity=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRLBRep::divide_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>crv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiplicity</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide this curve at the designated knot multiplicity point. </p>
<p>Function's return value is the number of the curves after divided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv_list</em>&nbsp;</td><td>divided curves will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiplicity</em>&nbsp;</td><td>designates the multiplicity of the knot to divide at, When multiplicity&lt;=0, <a class="el" href="class_m_g_r_l_b_rep.html#a82c73d30c6e8d5c94319c98718f1dec3" title="Returns the order.">order()</a>-1 is assumed, When multiplicity&gt;=order(), <a class="el" href="class_m_g_r_l_b_rep.html#a82c73d30c6e8d5c94319c98718f1dec3" title="Returns the order.">order()</a> is assumed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a1ee0ed7b28c40b502d4eeec470368b4d">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a099bc672335a06c605bb86b8fc49067b"></a><!-- doxytag: member="MGRLBRep::draw_1D" ref="a099bc672335a06c605bb86b8fc49067b" args="(void(*moveto)(int, int), void(*lineto)(int, int), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::draw_1D </td>
          <td>(</td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>t_is_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw this line's coordinate'th coordinate in 2D space as (t, LBRep(coordinate)) when t_is_x is true, or as ( LBRep(coordinate),t) when t_is_x is false, Here t is the parameter of the LBRep. </p>
<p>using drawing function moveto(int, int) and lineto(int,int). The other behaviours are the same as draw_2D. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>id of coordinate, that is =0:x, =1:y, and so on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_is_x</em>&nbsp;</td><td>=true:t is x coordinate, and false:t is y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70dba68c10d9dbd960a51cba9f721718"></a><!-- doxytag: member="MGRLBRep::draw_1D" ref="a70dba68c10d9dbd960a51cba9f721718" args="(void(*moveto)(float, float), void(*lineto)(float, float), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::draw_1D </td>
          <td>(</td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>t_is_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>id of coordinate, that is =0:x, =1:y, and so on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_is_x</em>&nbsp;</td><td>=true:t is x coordinate, and false:t is y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73af488197088f7137d87c387f56e073"></a><!-- doxytag: member="MGRLBRep::draw_1D" ref="a73af488197088f7137d87c387f56e073" args="(void(*moveto)(double, double), void(*lineto)(double, double), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::draw_1D </td>
          <td>(</td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>t_is_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>id of coordinate, that is =0:x, =1:y, and so on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_is_x</em>&nbsp;</td><td>=true:t is x coordinate, and false:t is y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad367fc367cfe8cd6ceaa5b58dcd48336"></a><!-- doxytag: member="MGRLBRep::draw_2D" ref="ad367fc367cfe8cd6ceaa5b58dcd48336" args="(void(*moveto)(int, int), void(*lineto)(int, int), const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::draw_2D </td>
          <td>(</td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw this line's 1st and 2nd coordinates in 2D space using drawing function moveto( , ) and lineto( , ). </p>
<p>wind[] is the window of the screen to draw the line in. Clipping will be performed about the wind[]. (wind[0], wind[1]) is the center coordinates of the window. wind[2] is width and wind[3] is hight of the window. When wind[2]&lt;=0, no clipping is performed. Even when wind[2]&lt;=0, wind[3] is necessary to input to specify the resolution of the line. In this case, wind[0] and wind[1] are not referended. ynum is the resolution of the line, is the number of straight line segments for the curve length of wind[3](height of window). draw_2D does not perform box including judment, always performs clipping operation and draws the line. Users must do obvious box inclusion test if maximum drawing performance is necessary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b6c6bb90b391ecb1ec56da31b8a23b1"></a><!-- doxytag: member="MGRLBRep::draw_2D" ref="a3b6c6bb90b391ecb1ec56da31b8a23b1" args="(void(*moveto)(float, float), void(*lineto)(float, float), const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::draw_2D </td>
          <td>(</td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84a06868905636541620a6ec7e73c1f3"></a><!-- doxytag: member="MGRLBRep::draw_2D" ref="a84a06868905636541620a6ec7e73c1f3" args="(void(*moveto)(double, double), void(*lineto)(double, double), const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::draw_2D </td>
          <td>(</td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf9d2a88d59cf71c8c76d75f6f383541"></a><!-- doxytag: member="MGRLBRep::drawSE" ref="abf9d2a88d59cf71c8c76d75f6f383541" args="(double span_length, double t0, double t1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::drawSE </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>Start parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>End parameter value of the curve. Draw will be performed from t0 to t1. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a20497e172065788e673b771f018d90af">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac892bfc228d273051f911216e68ce803"></a><!-- doxytag: member="MGRLBRep::eval" ref="ac892bfc228d273051f911216e68ce803" args="(double t, size_t nderiv=0, int left=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGRLBRep::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous n'th derivative data. </p>
<p>nderiv=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>Left continuous(left=true) or right continuous(left=false). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#acbcbb8f812be257921ef63c71afdedcf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a0e3b290b0584debdf0b1664796eb7484"></a><!-- doxytag: member="MGRLBRep::eval_all" ref="a0e3b290b0584debdf0b1664796eb7484" args="(double tau, MGPosition &amp;P, MGVector &amp;V1, MGVector &amp;V2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute position, 1st and 2nd derivatives. </p>
<p>パラメータ値を与えて位置、一次微分値、二次微分値をもとめる。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Input parameter value(パラメータ値) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Position(位置) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>1st derivative(1次微分値) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>2nd derivative(2次微分値) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a9ea3970501a3d9c681a38ff584018b41">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac6159f651c702908488affdd89faaa3c"></a><!-- doxytag: member="MGRLBRep::eval_all" ref="ac6159f651c702908488affdd89faaa3c" args="(double tau, size_t nderiv, double *deriv, int left=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate all of i'th derivative data for 0&lt;=i&lt;=nderiv. </p>
<p>Output will be put on deriv[j+i*sdim()] for 0&lt;=i&lt;=nderiv and 0&lt;=j&lt;<a class="el" href="class_m_g_r_l_b_rep.html#a9782a3b0d6a799172aa342240200d44e" title="Returns the space dimension.">sdim()</a>, i.e. deriv[j+i*sdim()] is i-th derivative data for 0&lt;=j&lt;<a class="el" href="class_m_g_r_l_b_rep.html#a9782a3b0d6a799172aa342240200d44e" title="Returns the space dimension.">sdim()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Parameter value to evaluate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deriv</em>&nbsp;</td><td>Output area of size (nderiv+1)*sdim(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>Left continuous(left=true) or right continuous(left=false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0b37e783673e32f09e422fbe14de441"></a><!-- doxytag: member="MGRLBRep::extend" ref="af0b37e783673e32f09e422fbe14de441" args="(double length, bool start=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::extend </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate this curve by an (approximate) chord length. </p>
<p>The extrapolation is C2 continuous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>approximate chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of which point to extend, start or end point of the line. If start is true extend on the start point. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#af0e8206d530257d27910d0676ba0be01">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a633b84e8d9c319bd753569e247488836"></a><!-- doxytag: member="MGRLBRep::extend" ref="a633b84e8d9c319bd753569e247488836" args="(int start, double length, double dk=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original NURBS by extrapolating the specified perimeter. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of start or end poit of the line, If start is true extend on the start point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at extrapolation start point. When dk=0, curvature keeps same, i.e., dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point, (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2564b4ecf078872a082cd1bd23242d1a"></a><!-- doxytag: member="MGRLBRep::extend_with_parameter" ref="a2564b4ecf078872a082cd1bd23242d1a" args="(double tau, double dk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::extend_with_parameter </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate the curve by the parameter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>The parameter value at the end of extended point, When tau&lt;<a class="el" href="class_m_g_r_l_b_rep.html#ab4a7800ef6396a09ed87b1f0f7564f60" title="Return starting parameter value.">param_s()</a>, extension will be done at the starting point, When tau&gt;<a class="el" href="class_m_g_r_l_b_rep.html#a1347fac4bf573b6c764005048d1059fd" title="Return ending parameter value.">param_e()</a>, extension will be done at the end point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at the connecting point. See <a class="el" href="class_m_g_r_l_b_rep.html#af0b37e783673e32f09e422fbe14de441" title="Extrapolate this curve by an (approximate) chord length.">extend()</a>; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2db3d688dd1211a90d157782f56e355e"></a><!-- doxytag: member="MGRLBRep::get_control_points" ref="a2db3d688dd1211a90d157782f56e355e" args="(MGBPointSeq &amp;cpoints) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGRLBRep::get_control_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cpoints</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts control points. </p>
<p>Fucntion's return value is true if control points was obtained, false if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpoints</em>&nbsp;</td><td>Control points will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7bb80ff3ce43fa39ab6845885089770f">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aeccb25cc040074dfe3883585c6e2a523"></a><!-- doxytag: member="MGRLBRep::intersect_1D" ref="aeccb25cc040074dfe3883585c6e2a523" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGRLBRep::intersect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection point of 1D sub NURBS of original B-rep. </p>
<p>Parameter values of this at intersection points will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7da60650ad1b0c4823eeb1c3ce8be722">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af19428e9123d5a96e53aab4880b43413"></a><!-- doxytag: member="MGRLBRep::is_coplanar" ref="af19428e9123d5a96e53aab4880b43413" args="(const MGCurve &amp;curve2, MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGRLBRep::is_coplanar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is co-planar with the 2nd curve curve2. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is co-planar. Function's return value is true if co-planar. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a84a92b42fe2946b772eb30081d2c5ad6">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="abc88d73f88250959329b252198fb12b1"></a><!-- doxytag: member="MGRLBRep::is_planar" ref="abc88d73f88250959329b252198fb12b1" args="(MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGRLBRep::is_planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is planar or not. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is planar. Function's return value is true if planar. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a3e6f96416ab574420cbed88ebfc414e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af0002a2943f4718f2b75198a111e0fbd"></a><!-- doxytag: member="MGRLBRep::isect" ref="af0002a2943f4718f2b75198a111e0fbd" args="(const MGCurve &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> MGRLBRep::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spline と Curve の交点を求める。 Intersection point of spline and curve. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a379e4f21b3055c90d7f83897341cd7d8">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a7ab1313b0b09eae154a485754a3dff4a"></a><!-- doxytag: member="MGRLBRep::isect" ref="a7ab1313b0b09eae154a485754a3dff4a" args="(const MGSurface &amp;surf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGRLBRep::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Spline and Surface. </p>
<p>Intersection of <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> and Surface </p>

<p>Implements <a class="el" href="class_m_g_curve.html">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a50f41ec1265ea9e4dd23e8ff52855a0d"></a><!-- doxytag: member="MGRLBRep::isect_2D" ref="a50f41ec1265ea9e4dd23e8ff52855a0d" args="(const MGStraight &amp;sl, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGRLBRep::isect_2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection point of 2D sub NURBS of original B-rep. </p>
<p>Parameter values of this at intersection points will be returned. Straight line sl and this(RLBRep) will be projected to 2D plane of coordinate kind (coordinate, coordinate+1), then intersection will be computed. For example when sl and this are 3 dimension (x,y,z), and coodinate =2, 2D data (z,x) are extracted from sl and this, then intersection will be performed. Note** <a class="el" href="class_m_g_straight.html" title="MGStraight is a curve of any space dimension, represent a straight line.">MGStraight</a> sl is treated as infinite straight line, even if it is finite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sl</em>&nbsp;</td><td>Straight line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of 2D sub space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bbbb06e2209e52822fdebfa64017701"></a><!-- doxytag: member="MGRLBRep::isect_3D" ref="a5bbbb06e2209e52822fdebfa64017701" args="(const MGPlane &amp;pl, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGRLBRep::isect_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of 3D sub NURBS of original B-rep. </p>
<p>Parameter values of thisat intersection points will be returned. This(RLBRep) will be projected to 3D plane of coordinate kind (coordinate, coordinate+1, coordinate+2), then intersection will be computed. This is valid only when <a class="el" href="class_m_g_r_l_b_rep.html#a9782a3b0d6a799172aa342240200d44e" title="Returns the space dimension.">sdim()</a>&gt;=4. For example when pl and this are 4 dimension (x,y,z,p), and coodinate =1, 3D data (y,z,p) are extracted from pl and this, then intersection will be performed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pl</em>&nbsp;</td><td>Plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of 3D sub space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad45a21e8d95e3a80d990870cb0b53783"></a><!-- doxytag: member="MGRLBRep::knot_vector" ref="ad45a21e8d95e3a80d990870cb0b53783" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a>&amp; MGRLBRep::knot_vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector. </p>
<p>RHS version. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a6b0a611b67e7de7e6763de85a869eacc">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a68ed2a1e306ba106b677c867069de633"></a><!-- doxytag: member="MGRLBRep::knot_vector" ref="a68ed2a1e306ba106b677c867069de633" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a>&amp; MGRLBRep::knot_vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector. </p>
<p>LHS version. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ac678277be215f7edddbe189c83ba48e3">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a9ba74256cfa8bd870e9c8471df266ebb"></a><!-- doxytag: member="MGRLBRep::limit" ref="a9ba74256cfa8bd870e9c8471df266ebb" args="(const MGInterval &amp;itvl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>itvl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身に指定したパラメータ範囲のlimitをつける。 Get the sub interval line of the original line. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a4f5e376f184379038ebac06536962e32">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="afdacbe34b22baade77555b962d596972"></a><!-- doxytag: member="MGRLBRep::line_bcoef" ref="afdacbe34b22baade77555b962d596972" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGRLBRep::line_bcoef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the B-coef's. </p>
<p>RHS version. </p>

</div>
</div>
<a class="anchor" id="a720d484e639be2885caeda33a63fe9a4"></a><!-- doxytag: member="MGRLBRep::line_bcoef" ref="a720d484e639be2885caeda33a63fe9a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGRLBRep::line_bcoef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the B-coef's. </p>
<p>LHS version. </p>

</div>
</div>
<a class="anchor" id="a99a0eaca0e8eae63074d4305f74817fc"></a><!-- doxytag: member="MGRLBRep::non_homogeneous_bcoef" ref="a99a0eaca0e8eae63074d4305f74817fc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGRLBRep::non_homogeneous_bcoef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return non_homogeneous B-Coefficients with weights of the rational B-Spline. </p>
<p>This <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> includes weights. </p>

</div>
</div>
<a class="anchor" id="a2d94a3c0591043be21ce905f3b3c7fbb"></a><!-- doxytag: member="MGRLBRep::non_rational" ref="a2d94a3c0591043be21ce905f3b3c7fbb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRLBRep::non_rational </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this is actually non_rational, i.e. </p>
<p>, all of the weights are same values. If non_rational return true, else false. </p>

</div>
</div>
<a class="anchor" id="a5ade0e6171293ed3d4f2848934f767c1"></a><!-- doxytag: member="MGRLBRep::oneD" ref="a5ade0e6171293ed3d4f2848934f767c1" args="(const double g[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGRLBRep::oneD </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>g</em>[4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve. </p>
<p>This is used to compute intersections with a plane g[4]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>Plane expression(a,b,c,d) where ax+by+cz=d. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac0d98232c1251692db526e28d65a6f7e">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ae306d5af9f9b247b387398448a02018c"></a><!-- doxytag: member="MGRLBRep::operator=" ref="ae306d5af9f9b247b387398448a02018c" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MGRLBRep(const MGRLBRep&amp;); ///Copy constructor. </p>
<p>We can use default copy constructor. Destructor ///////// ‾MGRLBRep(); ///We can use default destructor. Assignment. When the leaf object of this and crv2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="a6b90e729511e9bec4a8390a68868bc27"></a><!-- doxytag: member="MGRLBRep::out_to_IGES" ref="a6b90e729511e9bec4a8390a68868bc27" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRLBRep::out_to_IGES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>igesfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>SubordinateEntitySwitch</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector. </p>
<p><a class="el" href="class_m_g_knot_vector.html" title="Defines Knot vector of B-Representation.">MGKnotVector</a> knot_vector_real() const{return <a class="el" href="class_m_g_r_l_b_rep.html#a68ed2a1e306ba106b677c867069de633" title="Returns the knot vector.">knot_vector()</a>;} Debug Function IGES output function. PD126. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#a2a9cfbfd6f4963a47f4a5b4c4384f436">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="a7cd7adeb85fef88b47ae7ad99de0d6f5"></a><!-- doxytag: member="MGRLBRep::param_normalize" ref="a7cd7adeb85fef88b47ae7ad99de0d6f5" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGRLBRep::param_normalize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize parameter value t to the nearest knot if their distance is within tolerance. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ab8d6aac48fea5813393870bcbd6a1e78">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a18885b819cf4f01225b363fb5ae2a6b1"></a><!-- doxytag: member="MGRLBRep::part" ref="a18885b819cf4f01225b363fb5ae2a6b1" args="(double t1, double t2, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>* MGRLBRep::part </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of this curve from parameter t1 to t2. </p>
<p>Returned is the pointer to newed object, and so should be deleted by calling program, or memory leaked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a57c9d6e7f929b0d77c75cc6417daba2b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a42d26d183568e3982302e94ce41a98a4"></a><!-- doxytag: member="MGRLBRep::perps" ref="a42d26d183568e3982302e94ce41a98a4" args="(const MGCurve &amp;crv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGRLBRep::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the perpendicular points of this curve and the second one. </p>
<p>That is, if f(s) and g(t) are the points of the two curves f and g, then obtains points where the following conditions are satisfied: fs*(f-g)=0. gt*(g-f)=0. Here fs and gt are 1st derivatives at s and t of f and g. <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv2's parameter value. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a0da4a6809840a951581a99174dbebbab">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="accbf515dd2c383b15b962158fce22d32"></a><!-- doxytag: member="MGRLBRep::planar" ref="accbf515dd2c383b15b962158fce22d32" args="(MGPlane &amp;plane, MGStraight &amp;line, MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRLBRep::planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the line B-rep is planar. </p>
<p>Funtion's return value is; 0: Not planar, nor a point, nor straight line. 1: NURBS is a point. 2: NURBS is a straight line. 3: NURBS is planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>When Brep is not straight line nor a point, plane is returned. Even when not planar(return value is 0), plane nearest is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>When Brep is a line, line is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When Brep is a point, point is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa48bd02ee4b5b83610bbbbbc7d0af7e9"></a><!-- doxytag: member="MGRLBRep::reduce" ref="aa48bd02ee4b5b83610bbbbbc7d0af7e9" args="(int ndec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGRLBRep::reduce </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the NURBS by decreasing B-Rep dimension by ndec. </p>
<p>This is an approximation of the origimal NURBS. Return value is error flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndec</em>&nbsp;</td><td>Number of B-Rep dimension to decrease </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c90fbd486a60dac8e7e54a7874f8140"></a><!-- doxytag: member="MGRLBRep::refine" ref="a9c90fbd486a60dac8e7e54a7874f8140" args="(const MGKnotVector &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a>&amp; MGRLBRep::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change an original NURBS to new one with subdivided knot configuration. </p>
<p>Knots t must be subdivided knots. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afefcb8967b95d87d6fb3464c0c1441a4"></a><!-- doxytag: member="MGRLBRep::remove_knot" ref="afefcb8967b95d87d6fb3464c0c1441a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGRLBRep::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot. </p>
<p>line_zero tolerance is used. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#aac3a1862056a9ea5e662e692f2fcebbb">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a6b5168b1d7a6cbc610134ccdee172f57"></a><!-- doxytag: member="MGRLBRep::sweep" ref="a6b5168b1d7a6cbc610134ccdee172f57" args="(const MGUnit_vector &amp;uvec, double start_dist, double end_dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGRLBRep::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sweep surface from crv Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted. </p>
<p>The sweep surface is defined as: This curve(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ab444253d2ae843173c03d0dc2c79e814">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af78176beb1185058b7af73bc7bdb0ff4"></a><!-- doxytag: member="MGRLBRep::type" ref="af78176beb1185058b7af73bc7bdb0ff4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a> MGRLBRep::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲線のタイプをを返す。 Return the curve type. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a23f1534a8c49c1ca508e313088648113">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8334cd756aeba48b159ef0f88792dee9"></a><!-- doxytag: member="MGRLBRep::unlimit" ref="a8334cd756aeba48b159ef0f88792dee9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>&amp; MGRLBRep::unlimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>limitをはずす。 unlimit this line. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a7dd0795698c8dbd41ce5f76b0beabb20">MGCurve</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>RLBRep.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:27 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

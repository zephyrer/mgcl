<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGPosition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGPosition Class Reference<br/>
<small>
[<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGPosition" -->
<p>Represent a positional data.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Position.h&gt;</code></p>
<div class="dynheader">
Collaboration diagram for MGPosition:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_position__coll__graph.png" border="0" usemap="#_m_g_position_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_position_coll__map" id="_m_g_position_coll__map">
<area shape="rect" id="node2" href="class_m_g_vector.html" title="Vector of a general n space dimension." alt="" coords="11,5,91,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_position-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a7cab45a7a24dfdf4add4b1ac06b33"></a><!-- doxytag: member="MGPosition::MGPosition" ref="ac9a7cab45a7a24dfdf4add4b1ac06b33" args="(const MGPoint &amp;point)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ac9a7cab45a7a24dfdf4add4b1ac06b33">MGPosition</a> (const <a class="el" href="class_m_g_point.html">MGPoint</a> &amp;point)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion Constructor from a point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d92f1685ce5bd9ce10c8e8e8a7f9823"></a><!-- doxytag: member="MGPosition::MGPosition" ref="a4d92f1685ce5bd9ce10c8e8e8a7f9823" args="(const MGVector &amp;vec)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a4d92f1685ce5bd9ce10c8e8e8a7f9823">MGPosition</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion Constructor from a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa24fc48952f88f89b576b1a511077c4e"></a><!-- doxytag: member="MGPosition::MGPosition" ref="aa24fc48952f88f89b576b1a511077c4e" args="(size_t sdim=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aa24fc48952f88f89b576b1a511077c4e">MGPosition</a> (size_t sdim=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor void コンストラクタ. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a732b3a09a7230bdb94fc092ccc832069"></a><!-- doxytag: member="MGPosition::MGPosition" ref="a732b3a09a7230bdb94fc092ccc832069" args="(double x, double y)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a732b3a09a7230bdb94fc092ccc832069">MGPosition</a> (double x, double y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 2D position by providing x,y coordinate data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e568b6cc6156b60bc2afd1683ed45f8"></a><!-- doxytag: member="MGPosition::MGPosition" ref="a6e568b6cc6156b60bc2afd1683ed45f8" args="(double x, double y, double z)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a6e568b6cc6156b60bc2afd1683ed45f8">MGPosition</a> (double x, double y, double z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 3D position by providing x,y,z coordinate data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f023782de5f1c254edbbe9d534a7ee3"></a><!-- doxytag: member="MGPosition::MGPosition" ref="a8f023782de5f1c254edbbe9d534a7ee3" args="(double x, double y, double z, double w)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a8f023782de5f1c254edbbe9d534a7ee3">MGPosition</a> (double x, double y, double z, double w)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 4D position by providing x,y,z,w coordinate data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a20d2496d67d678a0107bff88c381e807">MGPosition</a> (size_t sdim, const double *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double の配列でcoordinate valueを指定しPositionを生成する。 Construct sdim space dimension positional data providing each coordinate data through doble array.  <a href="#a20d2496d67d678a0107bff88c381e807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a6f111cdb4f9456c3a3816d957d7338db">MGPosition</a> (size_t sdim, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct position by copying old position, changing space dimension and ordering of old coordinates.  <a href="#a6f111cdb4f9456c3a3816d957d7338db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa873b6ec6adf60af29096696c922c22c"></a><!-- doxytag: member="MGPosition::MGPosition" ref="aa873b6ec6adf60af29096696c922c22c" args="(const std::vector&lt; double &gt; &amp;darrays)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aa873b6ec6adf60af29096696c922c22c">MGPosition</a> (const std::vector&lt; double &gt; &amp;darrays)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from std::vector&lt;double&gt; <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ad3720d18f4a95ef49cb49fe7d9ad9ddb">operator=</a> (const double *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> ( const <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>&amp; ); We use default copy constructor.  <a href="#ad3720d18f4a95ef49cb49fe7d9ad9ddb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fca14f677e6488d3c9c18bbb87779a5"></a><!-- doxytag: member="MGPosition::operator[]" ref="a1fca14f677e6488d3c9c18bbb87779a5" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a1fca14f677e6488d3c9c18bbb87779a5">operator[]</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return i-th element of the position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e551ad8bb7986149c9b05ee828c46c5"></a><!-- doxytag: member="MGPosition::operator()" ref="a3e551ad8bb7986149c9b05ee828c46c5" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc58ad426e54bb617d6c5030bf984d21"></a><!-- doxytag: member="MGPosition::operator()" ref="adc58ad426e54bb617d6c5030bf984d21" args="(size_t i)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#adc58ad426e54bb617d6c5030bf984d21">operator()</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ac360115c2a75853f979db61f999aea81">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のPositionに与えられたPositionを加算して自身のPositionとする Translation of the position.  <a href="#ac360115c2a75853f979db61f999aea81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cdfc1bdd611450c0e71d25c13bc85cc"></a><!-- doxytag: member="MGPosition::operator+=" ref="a2cdfc1bdd611450c0e71d25c13bc85cc" args="(const MGPosition &amp;pos)" -->
<a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a1d805a4d53afa9ad9d7e2ed5fb01a019">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">単項マイナス。自身のPositionを反転し、Objectを生成 Unary minus.  <a href="#a1d805a4d53afa9ad9d7e2ed5fb01a019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a56db684f9ab6b25064d7fdb71b1e295f">operator-=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のPositionから与えられたVectorを減算し自身のPositionとする Translation of the position.  <a href="#a56db684f9ab6b25064d7fdb71b1e295f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a6c8f3f0b0f4c518464777a818d52a6c7">operator*=</a> (double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalarの乗算を行い自身のPositionとする Scaling of the position.  <a href="#a6c8f3f0b0f4c518464777a818d52a6c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a32c2911168272a0f500dc6e3f8082d29">operator*=</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MatrixによるPositionの変換を行い自身のPositionとする Matrix transformation of the position.  <a href="#a32c2911168272a0f500dc6e3f8082d29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a9c825ed0a284922e43c021b312d2c85e">operator*=</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PositionのTransformを行いPositionを生成して， 自身のPositionとする General transformation of the position.  <a href="#a9c825ed0a284922e43c021b312d2c85e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a6457a84a25ea10123d2344c2fd93a4e8">operator/=</a> (double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar除算を行い自身のPositionとする Scaling of the position.  <a href="#a6457a84a25ea10123d2344c2fd93a4e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#afd7472781501be0ba381dc2bc0f4e2f7">angle</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;normal) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let this be the center of the rotation, then compute the angle rotated around the normal from start to end.  <a href="#afd7472781501be0ba381dc2bc0f4e2f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717d9176e45365728703bdc8e22bf0ca"></a><!-- doxytag: member="MGPosition::clear" ref="a717d9176e45365728703bdc8e22bf0ca" args="(double init=0.0)" -->
<a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a717d9176e45365728703bdc8e22bf0ca">clear</a> (double init=0.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all the element by the value init. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a590161f09fe892ba43fc05a53cffc948">closest</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value of the curve from this point.  <a href="#a590161f09fe892ba43fc05a53cffc948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a9cfb94502f49d3e48c6e4d5b876486d3">closest</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value (u,v)of the surface from this point.  <a href="#a9cfb94502f49d3e48c6e4d5b876486d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#af9591e9a1ff4993704f6b64373e33ad3">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#af9591e9a1ff4993704f6b64373e33ad3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad163b620a19073e7c412484c9580cc8f"></a><!-- doxytag: member="MGPosition::data" ref="ad163b620a19073e7c412484c9580cc8f" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ad163b620a19073e7c412484c9580cc8f">data</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the 1st address of the array of the point double data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe5d519e8b53d3bb98e697529781a2ca"></a><!-- doxytag: member="MGPosition::data" ref="abe5d519e8b53d3bb98e697529781a2ca" args="()" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5facbc32b3c8f7941c0e10ce650447fa"></a><!-- doxytag: member="MGPosition::dlist_name" ref="a5facbc32b3c8f7941c0e10ce650447fa" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a5facbc32b3c8f7941c0e10ce650447fa">dlist_name</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display list name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38fd312ea655f3f6cecbb01c302af4e2"></a><!-- doxytag: member="MGPosition::distance" ref="a38fd312ea655f3f6cecbb01c302af4e2" args="(const MGPosition &amp;P2) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a38fd312ea655f3f6cecbb01c302af4e2">distance</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the distance of this and P2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ad23d2f6dd955a835f3d553abd239e8db">interpolate</a> (double t2, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;vec2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a Position by interpolating two Position.  <a href="#ad23d2f6dd955a835f3d553abd239e8db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aa932d589ebee071342755cf849b6c9df">is_collinear</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P2, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P3) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this, P2, and P3 are on a single straight line.  <a href="#aa932d589ebee071342755cf849b6c9df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aa0f9ec061b076593dbfdb71290f792"></a><!-- doxytag: member="MGPosition::is_null" ref="a3aa0f9ec061b076593dbfdb71290f792" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a3aa0f9ec061b076593dbfdb71290f792">is_null</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a906c5f14b368a2863f6e743a2516b795">len</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Positionと原点との距離を求める。 Return the lenght between the origin(0,0,0) and the position.  <a href="#a906c5f14b368a2863f6e743a2516b795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#adc20c50c6ffbe4ea133592f489226743">on</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">点が曲線上にあるかを調べる。曲線上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Test if the position is on a curve.  <a href="#adc20c50c6ffbe4ea133592f489226743"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aa9a1817ca3122def759f7b7ec0a53766">on</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">点が曲面上にあるかを調べる。曲面上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Test if the position is on a surface.  <a href="#aa9a1817ca3122def759f7b7ec0a53766"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#afb2f3ce46553bb5fb8e07765558e94c5">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PD116=Point.  <a href="#afb2f3ce46553bb5fb8e07765558e94c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a4802828d575d3e04510e249923e8ecd8">param</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve's parameter value of this point.  <a href="#a4802828d575d3e04510e249923e8ecd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#abf2e6ff7d0879863b149609178d09479">param</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return surface's parameter value of this point.  <a href="#abf2e6ff7d0879863b149609178d09479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a0db32bf4da06f47c6543295aaa22c8f1">perps</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all foot points of the perpendicular line from this point to a curve.  <a href="#a0db32bf4da06f47c6543295aaa22c8f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a608bcbb985f08869ff9c39650cc11c4f">perps</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all foot points of the perpendicular line from this point to a surface.  <a href="#a608bcbb985f08869ff9c39650cc11c4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec90a3d4abb1fae1ba15f7090f735f74"></a><!-- doxytag: member="MGPosition::project" ref="aec90a3d4abb1fae1ba15f7090f735f74" args="(const MGVector &amp;v2) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aec90a3d4abb1fae1ba15f7090f735f74">project</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身の点を原点からこの点までのベクトルとして ベクトル(v2)に射影したベクトルを求める。 v2 が 零ベクトルのとき(*this)が返る。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e90fcc13922a56c50ece0f291109837"></a><!-- doxytag: member="MGPosition::ref" ref="a6e90fcc13922a56c50ece0f291109837" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>ref</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ab8f770292ff40820cdf064659beb880d">resize</a> (size_t new_sdim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the position, that is , change the space dimension.  <a href="#ab8f770292ff40820cdf064659beb880d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e566c1ccab30f42a5e8c97020b23dc"></a><!-- doxytag: member="MGPosition::sdim" ref="ac6e566c1ccab30f42a5e8c97020b23dc" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ac6e566c1ccab30f42a5e8c97020b23dc">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7ffa2ba09a606ddd0bd4dd83deaac0f"></a><!-- doxytag: member="MGPosition::set_null" ref="ab7ffa2ba09a606ddd0bd4dd83deaac0f" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ab7ffa2ba09a606ddd0bd4dd83deaac0f">set_null</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this as a null position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a623bfda9bb0aa3e032d65dec6ffb2028">store_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2, size_t j=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store vec2 data into *this.  <a href="#a623bfda9bb0aa3e032d65dec6ffb2028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ad95013ee0129b382b5e29c26dbe3401a">store_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2, size_t j, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store vec2 data into *this.  <a href="#ad95013ee0129b382b5e29c26dbe3401a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a01db02fb67502c7527731a7b8557df04">swap</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two coordinates.  <a href="#a01db02fb67502c7527731a7b8557df04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c4827779a982e39a722ffd01ab7d85"></a><!-- doxytag: member="MGPosition::vector" ref="a70c4827779a982e39a722ffd01ab7d85" args="() const " -->
const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>vector</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25131d8faf64dad33d649d57144a39be"></a><!-- doxytag: member="MGPosition::dump_size" ref="a25131d8faf64dad33d649d57144a39be" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a25131d8faf64dad33d649d57144a39be">dump_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Functions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d045e94a95c554817c799fddefbfa3b"></a><!-- doxytag: member="MGPosition::dump" ref="a9d045e94a95c554817c799fddefbfa3b" args="(MGOfstream &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a9d045e94a95c554817c799fddefbfa3b">dump</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a386d95abae9e5891e069e208a80f2e97"></a><!-- doxytag: member="MGPosition::restore" ref="a386d95abae9e5891e069e208a80f2e97" args="(MGIfstream &amp;)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a386d95abae9e5891e069e208a80f2e97">restore</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore Function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afef185b9de21208083da45ddf5bbc7ff"></a><!-- doxytag: member="MGPosition::operator+" ref="afef185b9de21208083da45ddf5bbc7ff" args="(const MGPosition &amp;p1, const MGVector &amp;vec)" -->
MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#afef185b9de21208083da45ddf5bbc7ff">operator+</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translation of the position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f1a20666db0493a9285595aa670c2c"></a><!-- doxytag: member="MGPosition::operator+" ref="a73f1a20666db0493a9285595aa670c2c" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8d0df82f22ff6566a539ca865b544e1"></a><!-- doxytag: member="MGPosition::operator+" ref="af8d0df82f22ff6566a539ca865b544e1" args="(const MGVector &amp;v, const MGPosition &amp;p)" -->
MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba11ac6056ff1cee26fcfd08acc4285"></a><!-- doxytag: member="MGPosition::operator&#45;" ref="aeba11ac6056ff1cee26fcfd08acc4285" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aeba11ac6056ff1cee26fcfd08acc4285">operator-</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のPositionと与えられたPositionの減算してMGVectorを生成 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f1027ae52831ed682c5d546c65e8a0"></a><!-- doxytag: member="MGPosition::operator&#45;" ref="ad3f1027ae52831ed682c5d546c65e8a0" args="(const MGPosition &amp;p1, const MGVector &amp;v)" -->
MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ad3f1027ae52831ed682c5d546c65e8a0">operator-</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のPositionと与えられたVectorの減算してMGPositionを生成 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f032b180bbc0e3a5669d4740ed3198"></a><!-- doxytag: member="MGPosition::operator&#45;" ref="ab0f032b180bbc0e3a5669d4740ed3198" args="(const MGVector &amp;v, const MGPosition &amp;p1)" -->
MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ab0f032b180bbc0e3a5669d4740ed3198">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のPositionと与えられたVectorの減算してMGPositionを生成 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a3fe4c1ea6b617bb6491671492f0e9f16">operator%</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身の点と与えられたベクトルの内積を行う Inner product of a osition and a vector.  <a href="#a3fe4c1ea6b617bb6491671492f0e9f16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a1f80daca9aed5d70dc4888c9458c1377">operator*</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MatrixによるPositionの変換を行いObjectを生成 Matrix transformation of the position.  <a href="#a1f80daca9aed5d70dc4888c9458c1377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a7bfa7b17735b1b402441dcbb4f2e5fa8">operator*</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PositionのTransformを行いVectorを生成 General transformation of the position.  <a href="#a7bfa7b17735b1b402441dcbb4f2e5fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#ac2bc2a4c0d8187782127be151d33c343">operator*</a> (double s, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PositionのScalar乗算を行いObjectを生成 Scaling of the position.  <a href="#ac2bc2a4c0d8187782127be151d33c343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29e95de26216c5b4e2f39d68f503bb1"></a><!-- doxytag: member="MGPosition::operator*" ref="aa29e95de26216c5b4e2f39d68f503bb1" args="(const MGPosition &amp;p1, double s)" -->
MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aa29e95de26216c5b4e2f39d68f503bb1">operator*</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, double s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalarの乗算を行いPositionを生成. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#aca268d68a81eed77b1856247588d63d3">operator/</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, double s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar除算を行いObjectを生成 Scaling of the position.  <a href="#aca268d68a81eed77b1856247588d63d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ccbc4c9098f2e83beb264d4a66d09de"></a><!-- doxytag: member="MGPosition::operator&lt;&lt;" ref="a4ccbc4c9098f2e83beb264d4a66d09de" args="(std::ostream &amp;, const MGPosition &amp;)" -->
MGDECL friend std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a4ccbc4c9098f2e83beb264d4a66d09de">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#a368135936ee9dff60d01c58cb73690c0">operator==</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたPositionの成分の値を比較し、同じであれば TRUE を返却 Comparison of two positions.  <a href="#a368135936ee9dff60d01c58cb73690c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24e4f32cd4df44705b998ff4153156a0"></a><!-- doxytag: member="MGPosition::operator==" ref="a24e4f32cd4df44705b998ff4153156a0" args="(const MGVector &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a290b54038458faee7b52b44727500b95"></a><!-- doxytag: member="MGPosition::operator==" ref="a290b54038458faee7b52b44727500b95" args="(const MGPosition &amp;p1, const MGVector &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f734b9f4ae9f8def0c562185dc88d6"></a><!-- doxytag: member="MGPosition::operator!=" ref="a38f734b9f4ae9f8def0c562185dc88d6" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a013052d9774e41b8033a29aa6ac414fc"></a><!-- doxytag: member="MGPosition::operator!=" ref="a013052d9774e41b8033a29aa6ac414fc" args="(const MGVector &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4650eb2f0a2a2988d4054971e263d4"></a><!-- doxytag: member="MGPosition::operator!=" ref="a6c4650eb2f0a2a2988d4054971e263d4" args="(const MGPosition &amp;p1, const MGVector &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_position.html#af049b6799a054fde67556e197486516a">operator&lt;</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this position is less than p2.  <a href="#af049b6799a054fde67556e197486516a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a523aa78e69cb3de3b2e401bcd187e2ad"></a><!-- doxytag: member="MGPosition::operator&lt;=" ref="a523aa78e69cb3de3b2e401bcd187e2ad" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750ddc6e7d2ab606c608d8716e35e029"></a><!-- doxytag: member="MGPosition::operator&gt;" ref="a750ddc6e7d2ab606c608d8716e35e029" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e5468e31bfe11e64cd80642c94a337a"></a><!-- doxytag: member="MGPosition::operator&gt;=" ref="a8e5468e31bfe11e64cd80642c94a337a" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
MGDECL friend bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p2)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Represent a positional data. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a20d2496d67d678a0107bff88c381e807"></a><!-- doxytag: member="MGPosition::MGPosition" ref="a20d2496d67d678a0107bff88c381e807" args="(size_t sdim, const double *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPosition::MGPosition </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>double の配列でcoordinate valueを指定しPositionを生成する。 Construct sdim space dimension positional data providing each coordinate data through doble array. </p>
<p>This is the fundamental constructor.***** </p>

</div>
</div>
<a class="anchor" id="a6f111cdb4f9456c3a3816d957d7338db"></a><!-- doxytag: member="MGPosition::MGPosition" ref="a6f111cdb4f9456c3a3816d957d7338db" args="(size_t sdim, const MGPosition &amp;p, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPosition::MGPosition </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct position by copying old position, changing space dimension and ordering of old coordinates. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afd7472781501be0ba381dc2bc0f4e2f7"></a><!-- doxytag: member="MGPosition::angle" ref="afd7472781501be0ba381dc2bc0f4e2f7" args="(const MGPosition &amp;start, const MGPosition &amp;end, const MGVector &amp;normal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGPosition::angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Let this be the center of the rotation, then compute the angle rotated around the normal from start to end. </p>
<p>angle(start,end,normal)+angle(end,start,normal)=2*pai always holds. </p>

</div>
</div>
<a class="anchor" id="af9591e9a1ff4993704f6b64373e33ad3"></a><!-- doxytag: member="MGPosition::clone" ref="af9591e9a1ff4993704f6b64373e33ad3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>* MGPosition::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

</div>
</div>
<a class="anchor" id="a9cfb94502f49d3e48c6e4d5b876486d3"></a><!-- doxytag: member="MGPosition::closest" ref="a9cfb94502f49d3e48c6e4d5b876486d3" args="(const MGSurface &amp;surf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPosition::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value (u,v)of the surface from this point. </p>

</div>
</div>
<a class="anchor" id="a590161f09fe892ba43fc05a53cffc948"></a><!-- doxytag: member="MGPosition::closest" ref="a590161f09fe892ba43fc05a53cffc948" args="(const MGCurve &amp;curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGPosition::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value of the curve from this point. </p>
<p>Function's return value is the parameter value of the curve. </p>

</div>
</div>
<a class="anchor" id="ad23d2f6dd955a835f3d553abd239e8db"></a><!-- doxytag: member="MGPosition::interpolate" ref="ad23d2f6dd955a835f3d553abd239e8db" args="(double t2, const MGPosition &amp;vec2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPosition::interpolate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a Position by interpolating two Position. </p>
<p>Input scalar is a ratio t2. When t2 is zero, output position is a copy of the own position. Output=(*this)*(1-t2)+vec2*t2. </p>

</div>
</div>
<a class="anchor" id="aa932d589ebee071342755cf849b6c9df"></a><!-- doxytag: member="MGPosition::is_collinear" ref="aa932d589ebee071342755cf849b6c9df" args="(const MGPosition &amp;P2, const MGPosition &amp;P3) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPosition::is_collinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this, P2, and P3 are on a single straight line. </p>
<p>Function's return value is true if the three points are on a straight, false if not. </p>

</div>
</div>
<a class="anchor" id="a906c5f14b368a2863f6e743a2516b795"></a><!-- doxytag: member="MGPosition::len" ref="a906c5f14b368a2863f6e743a2516b795" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGPosition::len </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positionと原点との距離を求める。 Return the lenght between the origin(0,0,0) and the position. </p>

</div>
</div>
<a class="anchor" id="adc20c50c6ffbe4ea133592f489226743"></a><!-- doxytag: member="MGPosition::on" ref="adc20c50c6ffbe4ea133592f489226743" args="(const MGCurve &amp;curve, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPosition::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>点が曲線上にあるかを調べる。曲線上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Test if the position is on a curve. </p>
<p>If on, return the parameter value. Even if not on, return the nearest point of the curve. Function's return value is &gt;0 if the point is on the curve, and 0 if the point is not on the curve. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>Curve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value of the nearest point on the curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9a1817ca3122def759f7b7ec0a53766"></a><!-- doxytag: member="MGPosition::on" ref="aa9a1817ca3122def759f7b7ec0a53766" args="(const MGSurface &amp;surf, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPosition::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>点が曲面上にあるかを調べる。曲面上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Test if the position is on a surface. </p>
<p>If on, return the parameter value. Even if not on, return the nearest point of the surface. Function's return value is &gt;0 if the point is on the curve, and 0 if the point is not on the curve. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surf</em>&nbsp;</td><td>Surface pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the nearest point on surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c8f3f0b0f4c518464777a818d52a6c7"></a><!-- doxytag: member="MGPosition::operator*=" ref="a6c8f3f0b0f4c518464777a818d52a6c7" args="(double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalarの乗算を行い自身のPositionとする Scaling of the position. </p>

</div>
</div>
<a class="anchor" id="a32c2911168272a0f500dc6e3f8082d29"></a><!-- doxytag: member="MGPosition::operator*=" ref="a32c2911168272a0f500dc6e3f8082d29" args="(const MGMatrix &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MatrixによるPositionの変換を行い自身のPositionとする Matrix transformation of the position. </p>

</div>
</div>
<a class="anchor" id="a9c825ed0a284922e43c021b312d2c85e"></a><!-- doxytag: member="MGPosition::operator*=" ref="a9c825ed0a284922e43c021b312d2c85e" args="(const MGTransf &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PositionのTransformを行いPositionを生成して， 自身のPositionとする General transformation of the position. </p>

</div>
</div>
<a class="anchor" id="ac360115c2a75853f979db61f999aea81"></a><!-- doxytag: member="MGPosition::operator+=" ref="ac360115c2a75853f979db61f999aea81" args="(const MGVector &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のPositionに与えられたPositionを加算して自身のPositionとする Translation of the position. </p>

</div>
</div>
<a class="anchor" id="a1d805a4d53afa9ad9d7e2ed5fb01a019"></a><!-- doxytag: member="MGPosition::operator&#45;" ref="a1d805a4d53afa9ad9d7e2ed5fb01a019" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPosition::operator- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>単項マイナス。自身のPositionを反転し、Objectを生成 Unary minus. </p>
<p>Negate all of the elements of the position. </p>

</div>
</div>
<a class="anchor" id="a56db684f9ab6b25064d7fdb71b1e295f"></a><!-- doxytag: member="MGPosition::operator&#45;=" ref="a56db684f9ab6b25064d7fdb71b1e295f" args="(const MGVector &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のPositionから与えられたVectorを減算し自身のPositionとする Translation of the position. </p>

</div>
</div>
<a class="anchor" id="a6457a84a25ea10123d2344c2fd93a4e8"></a><!-- doxytag: member="MGPosition::operator/=" ref="a6457a84a25ea10123d2344c2fd93a4e8" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator/= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar除算を行い自身のPositionとする Scaling of the position. </p>

</div>
</div>
<a class="anchor" id="ad3720d18f4a95ef49cb49fe7d9ad9ddb"></a><!-- doxytag: member="MGPosition::operator=" ref="ad3720d18f4a95ef49cb49fe7d9ad9ddb" args="(const double *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPosition::operator= </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> ( const <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>&amp; ); We use default copy constructor. </p>
<p>Assignment Update position data by array of double. </p>

</div>
</div>
<a class="anchor" id="afb2f3ce46553bb5fb8e07765558e94c5"></a><!-- doxytag: member="MGPosition::out_to_IGES" ref="afb2f3ce46553bb5fb8e07765558e94c5" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPosition::out_to_IGES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>igesfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>SubordinateEntitySwitch</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PD116=Point. </p>
<p>Function's return value is the directory entry id created. </p>

</div>
</div>
<a class="anchor" id="a4802828d575d3e04510e249923e8ecd8"></a><!-- doxytag: member="MGPosition::param" ref="a4802828d575d3e04510e249923e8ecd8" args="(const MGCurve &amp;crv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGPosition::param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return curve's parameter value of this point. </p>
<p>If this point is not on the curve, return the nearest point's parameter value on the curve. </p>

</div>
</div>
<a class="anchor" id="abf2e6ff7d0879863b149609178d09479"></a><!-- doxytag: member="MGPosition::param" ref="abf2e6ff7d0879863b149609178d09479" args="(const MGSurface &amp;srf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPosition::param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return surface's parameter value of this point. </p>
<p>If this point is not on the surface, return the nearest point's parameter value on the surface. </p>

</div>
</div>
<a class="anchor" id="a608bcbb985f08869ff9c39650cc11c4f"></a><!-- doxytag: member="MGPosition::perps" ref="a608bcbb985f08869ff9c39650cc11c4f" args="(const MGSurface &amp;srf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGPosition::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all foot points of the perpendicular line from this point to a surface. </p>
<p>ポイントから与曲面へ下ろした垂線の足の，曲面のパラメータ値を すべて求める。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srf</em>&nbsp;</td><td>Surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0db32bf4da06f47c6543295aaa22c8f1"></a><!-- doxytag: member="MGPosition::perps" ref="a0db32bf4da06f47c6543295aaa22c8f1" args="(const MGCurve &amp;crv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGPosition::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all foot points of the perpendicular line from this point to a curve. </p>
<p>ポイントから与曲線へ下ろした垂線の足の，曲線のパラメータ値を すべて求める。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>Curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8f770292ff40820cdf064659beb880d"></a><!-- doxytag: member="MGPosition::resize" ref="ab8f770292ff40820cdf064659beb880d" args="(size_t new_sdim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPosition::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>new_sdim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize the position, that is , change the space dimension. </p>
<p>When this is enlarged, the extra space will contain garbages. </p>

</div>
</div>
<a class="anchor" id="ad95013ee0129b382b5e29c26dbe3401a"></a><!-- doxytag: member="MGPosition::store_at" ref="ad95013ee0129b382b5e29c26dbe3401a" args="(size_t i, const MGVector &amp;vec2, size_t j, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPosition::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store vec2 data into *this. </p>
<p>Storing will be done rap-around. That is, if id i or j reached to each <a class="el" href="class_m_g_position.html#ac6e566c1ccab30f42a5e8c97020b23dc" title="Get the space dimension.">sdim()</a>, the id will be changed to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>Displacement of *this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>Vector 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>j</em>&nbsp;</td><td>Displacement of vec2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a623bfda9bb0aa3e032d65dec6ffb2028"></a><!-- doxytag: member="MGPosition::store_at" ref="a623bfda9bb0aa3e032d65dec6ffb2028" args="(size_t i, const MGVector &amp;vec2, size_t j=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPosition::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store vec2 data into *this. </p>
<p>Store length is minimum of <a class="el" href="class_m_g_position.html#a906c5f14b368a2863f6e743a2516b795" title="Positionと原点との距離を求める。 Return the lenght between the origin(0...">len()</a> and vec2.len(). Storing will be done rap-around. That is, if id i or j reached to each <a class="el" href="class_m_g_position.html#ac6e566c1ccab30f42a5e8c97020b23dc" title="Get the space dimension.">sdim()</a>, the id will be changed to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>Displacement of *this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>Vector 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>j</em>&nbsp;</td><td>Displacement of vec2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01db02fb67502c7527731a7b8557df04"></a><!-- doxytag: member="MGPosition::swap" ref="a01db02fb67502c7527731a7b8557df04" args="(size_t i, size_t j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPosition::swap </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>swap two coordinates. </p>
<p>swap coordinates (i) and (j). </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a3fe4c1ea6b617bb6491671492f0e9f16"></a><!-- doxytag: member="MGPosition::operator%" ref="a3fe4c1ea6b617bb6491671492f0e9f16" args="(const MGPosition &amp;p1, const MGVector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend double operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身の点と与えられたベクトルの内積を行う Inner product of a osition and a vector. </p>

</div>
</div>
<a class="anchor" id="a7bfa7b17735b1b402441dcbb4f2e5fa8"></a><!-- doxytag: member="MGPosition::operator*" ref="a7bfa7b17735b1b402441dcbb4f2e5fa8" args="(const MGPosition &amp;p1, const MGTransf &amp;tr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PositionのTransformを行いVectorを生成 General transformation of the position. </p>

</div>
</div>
<a class="anchor" id="a1f80daca9aed5d70dc4888c9458c1377"></a><!-- doxytag: member="MGPosition::operator*" ref="a1f80daca9aed5d70dc4888c9458c1377" args="(const MGPosition &amp;p1, const MGMatrix &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MatrixによるPositionの変換を行いObjectを生成 Matrix transformation of the position. </p>

</div>
</div>
<a class="anchor" id="ac2bc2a4c0d8187782127be151d33c343"></a><!-- doxytag: member="MGPosition::operator*" ref="ac2bc2a4c0d8187782127be151d33c343" args="(double s, const MGPosition &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PositionのScalar乗算を行いObjectを生成 Scaling of the position. </p>

</div>
</div>
<a class="anchor" id="aca268d68a81eed77b1856247588d63d3"></a><!-- doxytag: member="MGPosition::operator/" ref="aca268d68a81eed77b1856247588d63d3" args="(const MGPosition &amp;p1, double s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_position.html">MGPosition</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar除算を行いObjectを生成 Scaling of the position. </p>

</div>
</div>
<a class="anchor" id="af049b6799a054fde67556e197486516a"></a><!-- doxytag: member="MGPosition::operator&lt;" ref="af049b6799a054fde67556e197486516a" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this position is less than p2. </p>
<p>Comparison depends on two positions' length. </p>

</div>
</div>
<a class="anchor" id="a368135936ee9dff60d01c58cb73690c0"></a><!-- doxytag: member="MGPosition::operator==" ref="a368135936ee9dff60d01c58cb73690c0" args="(const MGPosition &amp;p1, const MGPosition &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたPositionの成分の値を比較し、同じであれば TRUE を返却 Comparison of two positions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Position.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:27 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

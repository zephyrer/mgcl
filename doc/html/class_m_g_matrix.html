<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGMatrix Class Reference<br/>
<small>
[<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGMatrix" -->
<p><a class="el" href="class_m_g_matrix.html" title="MGMatrix is a matix of m by m, where m is the space dimension.">MGMatrix</a> is a matix of m by m, where m is the space dimension.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Matrix.h&gt;</code></p>

<p><a href="class_m_g_matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd69572b2aa0707c13e137c1bcf36f48"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="afd69572b2aa0707c13e137c1bcf36f48" args="(size_t sdim=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#afd69572b2aa0707c13e137c1bcf36f48">MGMatrix</a> (size_t sdim=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">void constructor:void コンストラクタ <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a024747dd6960924c287b2a64758b38c6"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a024747dd6960924c287b2a64758b38c6" args="(const MGVector &amp;, const MGVector &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a024747dd6960924c287b2a64758b38c6">MGMatrix</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 2D matrix from two vectors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c8fcb9c07884da9d854b22b0429bfc2"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a8c8fcb9c07884da9d854b22b0429bfc2" args="(const MGVector &amp;, const MGVector &amp;, const MGVector &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a8c8fcb9c07884da9d854b22b0429bfc2">MGMatrix</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 3D matrix from three vectors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a17b920fd30fbb1dcd6d16ca6d8fb9180">MGMatrix</a> (size_t dim, double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">各軸方向で等しい Scaling のためのMatrixを生成。 Scaling matrix of same scaling value for each coordinate.  <a href="#a17b920fd30fbb1dcd6d16ca6d8fb9180"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a36a5867da0857c4cff6ce6bde6f43574">MGMatrix</a> (size_t dim, const double *values, bool column_wise=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct dim dimension matrix from the array of double values.  <a href="#a36a5867da0857c4cff6ce6bde6f43574"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a6d41244e167ae9b469a0aa5164f61b86">MGMatrix</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec, double angle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたVector回りに指定の角度回転させるMatrixを作成する。 　Rotation matrix around vec.  <a href="#a6d41244e167ae9b469a0aa5164f61b86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a8f1ceec645ce1b7017305bd5870a20e6">MGMatrix</a> (size_t dim, size_t axis1, size_t axis2, double cosv, double sinv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a matrix to rotate in (axis1, axis2) plane by algle theta, where angle is defined as cosv=cos(angle), and sinv=sin(angle).  <a href="#a8f1ceec645ce1b7017305bd5870a20e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a24df61ff35154628cebf6c82e85b8e14">MGMatrix</a> (size_t dim, const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Matrix by copying old Matrix, changing space dimension and ordering of old coordinates.  <a href="#a24df61ff35154628cebf6c82e85b8e14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abad7fd3ca2e316c7fc0a87173e23b603"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="abad7fd3ca2e316c7fc0a87173e23b603" args="(const MGMatrix &amp;mat)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#abad7fd3ca2e316c7fc0a87173e23b603">MGMatrix</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8ec7634d22beb644723961109940c0"></a><!-- doxytag: member="MGMatrix::‾MGMatrix" ref="adc8ec7634d22beb644723961109940c0" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGMatrix</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef71e43a3aa4a14153ac53daba8b05b7"></a><!-- doxytag: member="MGMatrix::operator=" ref="aef71e43a3aa4a14153ac53daba8b05b7" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#aef71e43a3aa4a14153ac53daba8b05b7">operator=</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170050f9d0879b2353cd20bca2ea15d0"></a><!-- doxytag: member="MGMatrix::operator()" ref="a170050f9d0879b2353cd20bca2ea15d0" args="(size_t i, size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a170050f9d0879b2353cd20bca2ea15d0">operator()</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference (i,j)-th element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9b60627181f089c41d83cd63777468"></a><!-- doxytag: member="MGMatrix::operator()" ref="a5f9b60627181f089c41d83cd63777468" args="(size_t i, size_t j)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a5f9b60627181f089c41d83cd63777468">operator()</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)-th element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#abc7dd74df6dc43c3f093699a3082724b">operator*</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のMatrixと与えられたscaleの乗算を行いオブジェクトを生成。 Scaling of the matrix.  <a href="#abc7dd74df6dc43c3f093699a3082724b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#aafa89e4bc4bad2f448c8b856f6439323">operator*=</a> (double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のMatrixと与えられたscaleの乗算し自身のMatrixとする。 Scaling of the matrix.  <a href="#aafa89e4bc4bad2f448c8b856f6439323"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a287dc13281685bb5164adc18ba282bae">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のMatrixと与えられたMatrixの乗算を行いオブジェクトを生成。 Matrix and matrix multiplication.  <a href="#a287dc13281685bb5164adc18ba282bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#af0e46b57c6a0f167fa3e3209e3b88719">operator*=</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のMatrixと与えられたMatrixの乗算し自身のMatrixとする。 Matrix and matrix multiplication.  <a href="#af0e46b57c6a0f167fa3e3209e3b88719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_transf.html">MGTransf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a1b73025c49df9070c1ecc498304a94d4">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のMatrixと与えられたTransfの乗算を行いオブジェクトを生成。 Matrix and Transf multiplication.  <a href="#a1b73025c49df9070c1ecc498304a94d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a38245ca93842b3aee8257c1cbe267346">operator==</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Boolean Operation 自身のMatrixと与えられたMatrixが等しいかどうか 比較を行う。 Equation comparison.  <a href="#a38245ca93842b3aee8257c1cbe267346"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c94c54a4408deb182380e52954bb7b"></a><!-- doxytag: member="MGMatrix::operator!=" ref="af0c94c54a4408deb182380e52954bb7b" args="(const MGMatrix &amp;) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a900cbe2f753a658198536d29d689d478">convert_to_glMatrix</a> (double glMat[16]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert this transf matrix to OpenGL Matrix.  <a href="#a900cbe2f753a658198536d29d689d478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a802c39daf951fea50197e73d7f886fff"></a><!-- doxytag: member="MGMatrix::determinant" ref="a802c39daf951fea50197e73d7f886fff" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a802c39daf951fea50197e73d7f886fff">determinant</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">行列式の値を返却。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ab3850972d520960a605701057495100d">from_axis</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, size_t axis=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a matrix to transform a unit vector on an axis to a vector 'uvec', and replace own matrix with it.  <a href="#ab3850972d520960a605701057495100d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d1af7249822b3699a5795239d99bef7"></a><!-- doxytag: member="MGMatrix::is_null" ref="a5d1af7249822b3699a5795239d99bef7" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a5d1af7249822b3699a5795239d99bef7">is_null</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d19e3803eee8d55740307d4be3bd837"></a><!-- doxytag: member="MGMatrix::ref" ref="a9d19e3803eee8d55740307d4be3bd837" args="(size_t i, size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a9d19e3803eee8d55740307d4be3bd837">ref</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to (i,j)-th element of the matarix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ad1a4c9cfcef3417c5ee3571ae7ee2a4d">reflection</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a mirror reflection matrix about a plane whose normal is vec and that passes through the origin, then replace own matrix with it.  <a href="#ad1a4c9cfcef3417c5ee3571ae7ee2a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a30b1a277fb56d4d8288604bb5d548170">resize</a> (size_t nsdim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize, i.e., change, the space dimension.  <a href="#a30b1a277fb56d4d8288604bb5d548170"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c5553ec799e45d1958e5cfca67d0edc"></a><!-- doxytag: member="MGMatrix::sdim" ref="a0c5553ec799e45d1958e5cfca67d0edc" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a0c5553ec799e45d1958e5cfca67d0edc">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ac8e92876485733b277e8d3e6bcd33346">set_x_axis</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;unit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 2D space Matrix to transform for 'unit' to be x-coordimate, and replace own Matrix with it.  <a href="#ac8e92876485733b277e8d3e6bcd33346"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a5f40c69a260159d22812fdc2cffb5be2">set_reflect_2D</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit vector to be x-coordinate  <a href="#a5f40c69a260159d22812fdc2cffb5be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#aa621ba4462fa7d39594c2033becf4463">set_rotate_2D</a> (double angle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">原点の回りに指定の角度回転させる2D Matrixを作成し, 既存の Matrixと入れ換える。 Rotation 2D matrix around origin by angle(in radian).  <a href="#aa621ba4462fa7d39594c2033becf4463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a994c4d7999e71efe037c5f9f9e27546f">set_rotate_2D</a> (double cval, double sval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotation 2D matrix around origin by an angle.  <a href="#a994c4d7999e71efe037c5f9f9e27546f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a7139b9dc976b896e99902e3e6227cc2a">set_axis</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, size_t axis=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a 3D matrix to transform a vector 'uvec' to be one of the axises, and replace own matrix.  <a href="#a7139b9dc976b896e99902e3e6227cc2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#abbb8f07521ba34d87b48fd6800360ffa">set_vector</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, size_t axis=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a matrix to transform a unit vector on an axis to a vector 'uvec', and replace own matrix with it.  <a href="#abbb8f07521ba34d87b48fd6800360ffa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a59e437391e5da51c9039ac7cf82f722b">set_xy_axis</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvecx, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvecy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた２つの単位ベクトルを各々、X軸、Y軸にするよう原点の周りに 回転させる 3D Matrix を生成し，自身のMatrixと入れ替える。もし、 ２つ目の単位ベクトルが１つ目の単位ベクトルと直交しない場合は、２つのベ クトルのかわりに両ベクトルを含む平面内で直交するよう変換したベクトルを 使用する。 3D Matrix to transform uvecx to be x-axis and uvecy to be y-axis.  <a href="#a59e437391e5da51c9039ac7cf82f722b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a5453a0ef157d31eb0f1293e818cfda85">set_xy_vector</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvecx, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvecy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">X軸、Y軸を各々、与えられた２つの単位ベクトルにするよう原点の周りに 回転させる 3D Matrix を生成し，自身のMatrixと入れ替える。もし、 ２つ目の単位ベクトルが１つ目の単位ベクトルと直交しない場合は、２つのベ クトルのかわりに両ベクトルを含む平面内で直交するよう変換したベクトルを 使用する。 3D matrix to transform x and y axis to be uvecx and uvecy.  <a href="#a5453a0ef157d31eb0f1293e818cfda85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#abcc6a91f55b83975af3bfb1cafae8f50">set_reflect_3D</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">原点を通り、指定Vectorに垂直な平面に関して鏡面変換する 3D Matrix を既存のMatrixと入れ換える。 3D mirror reflection matrix about a plane whose normal is vec and passes through the origin.  <a href="#abcc6a91f55b83975af3bfb1cafae8f50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#aba7790f1411ad21f6f7bf8eb7d10eea0">set_rotate</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V0, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">（原点を基点とする）Vector V0 を V1に変換するMatrixを作成し、 自身のMatrixと入れ換える。 Construct the matrix to rotate and scale that transform vector V0 to V1, and replace this matrix with the matrix.  <a href="#aba7790f1411ad21f6f7bf8eb7d10eea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ab3fc62130149e1b5866550add52677bc">set_rotate_3D</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec, double angle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたVector回りに指定の角度回転させる3D Matrixを作成し既存の Matrixと入れ換える。 3D rotation matrix around vec.  <a href="#ab3fc62130149e1b5866550add52677bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a15bb9ddfe5c42c535ad0adcd044ef633">set_rotate_3D</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec, double cval, double sval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3D rotation matrix around vec.  <a href="#a15bb9ddfe5c42c535ad0adcd044ef633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ac42b4be31a3153c9959ef5b18e6f421c">set_scale</a> (double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">各軸方向で等しい Scaling のためのMatrixを生成し、既存の Matrixと入れ換える Scaling matrix of same scaling value for each coordinate.  <a href="#ac42b4be31a3153c9959ef5b18e6f421c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#acdda4e5e70d24ed4e12c6b1991c12f0d">set_diff_scale</a> (double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">各軸方向で異なる Scaling のためのMatrixを生成し、既存の Matrixと入れ換える。 Scaling matrix of different scaling values for each coordinate.  <a href="#acdda4e5e70d24ed4e12c6b1991c12f0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad67610203a49e7b597ec8e63f3078357"></a><!-- doxytag: member="MGMatrix::set_glMatrix" ref="ad67610203a49e7b597ec8e63f3078357" args="(const double glMat[16])" -->
<a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ad67610203a49e7b597ec8e63f3078357">set_glMatrix</a> (const double glMat[16])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up this matrix from OpenGL matrix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a831e84f69d2dc6d866d4dbb7a77c1ffb"></a><!-- doxytag: member="MGMatrix::set_null" ref="a831e84f69d2dc6d866d4dbb7a77c1ffb" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a831e84f69d2dc6d866d4dbb7a77c1ffb">set_null</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this as a null matrix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a8596192ab050ef9541bfd9e8c00c4f69">transpose</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">転置Matrixを生成。 Transpose matrix.  <a href="#a8596192ab050ef9541bfd9e8c00c4f69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a55a9551ba81e4e1b4703ed0b375f2d53">to_axis</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, size_t axis=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a matrix to transform a vector 'uvec' to be one of the axises, and replace own matrix.  <a href="#a55a9551ba81e4e1b4703ed0b375f2d53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#af63697f4fae37a2bc73aa30e537d6fd3">dump_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Functions.  <a href="#af63697f4fae37a2bc73aa30e537d6fd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad406b5d01284a44b9b2e5e1cb7725c6c"></a><!-- doxytag: member="MGMatrix::dump" ref="ad406b5d01284a44b9b2e5e1cb7725c6c" args="(MGOfstream &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#ad406b5d01284a44b9b2e5e1cb7725c6c">dump</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba11f3adfdf531e714f884b9dae9edb"></a><!-- doxytag: member="MGMatrix::restore" ref="a7ba11f3adfdf531e714f884b9dae9edb" args="(MGIfstream &amp;)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a7ba11f3adfdf531e714f884b9dae9edb">restore</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1d704926cf1258ede57e9174e07cf9"></a><!-- doxytag: member="MGMatrix::scale" ref="a7b1d704926cf1258ede57e9174e07cf9" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a7b1d704926cf1258ede57e9174e07cf9">scale</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the scaling factor of this matrix. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_matrix.html">MGMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#aba7f70076eb3bdcf6367d84fa525f9bc">operator*</a> (double scale, const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のMatrixと与えられたscaleの乗算を行いオブジェクトを生成。 Scaling of the matrix.  <a href="#aba7f70076eb3bdcf6367d84fa525f9bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41eff714b49a943ff5d7e64f4cf1ea3a"></a><!-- doxytag: member="MGMatrix::operator&lt;&lt;" ref="a41eff714b49a943ff5d7e64f4cf1ea3a" args="(std::ostream &amp;, const MGMatrix &amp;)" -->
MGDECL friend std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_matrix.html#a41eff714b49a943ff5d7e64f4cf1ea3a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String stream Function. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_matrix.html" title="MGMatrix is a matix of m by m, where m is the space dimension.">MGMatrix</a> is a matix of m by m, where m is the space dimension. </p>
<p><a class="el" href="class_m_g_matrix.html" title="MGMatrix is a matix of m by m, where m is the space dimension.">MGMatrix</a> provides transformation around the origin. General transformation is provided by <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>. Let M be a matrix and A be an object(including MGVector). Then matrix transformation of the object A is defined as: A*M. (Not M*A) </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a17b920fd30fbb1dcd6d16ca6d8fb9180"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a17b920fd30fbb1dcd6d16ca6d8fb9180" args="(size_t dim, double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGMatrix::MGMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>各軸方向で等しい Scaling のためのMatrixを生成。 Scaling matrix of same scaling value for each coordinate. </p>

</div>
</div>
<a class="anchor" id="a36a5867da0857c4cff6ce6bde6f43574"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a36a5867da0857c4cff6ce6bde6f43574" args="(size_t dim, const double *values, bool column_wise=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGMatrix::MGMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>column_wise</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct dim dimension matrix from the array of double values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>dimension of the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>array of values[dim*dim]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>column_wise</em>&nbsp;</td><td>If column_wise=true, (*this)(i,j)=values[i+dim*j], else(row_wise), (*this)(i,j)=values[j+dim*i], for 0&lt;=i,j&lt;=dim-1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d41244e167ae9b469a0aa5164f61b86"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a6d41244e167ae9b469a0aa5164f61b86" args="(const MGVector &amp;vec, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGMatrix::MGMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたVector回りに指定の角度回転させるMatrixを作成する。 　Rotation matrix around vec. </p>
<p>Space dimension of vec can be any number, i.e. can be more than 3. </p>

</div>
</div>
<a class="anchor" id="a8f1ceec645ce1b7017305bd5870a20e6"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a8f1ceec645ce1b7017305bd5870a20e6" args="(size_t dim, size_t axis1, size_t axis2, double cosv, double sinv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGMatrix::MGMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cosv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sinv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a matrix to rotate in (axis1, axis2) plane by algle theta, where angle is defined as cosv=cos(angle), and sinv=sin(angle). </p>
<p>cosv=cos(angle), sinv=sin(angel). That is cosv*cosv+sinv*sinv must be 1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>Space dimension(can be more than 3). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis1</em>&nbsp;</td><td>axis number 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis2</em>&nbsp;</td><td>axis number 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24df61ff35154628cebf6c82e85b8e14"></a><!-- doxytag: member="MGMatrix::MGMatrix" ref="a24df61ff35154628cebf6c82e85b8e14" args="(size_t dim, const MGMatrix &amp;, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGMatrix::MGMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Matrix by copying old Matrix, changing space dimension and ordering of old coordinates. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a900cbe2f753a658198536d29d689d478"></a><!-- doxytag: member="MGMatrix::convert_to_glMatrix" ref="a900cbe2f753a658198536d29d689d478" args="(double glMat[16]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGMatrix::convert_to_glMatrix </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>glMat</em>[16]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert this transf matrix to OpenGL Matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>glMat</em>&nbsp;</td><td>OpenGL Matrix will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af63697f4fae37a2bc73aa30e537d6fd3"></a><!-- doxytag: member="MGMatrix::dump_size" ref="af63697f4fae37a2bc73aa30e537d6fd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGMatrix::dump_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump Functions. </p>
<p>Calculate dump size </p>

</div>
</div>
<a class="anchor" id="ab3850972d520960a605701057495100d"></a><!-- doxytag: member="MGMatrix::from_axis" ref="ab3850972d520960a605701057495100d" args="(const MGUnit_vector &amp;uvec, size_t axis=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::from_axis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>axis</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a matrix to transform a unit vector on an axis to a vector 'uvec', and replace own matrix with it. </p>
<p>Inverse matrix of to_axis. axis can be any number(can be more than 2). Axis kind 0:x, 1:y, 2:z, ... </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Unit vector for an axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b73025c49df9070c1ecc498304a94d4"></a><!-- doxytag: member="MGMatrix::operator*" ref="a1b73025c49df9070c1ecc498304a94d4" args="(const MGTransf &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_transf.html">MGTransf</a> MGMatrix::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のMatrixと与えられたTransfの乗算を行いオブジェクトを生成。 Matrix and Transf multiplication. </p>

</div>
</div>
<a class="anchor" id="abc7dd74df6dc43c3f093699a3082724b"></a><!-- doxytag: member="MGMatrix::operator*" ref="abc7dd74df6dc43c3f093699a3082724b" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> MGMatrix::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のMatrixと与えられたscaleの乗算を行いオブジェクトを生成。 Scaling of the matrix. </p>

</div>
</div>
<a class="anchor" id="a287dc13281685bb5164adc18ba282bae"></a><!-- doxytag: member="MGMatrix::operator*" ref="a287dc13281685bb5164adc18ba282bae" args="(const MGMatrix &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> MGMatrix::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のMatrixと与えられたMatrixの乗算を行いオブジェクトを生成。 Matrix and matrix multiplication. </p>

</div>
</div>
<a class="anchor" id="af0e46b57c6a0f167fa3e3209e3b88719"></a><!-- doxytag: member="MGMatrix::operator*=" ref="af0e46b57c6a0f167fa3e3209e3b88719" args="(const MGMatrix &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のMatrixと与えられたMatrixの乗算し自身のMatrixとする。 Matrix and matrix multiplication. </p>

</div>
</div>
<a class="anchor" id="aafa89e4bc4bad2f448c8b856f6439323"></a><!-- doxytag: member="MGMatrix::operator*=" ref="aafa89e4bc4bad2f448c8b856f6439323" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のMatrixと与えられたscaleの乗算し自身のMatrixとする。 Scaling of the matrix. </p>

</div>
</div>
<a class="anchor" id="a38245ca93842b3aee8257c1cbe267346"></a><!-- doxytag: member="MGMatrix::operator==" ref="a38245ca93842b3aee8257c1cbe267346" args="(const MGMatrix &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGMatrix::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Boolean Operation 自身のMatrixと与えられたMatrixが等しいかどうか 比較を行う。 Equation comparison. </p>

</div>
</div>
<a class="anchor" id="ad1a4c9cfcef3417c5ee3571ae7ee2a4d"></a><!-- doxytag: member="MGMatrix::reflection" ref="ad1a4c9cfcef3417c5ee3571ae7ee2a4d" args="(const MGVector &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::reflection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a mirror reflection matrix about a plane whose normal is vec and that passes through the origin, then replace own matrix with it. </p>

</div>
</div>
<a class="anchor" id="a30b1a277fb56d4d8288604bb5d548170"></a><!-- doxytag: member="MGMatrix::resize" ref="a30b1a277fb56d4d8288604bb5d548170" args="(size_t nsdim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGMatrix::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nsdim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize, i.e., change, the space dimension. </p>
<p>Result matreix will contain garbages. </p>

</div>
</div>
<a class="anchor" id="a7139b9dc976b896e99902e3e6227cc2a"></a><!-- doxytag: member="MGMatrix::set_axis" ref="a7139b9dc976b896e99902e3e6227cc2a" args="(const MGUnit_vector &amp;uvec, size_t axis=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_axis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>axis</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a 3D matrix to transform a vector 'uvec' to be one of the axises, and replace own matrix. </p>
<p>Inverse matrix of set_vector. 3D version of to_axis. Axis kind 0:x, 1:y, 2:z. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Unit vector to be an axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdda4e5e70d24ed4e12c6b1991c12f0d"></a><!-- doxytag: member="MGMatrix::set_diff_scale" ref="acdda4e5e70d24ed4e12c6b1991c12f0d" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_diff_scale </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>各軸方向で異なる Scaling のためのMatrixを生成し、既存の Matrixと入れ換える。 Scaling matrix of different scaling values for each coordinate. </p>
<p>Not change space dimension. </p>

</div>
</div>
<a class="anchor" id="a5f40c69a260159d22812fdc2cffb5be2"></a><!-- doxytag: member="MGMatrix::set_reflect_2D" ref="a5f40c69a260159d22812fdc2cffb5be2" args="(const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_reflect_2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unit vector to be x-coordinate </p>
<p>原点を通り、指定Vectorに関して鏡面変換する 2D Matrixを作成し， 既存のMatrixと入れ換える。 Mirror reflection 2D matrix about a vector through origin. </p>

</div>
</div>
<a class="anchor" id="abcc6a91f55b83975af3bfb1cafae8f50"></a><!-- doxytag: member="MGMatrix::set_reflect_3D" ref="abcc6a91f55b83975af3bfb1cafae8f50" args="(const MGVector &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_reflect_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>原点を通り、指定Vectorに垂直な平面に関して鏡面変換する 3D Matrix を既存のMatrixと入れ換える。 3D mirror reflection matrix about a plane whose normal is vec and passes through the origin. </p>

</div>
</div>
<a class="anchor" id="aba7790f1411ad21f6f7bf8eb7d10eea0"></a><!-- doxytag: member="MGMatrix::set_rotate" ref="aba7790f1411ad21f6f7bf8eb7d10eea0" args="(const MGVector &amp;V0, const MGVector &amp;V1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>（原点を基点とする）Vector V0 を V1に変換するMatrixを作成し、 自身のMatrixと入れ換える。 Construct the matrix to rotate and scale that transform vector V0 to V1, and replace this matrix with the matrix. </p>
<p>Space dimension of V0 and V1 can be any number greater than 1. </p>

</div>
</div>
<a class="anchor" id="a994c4d7999e71efe037c5f9f9e27546f"></a><!-- doxytag: member="MGMatrix::set_rotate_2D" ref="a994c4d7999e71efe037c5f9f9e27546f" args="(double cval, double sval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_rotate_2D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotation 2D matrix around origin by an angle. </p>
<p>The angle is given by cval as cos(angle) and sval as sin(angle). </p>

</div>
</div>
<a class="anchor" id="aa621ba4462fa7d39594c2033becf4463"></a><!-- doxytag: member="MGMatrix::set_rotate_2D" ref="aa621ba4462fa7d39594c2033becf4463" args="(double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_rotate_2D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>原点の回りに指定の角度回転させる2D Matrixを作成し, 既存の Matrixと入れ換える。 Rotation 2D matrix around origin by angle(in radian). </p>

</div>
</div>
<a class="anchor" id="ab3fc62130149e1b5866550add52677bc"></a><!-- doxytag: member="MGMatrix::set_rotate_3D" ref="ab3fc62130149e1b5866550add52677bc" args="(const MGVector &amp;vec, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_rotate_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたVector回りに指定の角度回転させる3D Matrixを作成し既存の Matrixと入れ換える。 3D rotation matrix around vec. </p>

</div>
</div>
<a class="anchor" id="a15bb9ddfe5c42c535ad0adcd044ef633"></a><!-- doxytag: member="MGMatrix::set_rotate_3D" ref="a15bb9ddfe5c42c535ad0adcd044ef633" args="(const MGVector &amp;vec, double cval, double sval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_rotate_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>3D rotation matrix around vec. </p>
<p>The angle is given by cval as cos(angle) and sval as sin(angle). </p>

</div>
</div>
<a class="anchor" id="ac42b4be31a3153c9959ef5b18e6f421c"></a><!-- doxytag: member="MGMatrix::set_scale" ref="ac42b4be31a3153c9959ef5b18e6f421c" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_scale </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>各軸方向で等しい Scaling のためのMatrixを生成し、既存の Matrixと入れ換える Scaling matrix of same scaling value for each coordinate. </p>
<p>Not change space dimension. </p>

</div>
</div>
<a class="anchor" id="abbb8f07521ba34d87b48fd6800360ffa"></a><!-- doxytag: member="MGMatrix::set_vector" ref="abbb8f07521ba34d87b48fd6800360ffa" args="(const MGUnit_vector &amp;uvec, size_t axis=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>axis</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a matrix to transform a unit vector on an axis to a vector 'uvec', and replace own matrix with it. </p>
<p>Inverse matrix of set_axis. 3D version of from_axis. Axis kind 0:x, 1:y, 2:z. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Unit vector for an axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8e92876485733b277e8d3e6bcd33346"></a><!-- doxytag: member="MGMatrix::set_x_axis" ref="ac8e92876485733b277e8d3e6bcd33346" args="(const MGUnit_vector &amp;unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_x_axis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct 2D space Matrix to transform for 'unit' to be x-coordimate, and replace own Matrix with it. </p>
<p>2D version of to_axis. </p>

</div>
</div>
<a class="anchor" id="a59e437391e5da51c9039ac7cf82f722b"></a><!-- doxytag: member="MGMatrix::set_xy_axis" ref="a59e437391e5da51c9039ac7cf82f722b" args="(const MGUnit_vector &amp;uvecx, const MGUnit_vector &amp;uvecy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_xy_axis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvecx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvecy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた２つの単位ベクトルを各々、X軸、Y軸にするよう原点の周りに 回転させる 3D Matrix を生成し，自身のMatrixと入れ替える。もし、 ２つ目の単位ベクトルが１つ目の単位ベクトルと直交しない場合は、２つのベ クトルのかわりに両ベクトルを含む平面内で直交するよう変換したベクトルを 使用する。 3D Matrix to transform uvecx to be x-axis and uvecy to be y-axis. </p>
<p>If uvecx and uvecy does not cross at right angle, uvecy will be transformed. Unit vector 2 for y axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvecx</em>&nbsp;</td><td>Unit vector 1 for x axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5453a0ef157d31eb0f1293e818cfda85"></a><!-- doxytag: member="MGMatrix::set_xy_vector" ref="a5453a0ef157d31eb0f1293e818cfda85" args="(const MGUnit_vector &amp;uvecx, const MGUnit_vector &amp;uvecy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::set_xy_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvecx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvecy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>X軸、Y軸を各々、与えられた２つの単位ベクトルにするよう原点の周りに 回転させる 3D Matrix を生成し，自身のMatrixと入れ替える。もし、 ２つ目の単位ベクトルが１つ目の単位ベクトルと直交しない場合は、２つのベ クトルのかわりに両ベクトルを含む平面内で直交するよう変換したベクトルを 使用する。 3D matrix to transform x and y axis to be uvecx and uvecy. </p>
<p>This is the inverse matrix of <a class="el" href="class_m_g_matrix.html#a59e437391e5da51c9039ac7cf82f722b" title="与えられた２つの単位ベクトルを各々、X軸、Y軸にするよう原点の周りに...">set_xy_axis()</a>. If uvecy does not cross uvecx at right angle, uvecy is transformed to do so. Unit vector 2 for y axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvecx</em>&nbsp;</td><td>Unit vector 1 for x axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55a9551ba81e4e1b4703ed0b375f2d53"></a><!-- doxytag: member="MGMatrix::to_axis" ref="a55a9551ba81e4e1b4703ed0b375f2d53" args="(const MGUnit_vector &amp;uvec, size_t axis=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a>&amp; MGMatrix::to_axis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>axis</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a matrix to transform a vector 'uvec' to be one of the axises, and replace own matrix. </p>
<p>Inverse matrix of from_axis. axis can be any number(can be more than 2). Axis kind 0:x, 1:y, 2:z, ... </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Unit vector to be an axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8596192ab050ef9541bfd9e8c00c4f69"></a><!-- doxytag: member="MGMatrix::transpose" ref="a8596192ab050ef9541bfd9e8c00c4f69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> MGMatrix::transpose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>転置Matrixを生成。 Transpose matrix. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aba7f70076eb3bdcf6367d84fa525f9bc"></a><!-- doxytag: member="MGMatrix::operator*" ref="aba7f70076eb3bdcf6367d84fa525f9bc" args="(double scale, const MGMatrix &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_matrix.html">MGMatrix</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のMatrixと与えられたscaleの乗算を行いオブジェクトを生成。 Scaling of the matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Matrix.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:26 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

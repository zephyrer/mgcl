<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGLBRep Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGLBRep Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGLBRep" --><!-- doxytag: inherits="MGCurve" -->
<p><a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> is a class for B-SPline representation.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;LBRep.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGLBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_l_b_rep__inherit__graph.png" border="0" usemap="#_m_g_l_b_rep_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_l_b_rep_inherit__map" id="_m_g_l_b_rep_inherit__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="21,315,96,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGLBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_l_b_rep__coll__graph.png" border="0" usemap="#_m_g_l_b_rep_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_l_b_rep_coll__map" id="_m_g_l_b_rep_coll__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="204,581,279,611"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="192,501,291,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/><area shape="rect" id="node26" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity." alt="" coords="303,581,407,611"/><area shape="rect" id="node28" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="431,581,537,611"/><area shape="rect" id="node30" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="433,501,535,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_l_b_rep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ae85e328d0b334134f3ffdf068a0886"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a3ae85e328d0b334134f3ffdf068a0886" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a3ae85e328d0b334134f3ffdf068a0886">MGLBRep</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default(dummy) constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a9c99f2aa5aeda950c9cbafd8046e637a">MGLBRep</a> (size_t bdim, size_t order, size_t sdim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy constructor that specifies area length.  <a href="#a9c99f2aa5aeda950c9cbafd8046e637a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a3bc5ac31f967531ecbbe06377599dac9">MGLBRep</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bcoef)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-Representation, providing all the member data.  <a href="#a3bc5ac31f967531ecbbe06377599dac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a69267f1a2bbae1de1845dd81ca6e50bd">MGLBRep</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;points, int &amp;error, unsigned order=4, int circular=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep by intepolation from Point data only.  <a href="#a69267f1a2bbae1de1845dd81ca6e50bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a116823bcc9ace0537d237b84374dd11a">MGLBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;points, size_t order=4, double ratio=-1.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of a specified order, given data point abscissa and the ordinates.  <a href="#a116823bcc9ace0537d237b84374dd11a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a0745f038d902737adc9c463252517bc0">MGLBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;points, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of any order number by interpolation from Point data only with knot vector.  <a href="#a0745f038d902737adc9c463252517bc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a9a7729fe9b033d40ba82769fe12c0193">MGLBRep</a> (const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;begin, const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;end, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;value, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of order 4 by interpolation from Point data and end condition.  <a href="#a9a7729fe9b033d40ba82769fe12c0193"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a91c52d7583c7c6d18bc9d115c15ce2a2">MGLBRep</a> (size_t order, const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;begin, const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;end, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;value, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of any order by interpolation from Point data and end condition.  <a href="#a91c52d7583c7c6d18bc9d115c15ce2a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a1231164989f87e06b83843c2b0b18362">MGLBRep</a> (const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;begin, const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;end, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;value, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of any order by interpolation from Point data with end condition and the knot vector for the B-rep to construct.  <a href="#a1231164989f87e06b83843c2b0b18362"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a273e3545af3b76615ec8f0df82f00aa0">MGLBRep</a> (const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;begin, const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;end, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;points, const int *point_kind, const <a class="el" href="class_m_g_oscu_circle.html">MGOscuCircle</a> &amp;circle, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of order 4 from point and point-kind followed by osculating circle data.  <a href="#a273e3545af3b76615ec8f0df82f00aa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aee969edafb70d581bf00207bbd79e5bc">MGLBRep</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, size_t order=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Curve B-Rep.  <a href="#aee969edafb70d581bf00207bbd79e5bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#acff8d4754b86315be9574fd3c5017d0e">MGLBRep</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;old_brep, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate an original B-Rep by a new knot configuration.  <a href="#acff8d4754b86315be9574fd3c5017d0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aa600aca546e9f4f4df67de7a34a351b1">MGLBRep</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;old_curve, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new B-Rep by a new knots.  <a href="#aa600aca546e9f4f4df67de7a34a351b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#af784abc83cc98d425dd2aab739834f0c">MGLBRep</a> (unsigned coordinate1, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep1, unsigned coordinate2, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 3D B-Rep by mixing two 2D B-Rep.  <a href="#af784abc83cc98d425dd2aab739834f0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ad7b169e45f66b2c148013023c0a16bdd">MGLBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;points, const double *weight, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Line B-rep of any order number by least square approximation from Point data with approximation weights and knot vector of B-Rep.  <a href="#ad7b169e45f66b2c148013023c0a16bdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed641baffee414fb55fd3b0b1178c3ad"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="aed641baffee414fb55fd3b0b1178c3ad" args="(const MGPPRep &amp;pprep)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aed641baffee414fb55fd3b0b1178c3ad">MGLBRep</a> (const <a class="el" href="class_m_g_p_p_rep.html">MGPPRep</a> &amp;pprep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert PP-Rep to B-rep. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a941f742a10568b2536f7934624fd7389">MGLBRep</a> (const <a class="el" href="class_m_g_p_p_rep.html">MGPPRep</a> &amp;pprep, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor constructs B-Rep, converting from PP-Rep.  <a href="#a941f742a10568b2536f7934624fd7389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ae322c15ff646282195f48eee78e0b431">MGLBRep</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;old_brep, const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;knots)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new B-Rep by adding knots to an original B-Rep.  <a href="#ae322c15ff646282195f48eee78e0b431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aa3eacdad5ecc65cb3dc4c954c0d52a1e">MGLBRep</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep1, int continuity, int which, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct LBRep by connecting brep1 and brep2 to make one B-Representation.  <a href="#aa3eacdad5ecc65cb3dc4c954c0d52a1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a466bb320da15e7666dbfa56e5bbd7da5">MGLBRep</a> (double t1, double t2, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;old_brep, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new B-Rep by computing a part of the original.  <a href="#a466bb320da15e7666dbfa56e5bbd7da5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a5ff3f4b82c5dd326ce5523316d6d5e59">MGLBRep</a> (size_t dim, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lbrep, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Line B-Rep by changing space dimension and ordering of coordinates.  <a href="#a5ff3f4b82c5dd326ce5523316d6d5e59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a51b9b09f466bc20f1a80bded2b2fb8d1">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a51b9b09f466bc20f1a80bded2b2fb8d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a337e5327d7c8cba63ce0771cb7113573"></a><!-- doxytag: member="MGLBRep::operator=" ref="a337e5327d7c8cba63ce0771cb7113573" args="(const MGLBRep &amp;el2)" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a337e5327d7c8cba63ce0771cb7113573">operator=</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;el2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a14771b91dc82d8146600456ca6de23"></a><!-- doxytag: member="MGLBRep::operator+" ref="a3a14771b91dc82d8146600456ca6de23" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a3a14771b91dc82d8146600456ca6de23">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation object construction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70f10c766d93b78e34c8c0edbcfb202b"></a><!-- doxytag: member="MGLBRep::operator&#45;" ref="a70f10c766d93b78e34c8c0edbcfb202b" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1024eaf007af300e7cb0dbccf8f7eb8"></a><!-- doxytag: member="MGLBRep::operator*" ref="ab1024eaf007af300e7cb0dbccf8f7eb8" args="(double) const " -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76d8f9f48a3405dc0d8f84a36dc8c86f"></a><!-- doxytag: member="MGLBRep::operator*" ref="a76d8f9f48a3405dc0d8f84a36dc8c86f" args="(const MGMatrix &amp;) const " -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a724db96005550bf95bb57ff07ca04b62"></a><!-- doxytag: member="MGLBRep::operator*" ref="a724db96005550bf95bb57ff07ca04b62" args="(const MGTransf &amp;) const " -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4df466551f13aaa63247bd5347136d"></a><!-- doxytag: member="MGLBRep::operator+=" ref="abe4df466551f13aaa63247bd5347136d" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#abe4df466551f13aaa63247bd5347136d">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a187001ce0901454e63801d3bc89b1b8e"></a><!-- doxytag: member="MGLBRep::operator&#45;=" ref="a187001ce0901454e63801d3bc89b1b8e" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c35bff6cab859745c4be24cf7eabfaf"></a><!-- doxytag: member="MGLBRep::operator*=" ref="a9c35bff6cab859745c4be24cf7eabfaf" args="(double scale)" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109479644deda9d964a4432adb9401e7"></a><!-- doxytag: member="MGLBRep::operator*=" ref="a109479644deda9d964a4432adb9401e7" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee2462f3c8f967eb72ce55dbe482334"></a><!-- doxytag: member="MGLBRep::operator*=" ref="a8ee2462f3c8f967eb72ce55dbe482334" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d1aad34db14457375418f1e4791e04d"></a><!-- doxytag: member="MGLBRep::operator==" ref="a9d1aad34db14457375418f1e4791e04d" args="(const MGLBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a9d1aad34db14457375418f1e4791e04d">operator==</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6504964737f6d13012de6f75090302d1"></a><!-- doxytag: member="MGLBRep::operator==" ref="a6504964737f6d13012de6f75090302d1" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a6504964737f6d13012de6f75090302d1">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefc3c653c9fb9400a74cdf47c924618e"></a><!-- doxytag: member="MGLBRep::operator&lt;" ref="aefc3c653c9fb9400a74cdf47c924618e" args="(const MGLBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade057a7cc2eb1db541ee05b7e57d3815"></a><!-- doxytag: member="MGLBRep::operator&lt;" ref="ade057a7cc2eb1db541ee05b7e57d3815" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addee6718ca1cd8ff0d5ee47119ef273e"></a><!-- doxytag: member="MGLBRep::operator==" ref="addee6718ca1cd8ff0d5ee47119ef273e" args="(const MGRLBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f6f4181064100616ad981c02d8671bc"></a><!-- doxytag: member="MGLBRep::bdim" ref="a8f6f4181064100616ad981c02d8671bc" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a8f6f4181064100616ad981c02d8671bc">bdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#acee9f498fd571b7d5b69ed293a321d7a">box_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;l) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Return minimum box that includes the partial line.  <a href="#acee9f498fd571b7d5b69ed293a321d7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa4e08730d21a64fc7862c6f92a7f626"></a><!-- doxytag: member="MGLBRep::box_unlimit" ref="aaa4e08730d21a64fc7862c6f92a7f626" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aaa4e08730d21a64fc7862c6f92a7f626">box_unlimit</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum box that includes the whole line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a91b7194d537bcb45893fa6894be94eda">buildSRSmoothedLB_of_FreeEnd</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;y, const double *dy, double deviation, bool dev_is_sum=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build line B-Rep by Schoenberg and Reinsch smoothing function, supposing the end conditions are free end conditions, given data points (tau,y), weights dy at data points, and a deviation.  <a href="#a91b7194d537bcb45893fa6894be94eda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a0df5d8b58ec77aeb78b03fa18993ccc0">buildSRSmoothedLB_of_1stDeriv</a> (const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;begin, const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;end, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;y, const double *dy, double deviation, bool dev_is_sum=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build line B-Rep by Schoenberg and Reinsch smoothing function, given 1st derivatives on the start and end points, data points (tau,y), weights dy at data points, and a mean deviation deviation.  <a href="#a0df5d8b58ec77aeb78b03fa18993ccc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#af64766085003a6596bc9b8cf98605f8a">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#af64766085003a6596bc9b8cf98605f8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a0e8642500d4180053ce3dedca640b07d">change_range</a> (double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a0e8642500d4180053ce3dedca640b07d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a229dc1fa0055d3981a498875112e3123">change_order</a> (unsigned order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change order of the B-Rep.  <a href="#a229dc1fa0055d3981a498875112e3123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a638e987a231b600472d3786f5cb23836">change_order_by_approximation</a> (unsigned ordr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change order of the B-Rep by approximation.  <a href="#a638e987a231b600472d3786f5cb23836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a493d2c73e3fde8a00c64ca87d6387267"></a><!-- doxytag: member="MGLBRep::coef" ref="a493d2c73e3fde8a00c64ca87d6387267" args="(size_t i, size_t j)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a493d2c73e3fde8a00c64ca87d6387267">coef</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef ( left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8093777008c681d5823d302dc403ba8"></a><!-- doxytag: member="MGLBRep::coef" ref="af8093777008c681d5823d302dc403ba8" args="(size_t i, size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#af8093777008c681d5823d302dc403ba8">coef</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef (right hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a690d6754196c72a088d4fb273c7adcb9"></a><!-- doxytag: member="MGLBRep::coef" ref="a690d6754196c72a088d4fb273c7adcb9" args="(size_t i) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a690d6754196c72a088d4fb273c7adcb9">coef</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract (i,j)element for 0&lt;=j&lt;<a class="el" href="class_m_g_l_b_rep.html#aa006bc921b501329363f9fc8a8e79d9a" title="Returns the space dimension.">sdim()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e50c57bf6c7fedc75eb35f86ea6c91c"></a><!-- doxytag: member="MGLBRep::coef_data" ref="a7e50c57bf6c7fedc75eb35f86ea6c91c" args="(size_t i=0, size_t j=0) const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a7e50c57bf6c7fedc75eb35f86ea6c91c">coef_data</a> (size_t i=0, size_t j=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the line b-coef data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75d43b75144b759b7af978ebe45f40f9"></a><!-- doxytag: member="MGLBRep::coef_data" ref="a75d43b75144b759b7af978ebe45f40f9" args="(size_t i=0, size_t j=0)" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>coef_data</b> (size_t i=0, size_t j=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a309ada6ead9508378b1ebc0df27ac370">connect</a> (int continuity, int which, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect brep2 to this brep to make one B-Representation.  <a href="#a309ada6ead9508378b1ebc0df27ac370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aedd7e8fe2465460bfa32ff48077768ac">continuity</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;brep2, int &amp;which, double &amp;ratio) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute continuity with brep2.  <a href="#aedd7e8fe2465460bfa32ff48077768ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a73b4f696ed0bc99cba99eee038d3ecd6">coordinate_exchange</a> (size_t j1, size_t j2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange ordering of the coordinates.  <a href="#a73b4f696ed0bc99cba99eee038d3ecd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aa270f3a8f68a723930bd3d515a2ebc5e">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area.  <a href="#aa270f3a8f68a723930bd3d515a2ebc5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a29f023966dfe25e5cf3e73e416eabe8c">copy_as_nurbs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy as a newed curve.  <a href="#a29f023966dfe25e5cf3e73e416eabe8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ac0b8b58b0394dfaa4bfd40a6ca0993c5">copy_as_LBRep</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy as a newed curve.  <a href="#ac0b8b58b0394dfaa4bfd40a6ca0993c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a5e1c277fe0de545fed252aa97ca3cb9e">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by changing the original object's space dimension.  <a href="#a5e1c277fe0de545fed252aa97ca3cb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a4b7004b63812fae3664d115eb5cdcf30">copy_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;prange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area, and limitting the parameter range to prange.  <a href="#a4b7004b63812fae3664d115eb5cdcf30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#adb7bd33a2f4ee8aab8331743b674f145">curvilinear_integral</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvilinear integral of the 1st two coordinates.  <a href="#adb7bd33a2f4ee8aab8331743b674f145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a17208cdf34fdaed0d3d9a797ed941f3e">divide_multi</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;crv_list, int multiplicity=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide this curve at the designated knot multiplicity point.  <a href="#a17208cdf34fdaed0d3d9a797ed941f3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb348c44640eb75b615437c0a88f65a"></a><!-- doxytag: member="MGLBRep::display_control_polygon" ref="a3eb348c44640eb75b615437c0a88f65a" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a3eb348c44640eb75b615437c0a88f65a">display_control_polygon</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display control polygons using <a class="el" href="namespacemg_g_d_l.html#a737cd10d927fbfafda983392deabb6b2" title="Draw a control polygon.">mgGDL::MGDrawPointSeq()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a56a146bbb0dbac0062031ca2cfd326f5">draw_2D</a> (void(*moveto)(int, int), void(*lineto)(int, int), const double wind[4], size_t ynum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw this line's 1st and 2nd coordinates in 2D space using drawing function moveto( , ) and lineto( , ).  <a href="#a56a146bbb0dbac0062031ca2cfd326f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a790cc4751bf1fe190391cfdfc46cd542">draw_2D</a> (void(*moveto)(float, float), void(*lineto)(float, float), const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a2603405178d2485b0230bbb80059d9da">draw_2D</a> (void(*moveto)(double, double), void(*lineto)(double, double), const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a630e05ff0859ab52be2e870d1518041a">draw_1D</a> (void(*moveto)(int, int), void(*lineto)(int, int), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw this line's coordinate'th coordinate in 2D space as (t, LBRep(coordinate)) when t_is_x is true, or as ( LBRep(coordinate),t) when t_is_x is false, using drawing function moveto(int, int) and lineto(int,int).  <a href="#a630e05ff0859ab52be2e870d1518041a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a67aaf29e0e77d6c3bba47af6c54da913">draw_1D</a> (void(*moveto)(float, float), void(*lineto)(float, float), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a69c5b4b10b7e70eb5e6c394c4e5214e6">draw_1D</a> (void(*moveto)(double, double), void(*lineto)(double, double), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a06e39ceec02ce365c5deadafa0043db7">drawSE</a> (double span_length, double t0, double t1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a64aed702de6ade8db7b4b1e2578959b5">eval</a> (double, size_t nderiv=0, int leftcon=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous n'th derivative data.  <a href="#a64aed702de6ade8db7b4b1e2578959b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#af56dd48a49c5c5714271107d228595b7">eval_all</a> (double, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute position, 1st and 2nd derivatives.  <a href="#af56dd48a49c5c5714271107d228595b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a39627ea843ffbb7cd16a2ed5949cc6d4">eval_all</a> (double tau, size_t nderiv, double *deriv, int leftcon=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate all of i'th derivative data for 0&lt;=i&lt;=nderiv.  <a href="#a39627ea843ffbb7cd16a2ed5949cc6d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a488cd49ba84f3f813fbc029a7d5229c3">eval_line</a> (<a class="el" href="group___b_a_s_e.html#ga33d188179c505572699a57dd0e027e26">MGENDCOND</a> begin, <a class="el" href="group___b_a_s_e.html#ga33d188179c505572699a57dd0e027e26">MGENDCOND</a> end, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate line data at data point seq.(BLELIN).  <a href="#a488cd49ba84f3f813fbc029a7d5229c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ae7d21e6ec98b243c7d804ada86235296">eval_line</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate line data at data point seq.(BLELIN).  <a href="#ae7d21e6ec98b243c7d804ada86235296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a526a6917b8c90899287358a6b92e1e87">extend</a> (int start, double length, double dk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate the curve by the chord length.  <a href="#a526a6917b8c90899287358a6b92e1e87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aab8a998a09f65297cbb2c7a505cd85bf">extend</a> (double length, bool start=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate this curve by an (approximate) chord length.  <a href="#aab8a998a09f65297cbb2c7a505cd85bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a850e5d875f32c068fdedfd6aaaab7e5d">extend_with_parameter</a> (double tau, double dk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate the curve by the parameter value.  <a href="#a850e5d875f32c068fdedfd6aaaab7e5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a00ab0426c3f95a7432acfee78f2fe1ad">get_control_points</a> (<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;cpoints) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts control points.  <a href="#a00ab0426c3f95a7432acfee78f2fe1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43a4c6050737c8004f61a960271e52c7"></a><!-- doxytag: member="MGLBRep::identify_type" ref="a43a4c6050737c8004f61a960271e52c7" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a43a4c6050737c8004f61a960271e52c7">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a575c05dc1bb4919b9fa148b7e11fa216">is_coplanar</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is co-planar with the 2nd curve curve2.  <a href="#a575c05dc1bb4919b9fa148b7e11fa216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a208ad049aa9bd9ef6c99c5085a22c479">is_planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is planar or not.  <a href="#a208ad049aa9bd9ef6c99c5085a22c479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a70be406fdf3ec572a9c2f0996815ab4b">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spline と Curve の交点を求める。 Intersection point of spline and curve.  <a href="#a70be406fdf3ec572a9c2f0996815ab4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4dd1d3c4984f1215cfaaa39a6acd62f"></a><!-- doxytag: member="MGLBRep::isect" ref="ae4dd1d3c4984f1215cfaaa39a6acd62f" args="(const MGStraight &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a088fab79fff5fe114d244031e64df07d"></a><!-- doxytag: member="MGLBRep::isect" ref="a088fab79fff5fe114d244031e64df07d" args="(const MGRLBRep &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab22b4e2349d793cf07d4bb8eba5c4036"></a><!-- doxytag: member="MGLBRep::isect" ref="ab22b4e2349d793cf07d4bb8eba5c4036" args="(const MGEllipse &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c032bf89cd5ced26388fd28641bb518"></a><!-- doxytag: member="MGLBRep::isect" ref="a5c032bf89cd5ced26388fd28641bb518" args="(const MGLBRep &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace142857f985e1a778e93f71e5dd8560"></a><!-- doxytag: member="MGLBRep::isect" ref="ace142857f985e1a778e93f71e5dd8560" args="(const MGSurfCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a50f59639f4f65a81d95c109b92be2"></a><!-- doxytag: member="MGLBRep::isect" ref="a26a50f59639f4f65a81d95c109b92be2" args="(const MGBSumCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa16b88af34ca7e67ae0f3240e66e26e"></a><!-- doxytag: member="MGLBRep::isect" ref="aaa16b88af34ca7e67ae0f3240e66e26e" args="(const MGSurface &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aaa16b88af34ca7e67ae0f3240e66e26e">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> and Surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ede9525bebe8b77f93fc6c67065abab"></a><!-- doxytag: member="MGLBRep::isect" ref="a2ede9525bebe8b77f93fc6c67065abab" args="(const MGPlane &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada4ef9ec5094d96b3ee9ac0f9d89ec03"></a><!-- doxytag: member="MGLBRep::isect" ref="ada4ef9ec5094d96b3ee9ac0f9d89ec03" args="(const MGSphere &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ca589e8af44782003b2f84617b361a"></a><!-- doxytag: member="MGLBRep::isect" ref="a73ca589e8af44782003b2f84617b361a" args="(const MGCylinder &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8378be2158adc1aaeb53fd4f8d72dee8"></a><!-- doxytag: member="MGLBRep::isect" ref="a8378be2158adc1aaeb53fd4f8d72dee8" args="(const MGSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf1de91db173f33ae86312eb38bc3499"></a><!-- doxytag: member="MGLBRep::isect" ref="adf1de91db173f33ae86312eb38bc3499" args="(const MGRSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2958954d7e929e8bc721918dca5654a"></a><!-- doxytag: member="MGLBRep::isect" ref="aa2958954d7e929e8bc721918dca5654a" args="(const MGBSumSurf &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a956a86209c9cdb6cfac7a5035fcb73f9">knot</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot.  <a href="#a956a86209c9cdb6cfac7a5035fcb73f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a48c71161c275ae5fff809f5a026573be">knot</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot.  <a href="#a48c71161c275ae5fff809f5a026573be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ad6933144302ca3892d39a61e24158d4c">knot_data</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the knot vector data.  <a href="#ad6933144302ca3892d39a61e24158d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f43b89a7d6e46aa7bc38c4ee50d37ed"></a><!-- doxytag: member="MGLBRep::knot_data" ref="a8f43b89a7d6e46aa7bc38c4ee50d37ed" args="()" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_data</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a770c0faf6d9190d501020937c1883cdd">knot_vector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector.  <a href="#a770c0faf6d9190d501020937c1883cdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a94bb48ce4d83c0aa4e9297c2d0ff8c0c">knot_vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector.  <a href="#a94bb48ce4d83c0aa4e9297c2d0ff8c0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a95e25747174e4b17949c4cd5a3a29494">limit</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身に指定したパラメータ範囲のlimitをつける。 Get the sub interval line of the original line.  <a href="#a95e25747174e4b17949c4cd5a3a29494"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04895ff11d7b0145281fa37c62d55cae"></a><!-- doxytag: member="MGLBRep::line_bcoef" ref="a04895ff11d7b0145281fa37c62d55cae" args="() const " -->
const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a04895ff11d7b0145281fa37c62d55cae">line_bcoef</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's(RHS version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44886d976e307ac137f635c86e1cb991"></a><!-- doxytag: member="MGLBRep::line_bcoef" ref="a44886d976e307ac137f635c86e1cb991" args="()" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a44886d976e307ac137f635c86e1cb991">line_bcoef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's(LHS version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#af70692ddafc2663780ea9a7215b68f58">move</a> (int move_kind, double move_point_param, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;to_point, const double fix_point[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original line by moving move_point to to_point.  <a href="#af70692ddafc2663780ea9a7215b68f58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0963cc102a96719451460279e1719df8"></a><!-- doxytag: member="MGLBRep::negate" ref="a0963cc102a96719451460279e1719df8" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a0963cc102a96719451460279e1719df8">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change direction of the line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38933df4089f5d29eb7229f66c511163"></a><!-- doxytag: member="MGLBRep::negate_param" ref="a38933df4089f5d29eb7229f66c511163" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a38933df4089f5d29eb7229f66c511163">negate_param</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this curve is negated by "negate()". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adefe094f1b32caf33e07df70dcd3fa0d"></a><!-- doxytag: member="MGLBRep::order" ref="adefe094f1b32caf33e07df70dcd3fa0d" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#adefe094f1b32caf33e07df70dcd3fa0d">order</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acffb5c3b88f2c597f2af7aeb85d4fd7f"></a><!-- doxytag: member="MGLBRep::param_e" ref="acffb5c3b88f2c597f2af7aeb85d4fd7f" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#acffb5c3b88f2c597f2af7aeb85d4fd7f">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a739d4bfc688fe8d6f74e29de3947534e"></a><!-- doxytag: member="MGLBRep::param_s" ref="a739d4bfc688fe8d6f74e29de3947534e" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a739d4bfc688fe8d6f74e29de3947534e">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ad4f3d4bb0c4af552c4ca26c8838436c8">param_normalize</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize parameter value t to the nearest knot if their distance is within tolerance.  <a href="#ad4f3d4bb0c4af552c4ca26c8838436c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#affcc9c8f0476c88f73b96b75b7593a8c">part</a> (double t1, double t2, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of this curve from parameter t1 to t2.  <a href="#affcc9c8f0476c88f73b96b75b7593a8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a5b90fc7c7164c39d3552f48eb801442a">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与ポイントから曲線へ下ろした垂線の足の，曲線のパラメータ値を すべて求める。 Return all the foots of the straight lines that is perpendicular to the line.  <a href="#a5b90fc7c7164c39d3552f48eb801442a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a8dfa8c81b1df7c836eb645b599c488e8">perps</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the perpendicular points of this curve and the second one.  <a href="#a8dfa8c81b1df7c836eb645b599c488e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3b9b37b4318050773784ae6385b0081"></a><!-- doxytag: member="MGLBRep::perps" ref="aa3b9b37b4318050773784ae6385b0081" args="(const MGStraight &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f40f8d5defb4bf24802a0f3e4fcd9a"></a><!-- doxytag: member="MGLBRep::perps" ref="a49f40f8d5defb4bf24802a0f3e4fcd9a" args="(const MGRLBRep &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f394c7971f5842ae4de2386eb26bee6"></a><!-- doxytag: member="MGLBRep::perps" ref="a0f394c7971f5842ae4de2386eb26bee6" args="(const MGEllipse &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a41fc8104c5bff8d20760674f18f39"></a><!-- doxytag: member="MGLBRep::perps" ref="ac1a41fc8104c5bff8d20760674f18f39" args="(const MGLBRep &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885fbfb2bbdeabe88f6a372ed57e8cf7"></a><!-- doxytag: member="MGLBRep::perps" ref="a885fbfb2bbdeabe88f6a372ed57e8cf7" args="(const MGSurfCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a540913927e4e02ed856c3f12871421df"></a><!-- doxytag: member="MGLBRep::perps" ref="a540913927e4e02ed856c3f12871421df" args="(const MGBSumCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#add9ac4361143161a4cd756045f0160e2">planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;line, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the line B-rep is planar.  <a href="#add9ac4361143161a4cd756045f0160e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a772912ab57a98eb75078218d436e3b93">reduce</a> (int ndec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the B-Rep by decreasing B-Rep dimension by ndec.  <a href="#a772912ab57a98eb75078218d436e3b93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a866cb9a7578853653d05ec7658be0688">refine</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change an original B-Rep to new one with subdivided knot configuration.  <a href="#a866cb9a7578853653d05ec7658be0688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ad554fd02a7252dcd87ceb0bb599cf6f1">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot.  <a href="#ad554fd02a7252dcd87ceb0bb599cf6f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#adcf6eb229a8922dc9466538d1cc97bd0">remove_knot</a> (size_t j, size_t snum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove knot if removed line has the difference less than line_zero(); The difference is checked only for the space id of coef(.,j+k) of j=0, ..., snum-1.  <a href="#adcf6eb229a8922dc9466538d1cc97bd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ad3a1d19b4223ecdae7edf7cd41ab7f5c">remove_knot_one</a> (double line0, size_t nKnot, double &amp;totalTol, size_t &amp;num_knot, size_t sid=0, size_t snum=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数(1つのノット) 戻り値は、削除したノットの数 When snum!=0, tolerance of totalTol is checked only for coef(.,sid+j), where j=0, ..., snum-1.  <a href="#ad3a1d19b4223ecdae7edf7cd41ab7f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa006bc921b501329363f9fc8a8e79d9a"></a><!-- doxytag: member="MGLBRep::sdim" ref="aa006bc921b501329363f9fc8a8e79d9a" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aa006bc921b501329363f9fc8a8e79d9a">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a8371d4ab8811a7e0e55bfd75a36169ef">sweep</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sweep surface from crv Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted.  <a href="#a8371d4ab8811a7e0e55bfd75a36169ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ac810dcba8cdd5a853f3867305daed26e">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線のタイプをを返す。 Return the curve type.  <a href="#ac810dcba8cdd5a853f3867305daed26e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b2f9101304c7fd8c074ff3123cc4f1f"></a><!-- doxytag: member="MGLBRep::unlimit" ref="a9b2f9101304c7fd8c074ff3123cc4f1f" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a9b2f9101304c7fd8c074ff3123cc4f1f">unlimit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ｌｉｍｉｔをはずす。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eca7f1a6d098d41cec0b7b3a4825c01"></a><!-- doxytag: member="MGLBRep::unlimit_end" ref="a5eca7f1a6d098d41cec0b7b3a4825c01" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a5eca7f1a6d098d41cec0b7b3a4825c01">unlimit_end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the end point direction (終点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af949a31d9404f1fdee91741242fedf3d"></a><!-- doxytag: member="MGLBRep::unlimit_start" ref="af949a31d9404f1fdee91741242fedf3d" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#af949a31d9404f1fdee91741242fedf3d">unlimit_start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the start point direction (始点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aa0960c03e64454fe6c339d7e42011598">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector.  <a href="#aa0960c03e64454fe6c339d7e42011598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4816e7863fddf9b415323a1917892ca3"></a><!-- doxytag: member="MGLBRep::out" ref="a4816e7863fddf9b415323a1917892ca3" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a4816e7863fddf9b415323a1917892ca3">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6d9f0b536cecbf163be6a7251861eb"></a><!-- doxytag: member="MGLBRep::whoami" ref="a3f6d9f0b536cecbf163be6a7251861eb" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a16ef0a29fb48cb4ace7a0c0447b857b3">intersect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection point of 1D sub B-Rep of original B-rep.  <a href="#a16ef0a29fb48cb4ace7a0c0447b857b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#aafeddba9b7dda43198b56caa6cdf043c">oneD</a> (const double g[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve.  <a href="#aafeddba9b7dda43198b56caa6cdf043c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28c60f66a752fe66854f3400d26d3dee"></a><!-- doxytag: member="MGLBRep::ReadMembers" ref="a28c60f66a752fe66854f3400d26d3dee" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a28c60f66a752fe66854f3400d26d3dee">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み出す関数 戻り値boolは正常に読み出しが出来ればtrue、失敗すればfalseになる <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a95fcee604ae2cdca522b5cd6c76b52"></a><!-- doxytag: member="MGLBRep::WriteMembers" ref="a7a95fcee604ae2cdca522b5cd6c76b52" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a7a95fcee604ae2cdca522b5cd6c76b52">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 戻り値boolは正常に書き込みが出来ればtrue、失敗すればfalseになる <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a260d043fcb6797d59ef8d8b9613db191"></a><!-- doxytag: member="MGLBRep::MGCurve" ref="a260d043fcb6797d59ef8d8b9613db191" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a260d043fcb6797d59ef8d8b9613db191">MGCurve</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a57185a8c75407c288944d596184e9"></a><!-- doxytag: member="MGLBRep::MGStraight" ref="ae2a57185a8c75407c288944d596184e9" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ae2a57185a8c75407c288944d596184e9">MGStraight</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c74ab8db89c57468240dc0709fb6648"></a><!-- doxytag: member="MGLBRep::MGRLBRep" ref="a8c74ab8db89c57468240dc0709fb6648" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a8c74ab8db89c57468240dc0709fb6648">MGRLBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c0799d4515be8f84762cbe4713cdfc"></a><!-- doxytag: member="MGLBRep::operator+" ref="a14c0799d4515be8f84762cbe4713cdfc" args="(const MGVector &amp;v, const MGLBRep &amp;lb)" -->
MGDECL friend <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a14c0799d4515be8f84762cbe4713cdfc">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">translation by a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0fbbc68fb5b95bf9915ef394e14af15"></a><!-- doxytag: member="MGLBRep::operator*" ref="ae0fbbc68fb5b95bf9915ef394e14af15" args="(double scale, const MGLBRep &amp;)" -->
MGDECL friend <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#ae0fbbc68fb5b95bf9915ef394e14af15">operator*</a> (double scale, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scaling by a scalar. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a1923bd8524b3a3082e9a35129ebcfd8d">rebuild_knot</a> (const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;brepl, size_t order=0, <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> **tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線列のノットベクトルを再構築する 入力された複数曲線列を指定オーダーで再構築する。トレランスはline_zero()を使用している。 オーダーが指定されていないとき曲線列のうちで最も大きいオーダーを使用する。このとき、 Ellipse, Straightのオーダーは4として考える。 パラメータ範囲は1次微分値の大きさが１になるようにしたときの長さの平均を使用している。 戻り値は再構築後の曲線列が返却される。エラーのときヌルが返却される。  <a href="#a1923bd8524b3a3082e9a35129ebcfd8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a097c32386c3d89cc5b9592b440e99f0b">rebuild_knot</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;brepl, size_t order=0, <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> **tp=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as above, except that the input is MGPvector&lt;&gt;.  <a href="#a097c32386c3d89cc5b9592b440e99f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html#a784fd181cc136376919edddeed3a4414">remove_knot_curves</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;brepList, <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> **tp=0, double tp_length=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">複数カーブの共通で削除できるノットを削除する。 ただし、入力カーブは同じノットベクトルを持つものとする。  <a href="#a784fd181cc136376919edddeed3a4414"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> is a class for B-SPline representation. </p>
<p>For a general NURBS(non uniform rational B-Spline) is <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. LBRep abbrebiates Line B-Representation. <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> consists of a knot vector(MGKnotVector) and a control polygon(MGBPointSeq) whose B-representaiton dimension are the same. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9c99f2aa5aeda950c9cbafd8046e637a"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a9c99f2aa5aeda950c9cbafd8046e637a" args="(size_t bdim, size_t order, size_t sdim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dummy constructor that specifies area length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bdim</em>&nbsp;</td><td>b-rep dimension of the lbrep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>order of the lbrep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>space dimension of the lbrep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bc5ac31f967531ecbbe06377599dac9"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a3bc5ac31f967531ecbbe06377599dac9" args="(const MGKnotVector &amp;t, const MGBPointSeq &amp;bcoef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bcoef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-Representation, providing all the member data. </p>
<p>This is the fundamental constructor.***** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Knot Vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bcoef</em>&nbsp;</td><td>Line B-Coef. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69267f1a2bbae1de1845dd81ca6e50bd"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a69267f1a2bbae1de1845dd81ca6e50bd" args="(const MGBPointSeq &amp;points, int &amp;error, unsigned order=4, int circular=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>order</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>circular</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep by intepolation from Point data only. </p>
<p>If circular is true, start and end points are connected smoothly. If circular is true, order will be always 4, and input order is neglected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>Order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>circular</em>&nbsp;</td><td>Circular flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a116823bcc9ace0537d237b84374dd11a"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a116823bcc9ace0537d237b84374dd11a" args="(const MGNDDArray &amp;tau, const MGBPointSeq &amp;points, size_t order=4, double ratio=&#45;1.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ratio</em> = <code>-1.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of a specified order, given data point abscissa and the ordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio</em>&nbsp;</td><td>Maximum of data point ratio of pre and after spans. Let d(i)=tau[i]-tau[i-1], then if d(i)/d(i-1)&gt;ratio or d(i-1)/d(i)&gt;ratio, either tau[i] or tau[i-1] will be removed. This is done to prevent control polygon computation error. When ratio&lt;0. no data point removal will be done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0745f038d902737adc9c463252517bc0"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a0745f038d902737adc9c463252517bc0" args="(const MGNDDArray &amp;tau, const MGBPointSeq &amp;points, const MGKnotVector &amp;t, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of any order number by interpolation from Point data only with knot vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data(data point ordinate). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a7729fe9b033d40ba82769fe12c0193"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a9a7729fe9b033d40ba82769fe12c0193" args="(const MGLBRepEndC &amp;begin, const MGLBRepEndC &amp;end, const MGNDDArray &amp;tau, const MGBPointSeq &amp;value, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of order 4 by interpolation from Point data and end condition. </p>
<p>(tau(i), value(i,.)) for 0&lt;=i&lt;=n(the length of value). For the start and end point, tau does not have multiplicity. However, if tau has multiplicity at inner point, this means 1st derivative data is provided for the associated value, i.e.: If tau has multiplicity 2 as tau(i)=tau(i+1), value(i,.) is 1st derivative at tau(i) and value(i+1,.) is positional data at tau(i)(=tau(i+1)). If tau has multiplicity 3 as tau(i)=tau(i+1)=tau(i+2), value(i,.) is 1st derivative at tau(i)- , value(i+1,.) is positional data at tau(i)(=tau(i+1)), value(i+2,.) is 1st derivative at tau(i)+. Maximum multiplicity allowed is 3. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Begin end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End end conditoion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91c52d7583c7c6d18bc9d115c15ce2a2"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a91c52d7583c7c6d18bc9d115c15ce2a2" args="(size_t order, const MGLBRepEndC &amp;begin, const MGLBRepEndC &amp;end, const MGNDDArray &amp;tau, const MGBPointSeq &amp;value, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of any order by interpolation from Point data and end condition. </p>
<p>(tau(i), value(i,.)) for 0&lt;=i&lt;=n(the length of value). For the start and end point, tau does not have multiplicity. However, if tau has multiplicity at inner point, this means 1st derivative data is provided for the associated value, i.e.: If tau has multiplicity 2 as tau(i)=tau(i+1), value(i,.) is 1st derivative at tau(i) and value(i+1,.) is positional data at tau(i)(=tau(i+1)). If tau has multiplicity 3 as tau(i)=tau(i+1)=tau(i+2), value(i,.) is 1st derivative at tau(i)- , value(i+1,.) is positional data at tau(i)(=tau(i+1)), value(i+2,.) is 1st derivative at tau(i)+. Maximum multiplicity allowed is 3. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>Order of the <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Begin end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End end conditoion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1231164989f87e06b83843c2b0b18362"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a1231164989f87e06b83843c2b0b18362" args="(const MGLBRepEndC &amp;begin, const MGLBRepEndC &amp;end, const MGNDDArray &amp;tau, const MGBPointSeq &amp;value, const MGKnotVector &amp;t, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of any order by interpolation from Point data with end condition and the knot vector for the B-rep to construct. </p>
<p>(tau(i), value(i,.)) for 0&lt;=i&lt;=n(the length of value). tau(i) and knot vector t must satisfy Shoenberg's variation diminishing constraint. For the start and end point, tau does not have multiplicity. However, if tau has multiplicity at inner point, this means 1st derivative data is provided for the associated value, i.e.: If tau has multiplicity 2 as tau(i)=tau(i+1), value(i,.) is 1st derivative at tau(i) and value(i+1,.) is positional data at tau(i)(=tau(i+1)). If tau has multiplicity 3 as tau(i)=tau(i+1)=tau(i+2), value(i,.) is 1st derivative at tau(i)- , value(i+1,.) is positional data at tau(i)(=tau(i+1)), value(i+2,.) is 1st derivative at tau(i)+. Maximum multiplicity allowed is 3. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Begin end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End end conditoion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a273e3545af3b76615ec8f0df82f00aa0"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a273e3545af3b76615ec8f0df82f00aa0" args="(const MGLBRepEndC &amp;begin, const MGLBRepEndC &amp;end, const MGBPointSeq &amp;points, const int *point_kind, const MGOscuCircle &amp;circle, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>point_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_oscu_circle.html">MGOscuCircle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of order 4 from point and point-kind followed by osculating circle data. </p>
<p>point_kind[i] is point kind of the point points(i,.): =0:G2 point, =1:G0 point, =2:G1 point. If two consecutive points are 1 or 2, the span is a straight line. point_kind 2 is a start of G2 curve. If two straight line span meet at points(i), osculating circle can be generated at this point by providing circle data at this point. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Begin end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End end conditoion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point_kind</em>&nbsp;</td><td>Point kind of above point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>circle</em>&nbsp;</td><td>Provides osculating circle data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee969edafb70d581bf00207bbd79e5bc"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="aee969edafb70d581bf00207bbd79e5bc" args="(const MGCurve &amp;crv, size_t order=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Curve B-Rep. </p>
<p>This is an approximation, and the tolerance is <a class="el" href="class_m_g_tolerance.html#a10b55492588f36f67c17352ef77ae08f" title="Return m_line_zero. m_line_zeroを返却する。.">MGTolerance::line_zero()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>Original Curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>Order. When order=0 is input, and crv was a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>, the original order will be used. Otherwise(order=0 and crv was not an <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>) order will be set to 4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acff8d4754b86315be9574fd3c5017d0e"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="acff8d4754b86315be9574fd3c5017d0e" args="(const MGLBRep &amp;old_brep, const MGKnotVector &amp;t, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate an original B-Rep by a new knot configuration. </p>
<p>The new knot config must be inside the range of the original B-Rep parameter. However new knots may be coarse or fine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa600aca546e9f4f4df67de7a34a351b1"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="aa600aca546e9f4f4df67de7a34a351b1" args="(const MGCurve &amp;old_curve, const MGKnotVector &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new B-Rep by a new knots. </p>
<p>The parameter range of t must be inside the one of old_curve. The constructed MGLBRep's knot vector is t, and the <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> is the approximation of old_curve's parameter range from t.param_s() to t.param_e(); </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_curve</em>&nbsp;</td><td>Original curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af784abc83cc98d425dd2aab739834f0c"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="af784abc83cc98d425dd2aab739834f0c" args="(unsigned coordinate1, const MGLBRep &amp;brep1, unsigned coordinate2, const MGLBRep &amp;brep2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>coordinate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>coordinate2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct 3D B-Rep by mixing two 2D B-Rep. </p>
<p>The two 2D B-Rep's directions and start and end points must be the same. Second 2D B-Rep can be girth representaion, ie, Let brep1 is f(t)=(f1(t),f2(t)) and brep2 is g(s)=(g1(s),g2(s)), where f1,f2 are two coordinates, g1 is parameter t of f(t), g2(s) is the missing coordinate of f(t). Given parameter s, ( f1(g1(s)), f2(g1(s)), g2(s)) is a 3D space point. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate1</em>&nbsp;</td><td>Missing oordinate kind of the brep1 0:x, 1:y, 2:z. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep1</em>&nbsp;</td><td>Original 2D B-Rep1. Coordinates are (y,z), (z,x), (x,y) according to coordinate1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate2</em>&nbsp;</td><td>Missing coordinate kind of the brep2. 0:x, 1:y, 2:z, and 3:girth rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>Original 2D B-Rep2. Coordinates are (y,z), (z,x), (x,y) and (t, g2) according to coordinate2. t is parameter of brep1 and g2 is x, y, or z according to coordinate1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7b169e45f66b2c148013023c0a16bdd"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="ad7b169e45f66b2c148013023c0a16bdd" args="(const MGNDDArray &amp;tau, const MGBPointSeq &amp;points, const double *weight, const MGKnotVector &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Line B-rep of any order number by least square approximation from Point data with approximation weights and knot vector of B-Rep. </p>
<p>weight[i] is for points(i,.). For detail information of the approximation method, see "A Practical Guide to Splines by Carl de Boor" Springer-Verlag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>Weights for each points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>knot vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941f742a10568b2536f7934624fd7389"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a941f742a10568b2536f7934624fd7389" args="(const MGPPRep &amp;pprep, const MGKnotVector t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_p_p_rep.html">MGPPRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pprep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a>&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This constructor constructs B-Rep, converting from PP-Rep. </p>
<p>Knot Vector is input. Each knot of the knot vector is break point of pprep. The continuities at all the break points must be C(k-2) where k is the order of pprep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pprep</em>&nbsp;</td><td>PP-rep </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Knot Vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae322c15ff646282195f48eee78e0b431"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="ae322c15ff646282195f48eee78e0b431" args="(const MGLBRep &amp;old_brep, const MGKnotArray &amp;knots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>knots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new B-Rep by adding knots to an original B-Rep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>knots</em>&nbsp;</td><td>Knots to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3eacdad5ecc65cb3dc4c954c0d52a1e"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="aa3eacdad5ecc65cb3dc4c954c0d52a1e" args="(const MGLBRep &amp;brep1, int continuity, int which, const MGLBRep &amp;brep2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>continuity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct LBRep by connecting brep1 and brep2 to make one B-Representation. </p>
<p>brep1's parameter range will not be changed, instead brep2's range will be so modified that brep2 has the same 1st derivative magnitude as the original brep1's at the connecting point (start or end point of brep1). continuity and which can be obtained using the fucntion <a class="el" href="class_m_g_l_b_rep.html#aedd7e8fe2465460bfa32ff48077768ac" title="Compute continuity with brep2.">continuity()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brep1</em>&nbsp;</td><td>B-Rep 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>continuity</em>&nbsp;</td><td>continuity. must be&gt;=0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>which point of brep1 to which of brep2. meaingfull when continuity&gt;=0. =0: start of brep1 and start of brep2. =1: start of brep1 and end of brep2. =2: end of brep1 and start of brep2. =3: end of brep1 and end of brep2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>B-Rep 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a466bb320da15e7666dbfa56e5bbd7da5"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a466bb320da15e7666dbfa56e5bbd7da5" args="(double t1, double t2, const MGLBRep &amp;old_brep, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new B-Rep by computing a part of the original. </p>
<p>New one is exactly the same as the original except that it is partial. If multiple==true(!=0), knot(i)=t1 and knot(n+i)=t2 for i=0,..., k-1 will be guaranteed. Here, n=bdim() and k=order(). Both t1 and t2 must be inside te range of old_brep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>New parameter range. t1 must be less than t2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ff3f4b82c5dd326ce5523316d6d5e59"></a><!-- doxytag: member="MGLBRep::MGLBRep" ref="a5ff3f4b82c5dd326ce5523316d6d5e59" args="(size_t dim, const MGLBRep &amp;lbrep, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLBRep::MGLBRep </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lbrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Line B-Rep by changing space dimension and ordering of coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lbrep</em>&nbsp;</td><td>Original Line B-rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of original line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acee9f498fd571b7d5b69ed293a321d7a"></a><!-- doxytag: member="MGLBRep::box_limitted" ref="acee9f498fd571b7d5b69ed293a321d7a" args="(const MGInterval &amp;l) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGLBRep::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Return minimum box that includes the partial line. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a680d824802125a83533362f05ee84b71">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a0df5d8b58ec77aeb78b03fa18993ccc0"></a><!-- doxytag: member="MGLBRep::buildSRSmoothedLB_of_1stDeriv" ref="a0df5d8b58ec77aeb78b03fa18993ccc0" args="(const MGLBRepEndC &amp;begin, const MGLBRepEndC &amp;end, const MGNDDArray &amp;tau, const MGBPointSeq &amp;y, const double *dy, double deviation, bool dev_is_sum=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::buildSRSmoothedLB_of_1stDeriv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep_end_c.html">MGLBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>deviation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>dev_is_sum</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build line B-Rep by Schoenberg and Reinsch smoothing function, given 1st derivatives on the start and end points, data points (tau,y), weights dy at data points, and a mean deviation deviation. </p>
<p>If dy[i] gets larger, deviation at tau(i) gets larger. n can be any number greater than or equal to 2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Begin end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End end conditoion. begin.cond() and end.cond() must be MGENDC_1D or MGENDC_12D. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Data point ordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>dy[i] is the weight at tau[i] for i=0,..., tau.length()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>if dev_is_sum is true, deviation is the upper bound of Sum(((points(i)-pout(i))/dp[i])**2. if dev_is_sum is false, deviation is max_deviation of each point at tau[i],i.e., dev_is_sum=true: deviation&gt;=Sum(((points(i)-pout(i))/dp[i])**2), dev_is_sum=false:deviation&gt;=Max((points(i)-pout(i))**2), for i=0,...,n-1. Here pout(i) is the this-&gt;eval(tau(i)). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91b7194d537bcb45893fa6894be94eda"></a><!-- doxytag: member="MGLBRep::buildSRSmoothedLB_of_FreeEnd" ref="a91b7194d537bcb45893fa6894be94eda" args="(const MGNDDArray &amp;tau, const MGBPointSeq &amp;y, const double *dy, double deviation, bool dev_is_sum=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::buildSRSmoothedLB_of_FreeEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>deviation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>dev_is_sum</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build line B-Rep by Schoenberg and Reinsch smoothing function, supposing the end conditions are free end conditions, given data points (tau,y), weights dy at data points, and a deviation. </p>
<p>If dy[i] gets larger, deviation at tau(i) gets larger. n can be any number greater than or equal to 2. End conditions are free end condition.*** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data point abscissa </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Data point ordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>dy[i] is the weights at tau[i] for i=0,..., tau.length()-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>if dev_is_sum is true, deviation is the upper bound of Sum(((points(i)-pout(i))/dp[i])**2. if dev_is_sum is false, deviation is max_deviation of each point at tau[i],i.e., dev_is_sum=true: deviation&gt;=Sum(((points(i)-pout(i))/dp[i])**2), dev_is_sum=false:deviation&gt;=Max((points(i)-pout(i))**2), for i=0,...,n-1. Here pout(i) is the this-&gt;eval(tau(i)). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af64766085003a6596bc9b8cf98605f8a"></a><!-- doxytag: member="MGLBRep::change_dimension" ref="af64766085003a6596bc9b8cf98605f8a" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac83a24a002d65e6339859e51321fff57">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a229dc1fa0055d3981a498875112e3123"></a><!-- doxytag: member="MGLBRep::change_order" ref="a229dc1fa0055d3981a498875112e3123" args="(unsigned order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::change_order </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>order</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change order of the B-Rep. </p>
<p>When new order is greater than the original, new B-rep is guaranteed to be the same line as the original. However, if new order is less than the original one, new line is not the same in general. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>New order number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a638e987a231b600472d3786f5cb23836"></a><!-- doxytag: member="MGLBRep::change_order_by_approximation" ref="a638e987a231b600472d3786f5cb23836" args="(unsigned ordr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::change_order_by_approximation </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>ordr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change order of the B-Rep by approximation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ordr</em>&nbsp;</td><td>New order number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e8642500d4180053ce3dedca640b07d"></a><!-- doxytag: member="MGLBRep::change_range" ref="a0e8642500d4180053ce3dedca640b07d" args="(double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::change_range </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a260ff34df53249e6887a09553f84058b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa270f3a8f68a723930bd3d515a2ebc5e"></a><!-- doxytag: member="MGLBRep::clone" ref="aa270f3a8f68a723930bd3d515a2ebc5e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>* MGLBRep::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae85e37def31262577515e70078fb92e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a309ada6ead9508378b1ebc0df27ac370"></a><!-- doxytag: member="MGLBRep::connect" ref="a309ada6ead9508378b1ebc0df27ac370" args="(int continuity, int which, const MGLBRep &amp;brep2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::connect </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>continuity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect brep2 to this brep to make one B-Representation. </p>
<p>This parameter range will not be changed, instead brep2's range will be so changed that brep2 has the same 1st derivative magnitude as the original this brep's at the connecting point(start or end point of this). continuity and which can be obtained using the fucntion <a class="el" href="class_m_g_l_b_rep.html#aedd7e8fe2465460bfa32ff48077768ac" title="Compute continuity with brep2.">continuity()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>continuity</em>&nbsp;</td><td>continuity. must be&gt;=0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>which point of this to which of brep2. =0: start of this and start of brep2. =1: start of this and end of brep2. =2: end of this and start of brep2. =3: end of this and end of brep2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>B-Rep 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedd7e8fe2465460bfa32ff48077768ac"></a><!-- doxytag: member="MGLBRep::continuity" ref="aedd7e8fe2465460bfa32ff48077768ac" args="(const MGLBRep &amp;brep2, int &amp;which, double &amp;ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLBRep::continuity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute continuity with brep2. </p>
<p>Function's return value is: -1: G(-1) continuity, i.e. two lines are discontinuous. 0: G0 continuity, i.e. two lines are connected, but tangents are discontinuous 1: G1 continuity, i.e. two lines are connected, and tangents are also continuous. 2: G2 continuity, i.e. two lines are connected, and tangents and curvatures are also continuous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>Indicates which point of this is connected to which of brep2, is meaingfull when continuity&gt;=0. =0: start of this to start of brep2. =1: start of this to end of brep2. =2: end of this to start of brep2. =3: end of this to end of brep2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio</em>&nbsp;</td><td>Ratio of 1st derivatives of the two line will be returned. ratio= d2/d1, where d1=1st deriv of this and d2=of brep2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73b4f696ed0bc99cba99eee038d3ecd6"></a><!-- doxytag: member="MGLBRep::coordinate_exchange" ref="a73b4f696ed0bc99cba99eee038d3ecd6" args="(size_t j1, size_t j2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::coordinate_exchange </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange ordering of the coordinates. </p>
<p>Exchange coordinates (j1) and (j2). </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae8c6cb11b641e5b6f596867672bfda66">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac0b8b58b0394dfaa4bfd40a6ca0993c5"></a><!-- doxytag: member="MGLBRep::copy_as_LBRep" ref="ac0b8b58b0394dfaa4bfd40a6ca0993c5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>* MGLBRep::copy_as_LBRep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy as a newed curve. </p>
<p>The new curve will be <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. Returned object must be deleted. </p>

</div>
</div>
<a class="anchor" id="a29f023966dfe25e5cf3e73e416eabe8c"></a><!-- doxytag: member="MGLBRep::copy_as_nurbs" ref="a29f023966dfe25e5cf3e73e416eabe8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGLBRep::copy_as_nurbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy as a newed curve. </p>
<p>The new curve will be <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> or <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. When original curve was a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>, the new curve will be a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. Otherwise, the new curve will be a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. Returned object must be deleted. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a9ef3806ddfd62edf9b7b9c59626caf5a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1c277fe0de545fed252aa97ca3cb9e"></a><!-- doxytag: member="MGLBRep::copy_change_dimension" ref="a5e1c277fe0de545fed252aa97ca3cb9e" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>* MGLBRep::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a84add0aaacbc189dd584dbf9f5670d99">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a4b7004b63812fae3664d115eb5cdcf30"></a><!-- doxytag: member="MGLBRep::copy_limitted" ref="a4b7004b63812fae3664d115eb5cdcf30" args="(const MGInterval &amp;prange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGLBRep::copy_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area, and limitting the parameter range to prange. </p>
<p>Returned is newed object and must be deleted. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a45bda2b85297af3d92a32f23e011682f">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="adb7bd33a2f4ee8aab8331743b674f145"></a><!-- doxytag: member="MGLBRep::curvilinear_integral" ref="adb7bd33a2f4ee8aab8331743b674f145" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGLBRep::curvilinear_integral </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvilinear integral of the 1st two coordinates. </p>
<p>This integral can be used to compute area sorounded by the curve. (線積分）を求める。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a27b4724616d26b4b6aa076b010645a26">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a17208cdf34fdaed0d3d9a797ed941f3e"></a><!-- doxytag: member="MGLBRep::divide_multi" ref="a17208cdf34fdaed0d3d9a797ed941f3e" args="(MGPvector&lt; MGCurve &gt; &amp;crv_list, int multiplicity=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLBRep::divide_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>crv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiplicity</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide this curve at the designated knot multiplicity point. </p>
<p>Function's return value is the number of the curves after divided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv_list</em>&nbsp;</td><td>divided curves will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiplicity</em>&nbsp;</td><td>designates the multiplicity of the knot to divide at. When multiplicity&lt;=0, <a class="el" href="class_m_g_l_b_rep.html#adefe094f1b32caf33e07df70dcd3fa0d" title="Returns the order.">order()</a>-1 is assumed. When multiplicity&gt;=order(), <a class="el" href="class_m_g_l_b_rep.html#adefe094f1b32caf33e07df70dcd3fa0d" title="Returns the order.">order()</a> is assumed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a1ee0ed7b28c40b502d4eeec470368b4d">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a630e05ff0859ab52be2e870d1518041a"></a><!-- doxytag: member="MGLBRep::draw_1D" ref="a630e05ff0859ab52be2e870d1518041a" args="(void(*moveto)(int, int), void(*lineto)(int, int), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::draw_1D </td>
          <td>(</td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>t_is_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw this line's coordinate'th coordinate in 2D space as (t, LBRep(coordinate)) when t_is_x is true, or as ( LBRep(coordinate),t) when t_is_x is false, using drawing function moveto(int, int) and lineto(int,int). </p>
<p>Here t is the parameter of the LBRep. The other behaviours are the same as draw_2D. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>id of coordinate, that is =0:x, =1:y, and so on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_is_x</em>&nbsp;</td><td>=true:t is x coordinate, and false:t is y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67aaf29e0e77d6c3bba47af6c54da913"></a><!-- doxytag: member="MGLBRep::draw_1D" ref="a67aaf29e0e77d6c3bba47af6c54da913" args="(void(*moveto)(float, float), void(*lineto)(float, float), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::draw_1D </td>
          <td>(</td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>t_is_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>id of coordinate, that is =0:x, =1:y, and so on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_is_x</em>&nbsp;</td><td>=true:t is x coordinate, and false:t is y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69c5b4b10b7e70eb5e6c394c4e5214e6"></a><!-- doxytag: member="MGLBRep::draw_1D" ref="a69c5b4b10b7e70eb5e6c394c4e5214e6" args="(void(*moveto)(double, double), void(*lineto)(double, double), size_t coordinate, bool t_is_x, const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::draw_1D </td>
          <td>(</td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>t_is_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>id of coordinate, that is =0:x, =1:y, and so on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_is_x</em>&nbsp;</td><td>=true:t is x coordinate, and false:t is y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56a146bbb0dbac0062031ca2cfd326f5"></a><!-- doxytag: member="MGLBRep::draw_2D" ref="a56a146bbb0dbac0062031ca2cfd326f5" args="(void(*moveto)(int, int), void(*lineto)(int, int), const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::draw_2D </td>
          <td>(</td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, int)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw this line's 1st and 2nd coordinates in 2D space using drawing function moveto( , ) and lineto( , ). </p>
<p>wind[] is the window of the screen to draw the line in. Clipping will be performed about the wind[]. (wind[0], wind[1]) is the center coordinates of the window. wind[2] is width and wind[3] is hight of the window. When wind[2]&lt;=0, no clipping is performed. Even when wind[2]&lt;=0, wind[3] is necessary to input to specify the resolution of the line. In this case, wind[0] and wind[1] are not referended. ynum is the resolution of the line, is the number of straight line segments for the curve length of wind[3](height of window). draw_2D does not perform box including judment, always performs clipping operation and draws the line. Users must do obvious box inclusion test if maximum drawing performance is necessary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a790cc4751bf1fe190391cfdfc46cd542"></a><!-- doxytag: member="MGLBRep::draw_2D" ref="a790cc4751bf1fe190391cfdfc46cd542" args="(void(*moveto)(float, float), void(*lineto)(float, float), const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::draw_2D </td>
          <td>(</td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(float, float)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2603405178d2485b0230bbb80059d9da"></a><!-- doxytag: member="MGLBRep::draw_2D" ref="a2603405178d2485b0230bbb80059d9da" args="(void(*moveto)(double, double), void(*lineto)(double, double), const double wind[4], size_t ynum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::draw_2D </td>
          <td>(</td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>moveto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(double, double)&nbsp;</td>
          <td class="paramname"> <em>lineto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>wind</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ynum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wind</em>&nbsp;</td><td>window box to draw the line in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ynum</em>&nbsp;</td><td>Resolution of the line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06e39ceec02ce365c5deadafa0043db7"></a><!-- doxytag: member="MGLBRep::drawSE" ref="a06e39ceec02ce365c5deadafa0043db7" args="(double span_length, double t0, double t1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::drawSE </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>Start parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>End parameter value of the curve. Draw will be performed from t0 to t1. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a20497e172065788e673b771f018d90af">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a64aed702de6ade8db7b4b1e2578959b5"></a><!-- doxytag: member="MGLBRep::eval" ref="a64aed702de6ade8db7b4b1e2578959b5" args="(double, size_t nderiv=0, int leftcon=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGLBRep::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leftcon</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous n'th derivative data. </p>
<p>nderiv=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>leftcon</em>&nbsp;</td><td>Left continuous(leftcon=true) or right continuous(leftcon=false). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#acbcbb8f812be257921ef63c71afdedcf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af56dd48a49c5c5714271107d228595b7"></a><!-- doxytag: member="MGLBRep::eval_all" ref="af56dd48a49c5c5714271107d228595b7" args="(double, MGPosition &amp;, MGVector &amp;, MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute position, 1st and 2nd derivatives. </p>
<p>パラメータ値を与えて位置、一次微分値、二次微分値をもとめる。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a9ea3970501a3d9c681a38ff584018b41">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a39627ea843ffbb7cd16a2ed5949cc6d4"></a><!-- doxytag: member="MGLBRep::eval_all" ref="a39627ea843ffbb7cd16a2ed5949cc6d4" args="(double tau, size_t nderiv, double *deriv, int leftcon=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leftcon</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate all of i'th derivative data for 0&lt;=i&lt;=nderiv. </p>
<p>Output will be put on deriv[j+i*sdim()] for 0&lt;=i&lt;=nderiv and 0&lt;=j&lt;<a class="el" href="class_m_g_l_b_rep.html#aa006bc921b501329363f9fc8a8e79d9a" title="Returns the space dimension.">sdim()</a>, i.e. deriv[j+i*sdim()] is i-th derivative data for 0&lt;=j&lt;<a class="el" href="class_m_g_l_b_rep.html#aa006bc921b501329363f9fc8a8e79d9a" title="Returns the space dimension.">sdim()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Parameter value to evaluate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deriv</em>&nbsp;</td><td>Output area of size (nderiv+1)*sdim(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>leftcon</em>&nbsp;</td><td>Left continuous(leftcon=true) or right continuous(leftcon=false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a488cd49ba84f3f813fbc029a7d5229c3"></a><!-- doxytag: member="MGLBRep::eval_line" ref="a488cd49ba84f3f813fbc029a7d5229c3" args="(MGENDCOND begin, MGENDCOND end, const MGNDDArray &amp;tau, MGBPointSeq &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::eval_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_a_s_e.html#ga33d188179c505572699a57dd0e027e26">MGENDCOND</a>&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___b_a_s_e.html#ga33d188179c505572699a57dd0e027e26">MGENDCOND</a>&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate line data at data point seq.(BLELIN). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>Begin end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End end conditoion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Values evaluated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7d21e6ec98b243c7d804ada86235296"></a><!-- doxytag: member="MGLBRep::eval_line" ref="ae7d21e6ec98b243c7d804ada86235296" args="(const MGNDDArray &amp;tau, MGBPointSeq &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::eval_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate line data at data point seq.(BLELIN). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Values evaluated. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ae23f4567458a4f215eaa4f692373cf5b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a526a6917b8c90899287358a6b92e1e87"></a><!-- doxytag: member="MGLBRep::extend" ref="a526a6917b8c90899287358a6b92e1e87" args="(int start, double length, double dk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate the curve by the chord length. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of start or end poit of the line. If start is true extend on the start point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at the connecting point. extrapolation start point. When dk=0, curvature keeps same, i.e. dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point. (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab8a998a09f65297cbb2c7a505cd85bf"></a><!-- doxytag: member="MGLBRep::extend" ref="aab8a998a09f65297cbb2c7a505cd85bf" args="(double length, bool start=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::extend </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate this curve by an (approximate) chord length. </p>
<p>The extrapolation is C2 continuous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>approximate chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of which point to extend, start or end point of the line. If start is true extend on the start point. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#af0e8206d530257d27910d0676ba0be01">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a850e5d875f32c068fdedfd6aaaab7e5d"></a><!-- doxytag: member="MGLBRep::extend_with_parameter" ref="a850e5d875f32c068fdedfd6aaaab7e5d" args="(double tau, double dk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::extend_with_parameter </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate the curve by the parameter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>The parameter value at the end of extended point. When tau&lt;<a class="el" href="class_m_g_l_b_rep.html#a739d4bfc688fe8d6f74e29de3947534e" title="Return starting parameter value.">param_s()</a>, extension will be done at the starting point. When tau&gt;<a class="el" href="class_m_g_l_b_rep.html#acffb5c3b88f2c597f2af7aeb85d4fd7f" title="Return ending parameter value.">param_e()</a>, extension will be done at the end point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at the connecting point. See <a class="el" href="class_m_g_l_b_rep.html#a526a6917b8c90899287358a6b92e1e87" title="Extrapolate the curve by the chord length.">extend()</a>; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00ab0426c3f95a7432acfee78f2fe1ad"></a><!-- doxytag: member="MGLBRep::get_control_points" ref="a00ab0426c3f95a7432acfee78f2fe1ad" args="(MGBPointSeq &amp;cpoints) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLBRep::get_control_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cpoints</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts control points. </p>
<p>Fucntion's return value is true if control points was obtained, false if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpoints</em>&nbsp;</td><td>Control points will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7bb80ff3ce43fa39ab6845885089770f">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a16ef0a29fb48cb4ace7a0c0447b857b3"></a><!-- doxytag: member="MGLBRep::intersect_1D" ref="a16ef0a29fb48cb4ace7a0c0447b857b3" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGLBRep::intersect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection point of 1D sub B-Rep of original B-rep. </p>
<p>(BLIPP) Parameter values of intersection point will be returned. isect_1D covers this LBRep's C0 ontinuity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). Id of m_line_bcoef. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7da60650ad1b0c4823eeb1c3ce8be722">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a575c05dc1bb4919b9fa148b7e11fa216"></a><!-- doxytag: member="MGLBRep::is_coplanar" ref="a575c05dc1bb4919b9fa148b7e11fa216" args="(const MGCurve &amp;curve2, MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLBRep::is_coplanar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is co-planar with the 2nd curve curve2. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is co-planar. Function's return value is true if co-planar. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a84a92b42fe2946b772eb30081d2c5ad6">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a208ad049aa9bd9ef6c99c5085a22c479"></a><!-- doxytag: member="MGLBRep::is_planar" ref="a208ad049aa9bd9ef6c99c5085a22c479" args="(MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLBRep::is_planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is planar or not. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is planar. Function's return value is true if planar. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a3e6f96416ab574420cbed88ebfc414e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a70be406fdf3ec572a9c2f0996815ab4b"></a><!-- doxytag: member="MGLBRep::isect" ref="a70be406fdf3ec572a9c2f0996815ab4b" args="(const MGCurve &amp;curve2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> MGLBRep::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spline と Curve の交点を求める。 Intersection point of spline and curve. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a379e4f21b3055c90d7f83897341cd7d8">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a956a86209c9cdb6cfac7a5035fcb73f9"></a><!-- doxytag: member="MGLBRep::knot" ref="a956a86209c9cdb6cfac7a5035fcb73f9" args="(size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; MGLBRep::knot </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access to i-th element of knot. </p>
<p>( left-hand side version) </p>

</div>
</div>
<a class="anchor" id="a48c71161c275ae5fff809f5a026573be"></a><!-- doxytag: member="MGLBRep::knot" ref="a48c71161c275ae5fff809f5a026573be" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGLBRep::knot </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access to i-th element of knot. </p>
<p>(right hand side version) </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a625339525839a70c8224d621e2fbfa6e">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad6933144302ca3892d39a61e24158d4c"></a><!-- doxytag: member="MGLBRep::knot_data" ref="ad6933144302ca3892d39a61e24158d4c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* MGLBRep::knot_data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the knot vector data. </p>

</div>
</div>
<a class="anchor" id="a770c0faf6d9190d501020937c1883cdd"></a><!-- doxytag: member="MGLBRep::knot_vector" ref="a770c0faf6d9190d501020937c1883cdd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a>&amp; MGLBRep::knot_vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector. </p>
<p>(RHS version) </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a6b0a611b67e7de7e6763de85a869eacc">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a94bb48ce4d83c0aa4e9297c2d0ff8c0c"></a><!-- doxytag: member="MGLBRep::knot_vector" ref="a94bb48ce4d83c0aa4e9297c2d0ff8c0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a>&amp; MGLBRep::knot_vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector. </p>
<p>(LHS version) </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ac678277be215f7edddbe189c83ba48e3">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a95e25747174e4b17949c4cd5a3a29494"></a><!-- doxytag: member="MGLBRep::limit" ref="a95e25747174e4b17949c4cd5a3a29494" args="(const MGInterval &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身に指定したパラメータ範囲のlimitをつける。 Get the sub interval line of the original line. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a4f5e376f184379038ebac06536962e32">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af70692ddafc2663780ea9a7215b68f58"></a><!-- doxytag: member="MGLBRep::move" ref="af70692ddafc2663780ea9a7215b68f58" args="(int move_kind, double move_point_param, const MGPosition &amp;to_point, const double fix_point[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::move </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>move_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>move_point_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fix_point</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original line by moving move_point to to_point. </p>
<p>fix_point can be applied according to move_kind. move_kind=1: Start and end point of the line are fixed. The line is modified linearly so that move_point_param point is the maximum move. =2: The point fix_point[0] is fixed and the other end of the move_point_param side is moved. In this case, maximum move is the end point of the line. =3: fix_point[0]&lt;move_point_param&lt;fix_point[1], and two point fix_point[.] are fixed. The line is modified linearly so that move_point_param point is the maximum move. otherwise: Two fix point fix_point[.] are computed so that the modify range is the minimum. Other move is same as move_kind=3. Restriction: For the case move_kind=3, actual fix point is wider than specified range. The range is the smallest one possible including fix_point[]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>move_kind</em>&nbsp;</td><td>Indicates how to move line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>move_point_param</em>&nbsp;</td><td>indicate object point to move by the parameter value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to_point</em>&nbsp;</td><td>destination point of the abve source point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafeddba9b7dda43198b56caa6cdf043c"></a><!-- doxytag: member="MGLBRep::oneD" ref="aafeddba9b7dda43198b56caa6cdf043c" args="(const double g[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGLBRep::oneD </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>g</em>[4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve. </p>
<p>This is used to compute intersections with a plane g[4]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>Plane expression(a,b,c,d) where ax+by+cz=d. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac0d98232c1251692db526e28d65a6f7e">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a51b9b09f466bc20f1a80bded2b2fb8d1"></a><!-- doxytag: member="MGLBRep::operator=" ref="a51b9b09f466bc20f1a80bded2b2fb8d1" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and crv2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="aa0960c03e64454fe6c339d7e42011598"></a><!-- doxytag: member="MGLBRep::out_to_IGES" ref="aa0960c03e64454fe6c339d7e42011598" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLBRep::out_to_IGES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>igesfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>SubordinateEntitySwitch</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector. </p>
<p><a class="el" href="class_m_g_knot_vector.html" title="Defines Knot vector of B-Representation.">MGKnotVector</a> knot_vector_real() const{return <a class="el" href="class_m_g_l_b_rep.html#a94bb48ce4d83c0aa4e9297c2d0ff8c0c" title="Returns the knot vector.">knot_vector()</a>;} IGES output function. PD126. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#a2a9cfbfd6f4963a47f4a5b4c4384f436">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f3d4bb0c4af552c4ca26c8838436c8"></a><!-- doxytag: member="MGLBRep::param_normalize" ref="ad4f3d4bb0c4af552c4ca26c8838436c8" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGLBRep::param_normalize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize parameter value t to the nearest knot if their distance is within tolerance. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ab8d6aac48fea5813393870bcbd6a1e78">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="affcc9c8f0476c88f73b96b75b7593a8c"></a><!-- doxytag: member="MGLBRep::part" ref="affcc9c8f0476c88f73b96b75b7593a8c" args="(double t1, double t2, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGLBRep::part </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of this curve from parameter t1 to t2. </p>
<p>Returned is the pointer to newed object, and so should be deleted by calling program, or memory leaked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a57c9d6e7f929b0d77c75cc6417daba2b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8dfa8c81b1df7c836eb645b599c488e8"></a><!-- doxytag: member="MGLBRep::perps" ref="a8dfa8c81b1df7c836eb645b599c488e8" args="(const MGCurve &amp;crv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGLBRep::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the perpendicular points of this curve and the second one. </p>
<p>That is, if f(s) and g(t) are the points of the two curves f and g, then obtains points where the following conditions are satisfied: fs*(f-g)=0. gt*(g-f)=0. Here fs and gt are 1st derivatives at s and t of f and g. <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv2's parameter value. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a0da4a6809840a951581a99174dbebbab">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a5b90fc7c7164c39d3552f48eb801442a"></a><!-- doxytag: member="MGLBRep::perps" ref="a5b90fc7c7164c39d3552f48eb801442a" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGLBRep::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与ポイントから曲線へ下ろした垂線の足の，曲線のパラメータ値を すべて求める。 Return all the foots of the straight lines that is perpendicular to the line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>与ポイント </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ad94d161f9e243e1a47bf0ebe7b5dcf29">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="add9ac4361143161a4cd756045f0160e2"></a><!-- doxytag: member="MGLBRep::planar" ref="add9ac4361143161a4cd756045f0160e2" args="(MGPlane &amp;plane, MGStraight &amp;line, MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLBRep::planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the line B-rep is planar. </p>
<p>Funtion's return value is; 0: Not planar, nor a point, nor straight line. 1: B-Rep is a point. 2: B-Rep is a straight line. 3: B-Rep is planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>When Brep is not straight line nor a point, plane is returned. Even when not planar(return value is 0), plane nearest is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>When Brep is a line, line is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>When Brep is a point, point is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a772912ab57a98eb75078218d436e3b93"></a><!-- doxytag: member="MGLBRep::reduce" ref="a772912ab57a98eb75078218d436e3b93" args="(int ndec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLBRep::reduce </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the B-Rep by decreasing B-Rep dimension by ndec. </p>
<p>This is an approximation of the origimal B-Rep. Return value is error flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ndec</em>&nbsp;</td><td>Number of B-rep dimension to decrease </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a866cb9a7578853653d05ec7658be0688"></a><!-- doxytag: member="MGLBRep::refine" ref="a866cb9a7578853653d05ec7658be0688" args="(const MGKnotVector &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&amp; MGLBRep::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change an original B-Rep to new one with subdivided knot configuration. </p>
<p>Knots t must be subdivided knots. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>BLUNKknot vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcf6eb229a8922dc9466538d1cc97bd0"></a><!-- doxytag: member="MGLBRep::remove_knot" ref="adcf6eb229a8922dc9466538d1cc97bd0" args="(size_t j, size_t snum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::remove_knot </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>snum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove knot if removed line has the difference less than line_zero(); The difference is checked only for the space id of coef(.,j+k) of j=0, ..., snum-1. </p>
<p>When snum=0, snum is set as <a class="el" href="class_m_g_l_b_rep.html#aa006bc921b501329363f9fc8a8e79d9a" title="Returns the space dimension.">sdim()</a>; </p>

</div>
</div>
<a class="anchor" id="ad554fd02a7252dcd87ceb0bb599cf6f1"></a><!-- doxytag: member="MGLBRep::remove_knot" ref="ad554fd02a7252dcd87ceb0bb599cf6f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLBRep::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot. </p>
<p>line_zero tolerance is used. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#aac3a1862056a9ea5e662e692f2fcebbb">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad3a1d19b4223ecdae7edf7cd41ab7f5c"></a><!-- doxytag: member="MGLBRep::remove_knot_one" ref="ad3a1d19b4223ecdae7edf7cd41ab7f5c" args="(double line0, size_t nKnot, double &amp;totalTol, size_t &amp;num_knot, size_t sid=0, size_t snum=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLBRep::remove_knot_one </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>line0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nKnot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>totalTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>num_knot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>snum</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数(1つのノット) 戻り値は、削除したノットの数 When snum!=0, tolerance of totalTol is checked only for coef(.,sid+j), where j=0, ..., snum-1. </p>
<p>When snum=0, snum is set as <a class="el" href="class_m_g_l_b_rep.html#aa006bc921b501329363f9fc8a8e79d9a" title="Returns the space dimension.">sdim()</a>; </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line0</em>&nbsp;</td><td>Tolerance allowed for the knot removal. When line0=&lt;0., the knot will be removed unconditionally. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nKnot</em>&nbsp;</td><td>削除しようとするノットの番号 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>totalTol</em>&nbsp;</td><td>誤差合計 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_knot</em>&nbsp;</td><td>Remained knot number at knot(id) after removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sid</em>&nbsp;</td><td>Space dimension start id of this LBRep's B-coef. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>snum</em>&nbsp;</td><td>Num of space dimension for the totalTol tolerance check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8371d4ab8811a7e0e55bfd75a36169ef"></a><!-- doxytag: member="MGLBRep::sweep" ref="a8371d4ab8811a7e0e55bfd75a36169ef" args="(const MGUnit_vector &amp;uvec, double start_dist, double end_dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGLBRep::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sweep surface from crv Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted. </p>
<p>The sweep surface is defined as: This curve(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ab444253d2ae843173c03d0dc2c79e814">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac810dcba8cdd5a853f3867305daed26e"></a><!-- doxytag: member="MGLBRep::type" ref="ac810dcba8cdd5a853f3867305daed26e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a> MGLBRep::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲線のタイプをを返す。 Return the curve type. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a23f1534a8c49c1ca508e313088648113">MGCurve</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a097c32386c3d89cc5b9592b440e99f0b"></a><!-- doxytag: member="MGLBRep::rebuild_knot" ref="a097c32386c3d89cc5b9592b440e99f0b" args="(const MGPvector&lt; MGCurve &gt; &amp;brepl, size_t order=0, MGLBRep **tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&gt; rebuild_knot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>brepl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> **&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as above, except that the input is MGPvector&lt;&gt;. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brepl</em>&nbsp;</td><td>入力曲線列 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>指定オーダー </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>接続面 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1923bd8524b3a3082e9a35129ebcfd8d"></a><!-- doxytag: member="MGLBRep::rebuild_knot" ref="a1923bd8524b3a3082e9a35129ebcfd8d" args="(const std::vector&lt; const MGCurve * &gt; &amp;brepl, size_t order=0, MGLBRep **tp=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&gt; rebuild_knot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>brepl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> **&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲線列のノットベクトルを再構築する 入力された複数曲線列を指定オーダーで再構築する。トレランスはline_zero()を使用している。 オーダーが指定されていないとき曲線列のうちで最も大きいオーダーを使用する。このとき、 Ellipse, Straightのオーダーは4として考える。 パラメータ範囲は1次微分値の大きさが１になるようにしたときの長さの平均を使用している。 戻り値は再構築後の曲線列が返却される。エラーのときヌルが返却される。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brepl</em>&nbsp;</td><td>入力曲線列 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>指定オーダー </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>接続面 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a784fd181cc136376919edddeed3a4414"></a><!-- doxytag: member="MGLBRep::remove_knot_curves" ref="a784fd181cc136376919edddeed3a4414" args="(MGPvector&lt; MGLBRep &gt; &amp;brepList, MGLBRep **tp=0, double tp_length=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend void remove_knot_curves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>brepList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> **&nbsp;</td>
          <td class="paramname"> <em>tp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tp_length</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>複数カーブの共通で削除できるノットを削除する。 ただし、入力カーブは同じノットベクトルを持つものとする。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brepList</em>&nbsp;</td><td>曲線列 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>接続面 input and output. if tp[i] for crvl[i] was not null, converted new tp will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>LBRep.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:25 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

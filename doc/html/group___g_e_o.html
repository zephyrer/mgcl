<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: Geometry (sub) classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Geometry (sub) classes</h1>  </div>
</div>
<div class="contents">

<p><a class="el" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry.">MGGeometry</a> is top abstract class for <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>, <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>, and <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Geometry (sub) classes:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___g_e_o.png" border="0" alt="" usemap="#group______g__e__o"/>
<map name="group______g__e__o" id="group______g__e__o">
<area shape="rect" id="node2" href="group___b_a_s_e.html" title="_MSC_VER &gt; 1000" alt="" coords="255,8,343,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define <a class="el" href="class_m_g_b_sum_curve.html" title="Define MGBSumCurve Class(Boolean sum curve of three curves).">MGBSumCurve</a> Class(Boolean sum curve of three curves).  <a href="class_m_g_b_sum_curve.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines Boolean sum surface.  <a href="class_m_g_b_sum_surf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> is a composite of other leaf curves.  <a href="class_m_g_composite_curve.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html">MGCurve</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a> is an abstract class which represents a whole curve.  <a href="class_m_g_curve.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_cylinder.html" title="MGCylinder is a Cylinder in 3D space.">MGCylinder</a> is a Cylinder in 3D space.  <a href="class_m_g_cylinder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D.">MGEllipse</a> is a class to define an ellipse of 2D or 3D.  <a href="class_m_g_ellipse.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_geometry.html">MGGeometry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry.">MGGeometry</a> is an abstract class which represents a whole geometry.  <a href="class_m_g_geometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> is a class for B-SPline representation.  <a href="class_m_g_l_b_rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html">MGPlane</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> is infinite plane in 3D space.  <a href="class_m_g_plane.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_point.html">MGPoint</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a> represents one dimensional manifold, a point in a space.  <a href="class_m_g_point.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines Rational Line B-Representation.  <a href="class_m_g_r_l_b_rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines Surface B-Representation of rational form.  <a href="class_m_g_r_s_b_rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines Surface B-Representation, that is , B-Spline surface.  <a href="class_m_g_s_b_rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html">MGSphere</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_sphere.html" title="MGSphere is a Sphere in 3D space.">MGSphere</a> is a Sphere in 3D space.  <a href="class_m_g_sphere.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_straight.html">MGStraight</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_straight.html" title="MGStraight is a curve of any space dimension, represent a straight line.">MGStraight</a> is a curve of any space dimension, represent a straight line.  <a href="class_m_g_straight.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html">MGSurface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> is an abstract class of 3D surface.  <a href="class_m_g_surface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_surf_curve.html" title="MGSurfCurve is a curve defined by a surface and its parameter space line represented...">MGSurfCurve</a> is a curve defined by a surface and its parameter space line represented by (u,v).  <a href="class_m_g_surf_curve.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a> is a part of original curve that has limitted parameter range.  <a href="class_m_g_trimmed_curve.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_m_g_c_l.html">MGCL</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><a class="el" href="namespace_m_g_c_l.html" title="MGCL namespace defines varialbes without prefix mg or MG.">MGCL</a> namespace defines varialbes without prefix mg or MG. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGEXTERN double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#gab51c79e8dcb2e756f7cae935f1ce7155">MG_Curvature</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvature in 3D space, ie, the value is not negative.  <a href="#gab51c79e8dcb2e756f7cae935f1ce7155"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGEXTERN double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#gad5562298c860e1b277f0a97692b06a66">MG_Torsion</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute torsion.  <a href="#gad5562298c860e1b277f0a97692b06a66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#gabc0c44a6fadf5979699b82da6b47b509">one_arrow</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;root, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vecx, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;vecy, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;head, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;headtail1, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;headtail2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate arrow data from (root, vecx, vecy).  <a href="#gabc0c44a6fadf5979699b82da6b47b509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#ga729db792cd971c2da0a98e7db474ff2d">MGRLBRep_ellipse_weight</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P0, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;T0, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P2, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;T2, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P1, double &amp;w1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to compute control point P1 and weight w1 of rational form of an ellipse segment.  <a href="#ga729db792cd971c2da0a98e7db474ff2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGEXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#gab12e89ca0d3521e5d0bf901e0e67ef1a">MGBinominal</a> (size_t m, double *bc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute binominal coefficients (i,j) for 0&lt;=i&lt;=m and 0&lt;=j&lt;=i in bc[(m+1)*i+j].  <a href="#gab12e89ca0d3521e5d0bf901e0e67ef1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#ga193f3abcd0601365d9ea118f157427a5">construct_perimeters</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;peris, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;perimeters2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 4 perimeters, given at least two of the four.  <a href="#ga193f3abcd0601365d9ea118f157427a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#ga37139a12c165231d53b0ba0daa055d95">bool_sum</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> *edge_crvl[4], const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;tp, int &amp;error, <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct boolean sum surface from the four perimeters and their tangent planes.  <a href="#ga37139a12c165231d53b0ba0daa055d95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_e_o.html#gabaf291fe07adcf49c2df180edca5e1ff">bool_sum</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> *edge_crvl[4], <a class="el" href="class_m_g_s_b_rep_vec_t_p.html">MGSBRepVecTP</a> &amp;vectp, int &amp;error, <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry.">MGGeometry</a> is top abstract class for <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>, <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>, and <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga37139a12c165231d53b0ba0daa055d95"></a><!-- doxytag: member="SBRep.h::bool_sum" ref="ga37139a12c165231d53b0ba0daa055d95" args="(const MGCurve *edge_crvl[4], const MGSBRepTP &amp;tp, int &amp;error, MGSBRep &amp;surf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bool_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>edge_crvl</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct boolean sum surface from the four perimeters and their tangent planes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge_crvl</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>接続面(パラメータ範囲は境界線と同じ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaf291fe07adcf49c2df180edca5e1ff"></a><!-- doxytag: member="SBRep.h::bool_sum" ref="gabaf291fe07adcf49c2df180edca5e1ff" args="(const MGCurve *edge_crvl[4], MGSBRepVecTP &amp;vectp, int &amp;error, MGSBRep &amp;surf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bool_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>edge_crvl</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep_vec_t_p.html">MGSBRepVecTP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vectp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge_crvl</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vectp</em>&nbsp;</td><td>接続面(パラメータ範囲は境界線と同じ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga193f3abcd0601365d9ea118f157427a5"></a><!-- doxytag: member="SBRep.h::construct_perimeters" ref="ga193f3abcd0601365d9ea118f157427a5" args="(const MGPvector&lt; MGCurve &gt; &amp;peris, MGPvector&lt; MGLBRep &gt; &amp;perimeters2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int construct_perimeters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>perimeters2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct 4 perimeters, given at least two of the four. </p>
<p>Input perimeters may have different knot configuration. In this case they will be updated so as to have the same configuration. Function's return value indicates which perimeter(s) was missing: 10: all of the 4 were input(and knot configurations were updated to have the same). 0: only perimeter 0 was missing. 1: only perimeter 1 was missing. 2: only perimeter 2 was missing. 3: only perimeter 3 was missing. 4: perimeter 2 and 3 were missing. 5: perimeter 1 and 3 were missing. 6: perimeter 1 and 2 were missing. 7: perimeter 0 and 3 were missing. 8: perimeter 0 and 2 were missing. 9: perimeter 0 and 1 were missing. -2: less than 2 perimeters were provided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peris</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順). Let i be the perimeter number, and the data is missing, perimeter[i] must be null. If perimeter 3 data is missing, perimeters.size() may be 3. If perimeter 2 and 3 data are missing, perimeters.size() may be 2. When perimeters were not the same knot configuration along u(perimeter 0 and 2) or along v(perimeter 3 and1), they will be rebuild to have the same configuration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perimeters2</em>&nbsp;</td><td>new perimeters will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab51c79e8dcb2e756f7cae935f1ce7155"></a><!-- doxytag: member="Curve.h::MG_Curvature" ref="gab51c79e8dcb2e756f7cae935f1ce7155" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEXTERN double MG_Curvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvature in 3D space, ie, the value is not negative. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>First derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>Second derivative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5562298c860e1b277f0a97692b06a66"></a><!-- doxytag: member="Curve.h::MG_Torsion" ref="gad5562298c860e1b277f0a97692b06a66" args="(const MGVector &amp;v1, const MGVector &amp;v2, const MGVector &amp;v3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEXTERN double MG_Torsion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute torsion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>First derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>Second derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v3</em>&nbsp;</td><td>Third derivative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab12e89ca0d3521e5d0bf901e0e67ef1a"></a><!-- doxytag: member="RSBRep.h::MGBinominal" ref="gab12e89ca0d3521e5d0bf901e0e67ef1a" args="(size_t m, double *bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEXTERN void MGBinominal </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>bc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute binominal coefficients (i,j) for 0&lt;=i&lt;=m and 0&lt;=j&lt;=i in bc[(m+1)*i+j]. </p>

</div>
</div>
<a class="anchor" id="ga729db792cd971c2da0a98e7db474ff2d"></a><!-- doxytag: member="RLBRep.h::MGRLBRep_ellipse_weight" ref="ga729db792cd971c2da0a98e7db474ff2d" args="(const MGPosition &amp;P0, const MGVector &amp;T0, const MGPosition &amp;P, const MGPosition &amp;P2, const MGVector &amp;T2, MGPosition &amp;P1, double &amp;w1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL int MGRLBRep_ellipse_weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>w1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to compute control point P1 and weight w1 of rational form of an ellipse segment. </p>
<p>Pi and Ti are points and tangents of start and end for i=0,2. P is mid point of the ellipse. Function's output is if obtained(!=0:true) or not(=0:false). When obtained, =1:as finite control point, =2:as infinite. When T0, T2, P0, and P2 are not in one plane, function return 0.</p>
<p>(P0,1.) (P1,w1) (P2,1.) constitute the ellipse control polygon of order 3 in homogeneous form.</p>
<p>See "The NURBS Book" of W.Tiller and L.Piegl publised by Springer. </p>

</div>
</div>
<a class="anchor" id="gabc0c44a6fadf5979699b82da6b47b509"></a><!-- doxytag: member="Curve.h::one_arrow" ref="gabc0c44a6fadf5979699b82da6b47b509" args="(const MGPosition &amp;root, const MGVector &amp;vecx, const MGUnit_vector &amp;vecy, MGPosition &amp;head, MGPosition &amp;headtail1, MGPosition &amp;headtail2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL void one_arrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vecx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vecy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>headtail1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>headtail2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate arrow data from (root, vecx, vecy). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>root of the arrow </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vecx</em>&nbsp;</td><td>the vector from the roo to the head of the arrrow </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vecy</em>&nbsp;</td><td>vecy that is normal to the vector from root to head </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>head of the arrow will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>headtail1</em>&nbsp;</td><td>two tail of arrowhead line segments will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:15 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

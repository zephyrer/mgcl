<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: (Template) Functions or classes.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>(Template) Functions or classes.</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve_parameter.html">MGCurveParameter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class to compute a curve parameter defined by f(t)=0.  <a href="class_m_g_curve_parameter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_draw_func.html">MGDrawFunc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used for drawWire functions of all the MGObjects.  <a href="class_m_g_draw_func.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_command_drawer.html">MGCommandDrawer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_command_drawer.html" title="MGCommandDrawer is a utility class fo MGOpenGLView class.">MGCommandDrawer</a> is a utility class fo <a class="el" href="class_m_g_open_g_l_view.html" title="COpenGLWindow ビュー.">MGOpenGLView</a> class.  <a href="class_m_g_command_drawer.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#ga34cfd6dc8399cc731c50aada96dc2e93">mgDefint</a> (func &amp;f, double a, double b, double eps, int l=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integrate f(x)(l=0) or F(x)(l=1, see below) over finite interval (a,b).  <a href="#ga34cfd6dc8399cc731c50aada96dc2e93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#ga455a9498fe9d29c5a159fcefa85ccd14">mgGausp</a> (func &amp;f, double a, double b, int n=10)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Legendre-Gauss quadratuer formula over (a,b) .  <a href="#ga455a9498fe9d29c5a159fcefa85ccd14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#ga69ae005d56e5b9c1bdb67d058f9f6d21">factorizeLU</a> (<a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;W, int *id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU factorization to solve linear equations, general version.  <a href="#ga69ae005d56e5b9c1bdb67d058f9f6d21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#ga742675c1d966c04a42b04a06806d4902">solveLU</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;W, const int *id, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;A, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the linear equation W*X=A to get X, inputting factorize W and A.  <a href="#ga742675c1d966c04a42b04a06806d4902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#gac3b031e3e42621ef186e2bcccec43761">solveSymetricTridiagonal</a> (<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;W, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;A, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the linear equation M*X=A where M is a symetric tridiagonal matrix of order n.  <a href="#gac3b031e3e42621ef186e2bcccec43761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#gaa90b2ad3b792b8af88f466693d69efd8">factorizeBandLU</a> (<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;W, int nlower)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">factorizeBandLU executes the LU-factorization without pivoting of a banded matrix M.  <a href="#gaa90b2ad3b792b8af88f466693d69efd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#gadc2911360b50534a3916ea3a5849d31e">solveBandLU</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;W, int nlower, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;A, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">solveBandLU returns the solution of the linear system M*X = A.  <a href="#gadc2911360b50534a3916ea3a5849d31e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#ga017997d32d5712c1449222ac40f76afe">factorizeCholeLU</a> (<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;W)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs Cholesky factorization.  <a href="#ga017997d32d5712c1449222ac40f76afe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#ga8df629836666f3603e4b1efad4a9caa5">solveCholeLU</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;W, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;A, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solves the linear system C*X = A , provided W contains the Cholesky factorization.  <a href="#ga8df629836666f3603e4b1efad4a9caa5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class func &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___a_l_g_o_r_i_t_h_m.html#gaeca75f02674a35f2d7a735ea210db95c">mgNlbit</a> (func &amp;fn, double xl, double xr, double eps, int itr, int &amp;ier)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the solution fn(x)=0.  <a href="#gaeca75f02674a35f2d7a735ea210db95c"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa90b2ad3b792b8af88f466693d69efd8"></a><!-- doxytag: member="LinearEquation.h::factorizeBandLU" ref="gaa90b2ad3b792b8af88f466693d69efd8" args="(MGBPointSeq &amp;W, int nlower)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int factorizeBandLU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nlower</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>factorizeBandLU executes the LU-factorization without pivoting of a banded matrix M. </p>
<p>M's order is n with (nlower + 1 + nupper) bands of diagonals stored in W. GAUSS Elimination W I T H O U T pivoting is used. The routine is intended for use with matrices M which do not require row interchanges durnig factorization, especially for the TOTALLY POSITIVE matrices which occur in spline calculations. The routine should not be used for arbitrary banded matrices. For arbitary ones, use factorizeLU and solveLU. On function's return, W contains the LU factorization of the matix M. Function's return value is: =0:SUCCESS, =1:FAILURE.</p>
<p>NOTE: This program is translated to C++ from BANFAC of the book "A Practical Guide to Splines" by Carl de Boor, Springer-Verlag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>contains interesting part of the matrix M. W.length()=nlower+1+nupper=nband(band width of M), and W.sdim()=n(order of the matrix M). The diagonals(or bands) of M(i+j,j) are stored in W as W(i+nupper,j) for i=-nupper,..., nlower, and j=0,..., n-1. Explicitly, M has nlower bands below the diagonal and nupper bands above the diagonal. Thus the band width nband=nlower+1+nupper(=W.length()). For exapmle, the interesting entries of M of order 9, whose nlower=1 and nupper=2 would appear in the 4 subscripts of W(i, j) as follows:</td></tr>
  </table>
  </dd>
</dl>
<p>j= 0 1 2 3 4 5 6 7 8: i=0: x x 02 13 24 35 46 57 68, i=1: x 01 12 23 34 45 56 67 78, i=2: 00 11 22 33 44 55 66 77 88, i=3: 10 21 32 43 54 65 76 87 x.</p>
<p>All other entries of W not identified in this way with an entry of M are never referenced. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nlower</em>&nbsp;</td><td>number of bands of the matrix M below the main diagonal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga017997d32d5712c1449222ac40f76afe"></a><!-- doxytag: member="LinearEquation.h::factorizeCholeLU" ref="ga017997d32d5712c1449222ac40f76afe" args="(MGBPointSeq &amp;W)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factorizeCholeLU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs Cholesky factorization. </p>
<p>Let C is a symmetric positive semidefinite and banded matrix, having nbands diagonals at and below the main diagonal. Then C can be factorized as C = L*D*L-transpose with L, unit lower triangular and D, the diagonal of C.</p>
<p>M E T H O D ****** Gauss elimination , adapted to the symmetry and bandedness of C, is used. Near zero pivots are handled in a special way. The diagonal element C(i,i) = W(0,i) is saved initially in wrok array diag(i), for all i. At the i-th elimination step, the currrent pivot element, viz., W(0,i), is compared with its original value, diag(i). If, as the result of prior elimination steps, this element has been reduced by about a word length, (i.e., if W(0,i)+dang(i) &lt;= diag(i)), then the pivot is declared to be zero. and the entire i-th row is declared to be linearly dependent on the prededing rows. This has the effect of producing X(i)=0 when solving C*X=B for X, regardless of B. Justification for this is as follows. In contemplated applications of this program, the given equations are the normal equations for some least-squares approximation problem, diag(i)=C(i,i) gives the norm-square of the i-th basis function, and, at this point, W(0,i) contains the nrom-square of the error in the least-squares approximation to the i-th basis function by linear combinations of the first i-1. Having W(0,i)+diag(i) &lt;= diag(i) signifies that the n-th function is linearly dependent to machine accuracy on the first i-1 funcitons, therefore can safely be left out from the basis of approximationg functions. The solution of a linear system C*X=B is effected by the succession of the following two calls: factorizeCholeLU to get factorization, and solveCholeLU to solve for X.</p>
<p>NOTE: This program is translated to C++ from BCHFAC of the book "A Practical Guide to Splines" by Carl de Boor, Springer-Verlag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>contains nbands diagonals in W(.,j), with the main diagonal in W(.,0). Precisely, W(i,j) contains C(i+j,j), i=0,...,nbands-1, j=0,...,n-1. W.length()=nbands, and W.sdim()=n is the order of the matrix C. For example, the entries of a 7 diagonal symmetric matrix C of order 9 (nbands=4) would be stored in W(i,j) as follows:</td></tr>
  </table>
  </dd>
</dl>
<p>j= 0 1 2 3 4 5 6 7 8: i=0: 00 11 22 33 44 55 66 77 88, i=1: 10 21 32 43 54 65 76 87 x, i=2: 20 31 42 53 64 75 86 x x, i=3: 30 41 52 63 74 85 x x x.</p>
<p>All other entries of W not identified in this way with an entry of C are never referenced. On return, W contains the Cholesky factorization C= L*D*L-transpose with W(0,j) containing 1/D(j,j) for j=0,..., n-1. And W(i,j) containing L(i+j,j) for i=1,..., nbands-1, and j=0, ..., n-i-1. </p>

</div>
</div>
<a class="anchor" id="ga69ae005d56e5b9c1bdb67d058f9f6d21"></a><!-- doxytag: member="LinearEquation.h::factorizeLU" ref="ga69ae005d56e5b9c1bdb67d058f9f6d21" args="(MGMatrix &amp;W, int *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void factorizeLU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU factorization to solve linear equations, general version. </p>
<p>This is a general solver using pivotting, and so is inefficient compared with band matrix of diagonally dominant equations. If the equation is known as special equations as band matrix (as of diagonally dominant equations, or as Symetric Tridiagonal), use factorizeBandLU and solveBandLU, factorizeCholeLU and solveCholeLU, or solveSymetricTridiagonal.</p>
<p>factorizeLU factorizes W to LU in the linear equation W*X=A. Using output W, the solution of W*X=A is obtained by solveLU. Here, L is n by n lower triangular matrix and U is n by n upper triangular matrix. U's diagonal is (1). LU factorization using pivot. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>left-hand side matrix of n*n is input, and factorized LU matrix will be output where n=A.length(), left-bottom triangle including the diagonal will contain L, right-upper triangle excluding the diagonal will contain U. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>array of int id[n], pivot id will be output in id[i] for i=0,...,n-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34cfd6dc8399cc731c50aada96dc2e93"></a><!-- doxytag: member="defint.h::mgDefint" ref="ga34cfd6dc8399cc731c50aada96dc2e93" args="(func &amp;f, double a, double b, double eps, int l=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mgDefint </td>
          <td>(</td>
          <td class="paramtype">func &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>l</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integrate f(x)(l=0) or F(x)(l=1, see below) over finite interval (a,b). </p>
<p>The DE formula (double exponential formula) is applied. *Note* Original Fortran program codes are from DEFINT of the book "Fortran77による数値計算ソフトウェア" by M.Sugihara, M.Mori, published by Maruzen K.K.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>integral</em>&nbsp;</td><td>of f(x)(when l=0) or F(x)(when l=1). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Function object for integrand. f(x) returns the target integration function's value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>lower bound of integration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>upper bound of integration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eps</em>&nbsp;</td><td>absolute error tolerance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>0 or 1 If l=0 then integrate f(x) over (a,b) If l=1 then integrate F(x) over (a,b) In case of l=1 f must be defined as follows: IF (-c .LT. y .LT. 0) THEN f(y) = F(b - y) IF ( 0 .LT. y .LE. c) THEN f(y) = F(a - y) where c = (b - a) / 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga455a9498fe9d29c5a159fcefa85ccd14"></a><!-- doxytag: member="Gausp.h::mgGausp" ref="ga455a9498fe9d29c5a159fcefa85ccd14" args="(func &amp;f, double a, double b, int n=10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mgGausp </td>
          <td>(</td>
          <td class="paramtype">func &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Legendre-Gauss quadratuer formula over (a,b) . </p>
<p>The DE formula (double exponential formula) is applied. *Note* Original Fortran program codes are from DDGAUSP of the book "Fortran77による数値計算ソフトウェア" by M.Sugihara, M.Mori, published by Maruzen K.K.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>of integration. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Function object to evaluate the function f(t). f(t) must return double value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>lower bound of integration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>upper bound of integration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>number of points of the formula, must not be larger than 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeca75f02674a35f2d7a735ea210db95c"></a><!-- doxytag: member="nlbit.h::mgNlbit" ref="gaeca75f02674a35f2d7a735ea210db95c" args="(func &amp;fn, double xl, double xr, double eps, int itr, int &amp;ier)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mgNlbit </td>
          <td>(</td>
          <td class="paramtype">func &amp;&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>xr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>itr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>ier</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the solution fn(x)=0. </p>
<p>mgNlbit can be applied when known there exists a solution between (xl, xr). SOLUTION OF A NON-LINEAR EQUATION BY BISECTION METHOD AND REGULA FALSI METHOD.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>solution x obtained. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>Function object to evaluate the fucntion, must return double value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xl</em>&nbsp;</td><td>LEFT HAND SIDE VALUE OF THE SOLUTION. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xr</em>&nbsp;</td><td>RIGHT HAND SIDE VALUE OF THE SOLUTION . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eps</em>&nbsp;</td><td>tolerance allowed for the convergence in world coordnate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itr</em>&nbsp;</td><td>MAXIMUM NUMBER OF REPITITION. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ier</em>&nbsp;</td><td>Error code. =0:solution successfully obtained, =1:mgNlbit did not converg, and solution not obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc2911360b50534a3916ea3a5849d31e"></a><!-- doxytag: member="LinearEquation.h::solveBandLU" ref="gadc2911360b50534a3916ea3a5849d31e" args="(const MGBPointSeq &amp;W, int nlower, const MGBPointSeq &amp;A, MGBPointSeq &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveBandLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nlower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>solveBandLU returns the solution of the linear system M*X = A. </p>
<p>solveBandLU is the companion routine of factorizeBandLU, and factorizeBandLU executes the LU-Factorization for M in W.</p>
<p>NOTE: This program is translated to C++ from BANSLV of the book "A Practical Guide to Splines" by Carl de Boor, Springer-Verlag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>factorized LU matrix is input which is obtained by factorizeBandLU. Left-bottom triangle including the diagonal contain L, right-upper triangle excluding the diagonal contain U. Refer to factorizeBandLU. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nlower</em>&nbsp;</td><td>number of bands of the matrix M below the main diagonal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>right hand side vector. A.length() is W.sdim() =n(order of the matrix M). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>solved X will be output. X.length() will be A.length(), and X.sdim() will be A.sdim(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8df629836666f3603e4b1efad4a9caa5"></a><!-- doxytag: member="LinearEquation.h::solveCholeLU" ref="ga8df629836666f3603e4b1efad4a9caa5" args="(const MGBPointSeq &amp;W, const MGBPointSeq &amp;A, MGBPointSeq &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveCholeLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the linear system C*X = A , provided W contains the Cholesky factorization. </p>
<p>The Cholesky factorization is obtained by factorizeCholeLU. See factorizeCholeLU.</p>
<p>NOTE: This program is translated to C++ from BCHSLV of the book "A Practical Guide to Splines" by Carl de Boor, Springer-Verlag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>contains the Cholesky factorization for C, can be obtained by factorizeCholeLU. Refer to factorizeCholeLU. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>right hand side vector. A.length() is W.sdim()=n(order of the matrix C). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>solved X will be output. X.length() will be A.length(), and X.sdim() will be A.sdim(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga742675c1d966c04a42b04a06806d4902"></a><!-- doxytag: member="LinearEquation.h::solveLU" ref="ga742675c1d966c04a42b04a06806d4902" args="(const MGMatrix &amp;W, const int *id, const MGBPointSeq &amp;A, MGBPointSeq &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the linear equation W*X=A to get X, inputting factorize W and A. </p>
<p>W and id are obtained by factorizeLU. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>factorized LU matrix is input which is obtained by factorizeLU. left-bottom triangle including the diagonal contain L, right-upper triangle excluding the diagonal contain U. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>array of int id[n] which contain pivot id in id[i] for i=0,...,n-1, this is the output of factorizeLU. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>right hand side vector. A.length() is W.sdim(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>solved X will be output. X.length() will be A.length(), and X.sdim() will be A.sdim(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac3b031e3e42621ef186e2bcccec43761"></a><!-- doxytag: member="LinearEquation.h::solveSymetricTridiagonal" ref="gac3b031e3e42621ef186e2bcccec43761" args="(MGBPointSeq &amp;W, const MGBPointSeq &amp;A, MGBPointSeq &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void solveSymetricTridiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the linear equation M*X=A where M is a symetric tridiagonal matrix of order n. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>W</em>&nbsp;</td><td>the symetric tridiagonal matrix M is input. three bands of the matrix at and above the diagonal are input, W(i,0)=M(i,i), W(i,1)=M(i,i+1) and M(i+1,i), W(i,2)=M(i,i+2) and M(i+2,i) for i=0,...,n-1, Factorized matrix will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>right hand side vector. A.length() is W.length(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>solved X will be output. X.length() will be A.length(), and X.sdim() will be A.sdim(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:15 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

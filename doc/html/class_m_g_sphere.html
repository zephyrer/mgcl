<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGSphere Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGSphere Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGSphere" --><!-- doxytag: inherits="MGSurface" -->
<p><a class="el" href="class_m_g_sphere.html" title="MGSphere is a Sphere in 3D space.">MGSphere</a> is a Sphere in 3D space.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Sphere.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGSphere:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_sphere__inherit__graph.png" border="0" usemap="#_m_g_sphere_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_sphere_inherit__map" id="_m_g_sphere_inherit__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="76,315,161,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node12" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="132,237,225,267"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGSphere:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_sphere__coll__graph.png" border="0" usemap="#_m_g_sphere_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_sphere_coll__map" id="_m_g_sphere_coll__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="557,600,643,629"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="453,501,552,531"/><area shape="rect" id="node30" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="459,600,533,629"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="400,405,480,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="396,85,503,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="305,181,383,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="419,5,480,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="288,293,400,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="239,85,372,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="504,405,571,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="496,293,579,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="499,181,576,211"/><area shape="rect" id="node26" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="576,501,669,531"/><area shape="rect" id="node28" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D." alt="" coords="273,699,356,728"/><area shape="rect" id="node33" href="class_m_g_unit__vector.html" title="Define a unit vector, is a MGVector." alt="" coords="197,600,304,629"/><area shape="rect" id="node35" href="class_m_g_vector.html" title="Vector of a general n space dimension." alt="" coords="104,501,184,531"/><area shape="rect" id="node37" href="class_m_g_position.html" title="Represent a positional data." alt="" coords="5,600,96,629"/><area shape="rect" id="node41" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="328,600,435,629"/><area shape="rect" id="node43" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="328,501,429,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_sphere-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cf01f49ec25c5a687b9b6854ccbf300"></a><!-- doxytag: member="MGSphere::MGSphere" ref="a1cf01f49ec25c5a687b9b6854ccbf300" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a1cf01f49ec25c5a687b9b6854ccbf300">MGSphere</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor 初期化なしで柱面を生成する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a96319699e11f1605368f89ea9dbab39d">MGSphere</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;cntr, double radius)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a whole sphere from the center and the radius.  <a href="#a96319699e11f1605368f89ea9dbab39d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a6073fcb45a71718b093c03ad309cf12f">MGSphere</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;cntr, double radius, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;B, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;M)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a whole sphere from the center and the radius.  <a href="#a6073fcb45a71718b093c03ad309cf12f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#aebdadfc3eb1fe1754453c849e1395560">MGSphere</a> (size_t dim, const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;cyl, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Sphere by changing this space dimension or ordering the coordinates.  <a href="#aebdadfc3eb1fe1754453c849e1395560"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a099636c29a82122b98e6644ce5c75da0">MGSphere</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;ellipse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whole sphere(u parameter range is from 0 to 2 pai) around minor axis of the input ellipse.  <a href="#a099636c29a82122b98e6644ce5c75da0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#af6e9ea26a662ea95181ee40c0c39c266">MGSphere</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;ellipse, <a class="el" href="class_m_g_interval.html">MGInterval</a> urange)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sphere(u parameter range is urange) around minor axis of the input ellipse.  <a href="#af6e9ea26a662ea95181ee40c0c39c266"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a8ed91f4d707eecb608ab788bc3550aaf">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor//////////////// ‾MGSphere();.  <a href="#a8ed91f4d707eecb608ab788bc3550aaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a616263f17ff12c0a76031f9fe64b3d95"></a><!-- doxytag: member="MGSphere::operator=" ref="a616263f17ff12c0a76031f9fe64b3d95" args="(const MGSphere &amp;gel2)" -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af976f5b777eefdff63a4639b1b4f8a62"></a><!-- doxytag: member="MGSphere::operator+" ref="af976f5b777eefdff63a4639b1b4f8a62" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#af976f5b777eefdff63a4639b1b4f8a62">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translation of the Sphere. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaa202677e9e7d20d2b388b4a7cb867c"></a><!-- doxytag: member="MGSphere::operator&#45;" ref="afaa202677e9e7d20d2b388b4a7cb867c" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#afaa202677e9e7d20d2b388b4a7cb867c">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translation of the Sphere. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a84a52286c4ca40ad444a09e2937271a8">operator*</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">柱面のスケーリングを行い，柱面を作成する。 Scaling of the Sphere by a double.  <a href="#a84a52286c4ca40ad444a09e2937271a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1acef4f72c6c7dc529ff55b04b0b3e8"></a><!-- doxytag: member="MGSphere::operator*" ref="ae1acef4f72c6c7dc529ff55b04b0b3e8" args="(const MGMatrix &amp;) const " -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ae1acef4f72c6c7dc529ff55b04b0b3e8">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the Sphere by a matrix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674ac658910aec001fe294364fed6c90"></a><!-- doxytag: member="MGSphere::operator*" ref="a674ac658910aec001fe294364fed6c90" args="(const MGTransf &amp;) const " -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a674ac658910aec001fe294364fed6c90">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the Sphere by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fda158e64ae3a739cb00340e639442c"></a><!-- doxytag: member="MGSphere::operator+=" ref="a4fda158e64ae3a739cb00340e639442c" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a4fda158e64ae3a739cb00340e639442c">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b0ad37b7debdae4e10710dd196ee7c7"></a><!-- doxytag: member="MGSphere::operator&#45;=" ref="a0b0ad37b7debdae4e10710dd196ee7c7" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e77b5775a8b0d37435240571ee5ec41"></a><!-- doxytag: member="MGSphere::operator*=" ref="a1e77b5775a8b0d37435240571ee5ec41" args="(double scale)" -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fe47656a21c9a490f717c690d9e6668"></a><!-- doxytag: member="MGSphere::operator*=" ref="a5fe47656a21c9a490f717c690d9e6668" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac36245d6ee379e84c1c4c7b125549ac6"></a><!-- doxytag: member="MGSphere::operator*=" ref="ac36245d6ee379e84c1c4c7b125549ac6" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6957b5853d439d123b7b983b0ecb00"></a><!-- doxytag: member="MGSphere::operator==" ref="a3d6957b5853d439d123b7b983b0ecb00" args="(const MGSphere &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a3d6957b5853d439d123b7b983b0ecb00">operator==</a> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfe5b73d0efff132ff04390a0505643f"></a><!-- doxytag: member="MGSphere::operator==" ref="abfe5b73d0efff132ff04390a0505643f" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#abfe5b73d0efff132ff04390a0505643f">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82e427f562abdde829369f2f212447e9"></a><!-- doxytag: member="MGSphere::operator&lt;" ref="a82e427f562abdde829369f2f212447e9" args="(const MGSphere &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01434dc2adb92702a73461905c3ea2ac"></a><!-- doxytag: member="MGSphere::operator&lt;" ref="a01434dc2adb92702a73461905c3ea2ac" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ce91bc503e30ca7bb2067d1ec44d65"></a><!-- doxytag: member="MGSphere::operator!=" ref="a78ce91bc503e30ca7bb2067d1ec44d65" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ab884498cc6cfc55c0b568ba2e4ffc1"></a><!-- doxytag: member="MGSphere::operator!=" ref="a1ab884498cc6cfc55c0b568ba2e4ffc1" args="(const MGSphere &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#af407306717d0a09a833618f1883a6205">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PD196=Spherical surface(parameterized).  <a href="#af407306717d0a09a833618f1883a6205"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a18ab0f5154704651b4fca1c17d7ff8dd">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug function デバッグ関数//////////// Output function.  <a href="#a18ab0f5154704651b4fca1c17d7ff8dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a6f1d65f6e9c72c2dc48dc7b5657c9c97">box_limitted</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Box that includes limitted Sphere by box.  <a href="#a6f1d65f6e9c72c2dc48dc7b5657c9c97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a252840bfe0588dbc050d7e48789434a8">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#a252840bfe0588dbc050d7e48789434a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#aabb3dd8e981aac5715acb3c4a89c3972">change_range</a> (int is_u, double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#aabb3dd8e981aac5715acb3c4a89c3972"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#afa2bf9455d696da90d888dd7449fcfe4">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value (u,v) of this surface from a point.  <a href="#afa2bf9455d696da90d888dd7449fcfe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a758a0d5caeead60599bdcedd20a408cf">closest_on_perimeter</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point on a perimeter of the surface.  <a href="#a758a0d5caeead60599bdcedd20a408cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a2b71fbb3471168b4e56862ce4fc05c6a">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#a2b71fbb3471168b4e56862ce4fc05c6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ae96e9b634d0de211a1a7355d35ab719c">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#ae96e9b634d0de211a1a7355d35ab719c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a930d3ff1ae256984f22efcb9513f6947"></a><!-- doxytag: member="MGSphere::degenerate_at_v0" ref="a930d3ff1ae256984f22efcb9513f6947" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a930d3ff1ae256984f22efcb9513f6947">degenerate_at_v0</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ask if this sphere has the degenerate point at v=min. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e52ff545326a61b585a49e935cebb79"></a><!-- doxytag: member="MGSphere::degenerate_at_v1" ref="a9e52ff545326a61b585a49e935cebb79" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a9e52ff545326a61b585a49e935cebb79">degenerate_at_v1</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ask if this sphere has the degenerate point at v=max. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a821c6cae89508e5854379ab43515e576">distance</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた点との距離を返却する。 Return the distace between Sphere and the point.  <a href="#a821c6cae89508e5854379ab43515e576"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af93938dda25ce67c4a21244937ce840d"></a><!-- doxytag: member="MGSphere::ellipseu" ref="af93938dda25ce67c4a21244937ce840d" args="() const " -->
const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#af93938dda25ce67c4a21244937ce840d">ellipseu</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the constituent ellipses of the Sphere. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cb623e188e503831836e88cc08cbe9e"></a><!-- doxytag: member="MGSphere::ellipsev" ref="a1cb623e188e503831836e88cc08cbe9e" args="() const " -->
const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ellipsev</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29633f29952a6be6c9bb99aa004d162"></a><!-- doxytag: member="MGSphere::ellipseu" ref="ac29633f29952a6be6c9bb99aa004d162" args="()" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ellipseu</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecd5632ebf3189db3c79e9a6866894e3"></a><!-- doxytag: member="MGSphere::ellipsev" ref="aecd5632ebf3189db3c79e9a6866894e3" args="()" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ellipsev</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a38667e0405d3b3d7cb50a2ddd8055779">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a38667e0405d3b3d7cb50a2ddd8055779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a1b5a6e9f2820a9db9da6a13dd113ab7f">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a1b5a6e9f2820a9db9da6a13dd113ab7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54dbe0b99acb0626b273c7e8452d260"></a><!-- doxytag: member="MGSphere::exchange_uv" ref="ab54dbe0b99acb0626b273c7e8452d260" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ab54dbe0b99acb0626b273c7e8452d260">exchange_uv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange parameter u and v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ab8145245e1ba16d48dcc611f9bebd8c7">extend</a> (int perimeter, double param, double length, double dk=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original Surface by extrapolating the specified perimeter.  <a href="#ab8145245e1ba16d48dcc611f9bebd8c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9db4adb35946c0abc0aece436d788691"></a><!-- doxytag: member="MGSphere::identify_type" ref="a9db4adb35946c0abc0aece436d788691" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a9db4adb35946c0abc0aece436d788691">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7396884ebbd18e28dab9c0b197bfe035"></a><!-- doxytag: member="MGSphere::in_range" ref="a7396884ebbd18e28dab9c0b197bfe035" args="(double u, double v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a7396884ebbd18e28dab9c0b197bfe035">in_range</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is in the range of the FSurface parameter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a8e877be2279d845cae44c398bdad798d">intersect_dnum_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess.  <a href="#a8e877be2279d845cae44c398bdad798d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb6deeaaa54d78295e62114aec508f3d"></a><!-- doxytag: member="MGSphere::intersect_dnum_v" ref="adb6deeaaa54d78295e62114aec508f3d" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersect_dnum_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a86c0fe6443a1ca1b22c39f20e6700c63">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Curve の交点を求める。 Compute intesection of Sphere and Curve.  <a href="#a86c0fe6443a1ca1b22c39f20e6700c63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afabd84eea789e937e1277ac48012575b"></a><!-- doxytag: member="MGSphere::isect" ref="afabd84eea789e937e1277ac48012575b" args="(const MGStraight &amp;line) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;line) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad008a66bb8735487d830c30a1e5841c1"></a><!-- doxytag: member="MGSphere::isect" ref="ad008a66bb8735487d830c30a1e5841c1" args="(const MGRLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9dc31b716248c547257850fd773704"></a><!-- doxytag: member="MGSphere::isect" ref="a7c9dc31b716248c547257850fd773704" args="(const MGEllipse &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c4fa0eef17326974937345f0a039284"></a><!-- doxytag: member="MGSphere::isect" ref="a7c4fa0eef17326974937345f0a039284" args="(const MGLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98b03af75fe1b036f9a5523328e53a33"></a><!-- doxytag: member="MGSphere::isect" ref="a98b03af75fe1b036f9a5523328e53a33" args="(const MGSurfCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba17c6bca4541000c4f126dc80f1c7ce"></a><!-- doxytag: member="MGSphere::isect" ref="aba17c6bca4541000c4f126dc80f1c7ce" args="(const MGBSumCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#adee115831d2ad538d8b15cc244e5db9a">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Surface の交線を求める。 Surface and Surface intersection.  <a href="#adee115831d2ad538d8b15cc244e5db9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27fa0d02e2d51d91325adf008cb77f5"></a><!-- doxytag: member="MGSphere::isect" ref="ae27fa0d02e2d51d91325adf008cb77f5" args="(const MGPlane &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6f22c3249d59c766f826ded09b6ef06"></a><!-- doxytag: member="MGSphere::isect" ref="ae6f22c3249d59c766f826ded09b6ef06" args="(const MGSphere &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a673eaa4df1beeb46ffd5ccc1f865541a"></a><!-- doxytag: member="MGSphere::isect" ref="a673eaa4df1beeb46ffd5ccc1f865541a" args="(const MGCylinder &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26dfba60210d73d746fac5d6d3f445c6"></a><!-- doxytag: member="MGSphere::isect" ref="a26dfba60210d73d746fac5d6d3f445c6" args="(const MGSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36cf0154dd0b64f5c410dfaf53bbb172"></a><!-- doxytag: member="MGSphere::isect" ref="a36cf0154dd0b64f5c410dfaf53bbb172" args="(const MGRSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf73959513e6a11620a88055e1ac88e9"></a><!-- doxytag: member="MGSphere::isect" ref="abf73959513e6a11620a88055e1ac88e9" args="(const MGBSumSurf &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9b83189f01c29a58ff8503b1d7a59e0"></a><!-- doxytag: member="MGSphere::knot_u" ref="ad9b83189f01c29a58ff8503b1d7a59e0" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ad9b83189f01c29a58ff8503b1d7a59e0">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return knot value of (infinite-minus, infinite-plus). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e114b4e8fd06ed121ec3e4ede060f76"></a><!-- doxytag: member="MGSphere::knot_v" ref="a0e114b4e8fd06ed121ec3e4ede060f76" args="(size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a0e114b4e8fd06ed121ec3e4ede060f76">knot_v</a> (size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7159d36990d6d7b6c1dd3b7218bd5602"></a><!-- doxytag: member="MGSphere::knot_vector_u" ref="a7159d36990d6d7b6c1dd3b7218bd5602" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a7159d36990d6d7b6c1dd3b7218bd5602">knot_vector_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4703b77d26823cc6c8905364d215e276"></a><!-- doxytag: member="MGSphere::knot_vector_u" ref="a4703b77d26823cc6c8905364d215e276" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7add56eb2a7c13ab457a673beb5a9f2c"></a><!-- doxytag: member="MGSphere::knot_vector_v" ref="a7add56eb2a7c13ab457a673beb5a9f2c" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a7add56eb2a7c13ab457a673beb5a9f2c">knot_vector_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ac3bdd509c5a31310b558d7dfde6af"></a><!-- doxytag: member="MGSphere::knot_vector_v" ref="a91ac3bdd509c5a31310b558d7dfde6af" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a631b5b7772979e08f936e42d2f9d3bc1">M</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the three axises of the sphere.  <a href="#a631b5b7772979e08f936e42d2f9d3bc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f8c04bdd1d5eff01f56da5cc0f1802d"></a><!-- doxytag: member="MGSphere::N" ref="a1f8c04bdd1d5eff01f56da5cc0f1802d" args="() const " -->
const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>N</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f809a41a2d372d5c5ee40129a9a403"></a><!-- doxytag: member="MGSphere::B" ref="a94f809a41a2d372d5c5ee40129a9a403" args="() const " -->
const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>B</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af40c9d65e2c8a68ab464151baa2ace9c"></a><!-- doxytag: member="MGSphere::C" ref="af40c9d65e2c8a68ab464151baa2ace9c" args="() const " -->
const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>C</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#af68a83dfc72a9ae220528eeafe75472d">negate</a> (int is_u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">柱面を反転する。ノーマルを逆方向にする。 Negate the normal of the Sphere.  <a href="#af68a83dfc72a9ae220528eeafe75472d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a9f99e9945051e9d47c032234cc6b4259">negate_param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int is_u=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate along u-direction if is_u is ture,.  <a href="#a9f99e9945051e9d47c032234cc6b4259"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#af86134bda185afd3da8e1c9be506b2d1">offset_c1</a> (double ofs_value, int &amp;error) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。トレランスはline_zero()を使用している。 戻り値は、オフセット面のオートポインターが返却される。 Surface offset.  <a href="#af86134bda185afd3da8e1c9be506b2d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a90a678f3eab870fd5d9ce67da2ce48d7">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;puv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定点が面上にあるか調べる。（面上ならばtrue） Test if a point is on the Sphere.  <a href="#a90a678f3eab870fd5d9ce67da2ce48d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a91ed2857ac7d79ea1e56e813e2db1282">outgoing</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test if the surface normal is outgoing from the center or not.  <a href="#a91ed2857ac7d79ea1e56e813e2db1282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa01f22a8155f61f43401e18f936023fb"></a><!-- doxytag: member="MGSphere::param_error" ref="aa01f22a8155f61f43401e18f936023fb" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#aa01f22a8155f61f43401e18f936023fb">param_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter space error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc327cd710e60bea92472e1db5c86c47"></a><!-- doxytag: member="MGSphere::param_e_u" ref="acc327cd710e60bea92472e1db5c86c47" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#acc327cd710e60bea92472e1db5c86c47">param_e_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9addcab4b3b7e9cc6555cdec40aa1fb5"></a><!-- doxytag: member="MGSphere::param_e_v" ref="a9addcab4b3b7e9cc6555cdec40aa1fb5" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#aff650f278660186bc2ba84bc9c1fd845">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range of the Sphere(Infinite box).  <a href="#aff650f278660186bc2ba84bc9c1fd845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08f3edc7f0e4dc5144bd88be102e365c"></a><!-- doxytag: member="MGSphere::param_s_u" ref="a08f3edc7f0e4dc5144bd88be102e365c" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a08f3edc7f0e4dc5144bd88be102e365c">param_s_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4fe6488e5864252dae337dc96085947"></a><!-- doxytag: member="MGSphere::param_s_v" ref="ab4fe6488e5864252dae337dc96085947" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a8d150f3f3d1d375c9f74d573eacd0df3">parameter_curve</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter curve.  <a href="#a8d150f3f3d1d375c9f74d573eacd0df3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_sphere.html">MGSphere</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a8f095afc52d22271aa37d10d96a664ec">part</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;bx, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of the surface limitted by the parameter range bx.  <a href="#a8f095afc52d22271aa37d10d96a664ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a11d32da214e2c26d03cf9c654828fce0">perimeter_curve</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i must be &lt; <a class="el" href="class_m_g_sphere.html#a1d6c23b7f65a342a6be0f4b663efba77" title="Return how many perimeters this surface has.">perimeter_num()</a>.  <a href="#a11d32da214e2c26d03cf9c654828fce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d6c23b7f65a342a6be0f4b663efba77"></a><!-- doxytag: member="MGSphere::perimeter_num" ref="a1d6c23b7f65a342a6be0f4b663efba77" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a1d6c23b7f65a342a6be0f4b663efba77">perimeter_num</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many perimeters this surface has. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ae27787efac00f3e2b7d3de1ceaa55f63">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, const <a class="el" href="class_m_g_position.html">MGPosition</a> *uvguess=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた点にもっとも近い面上の点を返却する。パラメ ータ値も返却する。 Return the nearest point of the Sphere from P.  <a href="#ae27787efac00f3e2b7d3de1ceaa55f63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a67aec64f8ad44dc182da791208bd7534">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all(actually at most two) foots of perpendicular straight lines from P.  <a href="#a67aec64f8ad44dc182da791208bd7534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bec2f097402a3097c208c45f9d22129"></a><!-- doxytag: member="MGSphere::radius" ref="a7bec2f097402a3097c208c45f9d22129" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a7bec2f097402a3097c208c45f9d22129">radius</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the radius of the sphere. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ac531ee66ce206379acf8754492413d66">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力パラメータをパラメータ範囲でまるめて返却する。 Round the input uv into parameter range of the Sphere, return the same value as input.  <a href="#ac531ee66ce206379acf8754492413d66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c2563dc34b9abac05e8043d6d9f922d"></a><!-- doxytag: member="MGSphere::sdim" ref="a5c2563dc34b9abac05e8043d6d9f922d" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a5c2563dc34b9abac05e8043d6d9f922d">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9e98b19c1ad9724fec701e9961708ee"></a><!-- doxytag: member="MGSphere::sphere" ref="ae9e98b19c1ad9724fec701e9961708ee" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ae9e98b19c1ad9724fec701e9961708ee">sphere</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return if this is sphere(i.e. the length of M, N, and B are all equal) or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c82989361fc5f2c24e2467e5b249c85"></a><!-- doxytag: member="MGSphere::sphere_center" ref="a4c82989361fc5f2c24e2467e5b249c85" args="() const " -->
const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a4c82989361fc5f2c24e2467e5b249c85">sphere_center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the center of the sphere. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a260c9261c71928f41c796782296a6684">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面タイプを返却する。 Return surface type of the Sphere.  <a href="#a260c9261c71928f41c796782296a6684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c84cad91b96178c4bc31714683dfa18"></a><!-- doxytag: member="MGSphere::whoami" ref="a4c84cad91b96178c4bc31714683dfa18" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#adb94c05a8a193bcd6285ca3ff0321a73">isectSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox=mgNULL_BOX) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Surface and a straight line.  <a href="#adb94c05a8a193bcd6285ca3ff0321a73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae76ef87c9341d851f3dd7b6936fe16e8"></a><!-- doxytag: member="MGSphere::ReadMembers" ref="ae76ef87c9341d851f3dd7b6936fe16e8" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ae76ef87c9341d851f3dd7b6936fe16e8">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac48f8036948532ab15320a8032c93605"></a><!-- doxytag: member="MGSphere::WriteMembers" ref="ac48f8036948532ab15320a8032c93605" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ac48f8036948532ab15320a8032c93605">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c13316bc0fc580681c39a2b4186f257"></a><!-- doxytag: member="MGSphere::operator+" ref="a7c13316bc0fc580681c39a2b4186f257" args="(const MGVector &amp;v, const MGSphere &amp;cyl)" -->
MGDECL friend <a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#a7c13316bc0fc580681c39a2b4186f257">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;cyl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">translation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad66695c60e9a206bb88cb7aae89b0fe2"></a><!-- doxytag: member="MGSphere::operator*" ref="ad66695c60e9a206bb88cb7aae89b0fe2" args="(double scale, const MGSphere &amp;cyl)" -->
MGDECL friend <a class="el" href="class_m_g_sphere.html">MGSphere</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_sphere.html#ad66695c60e9a206bb88cb7aae89b0fe2">operator*</a> (double scale, const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;cyl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling of the Sphere by a double. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_sphere.html" title="MGSphere is a Sphere in 3D space.">MGSphere</a> is a Sphere in 3D space. </p>
<p>Sphere f(u,v) is expressed by two ellipses EL1(m_ellipseu) and EL2(m_ellipsev) as: f(u,v) = C+(M*cos(u)+N*sin(u))*cos(v)+B*sin(v), or f(u,v) = C+EL1(u)*cos(v)+B*sin(v), where EL1=M*cos(u)+N*sin(u), and EL2=C+N*cos(v)+B*sin(v). Here M is the major axis of EL1, N is the minor axis of EL1, N is also the major axis of EL2, and B=(unit vector of (M*N))*(N.len()), which is the minor axis of EL2. (M,N,B) make a orthonormal system. v is the angle with M axis in the (B,M) plane, and u is the angle with M in the (M,N) plane. v=0 parameter line makes the ellipse C+EL1, and u=pai/2 parameter line makes the ellipse EL2. MGSphereクラスは３次元空間における球を表すクラスである。 </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a96319699e11f1605368f89ea9dbab39d"></a><!-- doxytag: member="MGSphere::MGSphere" ref="a96319699e11f1605368f89ea9dbab39d" args="(const MGPosition &amp;cntr, double radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSphere::MGSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a whole sphere from the center and the radius. </p>
<p>Sphere radius. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cntr</em>&nbsp;</td><td>Sphere center. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6073fcb45a71718b093c03ad309cf12f"></a><!-- doxytag: member="MGSphere::MGSphere" ref="a6073fcb45a71718b093c03ad309cf12f" args="(const MGPosition &amp;cntr, double radius, const MGUnit_vector &amp;B, const MGVector &amp;M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSphere::MGSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a whole sphere from the center and the radius. </p>
<p>Let <a class="el" href="class_m_g_unit__vector.html" title="Define a unit vector, is a MGVector.">MGUnit_vector</a> N(B*M), M2(N*B). Then (M2,N,B) makes a orthonormal system, and this sphere is parameterized as: F(u,v)=cntr+radis*cos(v)(M*cos(u)+N*sin(u))+radis*sin(v)*B. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cntr</em>&nbsp;</td><td>Sphere center. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Sphere radius. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>axis </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>reference direciotn that is approximately perpendiculat to B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebdadfc3eb1fe1754453c849e1395560"></a><!-- doxytag: member="MGSphere::MGSphere" ref="aebdadfc3eb1fe1754453c849e1395560" args="(size_t dim, const MGSphere &amp;cyl, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSphere::MGSphere </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cyl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Sphere by changing this space dimension or ordering the coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cyl</em>&nbsp;</td><td>Original Sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new Surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of original Surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a099636c29a82122b98e6644ce5c75da0"></a><!-- doxytag: member="MGSphere::MGSphere" ref="a099636c29a82122b98e6644ce5c75da0" args="(const MGEllipse &amp;ellipse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSphere::MGSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ellipse</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whole sphere(u parameter range is from 0 to 2 pai) around minor axis of the input ellipse. </p>
<p>The parameter range of the ellipse must be within the range from -pai/2 to pai/2, and the range becomes the v parameter range of the sphere. The input ellipse makes u=const(u=pai/2) v-paramarter line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ellipse</em>&nbsp;</td><td>ellispe of the Sphere </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6e9ea26a662ea95181ee40c0c39c266"></a><!-- doxytag: member="MGSphere::MGSphere" ref="af6e9ea26a662ea95181ee40c0c39c266" args="(const MGEllipse &amp;ellipse, MGInterval urange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSphere::MGSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ellipse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_interval.html">MGInterval</a>&nbsp;</td>
          <td class="paramname"> <em>urange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sphere(u parameter range is urange) around minor axis of the input ellipse. </p>
<p>The parameter range of the ellipse must be in the range from -pai/2 to pai/2, and the range becomes the v parameter range of the sphere. The input ellipse makes u=const(u=pai/2) v-paramarter line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ellipse</em>&nbsp;</td><td>ellispe of the Sphere </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>urange</em>&nbsp;</td><td>parameter range along v in radian. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6f1d65f6e9c72c2dc48dc7b5657c9c97"></a><!-- doxytag: member="MGSphere::box_limitted" ref="a6f1d65f6e9c72c2dc48dc7b5657c9c97" args="(const MGBox &amp;uvrange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGSphere::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Box that includes limitted Sphere by box. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvrange</em>&nbsp;</td><td>Parameter Range of the surface. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a9182844563218c392ef526d29e5bfb7e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a252840bfe0588dbc050d7e48789434a8"></a><!-- doxytag: member="MGSphere::change_dimension" ref="a252840bfe0588dbc050d7e48789434a8" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>&amp; MGSphere::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ab37b86c29caed93258a98d7e70459d4e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aabb3dd8e981aac5715acb3c4a89c3972"></a><!-- doxytag: member="MGSphere::change_range" ref="aabb3dd8e981aac5715acb3c4a89c3972" args="(int is_u, double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>&amp; MGSphere::change_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, (t1,t2) are u-value. if not, v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a1d4365d58c465f916b2fb038ef896b2d">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a2b71fbb3471168b4e56862ce4fc05c6a"></a><!-- doxytag: member="MGSphere::clone" ref="a2b71fbb3471168b4e56862ce4fc05c6a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>* MGSphere::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a55ce6580673b46480f6ae5a8d2117c17">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="afa2bf9455d696da90d888dd7449fcfe4"></a><!-- doxytag: member="MGSphere::closest" ref="afa2bf9455d696da90d888dd7449fcfe4" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSphere::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value (u,v) of this surface from a point. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a968d690be2c0009a282ac74085b95422">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a758a0d5caeead60599bdcedd20a408cf"></a><!-- doxytag: member="MGSphere::closest_on_perimeter" ref="a758a0d5caeead60599bdcedd20a408cf" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSphere::closest_on_perimeter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point on a perimeter of the surface. </p>
<p>The point is returned as the parameter value (u,v) of this surface. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a79b233ce393381acf1017555e203971c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae96e9b634d0de211a1a7355d35ab719c"></a><!-- doxytag: member="MGSphere::copy_change_dimension" ref="ae96e9b634d0de211a1a7355d35ab719c" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>* MGSphere::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a0cf87d2f42a919c9f5bc44cc406ea0fd">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a821c6cae89508e5854379ab43515e576"></a><!-- doxytag: member="MGSphere::distance" ref="a821c6cae89508e5854379ab43515e576" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGSphere::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた点との距離を返却する。 Return the distace between Sphere and the point. </p>

</div>
</div>
<a class="anchor" id="a38667e0405d3b3d7cb50a2ddd8055779"></a><!-- doxytag: member="MGSphere::eval" ref="a38667e0405d3b3d7cb50a2ddd8055779" args="(double u, double v, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGSphere::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1b5a6e9f2820a9db9da6a13dd113ab7f"></a><!-- doxytag: member="MGSphere::eval" ref="a1b5a6e9f2820a9db9da6a13dd113ab7f" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGSphere::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab8145245e1ba16d48dcc611f9bebd8c7"></a><!-- doxytag: member="MGSphere::extend" ref="ab8145245e1ba16d48dcc611f9bebd8c7" args="(int perimeter, double param, double length, double dk=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>&amp; MGSphere::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>perimeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original Surface by extrapolating the specified perimeter. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. The extrapolation is done so that extrapolating length is "length" at the position of the parameter value "param" of the perimeter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perimeter</em>&nbsp;</td><td>perimeter number of the Surface. =0:v=min, =1:u=max, =2:v=max, =3:u=min. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of above perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend at the parameter param of the perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at extrapolation start point. When dk=0, curvature keeps same, i.e. dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point. (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ab52fd64da1afa26965f381962edf0f75">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8e877be2279d845cae44c398bdad798d"></a><!-- doxytag: member="MGSphere::intersect_dnum_u" ref="a8e877be2279d845cae44c398bdad798d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGSphere::intersect_dnum_u </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#adeee48dc794aa404bce3dc81b9679cfb">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a86c0fe6443a1ca1b22c39f20e6700c63"></a><!-- doxytag: member="MGSphere::isect" ref="a86c0fe6443a1ca1b22c39f20e6700c63" args="(const MGCurve &amp;curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGSphere::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Curve の交点を求める。 Compute intesection of Sphere and Curve. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a97fecbc27841cd336e1b26d2e64c2bf0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="adee115831d2ad538d8b15cc244e5db9a"></a><!-- doxytag: member="MGSphere::isect" ref="adee115831d2ad538d8b15cc244e5db9a" args="(const MGSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGSphere::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Surface の交線を求める。 Surface and Surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a3d84645dc04d80bb2ff1df214f3a3b9b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="adb94c05a8a193bcd6285ca3ff0321a73"></a><!-- doxytag: member="MGSphere::isectSl" ref="adb94c05a8a193bcd6285ca3ff0321a73" args="(const MGStraight &amp;sl, const MGBox &amp;uvbox=mgNULL_BOX) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGSphere::isectSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em> = <code>mgNULL_BOX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Surface and a straight line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>indicates if this surface is restrictied to the parameter range of uvbox. If uvbox.is_null(), no restriction. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aa0bd5720dfdbf979fa89054b785014ce">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a631b5b7772979e08f936e42d2f9d3bc1"></a><!-- doxytag: member="MGSphere::M" ref="a631b5b7772979e08f936e42d2f9d3bc1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGSphere::M </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the three axises of the sphere. </p>
<p><a class="el" href="class_m_g_sphere.html" title="MGSphere is a Sphere in 3D space.">MGSphere</a> is a Sphere in 3D space. Sphere f(u,v) is expressed by two ellipses EL1(m_ellipseu) and EL2(m_ellipsev) as: f(u,v) = C+(M*cos(u)+N*sin(u))*cos(v)+B*sin(v), or f(u,v) = C+EL1(u)*cos(v)+B*sin(v), where EL1=M*cos(u)+N*sin(u), and EL2=C+N*cos(v)+B*sin(v). Here M is the major axis of EL1, N is the minor axis of EL1, N is also the major axis of EL2, and B=(unit vector of (M*N))*(N.len()), which is the minor axis of EL2. (M,N,B) make a orthonormal system. v is the angle with M axis in the (B,M) plane, and u is the angle with M in the (M,N) plane. v=0 parameter line makes the ellipse C+EL1, and u=pai/2 parameter line makes the ellipse EL2. </p>

</div>
</div>
<a class="anchor" id="af68a83dfc72a9ae220528eeafe75472d"></a><!-- doxytag: member="MGSphere::negate" ref="af68a83dfc72a9ae220528eeafe75472d" args="(int is_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSphere::negate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>柱面を反転する。ノーマルを逆方向にする。 Negate the normal of the Sphere. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a5f1ebb47122de32a0f5702f160a51d2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9f99e9945051e9d47c032234cc6b4259"></a><!-- doxytag: member="MGSphere::negate_param" ref="a9f99e9945051e9d47c032234cc6b4259" args="(const MGPosition &amp;uv, int is_u=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSphere::negate_param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate along u-direction if is_u is ture,. </p>
<p>else along v-direction. Obtain parameter value if this surface is negated by "negate()". Negate along u-direction if is_u is ture, else along v-direction. </p>

</div>
</div>
<a class="anchor" id="af86134bda185afd3da8e1c9be506b2d1"></a><!-- doxytag: member="MGSphere::offset_c1" ref="af86134bda185afd3da8e1c9be506b2d1" args="(double ofs_value, int &amp;error) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGSphere::offset_c1 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。トレランスはline_zero()を使用している。 戻り値は、オフセット面のオートポインターが返却される。 Surface offset. </p>
<p>positive offset value is offset normal direction. the radius of curvature must be larger than offset value. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード 0:成功 -1:面におれがある -2:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ae2dab410e24064b16318be2f56d2246c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a90a678f3eab870fd5d9ce67da2ce48d7"></a><!-- doxytag: member="MGSphere::on" ref="a90a678f3eab870fd5d9ce67da2ce48d7" args="(const MGPosition &amp;point, MGPosition &amp;puv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGSphere::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>puv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定点が面上にあるか調べる。（面上ならばtrue） Test if a point is on the Sphere. </p>
<p>If on the Sphere, return true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>A point to test 指定点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>puv</em>&nbsp;</td><td>Parameter value of the Sphere will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a409507f5dcc86cab92e3448529a94196">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a84a52286c4ca40ad444a09e2937271a8"></a><!-- doxytag: member="MGSphere::operator*" ref="a84a52286c4ca40ad444a09e2937271a8" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a> MGSphere::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>柱面のスケーリングを行い，柱面を作成する。 Scaling of the Sphere by a double. </p>

</div>
</div>
<a class="anchor" id="a8ed91f4d707eecb608ab788bc3550aaf"></a><!-- doxytag: member="MGSphere::operator=" ref="a8ed91f4d707eecb608ab788bc3550aaf" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>&amp; MGSphere::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor//////////////// ‾MGSphere();. </p>
<p>Assignment. When the leaf object of this and srf2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a18ab0f5154704651b4fca1c17d7ff8dd"></a><!-- doxytag: member="MGSphere::out" ref="a18ab0f5154704651b4fca1c17d7ff8dd" args="(std::ostream &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; MGSphere::out </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug function デバッグ関数//////////// Output function. </p>
<p>Output to ostream メンバデータを標準出力に出力する。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a484f8cc1c250c5b52fb960b1fda5bb54">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="af407306717d0a09a833618f1883a6205"></a><!-- doxytag: member="MGSphere::out_to_IGES" ref="af407306717d0a09a833618f1883a6205" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSphere::out_to_IGES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>igesfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>SubordinateEntitySwitch</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PD196=Spherical surface(parameterized). </p>
<p>Function's return value is the directory entry id created. </p>

</div>
</div>
<a class="anchor" id="a91ed2857ac7d79ea1e56e813e2db1282"></a><!-- doxytag: member="MGSphere::outgoing" ref="a91ed2857ac7d79ea1e56e813e2db1282" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGSphere::outgoing </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if the surface normal is outgoing from the center or not. </p>
<p>If the sphere normao is outgoing, retrun true. </p>

</div>
</div>
<a class="anchor" id="aff650f278660186bc2ba84bc9c1fd845"></a><!-- doxytag: member="MGSphere::param_range" ref="aff650f278660186bc2ba84bc9c1fd845" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGSphere::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range of the Sphere(Infinite box). </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8d150f3f3d1d375c9f74d573eacd0df3"></a><!-- doxytag: member="MGSphere::parameter_curve" ref="a8d150f3f3d1d375c9f74d573eacd0df3" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSphere::parameter_curve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter curve. </p>
<p>Returned is newed area pointer, and must be freed by delete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a470c01ec42c6e71b6c34601cc558ec96">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8f095afc52d22271aa37d10d96a664ec"></a><!-- doxytag: member="MGSphere::part" ref="a8f095afc52d22271aa37d10d96a664ec" args="(const MGBox &amp;bx, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_sphere.html">MGSphere</a>* MGSphere::part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of the surface limitted by the parameter range bx. </p>
<p>bx(0) is the parameter (us,ue) and bx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a7a924b141ca6ea037545953c5e00d682">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a11d32da214e2c26d03cf9c654828fce0"></a><!-- doxytag: member="MGSphere::perimeter_curve" ref="a11d32da214e2c26d03cf9c654828fce0" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSphere::perimeter_curve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>i must be &lt; <a class="el" href="class_m_g_sphere.html#a1d6c23b7f65a342a6be0f4b663efba77" title="Return how many perimeters this surface has.">perimeter_num()</a>. </p>
<p>When <a class="el" href="class_m_g_sphere.html#a1d6c23b7f65a342a6be0f4b663efba77" title="Return how many perimeters this surface has.">perimeter_num()</a>==0, this function is undefined. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a57c8bffdb617cf4ff7c654e2b080200c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae27787efac00f3e2b7d3de1ceaa55f63"></a><!-- doxytag: member="MGSphere::perp_point" ref="ae27787efac00f3e2b7d3de1ceaa55f63" args="(const MGPosition &amp;P, MGPosition &amp;uv, const MGPosition *uvguess=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSphere::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td>
          <td class="paramname"> <em>uvguess</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた点にもっとも近い面上の点を返却する。パラメ ータ値も返却する。 Return the nearest point of the Sphere from P. </p>
<p>Function's return value is always true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>与えられた点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the Sphere will be output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ac94884f1674a06f476c417511a93eb2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a67aec64f8ad44dc182da791208bd7534"></a><!-- doxytag: member="MGSphere::perps" ref="a67aec64f8ad44dc182da791208bd7534" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGSphere::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return all(actually at most two) foots of perpendicular straight lines from P. </p>
<p>When two points are output, the nearer point will be output first in <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point of a space(指定点) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aed36001c59550de9c2054564844c638f">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ac531ee66ce206379acf8754492413d66"></a><!-- doxytag: member="MGSphere::range" ref="ac531ee66ce206379acf8754492413d66" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSphere::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力パラメータをパラメータ範囲でまるめて返却する。 Round the input uv into parameter range of the Sphere, return the same value as input. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8966c7e15642175de66afee13234dfc5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a260c9261c71928f41c796782296a6684"></a><!-- doxytag: member="MGSphere::type" ref="a260c9261c71928f41c796782296a6684" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a> MGSphere::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面タイプを返却する。 Return surface type of the Sphere. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a83ad0b3f99b05d775a1d4d7352baf9d0">MGSurface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Sphere.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:28 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

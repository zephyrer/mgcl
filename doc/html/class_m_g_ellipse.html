<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGEllipse Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGEllipse Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGEllipse" --><!-- doxytag: inherits="MGCurve" -->
<p><a class="el" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D.">MGEllipse</a> is a class to define an ellipse of 2D or 3D.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Ellipse.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGEllipse:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_ellipse__inherit__graph.png" border="0" usemap="#_m_g_ellipse_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_ellipse_inherit__map" id="_m_g_ellipse_inherit__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="21,315,96,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGEllipse:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_ellipse__coll__graph.png" border="0" usemap="#_m_g_ellipse_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_ellipse_coll__map" id="_m_g_ellipse_coll__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="204,600,279,629"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="192,501,291,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/><area shape="rect" id="node26" href="class_m_g_unit__vector.html" title="Define a unit vector, is a MGVector." alt="" coords="380,600,487,629"/><area shape="rect" id="node28" href="class_m_g_vector.html" title="Vector of a general n space dimension." alt="" coords="393,501,473,531"/><area shape="rect" id="node30" href="class_m_g_position.html" title="Represent a positional data." alt="" coords="511,600,601,629"/><area shape="rect" id="node34" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="625,600,732,629"/><area shape="rect" id="node36" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="628,501,729,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_ellipse-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dfe059e199ce729b4f640eda61fd9ae"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a3dfe059e199ce729b4f640eda61fd9ae" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a3dfe059e199ce729b4f640eda61fd9ae">MGEllipse</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor(初期化なしで楕円を生成する). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a5fd279ed8c3aae278140272d9888136a">MGEllipse</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;el, bool to_radian=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a5fd279ed8c3aae278140272d9888136a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ac8e51d601c8ec59a3d6959641fda99fe">MGEllipse</a> (size_t sdim, const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;ellip, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change space dimension and ordering of coordinates.  <a href="#ac8e51d601c8ec59a3d6959641fda99fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a1449e8b130a641a0fbe2125038de9018">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;major_axis, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;minor_axis, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;prange)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ellipase from center, major axis vector, minor axis vector, and the parameter range.  <a href="#a1449e8b130a641a0fbe2125038de9018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#abbecd9c2e2eb4e309fcf4e1f49525a32">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center, double r, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;normal=mgZ_UVEC)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A whole circle form center, radius, and the normal.  <a href="#abbecd9c2e2eb4e309fcf4e1f49525a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aedaea0f99b337729d4f1d36aee6cf69e">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;spoint, double d=<a class="el" href="group___b_a_s_e.html#ga2ab7c015a009fa7d1fc3386171e60f08">mgDBLPAI</a>, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v=mgZ_UVEC)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arc from center, start point, angle d, and the normal.  <a href="#aedaea0f99b337729d4f1d36aee6cf69e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#adbbf9c0e20b4617ef3a868f112850d43">MGEllipse</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;corner1, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;corner2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">矩形に内接する楕円を生成する plane 楕円が乗る平面に平行な平面 corner1 楕円が内接する矩形のコーナーの座標 corner2 corner1 の対頂角の座標のヒント  <a href="#adbbf9c0e20b4617ef3a868f112850d43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a2aed3086ad065a76744b53dfec577e47">MGEllipse</a> (double r, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;N, bool whole_circle=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arc of radius r whose start point is start, and the end point is end.  <a href="#a2aed3086ad065a76744b53dfec577e47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a6a3643a3babfdce095db481400adea1e">MGEllipse</a> (double r, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;reference, bool whole_circle=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arc of radius r whose start point is start, and the end point is end.  <a href="#a6a3643a3babfdce095db481400adea1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a379849051861672ae9008e8f800d0b99">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V2, double d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arc of the circle that osculates to two straight lines that passes point P and whose directional vectors are V1 and V2.  <a href="#a379849051861672ae9008e8f800d0b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ae6efe0bdc67c0d67886909a1273f0335">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;through, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, bool whole_circle=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arc from start point, through point, and end point.  <a href="#ae6efe0bdc67c0d67886909a1273f0335"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a16ac01b1c0d18d74d421d87b08944d89">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;N, bool whole_circle=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arc from center, start point, end point.  <a href="#a16ac01b1c0d18d74d421d87b08944d89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ae0844c8a9e451ffd5734f96996e2d5af">MGEllipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;dir_s, bool whole_circle=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct the arc whose start point is start, whose end point is end, and whose tangent at the start point is dir_s.  <a href="#ae0844c8a9e451ffd5734f96996e2d5af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a32d75c1befaf3c3680fc71a1f38a31a6">MGEllipse</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, double dRadius, double &amp;t1, double &amp;t2, int &amp;rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">目的： 基本線２本と半径からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線は同一平面上にあること 戻り値： 0: 正常終了 -1: 基本線の曲率半径より半径Rが大きい -2: 基本線同士の交点が求まらない Start point of the generated ellipse is either t1 side or t2, which depends on normal direction.  <a href="#a32d75c1befaf3c3680fc71a1f38a31a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a2d7c59cfbedab4aaf747b6640d305487">MGEllipse</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, double t1, double &amp;t2, int &amp;rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">目的： 基本線２本とＲ止まり点からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線は同一平面上にあること 戻り値： 0: 正常終了 -1: 入力値が不正 -2: crv2上の接点が求まらない(交点なし) -3: crv2上の接点が求まらない(収束しない) Start point of the generated ellipse is either t1 side or t2, which depends on normal direction.  <a href="#a2d7c59cfbedab4aaf747b6640d305487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a725b00a7a7d0fbde1d7fac078e3c94b1">MGEllipse</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv3, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, double &amp;t1, double &amp;t2, double &amp;t3, int &amp;rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">目的： 基本線３本からコーナーＲを作成する crv1, crv2, crv3がそれぞれ始点、通過点、終点となるようにする。 初期パラメータはコーナーＲが接する近辺に設定し、基本線は同一平面上にあること 戻り値： 0: 正常終了 -1: 連立方程式が解けなかった -2: 収束しなかった(パラメータ範囲を超えてしまった) -3: 収束しなかった(無限ループにおちいった)  <a href="#a725b00a7a7d0fbde1d7fac078e3c94b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ac0a62b9b7f876f8270eef4e3f8c73adb">MGEllipse</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;pos, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, double dRadius, double &amp;dParam, int &amp;rc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">目的： 基本線と円弧端点と半径からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線と円弧端点は同一平面上にあること 戻り値： 0: 正常終了 -1: 入力値が不正 -2: 半径値が小さすぎる -3: 半径値が大きすぎる -4: 基本線をオフセットしたカーブと円弧端点から作成した円の交点が求まらなかった  <a href="#ac0a62b9b7f876f8270eef4e3f8c73adb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a0b9b092c22652d237ea1a3e37e0ef392">MGEllipse</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P2, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">目的： 基本線と基本線上Ｒ止まりと円弧端点からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線と円弧端点は同一平面上にあること  <a href="#a0b9b092c22652d237ea1a3e37e0ef392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ae26447db9a1b9a1e8b01debd0fd85b8a">MGEllipse</a> (const <a class="el" href="class_m_g_iges_directory_entry.html">MGIgesDirectoryEntry</a> &amp;de)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion constructor from <a class="el" href="class_m_g_iges_directory_entry.html" title="MGIgesDirectoryEntry describes a directory entry section of an IGES file.">MGIgesDirectoryEntry</a> object.  <a href="#ae26447db9a1b9a1e8b01debd0fd85b8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3746890aba289e54e7d1a123d5526cb0"></a><!-- doxytag: member="MGEllipse::‾MGEllipse" ref="a3746890aba289e54e7d1a123d5526cb0" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGEllipse</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#adc7f18f46eed7849cce0a27a73e95193">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#adc7f18f46eed7849cce0a27a73e95193"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f7ccf9a623c3db5a480b8c04887d006"></a><!-- doxytag: member="MGEllipse::operator=" ref="a9f7ccf9a623c3db5a480b8c04887d006" args="(const MGEllipse &amp;el2)" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;el2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e2356ba26bf432b29a3d40a3c8e6525"></a><!-- doxytag: member="MGEllipse::operator+" ref="a3e2356ba26bf432b29a3d40a3c8e6525" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a3e2356ba26bf432b29a3d40a3c8e6525">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation object construction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa9b3cd800240566f04906326fe44067"></a><!-- doxytag: member="MGEllipse::operator&#45;" ref="afa9b3cd800240566f04906326fe44067" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b66d0a52bf74e9e690e6acaf32cf13d"></a><!-- doxytag: member="MGEllipse::operator*" ref="a4b66d0a52bf74e9e690e6acaf32cf13d" args="(double scale) const " -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afde59b339bb7edb1fa68df714d90f428"></a><!-- doxytag: member="MGEllipse::operator*" ref="afde59b339bb7edb1fa68df714d90f428" args="(const MGMatrix &amp;) const " -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcfa601944d3c8461cb5330272e4be26"></a><!-- doxytag: member="MGEllipse::operator*" ref="abcfa601944d3c8461cb5330272e4be26" args="(const MGTransf &amp;) const " -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e91b4a5713e7b890e58ec91ca36ec30"></a><!-- doxytag: member="MGEllipse::operator+=" ref="a6e91b4a5713e7b890e58ec91ca36ec30" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a6e91b4a5713e7b890e58ec91ca36ec30">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73cdca6282744ae574e6c31ce7bae23c"></a><!-- doxytag: member="MGEllipse::operator&#45;=" ref="a73cdca6282744ae574e6c31ce7bae23c" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a49a75cdf2491097e562de76ac2ae98"></a><!-- doxytag: member="MGEllipse::operator*=" ref="a8a49a75cdf2491097e562de76ac2ae98" args="(double scale)" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5784dcb6f713f425b0c2940dce9bb66b"></a><!-- doxytag: member="MGEllipse::operator*=" ref="a5784dcb6f713f425b0c2940dce9bb66b" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ff23d6e1916997c0805acbb34de7389"></a><!-- doxytag: member="MGEllipse::operator*=" ref="a0ff23d6e1916997c0805acbb34de7389" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d12ab04eaedadcadaedd4159b050e03"></a><!-- doxytag: member="MGEllipse::operator==" ref="a8d12ab04eaedadcadaedd4159b050e03" args="(const MGEllipse &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a8d12ab04eaedadcadaedd4159b050e03">operator==</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45d6b2b233bcdcbdd74805096d465e94"></a><!-- doxytag: member="MGEllipse::operator==" ref="a45d6b2b233bcdcbdd74805096d465e94" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a45d6b2b233bcdcbdd74805096d465e94">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a873ce8fa460514d383904cc2e3024b80"></a><!-- doxytag: member="MGEllipse::operator&lt;" ref="a873ce8fa460514d383904cc2e3024b80" args="(const MGEllipse &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a528c72b1d20f88f5222dbd46ade09221"></a><!-- doxytag: member="MGEllipse::operator&lt;" ref="a528c72b1d20f88f5222dbd46ade09221" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74ecb3973ea80e401fb1f9f54f47f951"></a><!-- doxytag: member="MGEllipse::bdim" ref="a74ecb3973ea80e401fb1f9f54f47f951" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a74ecb3973ea80e401fb1f9f54f47f951">bdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a0f6dd60b74f5bc68fd865dc021ffb5b9">box_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum box that includes the curve of parameter interval.  <a href="#a0f6dd60b74f5bc68fd865dc021ffb5b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaddc892475ddc7cf5f49ac6dced87757"></a><!-- doxytag: member="MGEllipse::center" ref="aaddc892475ddc7cf5f49ac6dced87757" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aaddc892475ddc7cf5f49ac6dced87757">center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the center of the ellipse:楕円の中心座標を返却する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a7433c299d5ef3460d0b78ea1e7091982">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#a7433c299d5ef3460d0b78ea1e7091982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79a30116651afa6273254c1a35d7a75e"></a><!-- doxytag: member="MGEllipse::change_param_to_radian" ref="a79a30116651afa6273254c1a35d7a75e" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a79a30116651afa6273254c1a35d7a75e">change_param_to_radian</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chane the parameter range of this ellipse to radian. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a0f3cbc528d7b7b7c9b22e731744ef021">change_range</a> (double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a0f3cbc528d7b7b7c9b22e731744ef021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aa41287c856454b1df3d2183a2267ade4">circle</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if true circle.  <a href="#aa41287c856454b1df3d2183a2267ade4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a15506aae416fc587969212c88cb54908">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area.  <a href="#a15506aae416fc587969212c88cb54908"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a085a7533eb1b9385625b0a98d1ab8af7">copy_as_nurbs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy as a newed curve.  <a href="#a085a7533eb1b9385625b0a98d1ab8af7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a8cf5668afef437ce38ade622359e02b6">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by changing the original object's space dimension.  <a href="#a8cf5668afef437ce38ade622359e02b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#acf8250c17c44468121fc8f4e29e09353">coordinate_exchange</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange ordering of the coordinates.  <a href="#acf8250c17c44468121fc8f4e29e09353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a7ce7503763c81a68c9a6ee7043476a5d">create_ellipse</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;F0, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;F1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">焦点と通過点を与えて楕円を生成する F0 焦点 F1 焦点 P 楕円上の点  <a href="#a7ce7503763c81a68c9a6ee7043476a5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a629c3f6cb9490d64faa2d877512f1208">curvilinear_integral</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvilinear integral of the 1st two coordinates.  <a href="#a629c3f6cb9490d64faa2d877512f1208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a99b0bc2fe40e482a4fabcf17bccc533a">drawSE</a> (double span_length, double t0, double t1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From t1 to t2;.  <a href="#a99b0bc2fe40e482a4fabcf17bccc533a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4534b6b2a0661bdaed132624f5cb8e2d"></a><!-- doxytag: member="MGEllipse::ellipse_type" ref="a4534b6b2a0661bdaed132624f5cb8e2d" args="() const " -->
<a class="el" href="group___b_a_s_e.html#ga6f7735ca1f3d364446c616cf798409e2">MGELLIPSE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a4534b6b2a0661bdaed132624f5cb8e2d">ellipse_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ellipse type:楕円のタイプを返却する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#acac237a8d8c3a9ac258735cf238c4aa6">eval</a> (double, size_t nderiv=0, int left=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate n'th derivative data.  <a href="#acac237a8d8c3a9ac258735cf238c4aa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aae7796e15604cd3e777ca6be29935206">eval_deriv</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluatefirst derivative data.  <a href="#aae7796e15604cd3e777ca6be29935206"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a2f83fcc8c47bf772314c5c623d567bbc">eval_all</a> (double, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute position, 1st and 2nd derivatives.  <a href="#a2f83fcc8c47bf772314c5c623d567bbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aeb26eaac584837932c3d6d301a2b4a1d">eval_in_radian</a> (double t, size_t nderiv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate ellipse data.  <a href="#aeb26eaac584837932c3d6d301a2b4a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#abef59329d2ecac6a379108b47e794bfd">eval_in_degree</a> (double degree, size_t nderiv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate ellipse data.  <a href="#abef59329d2ecac6a379108b47e794bfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ac75699928ee734689e2a9fe28bbbc85f">eval_position</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute positional data.  <a href="#ac75699928ee734689e2a9fe28bbbc85f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a91b8d9443d9b514125755abdfde13ba4">extend</a> (double length, bool start=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate this curve by an (approximate) chord length.  <a href="#a91b8d9443d9b514125755abdfde13ba4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a796a9d3376d46b19a976fa5f29952b15"></a><!-- doxytag: member="MGEllipse::gp_to_radian" ref="a796a9d3376d46b19a976fa5f29952b15" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a796a9d3376d46b19a976fa5f29952b15">gp_to_radian</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the radian parameter of the general parameter t;. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a127b476e67ac2296edc7f1e0eda0c1f9"></a><!-- doxytag: member="MGEllipse::identify_type" ref="a127b476e67ac2296edc7f1e0eda0c1f9" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a127b476e67ac2296edc7f1e0eda0c1f9">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#adfafb35c501200a885f21cb2e1cc8c2d">in_RelativeRange_of_radian</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if angle t is in the parameter range.  <a href="#adfafb35c501200a885f21cb2e1cc8c2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56560f6010dbfb1913307f0bbe2894fb"></a><!-- doxytag: member="MGEllipse::intersect_dnum" ref="a56560f6010dbfb1913307f0bbe2894fb" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a56560f6010dbfb1913307f0bbe2894fb">intersect_dnum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide divide number of curve span for function intersect. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a5053c86a267104e02a93cee37b34b3bf">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of ellipse and curve.  <a href="#a5053c86a267104e02a93cee37b34b3bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bdf0ea430026dc8e7e6ce8d3ebdae56"></a><!-- doxytag: member="MGEllipse::isect" ref="a8bdf0ea430026dc8e7e6ce8d3ebdae56" args="(const MGStraight &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc48c42d358773e074df941fd807137"></a><!-- doxytag: member="MGEllipse::isect" ref="a5bc48c42d358773e074df941fd807137" args="(const MGEllipse &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73d6d0d5240aa5060abb8c80c61358a5"></a><!-- doxytag: member="MGEllipse::isect" ref="a73d6d0d5240aa5060abb8c80c61358a5" args="(const MGSurfCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4076d5715dcbdbe555737b7ea8230237"></a><!-- doxytag: member="MGEllipse::isect" ref="a4076d5715dcbdbe555737b7ea8230237" args="(const MGBSumCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a4ffbdf187decf0b4e49ad08004adf189">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Ellipse and Surface.  <a href="#a4ffbdf187decf0b4e49ad08004adf189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a123c85c74bdf888640aff82ffa707a36"></a><!-- doxytag: member="MGEllipse::isect" ref="a123c85c74bdf888640aff82ffa707a36" args="(const MGPlane &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa86b841d995cb2430c2fd8d9d610229d"></a><!-- doxytag: member="MGEllipse::isect" ref="aa86b841d995cb2430c2fd8d9d610229d" args="(const MGSphere &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e956dd07c779c90cb56b206c448632a"></a><!-- doxytag: member="MGEllipse::isect" ref="a7e956dd07c779c90cb56b206c448632a" args="(const MGCylinder &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedaec24e60a0a7f0aeb14dba366b1cfb"></a><!-- doxytag: member="MGEllipse::isect" ref="aedaec24e60a0a7f0aeb14dba366b1cfb" args="(const MGSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaf4b8278910e131b16e27f92644614c"></a><!-- doxytag: member="MGEllipse::isect" ref="aeaf4b8278910e131b16e27f92644614c" args="(const MGRSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aba82acf826993852bdde6c505cb0bd"></a><!-- doxytag: member="MGEllipse::isect" ref="a7aba82acf826993852bdde6c505cb0bd" args="(const MGBSumSurf &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a7f2ba248fb3216bb8422e7c819ffede9">is_linear</a> (<a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;straight) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is linear or not, that is, is straight or not.  <a href="#a7f2ba248fb3216bb8422e7c819ffede9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a62df31d96af72c2333bb60f9c8bb6d69">is_planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is planar or not.  <a href="#a62df31d96af72c2333bb60f9c8bb6d69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a37060c40dd4a5bc09142673bddfb094f">is_whole_ellipse</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this ellipse is whole ellipse or not.  <a href="#a37060c40dd4a5bc09142673bddfb094f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a321adaac31b4c61b57da1e132fa288b5">knot</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot.  <a href="#a321adaac31b4c61b57da1e132fa288b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2fc787a162091f4554c69444ca79efa"></a><!-- doxytag: member="MGEllipse::knot_vector" ref="aa2fc787a162091f4554c69444ca79efa" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aa2fc787a162091f4554c69444ca79efa">knot_vector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector of the curve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a590506fce597a2c2a1903133efc9f4f6"></a><!-- doxytag: member="MGEllipse::knot_vector" ref="a590506fce597a2c2a1903133efc9f4f6" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a590506fce597a2c2a1903133efc9f4f6">knot_vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector of the curve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ab4436d6be20ada9efd6a93d5799418d7">limit</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update this by limiting the parameter range of the curve.  <a href="#ab4436d6be20ada9efd6a93d5799418d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6a2353313f708f2cc0c0bfd24e00b2d"></a><!-- doxytag: member="MGEllipse::negate" ref="ab6a2353313f708f2cc0c0bfd24e00b2d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ab6a2353313f708f2cc0c0bfd24e00b2d">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the curve direction(曲線の方向を反転する) 楕円の方向を反転する。方向ベクトルを逆にする。範囲があるとき は始終点を入れ換える。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fb8ddd3f86489ce3baf2fef8f93e3c"></a><!-- doxytag: member="MGEllipse::negate_param" ref="ad9fb8ddd3f86489ce3baf2fef8f93e3c" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ad9fb8ddd3f86489ce3baf2fef8f93e3c">negate_param</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this curve is negated by "negate()". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785f1263c199643008def3e3ba2bb7cb"></a><!-- doxytag: member="MGEllipse::unlimit" ref="a785f1263c199643008def3e3ba2bb7cb" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a785f1263c199643008def3e3ba2bb7cb">unlimit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve(limitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a269a0a6d5cc6ef7aa3b51134ad60ed9e"></a><!-- doxytag: member="MGEllipse::unlimit_end" ref="a269a0a6d5cc6ef7aa3b51134ad60ed9e" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a269a0a6d5cc6ef7aa3b51134ad60ed9e">unlimit_end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the end point direction (終点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2ffb23d1a306761f266edec7f62ac75"></a><!-- doxytag: member="MGEllipse::unlimit_start" ref="aa2ffb23d1a306761f266edec7f62ac75" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aa2ffb23d1a306761f266edec7f62ac75">unlimit_start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the start point direction (始点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ac2c34ad9386b5de4a45ecdebe9ea9e2e">length</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cmpute curve length of the interval.  <a href="#ac2c34ad9386b5de4a45ecdebe9ea9e2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a1cdf1c6a9a055aee3af48cac543304fe">length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute whole curve length.  <a href="#a1cdf1c6a9a055aee3af48cac543304fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a7ae14a26b603cb98eed616040a670dfe">length_param</a> (double t, double len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse function of length.  <a href="#a7ae14a26b603cb98eed616040a670dfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79a5dc865dc8d8ac3f577a1a5d9d7e5a"></a><!-- doxytag: member="MGEllipse::major_axis" ref="a79a5dc865dc8d8ac3f577a1a5d9d7e5a" args="() const " -->
const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a79a5dc865dc8d8ac3f577a1a5d9d7e5a">major_axis</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return major axis:長軸を返却する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92c17ad9ca61b692e44a233d74ad9c13"></a><!-- doxytag: member="MGEllipse::major_len" ref="a92c17ad9ca61b692e44a233d74ad9c13" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a92c17ad9ca61b692e44a233d74ad9c13">major_len</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return major axis length:長軸の長さを返却する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d81841d12f1639431744f78d870fe60"></a><!-- doxytag: member="MGEllipse::minor_axis" ref="a8d81841d12f1639431744f78d870fe60" args="() const " -->
const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a8d81841d12f1639431744f78d870fe60">minor_axis</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minor axis:短軸を返却する. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f76475d6e2534f403956ea8ffc5ab22"></a><!-- doxytag: member="MGEllipse::minor_len" ref="a6f76475d6e2534f403956ea8ffc5ab22" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a6f76475d6e2534f403956ea8ffc5ab22">minor_len</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return major axis length:長軸の長さを返却する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed0cd1a247ded785509da96ffd11df70"></a><!-- doxytag: member="MGEllipse::normal" ref="aed0cd1a247ded785509da96ffd11df70" args="() const " -->
const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aed0cd1a247ded785509da96ffd11df70">normal</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return normal:楕円のある平面の法線ベクトルを返却する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a28139b3940e1956d394a0dc22c37ef20">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;, double &amp;d1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if given point is on the curve or not.  <a href="#a28139b3940e1956d394a0dc22c37ef20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56310cbd11292c85b48320678c982bf9"></a><!-- doxytag: member="MGEllipse::order" ref="a56310cbd11292c85b48320678c982bf9" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a56310cbd11292c85b48320678c982bf9">order</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfdd445d9fec8328806377458bec743c"></a><!-- doxytag: member="MGEllipse::param_e" ref="abfdd445d9fec8328806377458bec743c" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#abfdd445d9fec8328806377458bec743c">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ad3f7e91fffbd3cdd1b1ea81b52f7857a">param_normalize</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize parameter value t to the nearest knot if their distance is within tolerance.  <a href="#ad3f7e91fffbd3cdd1b1ea81b52f7857a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2196c69aecb30fafaa936d963043004"></a><!-- doxytag: member="MGEllipse::param_s" ref="ae2196c69aecb30fafaa936d963043004" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ae2196c69aecb30fafaa936d963043004">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c59e01435170500a7fdcbad73a4cc1b"></a><!-- doxytag: member="MGEllipse::param_range_is_in_radian" ref="a3c59e01435170500a7fdcbad73a4cc1b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a3c59e01435170500a7fdcbad73a4cc1b">param_range_is_in_radian</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this ellipase 's parameter range is expressed in radian. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a09bd219f1aec2091843b147514742e2d">part</a> (double t1, double t2, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of this curve from parameter t1 to t2.  <a href="#a09bd219f1aec2091843b147514742e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a44e7303d2204c576fc5fc2f9e99843e3">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p, double &amp;d, const double *g=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a foot point of the perpendicular line from point p to the curve.  <a href="#a44e7303d2204c576fc5fc2f9e99843e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a599280090297f336ab38e45476a9ebfd">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all foot points of the perpendicular line from point p to the curve.  <a href="#a599280090297f336ab38e45476a9ebfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ad5b20b0db0416decbd1b2c4f95544e73">perps</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the perpendicular points of this curve and the second one.  <a href="#ad5b20b0db0416decbd1b2c4f95544e73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7db0e8053e5ec9dc2a7ac5ec9edf9a54"></a><!-- doxytag: member="MGEllipse::perps" ref="a7db0e8053e5ec9dc2a7ac5ec9edf9a54" args="(const MGStraight &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98640c9472a873d764dd4315fa58b4db"></a><!-- doxytag: member="MGEllipse::radian_to_gp" ref="a98640c9472a873d764dd4315fa58b4db" args="(double angle) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a98640c9472a873d764dd4315fa58b4db">radian_to_gp</a> (double angle) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute general parameter t from the radian parameter angle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a73beddac4262cbf06c03faba21c91"></a><!-- doxytag: member="MGEllipse::radius" ref="ac6a73beddac4262cbf06c03faba21c91" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ac6a73beddac4262cbf06c03faba21c91">radius</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the radius of the circle. This is valid only when <a class="el" href="class_m_g_ellipse.html#aa41287c856454b1df3d2183a2267ade4" title="Test if true circle.">circle()</a> is true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada81493163d8da74db991aecbacc22b1"></a><!-- doxytag: member="MGEllipse::sdim" ref="ada81493163d8da74db991aecbacc22b1" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ada81493163d8da74db991aecbacc22b1">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a03c03697c8e98106d9ce1d5817df6ec9">set_arc</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;start, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;end, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;dir_s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace this ellipse with the arc whose start point is start, whose end point is end, and whose tangent at the start point is dir_s.  <a href="#a03c03697c8e98106d9ce1d5817df6ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a81f8f23292e472dd3720b1612eea1b72">sweep</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sweep surface from crv.  <a href="#a81f8f23292e472dd3720b1612eea1b72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a004b75b0a3f2150b0bea8f1873d51ee4"></a><!-- doxytag: member="MGEllipse::type" ref="a004b75b0a3f2150b0bea8f1873d51ee4" args="() const " -->
<a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a004b75b0a3f2150b0bea8f1873d51ee4">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve type(曲線のタイプを返す). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ae81340c926a54a5c65d5b5e231b751bb">out</a> (std::ostream &amp;ostrm) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug function:デバッグ関数.  <a href="#ae81340c926a54a5c65d5b5e231b751bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01932c6560f5acf19f2f8977905474e3"></a><!-- doxytag: member="MGEllipse::out_to_IGES" ref="a01932c6560f5acf19f2f8977905474e3" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a01932c6560f5acf19f2f8977905474e3">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output to IGES stream file. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#af9bda4e4adf08400df7962669a148a31">intersect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection point of 1D sub curve of original curve.  <a href="#af9bda4e4adf08400df7962669a148a31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a21460d5488d65ff3d0fed239898247b0">oneD</a> (const double g[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve.  <a href="#a21460d5488d65ff3d0fed239898247b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad27ec33da3bf168c0d175787870c0f88"></a><!-- doxytag: member="MGEllipse::ReadMembers" ref="ad27ec33da3bf168c0d175787870c0f88" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ad27ec33da3bf168c0d175787870c0f88">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み出す関数 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdd0e2bf6337c956d1ffb3bca205d032"></a><!-- doxytag: member="MGEllipse::WriteMembers" ref="afdd0e2bf6337c956d1ffb3bca205d032" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#afdd0e2bf6337c956d1ffb3bca205d032">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a9013391beeb674dd8954020718a262"></a><!-- doxytag: member="MGEllipse::whoami" ref="a8a9013391beeb674dd8954020718a262" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab076a779a8188015756fc0be78ffd06e"></a><!-- doxytag: member="MGEllipse::MGCylinder" ref="ab076a779a8188015756fc0be78ffd06e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#ab076a779a8188015756fc0be78ffd06e">MGCylinder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f1e9897005bb1908b44bd5f6b264234"></a><!-- doxytag: member="MGEllipse::MGSphere" ref="a2f1e9897005bb1908b44bd5f6b264234" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#a2f1e9897005bb1908b44bd5f6b264234">MGSphere</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea139ae3c6572896a174784443030b6f"></a><!-- doxytag: member="MGEllipse::operator+" ref="aea139ae3c6572896a174784443030b6f" args="(const MGVector &amp;v, const MGEllipse &amp;e)" -->
MGDECL friend <a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_ellipse.html#aea139ae3c6572896a174784443030b6f">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04eec809291a088c8e21de2dacf31f36"></a><!-- doxytag: member="MGEllipse::operator*" ref="a04eec809291a088c8e21de2dacf31f36" args="(double scale, const MGEllipse &amp;el)" -->
MGDECL friend <a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale, const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;el)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D.">MGEllipse</a> is a class to define an ellipse of 2D or 3D. </p>
<p>Ellipse is expressed as below using parameter t(radian): Point(t) = m_center + m_m * cos(t) + m_n * sin(t), where t0 &lt;= t &lt;= t1, -2 pai&lt;=t0&lt;t1&lt;=2 pai and t1-t0&lt;=2 pai. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fd279ed8c3aae278140272d9888136a"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a5fd279ed8c3aae278140272d9888136a" args="(const MGEllipse &amp;el, bool to_radian=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>to_radian</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>If to_radian is true, the parameter range will be changed to radian values. </p>

</div>
</div>
<a class="anchor" id="ac8e51d601c8ec59a3d6959641fda99fe"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="ac8e51d601c8ec59a3d6959641fda99fe" args="(size_t sdim, const MGEllipse &amp;ellip, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ellip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change space dimension and ordering of coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ellip</em>&nbsp;</td><td>original ellipse data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>start position coordinate of new ellipse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>start position coordinate of original </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1449e8b130a641a0fbe2125038de9018"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a1449e8b130a641a0fbe2125038de9018" args="(const MGPosition &amp;center, const MGVector &amp;major_axis, const MGVector &amp;minor_axis, const MGInterval &amp;prange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>major_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>minor_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ellipase from center, major axis vector, minor axis vector, and the parameter range. </p>
<p>If minor axis vector is not normal to major, it is set to normal. 中心、２つのベクトル、パラメータ範囲から楕円を生成する. This is the fundamental constructor.****** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>Center:中心点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>major_axis</em>&nbsp;</td><td>Major axis:第１ベクタ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minor_axis</em>&nbsp;</td><td>Minor axis:第２ベクタ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prange</em>&nbsp;</td><td>Parameter range in radian:角度の範囲(ラジアン) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbecd9c2e2eb4e309fcf4e1f49525a32"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="abbecd9c2e2eb4e309fcf4e1f49525a32" args="(const MGPosition &amp;center, double r, const MGVector &amp;normal=mgZ_UVEC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em> = <code>mgZ_UVEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A whole circle form center, radius, and the normal. </p>
<p>中心、半径、パラメータ範囲と法線ベクトルを指定して真円を作成する。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>Center:中心点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>Radius:半径 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>Normal:法線 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedaea0f99b337729d4f1d36aee6cf69e"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="aedaea0f99b337729d4f1d36aee6cf69e" args="(const MGPosition &amp;center, const MGPosition &amp;spoint, double d=mgDBLPAI, const MGVector &amp;v=mgZ_UVEC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code><a class="el" href="group___b_a_s_e.html#ga2ab7c015a009fa7d1fc3386171e60f08">mgDBLPAI</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em> = <code>mgZ_UVEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arc from center, start point, angle d, and the normal. </p>
<p>The angle can be negative value. When it is negative, the arc's direction is clockwise around v. When positive, anti-clockwise. The start point's angle is zero, and the the end point's angle is d. 中心、始点、角度と法線を指定して円弧を作成する。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>Center:中心点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spoint</em>&nbsp;</td><td>Start point:始点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>Angle in radian. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Normal:法線 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbbf9c0e20b4617ef3a868f112850d43"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="adbbf9c0e20b4617ef3a868f112850d43" args="(const MGPlane &amp;plane, const MGPosition &amp;corner1, MGPosition &amp;corner2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>corner1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>corner2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>矩形に内接する楕円を生成する plane 楕円が乗る平面に平行な平面 corner1 楕円が内接する矩形のコーナーの座標 corner2 corner1 の対頂角の座標のヒント </p>
<p>もし corner2 が corner1 を通る plane に平行な平面に 乗っていない場合、corner2 は平行な平面に面直投影され、 それが計算に用いられる。 </p>

</div>
</div>
<a class="anchor" id="a2aed3086ad065a76744b53dfec577e47"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a2aed3086ad065a76744b53dfec577e47" args="(double r, const MGPosition &amp;start, const MGPosition &amp;end, const MGVector &amp;N, bool whole_circle=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>whole_circle</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An arc of radius r whose start point is start, and the end point is end. </p>
<p>and that is normal to the vector N. The circle lies on the plane whose normal is N and that passes through start and end. radius r is able to have minus value, in which case the longer part of the arc out of the whole circle is constructed. The center of the circle C is: C=M+MGUnit_vector(sign(r)*N*(end-start))*sqrt(r*r-d*d), where M=(start+end)*.5, and d is the distance between start and M. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>radius </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whole_circle</em>&nbsp;</td><td>true if the whole circle is to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a3643a3babfdce095db481400adea1e"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a6a3643a3babfdce095db481400adea1e" args="(double r, const MGPosition &amp;start, const MGPosition &amp;end, const MGPosition &amp;reference, bool whole_circle=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>whole_circle</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An arc of radius r whose start point is start, and the end point is end. </p>
<p>The circle lies on the plane that the three points start, end, and reference lie on. The center of the circle C is: C=M+MGUnit_vector(sign(r)*N*(end-start))*sqrt(r*r-d*d), where M=(start+end)*.5, d is the distance between start and M, and N=(reference-start)*(end-start). That is, if r&gt;0., the position reference indicates on which side the C lies against the vector (end-start), C and reference lie in the same half plane that the vector (end-start) divides. If r&lt;0., C and reference lie in the opposite side. When r&gt;0., smaller part arc of the circle is selected, and when r&lt;0., larger part of the circle is selected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>radius </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whole_circle</em>&nbsp;</td><td>true if the whole circle is to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a379849051861672ae9008e8f800d0b99"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a379849051861672ae9008e8f800d0b99" args="(const MGPosition &amp;P, const MGVector &amp;V1, const MGVector &amp;V2, double d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arc of the circle that osculates to two straight lines that passes point P and whose directional vectors are V1 and V2. </p>
<p>The starting point is the contact point with the 1st line, and end point is the contact point with 2nd line. If radius d is positive, the arc is the one of point P side, and if negative, the other side. １点Pと２つのベクトル(V1, V2)からなる２直線に接する指定半径の 円弧を作成する。 第一ベクトルとの接点を始点、他方を終点とし、 d&gt;0 のときこれらで分割された円弧の指定点P側を d&lt;0 のときPと反対側を作成する。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Start point of two straight lines:直線の始点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V1</em>&nbsp;</td><td>Directional vector 1:直線の方向ベクトル１ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>Directional vector 2:直線の方向ベクトル２ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>Radius:半径 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6efe0bdc67c0d67886909a1273f0335"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="ae6efe0bdc67c0d67886909a1273f0335" args="(const MGPosition &amp;start, const MGPosition &amp;through, const MGPosition &amp;end, bool whole_circle=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>through</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>whole_circle</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arc from start point, through point, and end point. </p>
<p>始点、通過点、終点を指定して円弧を作成する。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start point:始点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>through</em>&nbsp;</td><td>Through point:通過点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End point:終点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whole_circle</em>&nbsp;</td><td>true if the whole circle is to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16ac01b1c0d18d74d421d87b08944d89"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a16ac01b1c0d18d74d421d87b08944d89" args="(const MGPosition &amp;center, const MGPosition &amp;start, const MGPosition &amp;end, const MGVector &amp;N, bool whole_circle=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>whole_circle</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arc from center, start point, end point. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>center of the circle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start point:始点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End point:終点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Normal of the plane the circle lies on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whole_circle</em>&nbsp;</td><td>true if the whole circle is to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0844c8a9e451ffd5734f96996e2d5af"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="ae0844c8a9e451ffd5734f96996e2d5af" args="(const MGPosition &amp;start, const MGPosition &amp;end, const MGVector &amp;dir_s, bool whole_circle=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dir_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>whole_circle</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the arc whose start point is start, whose end point is end, and whose tangent at the start point is dir_s. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>whole_circle</em>&nbsp;</td><td>true if the whole circle is to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32d75c1befaf3c3680fc71a1f38a31a6"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a32d75c1befaf3c3680fc71a1f38a31a6" args="(const MGCurve &amp;crv1, const MGCurve &amp;crv2, const MGUnit_vector &amp;normal, double dRadius, double &amp;t1, double &amp;t2, int &amp;rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>目的： 基本線２本と半径からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線は同一平面上にあること 戻り値： 0: 正常終了 -1: 基本線の曲率半径より半径Rが大きい -2: 基本線同士の交点が求まらない Start point of the generated ellipse is either t1 side or t2, which depends on normal direction. </p>
<p>The ellipse direction is defined from normal, If the arc length from t1 to t2(arond normal) is smaller than from t2 to t1(around normal), the start point is on t1 side. If the arc length from t1 to t2 is longer than from t2 to t1, the start point is on t2 side. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv1</em>&nbsp;</td><td>I:基本線1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>crv2</em>&nbsp;</td><td>I:基本線2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>I:基本線のノーマルベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dRadius</em>&nbsp;</td><td>I:コーナーＲの半径 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>I:基本線１の初期パラメータ(コーナーＲを作成する側を指定) O:コーナーＲと接する基本線１のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>I:基本線２の初期パラメータ(コーナーＲを作成する側を指定) O:コーナーＲと接する基本線２のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rc</em>&nbsp;</td><td>O:リターンコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d7c59cfbedab4aaf747b6640d305487"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a2d7c59cfbedab4aaf747b6640d305487" args="(const MGCurve &amp;crv1, const MGCurve &amp;crv2, const MGUnit_vector &amp;normal, double t1, double &amp;t2, int &amp;rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>目的： 基本線２本とＲ止まり点からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線は同一平面上にあること 戻り値： 0: 正常終了 -1: 入力値が不正 -2: crv2上の接点が求まらない(交点なし) -3: crv2上の接点が求まらない(収束しない) Start point of the generated ellipse is either t1 side or t2, which depends on normal direction. </p>
<p>The ellipse direction is defined from normal, If the arc length from t1 to t2(arond normal) is smaller than from t2 to t1(around normal), the start point is on t1 side. If the arc length from t1 to t2 is longer than from t2 to t1, the start point is on t2 side. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv1</em>&nbsp;</td><td>I:基本線1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>crv2</em>&nbsp;</td><td>I:基本線2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>I:基本線のノーマルベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>I:基本線1上のＲ止まり点のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>I:基本線2の初期パラメータ(コーナーＲを作成する側を指定) O:コーナーＲと接する基本線２のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rc</em>&nbsp;</td><td>O:リターンコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a725b00a7a7d0fbde1d7fac078e3c94b1"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a725b00a7a7d0fbde1d7fac078e3c94b1" args="(const MGCurve &amp;crv1, const MGCurve &amp;crv2, const MGCurve &amp;crv3, const MGUnit_vector &amp;normal, double &amp;t1, double &amp;t2, double &amp;t3, int &amp;rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>目的： 基本線３本からコーナーＲを作成する crv1, crv2, crv3がそれぞれ始点、通過点、終点となるようにする。 初期パラメータはコーナーＲが接する近辺に設定し、基本線は同一平面上にあること 戻り値： 0: 正常終了 -1: 連立方程式が解けなかった -2: 収束しなかった(パラメータ範囲を超えてしまった) -3: 収束しなかった(無限ループにおちいった) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv1</em>&nbsp;</td><td>I:基本線1(始点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>crv2</em>&nbsp;</td><td>I:基本線2(通過点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>crv3</em>&nbsp;</td><td>I:基本線3(終点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>I:基本線のノーマルベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>I:基本線1の初期パラメータ(コーナーＲの始点近辺) O:コーナーＲの始点における基本線１のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>I:基本線2の初期パラメータ(コーナーＲの通過点近辺) O:コーナーＲの通過点における基本線２のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t3</em>&nbsp;</td><td>I:基本線3の初期パラメータ(コーナーＲの終点近辺) O:コーナーＲの終点における基本線２のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rc</em>&nbsp;</td><td>O:リターンコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0a62b9b7f876f8270eef4e3f8c73adb"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="ac0a62b9b7f876f8270eef4e3f8c73adb" args="(const MGCurve &amp;crv, const MGPosition &amp;pos, const MGUnit_vector &amp;normal, double dRadius, double &amp;dParam, int &amp;rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>目的： 基本線と円弧端点と半径からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線と円弧端点は同一平面上にあること 戻り値： 0: 正常終了 -1: 入力値が不正 -2: 半径値が小さすぎる -3: 半径値が大きすぎる -4: 基本線をオフセットしたカーブと円弧端点から作成した円の交点が求まらなかった </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>I:基本線 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>I:円弧端点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>I:基本線のノーマルベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dRadius</em>&nbsp;</td><td>I:コーナーＲの半径 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dParam</em>&nbsp;</td><td>I:基本線の初期パラメータ(コーナーＲを作成する側を指定) O:コーナーＲと接する基本線１のパラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rc</em>&nbsp;</td><td>O:リターンコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b9b092c22652d237ea1a3e37e0ef392"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="a0b9b092c22652d237ea1a3e37e0ef392" args="(const MGCurve &amp;crv, const MGPosition &amp;P2, const MGUnit_vector &amp;normal, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>目的： 基本線と基本線上Ｒ止まりと円弧端点からコーナーＲを作成する 初期パラメータはコーナーＲを作成したい側に設定し、基本線と円弧端点は同一平面上にあること </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>I:基本線 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P2</em>&nbsp;</td><td>I:円弧端点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>I:基本線のノーマルベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>I:R止まり点のパラメータ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae26447db9a1b9a1e8b01debd0fd85b8a"></a><!-- doxytag: member="MGEllipse::MGEllipse" ref="ae26447db9a1b9a1e8b01debd0fd85b8a" args="(const MGIgesDirectoryEntry &amp;de)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEllipse::MGEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_iges_directory_entry.html">MGIgesDirectoryEntry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>de</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversion constructor from <a class="el" href="class_m_g_iges_directory_entry.html" title="MGIgesDirectoryEntry describes a directory entry section of an IGES file.">MGIgesDirectoryEntry</a> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>de</em>&nbsp;</td><td>type number must be 100(Circular Arc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0f6dd60b74f5bc68fd865dc021ffb5b9"></a><!-- doxytag: member="MGEllipse::box_limitted" ref="a0f6dd60b74f5bc68fd865dc021ffb5b9" args="(const MGInterval &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGEllipse::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return minimum box that includes the curve of parameter interval. </p>
<p>パラメータ値による楕円上のポイントによって境界が与えられた 部分または、楕円の周りを含む最小のボックスを返す。 </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a680d824802125a83533362f05ee84b71">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a7433c299d5ef3460d0b78ea1e7091982"></a><!-- doxytag: member="MGEllipse::change_dimension" ref="a7433c299d5ef3460d0b78ea1e7091982" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&amp; MGEllipse::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac83a24a002d65e6339859e51321fff57">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a0f3cbc528d7b7b7c9b22e731744ef021"></a><!-- doxytag: member="MGEllipse::change_range" ref="a0f3cbc528d7b7b7c9b22e731744ef021" args="(double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEllipse::change_range </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a260ff34df53249e6887a09553f84058b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa41287c856454b1df3d2183a2267ade4"></a><!-- doxytag: member="MGEllipse::circle" ref="aa41287c856454b1df3d2183a2267ade4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::circle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if true circle. </p>
<p>If circle, return true. 円か調べる。円のときtrue。 </p>

</div>
</div>
<a class="anchor" id="a15506aae416fc587969212c88cb54908"></a><!-- doxytag: member="MGEllipse::clone" ref="a15506aae416fc587969212c88cb54908" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>* MGEllipse::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae85e37def31262577515e70078fb92e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="acf8250c17c44468121fc8f4e29e09353"></a><!-- doxytag: member="MGEllipse::coordinate_exchange" ref="acf8250c17c44468121fc8f4e29e09353" args="(size_t i, size_t j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&amp; MGEllipse::coordinate_exchange </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange ordering of the coordinates. </p>
<p>Exchange coordinates (i) and (j). </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae8c6cb11b641e5b6f596867672bfda66">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a085a7533eb1b9385625b0a98d1ab8af7"></a><!-- doxytag: member="MGEllipse::copy_as_nurbs" ref="a085a7533eb1b9385625b0a98d1ab8af7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGEllipse::copy_as_nurbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy as a newed curve. </p>
<p>The new curve will be <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> or <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. When original curve was a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>, the new curve will be a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. Otherwise, the new curve will be a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. Returned object must be deleted. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a9ef3806ddfd62edf9b7b9c59626caf5a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8cf5668afef437ce38ade622359e02b6"></a><!-- doxytag: member="MGEllipse::copy_change_dimension" ref="a8cf5668afef437ce38ade622359e02b6" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>* MGEllipse::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a84add0aaacbc189dd584dbf9f5670d99">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a7ce7503763c81a68c9a6ee7043476a5d"></a><!-- doxytag: member="MGEllipse::create_ellipse" ref="a7ce7503763c81a68c9a6ee7043476a5d" args="(const MGPosition &amp;F0, const MGPosition &amp;F1, const MGPosition &amp;P)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::create_ellipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>焦点と通過点を与えて楕円を生成する F0 焦点 F1 焦点 P 楕円上の点 </p>
<p>F0 と F1 は相異なる焦点でなければ失敗する。 P が2焦点を結ぶ直線上にあるとき失敗する。 </p>

</div>
</div>
<a class="anchor" id="a629c3f6cb9490d64faa2d877512f1208"></a><!-- doxytag: member="MGEllipse::curvilinear_integral" ref="a629c3f6cb9490d64faa2d877512f1208" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEllipse::curvilinear_integral </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvilinear integral of the 1st two coordinates. </p>
<p>This integral can be used to compute closed area sorounded by the curve. (線積分）を求める。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a27b4724616d26b4b6aa076b010645a26">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a99b0bc2fe40e482a4fabcf17bccc533a"></a><!-- doxytag: member="MGEllipse::drawSE" ref="a99b0bc2fe40e482a4fabcf17bccc533a" args="(double span_length, double t0, double t1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEllipse::drawSE </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From t1 to t2;. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>Start parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>End parameter value of the curve, Draw will be performed from t0 to t1. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a20497e172065788e673b771f018d90af">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="acac237a8d8c3a9ac258735cf238c4aa6"></a><!-- doxytag: member="MGEllipse::eval" ref="acac237a8d8c3a9ac258735cf238c4aa6" args="(double, size_t nderiv=0, int left=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGEllipse::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate n'th derivative data. </p>
<p>nderiv=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>Left continuous(left=true) or right continuous(left=false). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#acbcbb8f812be257921ef63c71afdedcf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a2f83fcc8c47bf772314c5c623d567bbc"></a><!-- doxytag: member="MGEllipse::eval_all" ref="a2f83fcc8c47bf772314c5c623d567bbc" args="(double, MGPosition &amp;, MGVector &amp;, MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEllipse::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute position, 1st and 2nd derivatives. </p>
<p>パラメータを与え、位置、一次微分値、二次微分値を求める。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a9ea3970501a3d9c681a38ff584018b41">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aae7796e15604cd3e777ca6be29935206"></a><!-- doxytag: member="MGEllipse::eval_deriv" ref="aae7796e15604cd3e777ca6be29935206" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGEllipse::eval_deriv </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluatefirst derivative data. </p>
<p>楕円上の与えられたパラメータ値における一次微分値を返却する。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#af1870e1105d7e44e856b362953479c38">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="abef59329d2ecac6a379108b47e794bfd"></a><!-- doxytag: member="MGEllipse::eval_in_degree" ref="abef59329d2ecac6a379108b47e794bfd" args="(double degree, size_t nderiv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGEllipse::eval_in_degree </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate ellipse data. </p>
<p>Input parameter degree must be in degree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>degree</em>&nbsp;</td><td>Parameter value in degree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb26eaac584837932c3d6d301a2b4a1d"></a><!-- doxytag: member="MGEllipse::eval_in_radian" ref="aeb26eaac584837932c3d6d301a2b4a1d" args="(double t, size_t nderiv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGEllipse::eval_in_radian </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate ellipse data. </p>
<p>Input parameter t must be in radian. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value in radian. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac75699928ee734689e2a9fe28bbbc85f"></a><!-- doxytag: member="MGEllipse::eval_position" ref="ac75699928ee734689e2a9fe28bbbc85f" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGEllipse::eval_position </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute positional data. </p>
<p>与えられたパラメータ値に相当する楕円上の点を返却する。 Input parameter t must be in radian. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a005668fa2dca670c5ff755c9bb06945d">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a91b8d9443d9b514125755abdfde13ba4"></a><!-- doxytag: member="MGEllipse::extend" ref="a91b8d9443d9b514125755abdfde13ba4" args="(double length, bool start=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEllipse::extend </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate this curve by an (approximate) chord length. </p>
<p>The extrapolation is C2 continuous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>approximate chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of which point to extend, start or end point of the line, If start is true extend on the start point. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#af0e8206d530257d27910d0676ba0be01">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="adfafb35c501200a885f21cb2e1cc8c2d"></a><!-- doxytag: member="MGEllipse::in_RelativeRange_of_radian" ref="adfafb35c501200a885f21cb2e1cc8c2d" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::in_RelativeRange_of_radian </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if angle t is in the parameter range. </p>
<p>t is increased or decreased by 2*PAI if necessary in testing. Radian version. Input t must be of radian. </p>

</div>
</div>
<a class="anchor" id="af9bda4e4adf08400df7962669a148a31"></a><!-- doxytag: member="MGEllipse::intersect_1D" ref="af9bda4e4adf08400df7962669a148a31" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGEllipse::intersect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection point of 1D sub curve of original curve. </p>
<p>Parameter values of intersection point will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7da60650ad1b0c4823eeb1c3ce8be722">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a7f2ba248fb3216bb8422e7c819ffede9"></a><!-- doxytag: member="MGEllipse::is_linear" ref="a7f2ba248fb3216bb8422e7c819ffede9" args="(MGStraight &amp;straight) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::is_linear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>straight</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is linear or not, that is, is straight or not. </p>
<p><a class="el" href="class_m_g_straight.html" title="MGStraight is a curve of any space dimension, represent a straight line.">MGStraight</a> expression will be out to straight if this is linear or not. Function's return value is true if linear. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ac8483acd59478145655b63787b46557a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a62df31d96af72c2333bb60f9c8bb6d69"></a><!-- doxytag: member="MGEllipse::is_planar" ref="a62df31d96af72c2333bb60f9c8bb6d69" args="(MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::is_planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is planar or not. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is planar. Function's return value is true if planar. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a3e6f96416ab574420cbed88ebfc414e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a37060c40dd4a5bc09142673bddfb094f"></a><!-- doxytag: member="MGEllipse::is_whole_ellipse" ref="a37060c40dd4a5bc09142673bddfb094f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::is_whole_ellipse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this ellipse is whole ellipse or not. </p>
<p>Function's return value is true if this is whole. </p>

</div>
</div>
<a class="anchor" id="a5053c86a267104e02a93cee37b34b3bf"></a><!-- doxytag: member="MGEllipse::isect" ref="a5053c86a267104e02a93cee37b34b3bf" args="(const MGCurve &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> MGEllipse::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of ellipse and curve. </p>
<p>Ellipse と Curve の交点を求める。 </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a379e4f21b3055c90d7f83897341cd7d8">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a4ffbdf187decf0b4e49ad08004adf189"></a><!-- doxytag: member="MGEllipse::isect" ref="a4ffbdf187decf0b4e49ad08004adf189" args="(const MGSurface &amp;surf) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGEllipse::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Ellipse and Surface. </p>
<p>Intersection of <a class="el" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D.">MGEllipse</a> and Surface </p>

<p>Implements <a class="el" href="class_m_g_curve.html">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a321adaac31b4c61b57da1e132fa288b5"></a><!-- doxytag: member="MGEllipse::knot" ref="a321adaac31b4c61b57da1e132fa288b5" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEllipse::knot </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access to i-th element of knot. </p>
<p>i=0, 1 and returns start or end parameter value of the ellipse. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a625339525839a70c8224d621e2fbfa6e">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac2c34ad9386b5de4a45ecdebe9ea9e2e"></a><!-- doxytag: member="MGEllipse::length" ref="ac2c34ad9386b5de4a45ecdebe9ea9e2e" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEllipse::length </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cmpute curve length of the interval. </p>
<p>If t1 is greater than t2, return negative value. 与えられたパラメータ間の曲線に沿った距離を返却する。 パラメータ値が昇順で与えられたとき正値、降順のとき負値を 返す。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7d7c4dd68f29d059515a267023f50ddf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a1cdf1c6a9a055aee3af48cac543304fe"></a><!-- doxytag: member="MGEllipse::length" ref="a1cdf1c6a9a055aee3af48cac543304fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEllipse::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute whole curve length. </p>
<p>楕円の全体の長さを返却する。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a1873bf48b6b84ba4e5c0b41fc5d10b18">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a7ae14a26b603cb98eed616040a670dfe"></a><!-- doxytag: member="MGEllipse::length_param" ref="a7ae14a26b603cb98eed616040a670dfe" args="(double t, double len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEllipse::length_param </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse function of length. </p>
<p>Compute the point that is away from the point t by length len. パラメータtで示される点から指定距離lenはなれた点のパラメータ を返す。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ac9db090d93e6b0a1e7f9c6b6d29e7c48">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ab4436d6be20ada9efd6a93d5799418d7"></a><!-- doxytag: member="MGEllipse::limit" ref="ab4436d6be20ada9efd6a93d5799418d7" args="(const MGInterval &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&amp; MGEllipse::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update this by limiting the parameter range of the curve. </p>
<p>自身の楕円に指定された範囲のlimitを付加する。 </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a4f5e376f184379038ebac06536962e32">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a28139b3940e1956d394a0dc22c37ef20"></a><!-- doxytag: member="MGEllipse::on" ref="a28139b3940e1956d394a0dc22c37ef20" args="(const MGPosition &amp;, double &amp;d1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEllipse::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if given point is on the curve or not. </p>
<p>If yes, return parameter value of the curve. Even if not, return nearest point's parameter. Function's return value is true(&gt;0) if the point is on the curve, and false(0) if the point is not on the curve. 点が楕円上にあるか調べる。楕円上であれば，そのパラメータ値を， そうでなくても最近傍点のパラメータ値を返す。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d1</em>&nbsp;</td><td>Parameter value will be returned:パラメータ </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ad2c08f169d6d447464d73d4d6b33ae1d">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a21460d5488d65ff3d0fed239898247b0"></a><!-- doxytag: member="MGEllipse::oneD" ref="a21460d5488d65ff3d0fed239898247b0" args="(const double g[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGEllipse::oneD </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>g</em>[4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve. </p>
<p>This is used to compute intersections with a plane g[4]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>Plane expression(a,b,c,d) where ax+by+cz=d. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac0d98232c1251692db526e28d65a6f7e">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="adc7f18f46eed7849cce0a27a73e95193"></a><!-- doxytag: member="MGEllipse::operator=" ref="adc7f18f46eed7849cce0a27a73e95193" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>&amp; MGEllipse::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and crv2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="ae81340c926a54a5c65d5b5e231b751bb"></a><!-- doxytag: member="MGEllipse::out" ref="ae81340c926a54a5c65d5b5e231b751bb" args="(std::ostream &amp;ostrm) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; MGEllipse::out </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>ostrm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug function:デバッグ関数. </p>
<p>Output function. Output to stream <a href="file:">file:</a>メンバデータを標準出力に出力する。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a538827e5527c142cfadb8dff92de2f4b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad3f7e91fffbd3cdd1b1ea81b52f7857a"></a><!-- doxytag: member="MGEllipse::param_normalize" ref="ad3f7e91fffbd3cdd1b1ea81b52f7857a" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEllipse::param_normalize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize parameter value t to the nearest knot if their distance is within tolerance. </p>
<p>For ellipse, the knots are start and end points. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ab8d6aac48fea5813393870bcbd6a1e78">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a09bd219f1aec2091843b147514742e2d"></a><!-- doxytag: member="MGEllipse::part" ref="a09bd219f1aec2091843b147514742e2d" args="(double t1, double t2, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_ellipse.html">MGEllipse</a>* MGEllipse::part </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of this curve from parameter t1 to t2. </p>
<p>Returned is the pointer to newed object, and so should be deleted by the calling program, or memory leaked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a57c9d6e7f929b0d77c75cc6417daba2b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a44e7303d2204c576fc5fc2f9e99843e3"></a><!-- doxytag: member="MGEllipse::perp_point" ref="a44e7303d2204c576fc5fc2f9e99843e3" args="(const MGPosition &amp;p, double &amp;d, const double *g=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGEllipse::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>g</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a foot point of the perpendicular line from point p to the curve. </p>
<p>If more than one points are found, return nearest one. Function's return value is if point is obtained(&gt;0) or not(0) 与ポイントから楕円への垂線の足、そのポイントでの楕円の パラメータ値を返却する。 value of the ellipse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>A point:与ポイント </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>Parameter value will be returned:パラメータ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>guess parameter value of the foot parameter </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ac4caa8d093daac4815df907eca6f1aaf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b20b0db0416decbd1b2c4f95544e73"></a><!-- doxytag: member="MGEllipse::perps" ref="ad5b20b0db0416decbd1b2c4f95544e73" args="(const MGCurve &amp;crv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGEllipse::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the perpendicular points of this curve and the second one. </p>
<p>That is, if f(s) and g(t) are the points of the two curves f and g, then obtains points where the following conditions are satisfied: fs*(f-g)=0. gt*(g-f)=0. Here fs and gt are 1st derivatives at s and t of f and g. <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv2's parameter value. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a0da4a6809840a951581a99174dbebbab">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a599280090297f336ab38e45476a9ebfd"></a><!-- doxytag: member="MGEllipse::perps" ref="a599280090297f336ab38e45476a9ebfd" args="(const MGPosition &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGEllipse::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all foot points of the perpendicular line from point p to the curve. </p>
<p>与ポイントから楕円へ下ろした垂線の足の，楕円のパラメータ値を すべて求める。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ad94d161f9e243e1a47bf0ebe7b5dcf29">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a03c03697c8e98106d9ce1d5817df6ec9"></a><!-- doxytag: member="MGEllipse::set_arc" ref="a03c03697c8e98106d9ce1d5817df6ec9" args="(const MGPosition &amp;start, const MGPosition &amp;end, const MGVector &amp;dir_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEllipse::set_arc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dir_s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace this ellipse with the arc whose start point is start, whose end point is end, and whose tangent at the start point is dir_s. </p>

</div>
</div>
<a class="anchor" id="a81f8f23292e472dd3720b1612eea1b72"></a><!-- doxytag: member="MGEllipse::sweep" ref="a81f8f23292e472dd3720b1612eea1b72" args="(const MGUnit_vector &amp;uvec, double start_dist, double end_dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGEllipse::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sweep surface from crv. </p>
<p>Output is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted. The sweep surface is defined as: This curve(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ab444253d2ae843173c03d0dc2c79e814">MGCurve</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Ellipse.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:21 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

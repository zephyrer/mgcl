<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGLoop Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGLoop" --><!-- doxytag: inherits="MGBoundary" -->
<p><a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a> is a boundary of a face, a boundary of 2D manifold cell.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Loop.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGLoop:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_loop__inherit__graph.png" border="0" usemap="#_m_g_loop_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_loop_inherit__map" id="_m_g_loop_inherit__map">
<area shape="rect" id="node2" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension." alt="" coords="9,392,108,421"/><area shape="rect" id="node4" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="12,315,105,344"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="12,237,105,267"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGLoop:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_loop__coll__graph.png" border="0" usemap="#_m_g_loop_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_loop_coll__map" id="_m_g_loop_coll__map">
<area shape="rect" id="node2" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension." alt="" coords="143,869,241,899"/><area shape="rect" id="node4" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="125,581,219,611"/><area shape="rect" id="node30" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="212,677,295,707"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="120,485,213,515"/><area shape="rect" id="node32" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="171,773,264,803"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="163,373,243,403"/><area shape="rect" id="node36" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="268,581,367,611"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node16" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node14" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,261,167,291"/><area shape="rect" id="node19" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node22" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="308,485,375,515"/><area shape="rect" id="node28" href="class_m_g_cell.html" title="MGCell is a general cell that has bound." alt="" coords="295,773,359,803"/><area shape="rect" id="node24" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="300,373,383,403"/><area shape="rect" id="node26" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="303,261,380,291"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_loop-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#afba3b2d80be1fd2e592fbb25de8d6cc0">LoopKind</a> { <br/>
&nbsp;&nbsp;<b>UNDEFINED</b> = -1, 
<b>INACTIVE</b> = 0, 
<b>PERIMITER_LOOP</b> = 1, 
<a class="el" href="class_m_g_loop.html#afba3b2d80be1fd2e592fbb25de8d6cc0a92d88d1cffd798a0b467c73a32e49514">OUTER_LOOP</a> = 2, 
<br/>
&nbsp;&nbsp;<a class="el" href="class_m_g_loop.html#afba3b2d80be1fd2e592fbb25de8d6cc0aab676c70f5ef05583f89fe58269188ea">INNER_LOOP</a> = 3, 
<b>NETWORK</b> = 4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15197198c3aa8c636b1dc12a8a308106"></a><!-- doxytag: member="MGLoop::MGLoop" ref="a15197198c3aa8c636b1dc12a8a308106" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a15197198c3aa8c636b1dc12a8a308106">MGLoop</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbeaa305cb6ed785d96d52cd42cfcda9"></a><!-- doxytag: member="MGLoop::MGLoop" ref="afbeaa305cb6ed785d96d52cd42cfcda9" args="(MGEdge *edge)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#afbeaa305cb6ed785d96d52cd42cfcda9">MGLoop</a> (<a class="el" href="class_m_g_edge.html">MGEdge</a> *edge)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a loop of one edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae980553a4b37d3839594be4bac498bb6"></a><!-- doxytag: member="MGLoop::MGLoop" ref="ae980553a4b37d3839594be4bac498bb6" args="(const MGLoop &amp;loop2)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ae980553a4b37d3839594be4bac498bb6">MGLoop</a> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;loop2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a17f9dcbf00405ce90e6b95be1805704a">MGLoop</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;world_curve)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Loop of one edge of one curve cell.  <a href="#a17f9dcbf00405ce90e6b95be1805704a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40a21cae1a058e2318a3d03847c113f9"></a><!-- doxytag: member="MGLoop::MGLoop" ref="a40a21cae1a058e2318a3d03847c113f9" args="(const MGCurve &amp;param_curve, const MGInterval &amp;range1, const MGCurve &amp;world_curve, const MGInterval &amp;range2)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGLoop</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;world_curve, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b7f6296c8054254d4b9b2d63d5430ec"></a><!-- doxytag: member="MGLoop::MGLoop" ref="a0b7f6296c8054254d4b9b2d63d5430ec" args="(std::auto_ptr&lt; MGCurve &gt; &amp;param_curve, std::auto_ptr&lt; MGCurve &gt; &amp;world_curve)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGLoop</b> (std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;param_curve, std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;world_curve)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a843f58910e6f890d5f415b3322cf69f5">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a843f58910e6f890d5f415b3322cf69f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fab63aa7f84c22dddc9a27afedb6a07"></a><!-- doxytag: member="MGLoop::operator=" ref="a1fab63aa7f84c22dddc9a27afedb6a07" args="(const MGLoop &amp;gel2)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99934b9e94831304263e047a0bc62404"></a><!-- doxytag: member="MGLoop::operator+=" ref="a99934b9e94831304263e047a0bc62404" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a99934b9e94831304263e047a0bc62404">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e379890098ef9db159f44cdf9610710"></a><!-- doxytag: member="MGLoop::operator&#45;=" ref="a3e379890098ef9db159f44cdf9610710" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9586677497c0722b931a7a064ecf38dc"></a><!-- doxytag: member="MGLoop::operator*=" ref="a9586677497c0722b931a7a064ecf38dc" args="(double scale)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad82e3afc0dfb7aad0431ced24f6a5d7"></a><!-- doxytag: member="MGLoop::operator*=" ref="aad82e3afc0dfb7aad0431ced24f6a5d7" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a279877e42cf8e00f2f26b9c70adc359e"></a><!-- doxytag: member="MGLoop::operator*=" ref="a279877e42cf8e00f2f26b9c70adc359e" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a46a0215e6e93e93eb86cba0dd0cad332">operator&lt;</a> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator is to sort loops in the order: 1.  <a href="#a46a0215e6e93e93eb86cba0dd0cad332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac17ac24a788333c896de44157d47d254"></a><!-- doxytag: member="MGLoop::operator&lt;" ref="ac17ac24a788333c896de44157d47d254" args="(const MGComplex &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ac17ac24a788333c896de44157d47d254">operator&lt;</a> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6209fa6229531d2c0e6468b41cc0e2a5"></a><!-- doxytag: member="MGLoop::operator&lt;" ref="a6209fa6229531d2c0e6468b41cc0e2a5" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af31566a1da06bb4d1f3eaa3f68a1a96c"></a><!-- doxytag: member="MGLoop::active" ref="af31566a1da06bb4d1f3eaa3f68a1a96c" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#af31566a1da06bb4d1f3eaa3f68a1a96c">active</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is active boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a01f5796b0c191cfd4d04ddc64ad330cf">append</a> (<a class="el" href="class_m_g_edge.html">MGEdge</a> *edge)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append edge to the end of loop.  <a href="#a01f5796b0c191cfd4d04ddc64ad330cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ac1958a0d626039ef63b08c46c1495f6a">append_edge_from_crv</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;wcrv, double &amp;tLast, double terror, const std::vector&lt; double &gt; &amp;pspan, int peri_num, bool orientation_is_opposite=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build one edge of srf from the curve wcrv on srf and common information pspan and peri_num, which are a perimeter peri_num's parameter spans(psapn).  <a href="#ac1958a0d626039ef63b08c46c1495f6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#acca4a6777715106dcf6b87b75b68b967">area</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvilinear integral of the parameter space of the area sorrounded by the loop.  <a href="#acca4a6777715106dcf6b87b75b68b967"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a2f508538ea52752298e9399a05fe2510">both_end_on_perimeter</a> (size_t &amp;pid_s, size_t &amp;pid_e, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *srf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if loop is a perimeter boundary or not.  <a href="#a2f508538ea52752298e9399a05fe2510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aca2915ed89d1bd52afaf0072f48c45af">clone</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;parent) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone.  <a href="#aca2915ed89d1bd52afaf0072f48c45af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a9675c0e77ade5b4ebd3f62fce826f90c">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new object by copying to newed area.  <a href="#a9675c0e77ade5b4ebd3f62fce826f90c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a17cc2fbb32e4bda10316d10ae0a5a73c">clone_without_binders</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;parent) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone that has not binders.  <a href="#a17cc2fbb32e4bda10316d10ae0a5a73c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99293ab2b4b39d6ae966342d9bc7ad24"></a><!-- doxytag: member="MGLoop::clone_without_binders" ref="a99293ab2b4b39d6ae966342d9bc7ad24" args="() const " -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>clone_without_binders</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13578b8fcc8499c7481e07180041b00a"></a><!-- doxytag: member="MGLoop::closed" ref="a13578b8fcc8499c7481e07180041b00a" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a13578b8fcc8499c7481e07180041b00a">closed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is closed boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aa6ef41050035050b0ff43ee8b8ce7626">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, double &amp;distance) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute closest point from the point P to this loop.  <a href="#aa6ef41050035050b0ff43ee8b8ce7626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#af9344b569fa20df4322c683baacefe4f">common</a> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;loop2, std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt; &amp;pranges1, std::vector&lt; double &gt; &amp;branges1, std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt; &amp;pranges2, std::vector&lt; double &gt; &amp;branges2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute common range of two loops, this and loop2.  <a href="#af9344b569fa20df4322c683baacefe4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a8eb00667d47744ac035a69ea30e7a1f8">compute_area</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvilinear integral of the loop.  <a href="#a8eb00667d47744ac035a69ea30e7a1f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1f27117f120c7e3410770e494f9ec885">copy_boundary</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;loop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy loop data into this.  <a href="#a1f27117f120c7e3410770e494f9ec885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee3c12f2d079732c3da45dcc485b8eac"></a><!-- doxytag: member="MGLoop::copy_boundary_without_binders" ref="aee3c12f2d079732c3da45dcc485b8eac" args="(const MGBoundary &amp;loop)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aee3c12f2d079732c3da45dcc485b8eac">copy_boundary_without_binders</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;loop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy boundary data into this, but does not copy the binders. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ac70c682ac66faf7a7d0ffa0f72550c3c">curves</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain vector of curves(TrimmedCurve) of the loop.  <a href="#ac70c682ac66faf7a7d0ffa0f72550c3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ab4a245a80a9cbd78955a5dd7835c19bf">curves_world</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain vector of curves(world coordinate expression) of the loop.  <a href="#ab4a245a80a9cbd78955a5dd7835c19bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff1e4e424ecd1b060e3fb8929cfb1a3"></a><!-- doxytag: member="MGLoop::edge" ref="a9ff1e4e424ecd1b060e3fb8929cfb1a3" args="(size_t i)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a9ff1e4e424ecd1b060e3fb8929cfb1a3">edge</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return i-th edge pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2e0abd3bb8bb82d8768c8e0549b799e"></a><!-- doxytag: member="MGLoop::edge" ref="ab2e0abd3bb8bb82d8768c8e0549b799e" args="(size_t i) const " -->
const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>edge</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae48ca8ac25d2de4eb60ae0c5546a70ad"></a><!-- doxytag: member="MGLoop::edge_exist" ref="ae48ca8ac25d2de4eb60ae0c5546a70ad" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ae48ca8ac25d2de4eb60ae0c5546a70ad">edge_exist</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if at least one edge is included in this loop. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a05d8db5b9ee44632ef57c145fdf25d24">edge_num</a> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> *e) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get edge number in this loop.  <a href="#a05d8db5b9ee44632ef57c145fdf25d24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a265214dd962eacfcc1ee2bfd5c7526f0">end_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return end point of this loop as <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>.  <a href="#a265214dd962eacfcc1ee2bfd5c7526f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ae87fa0caf81b0dc0baeb3f4178d0c746">end_LPoint</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return end point of this loop as <a class="el" href="class_m_g_l_e_point.html" title="MGLEPoint is to represent Loop&#39;s point.">MGLEPoint</a>.  <a href="#ae87fa0caf81b0dc0baeb3f4178d0c746"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ae5963f7adadcfc3d90d46e404d640639">error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get error of this loop.  <a href="#ae5963f7adadcfc3d90d46e404d640639"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4d3f99b6abfd62d2aa07c78faca591e"></a><!-- doxytag: member="MGLoop::eval" ref="ac4d3f99b6abfd62d2aa07c78faca591e" args="(const MGLPoint &amp;t, size_t nderi=0) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ac4d3f99b6abfd62d2aa07c78faca591e">eval</a> (const <a class="el" href="class_m_g_l_point.html">MGLPoint</a> &amp;t, size_t nderi=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the loop at the point t. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a873ff4c8343811b9f7e6e8298bdeba24"></a><!-- doxytag: member="MGLoop::eval" ref="a873ff4c8343811b9f7e6e8298bdeba24" args="(size_t i, double t, size_t nderi=0) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a873ff4c8343811b9f7e6e8298bdeba24">eval</a> (size_t i, double t, size_t nderi=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the loop at i-th edge's parameter t. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aa797a4406b8181d90682e3b028915de9">face</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer of the face.  <a href="#aa797a4406b8181d90682e3b028915de9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee2f41e05e5bd02756c205f83bf7baeb"></a><!-- doxytag: member="MGLoop::face" ref="aee2f41e05e5bd02756c205f83bf7baeb" args="()" -->
<a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aee2f41e05e5bd02756c205f83bf7baeb">face</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> pointer if this <a class="el" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element.">MGGel</a> is an <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, else return null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1696cd533614098de6d5899180e6afb6"></a><!-- doxytag: member="MGLoop::first_edge" ref="a1696cd533614098de6d5899180e6afb6" args="() const " -->
const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1696cd533614098de6d5899180e6afb6">first_edge</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer of the first edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c0343777fa85ab5b2f46e2632fcd4f9"></a><!-- doxytag: member="MGLoop::first_edge" ref="a5c0343777fa85ab5b2f46e2632fcd4f9" args="()" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>first_edge</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aae70334fe084842eb688aa861200c767">get_loop_id_in_face</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the loop id of this loop in the star face baoundary.  <a href="#aae70334fe084842eb688aa861200c767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a45217a39b3cfa214dcc4203ac76ec771">inside</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is inside this loop or not.  <a href="#a45217a39b3cfa214dcc4203ac76ec771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93430c189b85e2c6a235da44f2c4c069"></a><!-- doxytag: member="MGLoop::inside" ref="a93430c189b85e2c6a235da44f2c4c069" args="(const MGPosition &amp;uv) const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>inside</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e4a53888e4912ad4fbc19f0c71d9ee7"></a><!-- doxytag: member="MGLoop::identify_type" ref="a0e4a53888e4912ad4fbc19f0c71d9ee7" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a0e4a53888e4912ad4fbc19f0c71d9ee7">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_cisect__vector.html">MGLCisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a62cf90109654ee0f16d20b833450c05d">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersections of this loop(parameter rep of a face) and param_curve.  <a href="#a62cf90109654ee0f16d20b833450c05d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1e64d7899323bb96498f68277ac0154d">isect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of 1D sub curves of the original loop.  <a href="#a1e64d7899323bb96498f68277ac0154d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_cisect__vector.html">MGLCisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a7f8ea24a0fd9672a66f2cc2156d66bc4">isect_with_endpoints</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersections of this loop(parameter rep of the face) and param_curve.  <a href="#a7f8ea24a0fd9672a66f2cc2156d66bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afadb80f2a6153a313ca507271ac2078f"></a><!-- doxytag: member="MGLoop::is_inactive" ref="afadb80f2a6153a313ca507271ac2078f" args="(const MGFSurface *srf=0) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#afadb80f2a6153a313ca507271ac2078f">is_inactive</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *srf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this loop is inactive or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a840a65261c222644cb7868c8a75ed9c0">is_inner_boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *srf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this loop is inner boundary.  <a href="#a840a65261c222644cb7868c8a75ed9c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a3602898500be5639cbb1a2310aa4b902">is_outer_boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *srf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this loop is outer boundary.  <a href="#a3602898500be5639cbb1a2310aa4b902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a6669baf89c7944f0e1d012a6e29a6011">is_perimeter_boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *srf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this loop is perimeter boundary.  <a href="#a6669baf89c7944f0e1d012a6e29a6011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a347bb2d47636d9d9ed7d5f7def79fc94"></a><!-- doxytag: member="MGLoop::is_network" ref="a347bb2d47636d9d9ed7d5f7def79fc94" args="(const MGFSurface *srf=0) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a347bb2d47636d9d9ed7d5f7def79fc94">is_network</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *srf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this loop is network. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36d422cbd995c9a6adf56342f4ab91ff"></a><!-- doxytag: member="MGLoop::isect" ref="a36d422cbd995c9a6adf56342f4ab91ff" args="(const MGLoop &amp;loop2) const " -->
<a class="el" href="class_m_g_l_lisect__vector.html">MGLLisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a36d422cbd995c9a6adf56342f4ab91ff">isect</a> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;loop2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersections of two loops. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a0520850fee6709a4616c95537277b144">join</a> (bool start, const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;loop2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join two loops.  <a href="#a0520850fee6709a4616c95537277b144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21c845aeb2cd8f9d7cdc264887cabdee"></a><!-- doxytag: member="MGLoop::join" ref="a21c845aeb2cd8f9d7cdc264887cabdee" args="(bool start, MGLoop *loop2)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>join</b> (bool start, <a class="el" href="class_m_g_loop.html">MGLoop</a> *loop2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f62979ac30572aaef7153c494fb5cd2"></a><!-- doxytag: member="MGLoop::join" ref="a4f62979ac30572aaef7153c494fb5cd2" args="(bool start, std::auto_ptr&lt; MGLoop &gt; &amp;loop2)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>join</b> (bool start, std::auto_ptr&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;loop2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12915cce17ce15fdedebd00b17abfeaa"></a><!-- doxytag: member="MGLoop::last_edge" ref="a12915cce17ce15fdedebd00b17abfeaa" args="() const " -->
const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a12915cce17ce15fdedebd00b17abfeaa">last_edge</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return edge pointer of the last edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a060c97ea949b1d618367ad01d7bf9417"></a><!-- doxytag: member="MGLoop::last_edge" ref="a060c97ea949b1d618367ad01d7bf9417" args="()" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>last_edge</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a93c4e59ce176e84d0144c15a47e16ca5">make_close</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make this loop as closed.  <a href="#a93c4e59ce176e84d0144c15a47e16ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a259def63b0170a018a6e42f81b9de8f8">make_vertex</a> (const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;lp, <a class="el" href="class_m_g_edge.html">MGEdge</a> *&amp;pre, <a class="el" href="class_m_g_edge.html">MGEdge</a> *&amp;aft)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a vertex at lp and subdivide the edge into two edges.  <a href="#a259def63b0170a018a6e42f81b9de8f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ee129e25ef3e97fe2c2188926f6570"></a><!-- doxytag: member="MGLoop::manifold_dimension" ref="a37ee129e25ef3e97fe2c2188926f6570" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a37ee129e25ef3e97fe2c2188926f6570">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a845e23d7051cd4ad9e436df37b6e6878">merge_network</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge with param_curve as a network loop.  <a href="#a845e23d7051cd4ad9e436df37b6e6878"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#adb67f59a5de984160fe5c491912a5b09">merge_trim</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge loop2 or param_curve to the existing loop data, and build a loop.  <a href="#adb67f59a5de984160fe5c491912a5b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5e6323451831763af977c8f2737d62a"></a><!-- doxytag: member="MGLoop::merge_trim" ref="aa5e6323451831763af977c8f2737d62a" args="(const MGCurve &amp;param_curve, const MGInterval &amp;range1)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>merge_trim</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e8b110078eaed42cde7e5ab332ce419"></a><!-- doxytag: member="MGLoop::merge_trim" ref="a2e8b110078eaed42cde7e5ab332ce419" args="(const MGCurve &amp;param_curve, const MGCurve &amp;world_curve)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>merge_trim</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;world_curve)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a919747b941f36cd4ece6c5ad07b500f7"></a><!-- doxytag: member="MGLoop::merge_trim" ref="a919747b941f36cd4ece6c5ad07b500f7" args="(const MGCurve &amp;param_curve, const MGInterval &amp;range1, const MGCurve &amp;world_curve)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>merge_trim</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;world_curve)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea37b9d347dde7532fa018a8508f437c"></a><!-- doxytag: member="MGLoop::merge_trim" ref="aea37b9d347dde7532fa018a8508f437c" args="(const MGLoop &amp;loop2)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>merge_trim</b> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;loop2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a0217deb22f44c6c6f51545d18143b5a3">mid_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the mid point of this loop.  <a href="#a0217deb22f44c6c6f51545d18143b5a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a3cb3edc035c3c2c7e04b6675e7d40952">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse the direction of the boundary.  <a href="#a3cb3edc035c3c2c7e04b6675e7d40952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a9a86db2fa1dda6c240a1cea544f4ab97">negate_as_boundary</a> (const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *parent=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the boundary according to the parent cell negation.  <a href="#a9a86db2fa1dda6c240a1cea544f4ab97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf2ede3d64ab6af83ddc3119bd7809de"></a><!-- doxytag: member="MGLoop::number_of_edges" ref="aaf2ede3d64ab6af83ddc3119bd7809de" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aaf2ede3d64ab6af83ddc3119bd7809de">number_of_edges</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of edge included. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a2eeeed0bec56fced2d3b49570f63eea6">on_perimeter_end</a> (size_t &amp;pid_e, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *surf=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if start or end point of the loop is on perimeter of the surface.  <a href="#a2eeeed0bec56fced2d3b49570f63eea6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a233dce45a78a51f02b488f15fd839d03"></a><!-- doxytag: member="MGLoop::on_perimeter_start" ref="a233dce45a78a51f02b488f15fd839d03" args="(size_t &amp;pid_s, const MGFSurface *surf=0) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>on_perimeter_start</b> (size_t &amp;pid_s, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *surf=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bad38e635700f30102aa8e8f07fe536"></a><!-- doxytag: member="MGLoop::on_surface_perimeter" ref="a5bad38e635700f30102aa8e8f07fe536" args="(const MGFace &amp;f) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a5bad38e635700f30102aa8e8f07fe536">on_surface_perimeter</a> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if all the edges included are on a surface perimeter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fe8de3768b7edae5fe6425b8c294819"></a><!-- doxytag: member="MGLoop::out" ref="a5fe8de3768b7edae5fe6425b8c294819" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a5fe8de3768b7edae5fe6425b8c294819">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e27f745e37873f89bb242b07209f3f9"></a><!-- doxytag: member="MGLoop::prepend" ref="a8e27f745e37873f89bb242b07209f3f9" args="(MGEdge *e)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a8e27f745e37873f89bb242b07209f3f9">prepend</a> (<a class="el" href="class_m_g_edge.html">MGEdge</a> *e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend edge to the start of the loop. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ceec8a506ce9b8e52a2a972ea1fa18a"></a><!-- doxytag: member="MGLoop::remove_pendent_edge" ref="a1ceec8a506ce9b8e52a2a972ea1fa18a" args="(const MGFSurface &amp;face)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1ceec8a506ce9b8e52a2a972ea1fa18a">remove_pendent_edge</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove pendent edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89521c87d323d87136d9a5bc69186901"></a><!-- doxytag: member="MGLoop::surface" ref="a89521c87d323d87136d9a5bc69186901" args="() const " -->
const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a89521c87d323d87136d9a5bc69186901">surface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parent surface pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a8d5e18eaf11165fd56287ecb94d5b007">start_LPoint</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return start point of this loop as <a class="el" href="class_m_g_l_e_point.html" title="MGLEPoint is to represent Loop&#39;s point.">MGLEPoint</a>.  <a href="#a8d5e18eaf11165fd56287ecb94d5b007"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ad878e5c041f7e30072987d9747315189">start_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return start point of this loop as <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>.  <a href="#ad878e5c041f7e30072987d9747315189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_m_g_edge.html">MGEdge</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a9ac9667247fa8b84731f6badc230f1fd">subdivide</a> (const std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt; &amp;ranges)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subdivide this loop so that one parameter range in ranges becomes one edge.  <a href="#a9ac9667247fa8b84731f6badc230f1fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ad57336bd9a4973b3a0b5c9aecc8b8df2">subdivide</a> (<a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;le1, <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;le2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subdivide this loop so that one parameter range from le1 to le2 becomes one edge.  <a href="#ad57336bd9a4973b3a0b5c9aecc8b8df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a53e96a6db30ca82c980107dd835ecaf3">trim</a> (const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;t1, const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the loop.  <a href="#a53e96a6db30ca82c980107dd835ecaf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a455743a09d3f59988b3076e291c5064a"></a><!-- doxytag: member="MGLoop::trim_end" ref="a455743a09d3f59988b3076e291c5064a" args="(const MGLEPoint &amp;t1)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a455743a09d3f59988b3076e291c5064a">trim_end</a> (const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the loop. Result is from start to t1. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d20cb3faafef42981d1c9547c9f83e6"></a><!-- doxytag: member="MGLoop::trim_start" ref="a3d20cb3faafef42981d1c9547c9f83e6" args="(const MGLEPoint &amp;t1)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a3d20cb3faafef42981d1c9547c9f83e6">trim_start</a> (const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the loop. Result is from t1 to end. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#abf8ced8c938bd9f5b6a972713d80eb45">MGLoop</a> (std::list&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt; boundaries)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fundamental constructor.  <a href="#abf8ced8c938bd9f5b6a972713d80eb45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a781298c165c360921b859abbe2fea373">MGLoop</a> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;loop, MGCellMap &amp;cmap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor with mapping.  <a href="#a781298c165c360921b859abbe2fea373"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a681c66d11d6be25b2d9fc7bec3101c07">clone</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;parent, MGCellMap &amp;cmap) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone.  <a href="#a681c66d11d6be25b2d9fc7bec3101c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b495c28e5783a562292b494da37c7f5"></a><!-- doxytag: member="MGLoop::clone" ref="a7b495c28e5783a562292b494da37c7f5" args="(MGCellMap &amp;cmap) const " -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>clone</b> (MGCellMap &amp;cmap) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8b4d73725f40673f2feff2e59211846"></a><!-- doxytag: member="MGLoop::whoami" ref="ac8b4d73725f40673f2feff2e59211846" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa49a2064a6c024a0fe138e1ab6267178"></a><!-- doxytag: member="MGLoop::ReadMembers" ref="aa49a2064a6c024a0fe138e1ab6267178" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#aa49a2064a6c024a0fe138e1ab6267178">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32bc219b0ad412703445e1bf7d800f81"></a><!-- doxytag: member="MGLoop::WriteMembers" ref="a32bc219b0ad412703445e1bf7d800f81" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a32bc219b0ad412703445e1bf7d800f81">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6e5cc99c9f14d029d61a74031ded4e"></a><!-- doxytag: member="MGLoop::MGFace" ref="a1f6e5cc99c9f14d029d61a74031ded4e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1f6e5cc99c9f14d029d61a74031ded4e">MGFace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af72d9909f1d3964ebe7e7a084227a5d0"></a><!-- doxytag: member="MGLoop::MGEdge" ref="af72d9909f1d3964ebe7e7a084227a5d0" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#af72d9909f1d3964ebe7e7a084227a5d0">MGEdge</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab264ca5f1cad4df3dc449de3412fbdc8"></a><!-- doxytag: member="MGLoop::edge_from_iterator" ref="ab264ca5f1cad4df3dc449de3412fbdc8" args="(pcellItr i)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#ab264ca5f1cad4df3dc449de3412fbdc8">edge_from_iterator</a> (pcellItr i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get edge pointer from its iterator in <a class="el" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells.">MGComplex</a> of MGBoudarynD. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46191f438691211a38942065189f24e9"></a><!-- doxytag: member="MGLoop::edge_from_iterator" ref="a46191f438691211a38942065189f24e9" args="(const_pcellItr i)" -->
const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>edge_from_iterator</b> (const_pcellItr i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1f81c374ac020347bd2b52ad8ab006f1">eval</a> (const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;t, size_t nderi=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the loop at the point t.  <a href="#a1f81c374ac020347bd2b52ad8ab006f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_loop.html#a1a432c51bb0e630b2151e189d8547ef3">inside_outer_loop</a> (const std::vector&lt; const <a class="el" href="class_m_g_loop.html">MGLoop</a> * &gt; &amp;loop, const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if (u,v) is inside the outer boundary(of std::vector&lt;MGLoop*&gt;&amp; boundaries).  <a href="#a1a432c51bb0e630b2151e189d8547ef3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a> is a boundary of a face, a boundary of 2D manifold cell. </p>
<p><a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a> accepts parameter space curve and world space curve of of a boundary curve, and constructs a boundary of a face from the two types of curves. Input curves direction indicate which part of the face will be target part after trimed by the boundary. In 2D space (u,v) of the parameter space, LEFT side of the parameter curve along the curve's direction is the target part of face. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="afba3b2d80be1fd2e592fbb25de8d6cc0"></a><!-- doxytag: member="MGLoop::LoopKind" ref="afba3b2d80be1fd2e592fbb25de8d6cc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_g_loop.html#afba3b2d80be1fd2e592fbb25de8d6cc0">MGLoop::LoopKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afba3b2d80be1fd2e592fbb25de8d6cc0a92d88d1cffd798a0b467c73a32e49514"></a><!-- doxytag: member="OUTER_LOOP" ref="afba3b2d80be1fd2e592fbb25de8d6cc0a92d88d1cffd798a0b467c73a32e49514" args="" -->OUTER_LOOP</em>&nbsp;</td><td>
<p>must be cloded. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afba3b2d80be1fd2e592fbb25de8d6cc0aab676c70f5ef05583f89fe58269188ea"></a><!-- doxytag: member="INNER_LOOP" ref="afba3b2d80be1fd2e592fbb25de8d6cc0aab676c70f5ef05583f89fe58269188ea" args="" -->INNER_LOOP</em>&nbsp;</td><td>
<p>must be cloded. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a17f9dcbf00405ce90e6b95be1805704a"></a><!-- doxytag: member="MGLoop::MGLoop" ref="a17f9dcbf00405ce90e6b95be1805704a" args="(const MGCurve &amp;param_curve, const MGCurve &amp;world_curve)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLoop::MGLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>world_curve</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Loop of one edge of one curve cell. </p>
<p>param_curve is parameter space representation of the face of which this loop will be a boundary, will make parameter cell. world_curve is world coordinate representation of the face of which this loop will be a boundary, will make binder cell. range1 is parameter range of the curve param_curve, range2 is parameter range of the curve world_curve. When range1,2 are not specified, the start and the end of the curve are treated as their ranges. param_curve and world_curve must have the same direction. </p>

</div>
</div>
<a class="anchor" id="abf8ced8c938bd9f5b6a972713d80eb45"></a><!-- doxytag: member="MGLoop::MGLoop" ref="abf8ced8c938bd9f5b6a972713d80eb45" args="(std::list&lt; MGCellNB * &gt; boundaries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLoop::MGLoop </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fundamental constructor. </p>
<p>Construct from boundary complex(i.e. <a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a>). This constructor takes the ownership of MGCell* in boundary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boundaries</em>&nbsp;</td><td>Boundary data of the super class <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a781298c165c360921b859abbe2fea373"></a><!-- doxytag: member="MGLoop::MGLoop" ref="a781298c165c360921b859abbe2fea373" args="(const MGLoop &amp;loop, MGCellMap &amp;cmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGLoop::MGLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor with mapping. </p>
<p>Binder cells of the pcells in loop will be registered in cmap cellmap to register binder association. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>loop</em>&nbsp;</td><td>original Loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a01f5796b0c191cfd4d04ddc64ad330cf"></a><!-- doxytag: member="MGLoop::append" ref="a01f5796b0c191cfd4d04ddc64ad330cf" args="(MGEdge *edge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td>
          <td class="paramname"> <em>edge</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append edge to the end of loop. </p>
<p>"append" connects the edge's start to the end of the loop. </p>

</div>
</div>
<a class="anchor" id="ac1958a0d626039ef63b08c46c1495f6a"></a><!-- doxytag: member="MGLoop::append_edge_from_crv" ref="ac1958a0d626039ef63b08c46c1495f6a" args="(const MGSurface &amp;srf, const MGCurve &amp;wcrv, double &amp;tLast, double terror, const std::vector&lt; double &gt; &amp;pspan, int peri_num, bool orientation_is_opposite=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::append_edge_from_crv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wcrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>tLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>terror</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pspan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>peri_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>orientation_is_opposite</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build one edge of srf from the curve wcrv on srf and common information pspan and peri_num, which are a perimeter peri_num's parameter spans(psapn). </p>
<p>wcrv must not be a <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. One edge is generated and append to this loop. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wcrv</em>&nbsp;</td><td>curve of world coordinates on this face that may coincide to a perimeter of the surface of this face. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tLast</em>&nbsp;</td><td>wcrv's parameter value to start is input and the end param value of the last edge generated will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>terror</em>&nbsp;</td><td>wcrv's parameter space error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pspan</em>&nbsp;</td><td>common parameter value of a perimeter peri_num. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peri_num</em>&nbsp;</td><td>pspan and peri_num are output of getPerimeterCommon(). Refer to it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orientation_is_opposite</em>&nbsp;</td><td>orientation flag of wcrv to edge. True if opposite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acca4a6777715106dcf6b87b75b68b967"></a><!-- doxytag: member="MGLoop::area" ref="acca4a6777715106dcf6b87b75b68b967" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGLoop::area </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvilinear integral of the parameter space of the area sorrounded by the loop. </p>

</div>
</div>
<a class="anchor" id="a2f508538ea52752298e9399a05fe2510"></a><!-- doxytag: member="MGLoop::both_end_on_perimeter" ref="a2f508538ea52752298e9399a05fe2510" args="(size_t &amp;pid_s, size_t &amp;pid_e, const MGFSurface *srf=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::both_end_on_perimeter </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>pid_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>pid_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>srf</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if loop is a perimeter boundary or not. </p>
<p>If yes, get the perimeter ids. pid_s, e are valid only when <a class="el" href="class_m_g_loop.html#a2f508538ea52752298e9399a05fe2510" title="Test if loop is a perimeter boundary or not.">both_end_on_perimeter()</a> is true, contain perimeter numbers of the start or end of the loop. </p>

</div>
</div>
<a class="anchor" id="aca2915ed89d1bd52afaf0072f48c45af"></a><!-- doxytag: member="MGLoop::clone" ref="aca2915ed89d1bd52afaf0072f48c45af" args="(MGCell &amp;parent) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_loop.html">MGLoop</a>* MGLoop::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone. </p>
<p>Output is a newed object, must be deleted by calling program. </p>

<p>Implements <a class="el" href="class_m_g_boundary.html#ad0c3d93096d2338e542ec119dc46aac8">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="a9675c0e77ade5b4ebd3f62fce826f90c"></a><!-- doxytag: member="MGLoop::clone" ref="a9675c0e77ade5b4ebd3f62fce826f90c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_loop.html">MGLoop</a>* MGLoop::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_boundary.html#a545ab978b74513d4bf83fba61de8028d">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="a681c66d11d6be25b2d9fc7bec3101c07"></a><!-- doxytag: member="MGLoop::clone" ref="a681c66d11d6be25b2d9fc7bec3101c07" args="(MGCell &amp;parent, MGCellMap &amp;cmap) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_loop.html">MGLoop</a>* MGLoop::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone. </p>
<p>The forms that have cmap as an argumetnt is to register binder association. Returned is pointer of newed object, must be deleted. When parent is specified, clone's parent is set to the parent. </p>

<p>Implements <a class="el" href="class_m_g_boundary.html#aa6831d69243fa31cdb90c028b81dfab1">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="a17cc2fbb32e4bda10316d10ae0a5a73c"></a><!-- doxytag: member="MGLoop::clone_without_binders" ref="a17cc2fbb32e4bda10316d10ae0a5a73c" args="(MGCell &amp;parent) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_loop.html">MGLoop</a>* MGLoop::clone_without_binders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone that has not binders. </p>
<p>Output is a newed object, must be deleted by calling program. </p>

<p>Implements <a class="el" href="class_m_g_boundary.html#ae875574006b65c3a5bc4f7cf03799762">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="aa6ef41050035050b0ff43ee8b8ce7626"></a><!-- doxytag: member="MGLoop::closest" ref="aa6ef41050035050b0ff43ee8b8ce7626" args="(const MGPosition &amp;P, double &amp;distance) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> MGLoop::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute closest point from the point P to this loop. </p>
<p>Returned is the loop's point, and distance is the length of distance between P and <a class="el" href="class_m_g_l_e_point.html" title="MGLEPoint is to represent Loop&#39;s point.">MGLEPoint</a>. All the coordinate values are of parameter space of the face's surface. </p>

</div>
</div>
<a class="anchor" id="af9344b569fa20df4322c683baacefe4f"></a><!-- doxytag: member="MGLoop::common" ref="af9344b569fa20df4322c683baacefe4f" args="(const MGLoop &amp;loop2, std::vector&lt; MGLEPoint &gt; &amp;pranges1, std::vector&lt; double &gt; &amp;branges1, std::vector&lt; MGLEPoint &gt; &amp;pranges2, std::vector&lt; double &gt; &amp;branges2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGLoop::common </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>loop2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pranges1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>branges1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pranges2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>branges2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute common range of two loops, this and loop2. </p>
<p>Function's return value is number of ranges obtained. In variable ranges, common ranges are output as: Let n be output of the function, then ranges1.size()=ranges2.size()=2*n. ranges1[2*i+0] and ranges1[2*i+1] are parameter values of this loop, and ranges2[2*i+0] and ranges2[2*i+1] are parameter values of loop2. Although ranges1[2*i+0] &lt; ranges1[2*i+1] always holds, ranges2[2*i+0] &lt; ranges2[2*i+1], or ranges2[2*i+0] &gt; ranges2[2*i+1]. Let f1() be this loop, and f2() be loop2, then f1(ranges1[j]) and f2(ranges2[j]) represent the same point in star Face world for 0&lt;=j&lt;n*2 . This and loop2 must have each star faces. </p>

</div>
</div>
<a class="anchor" id="a8eb00667d47744ac035a69ea30e7a1f8"></a><!-- doxytag: member="MGLoop::compute_area" ref="a8eb00667d47744ac035a69ea30e7a1f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGLoop::compute_area </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvilinear integral of the loop. </p>
<p>Computation is done in the parameter space of the face. </p>

</div>
</div>
<a class="anchor" id="a1f27117f120c7e3410770e494f9ec885"></a><!-- doxytag: member="MGLoop::copy_boundary" ref="a1f27117f120c7e3410770e494f9ec885" args="(const MGBoundary &amp;loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::copy_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>loop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy loop data into this. </p>
<p>This boundary data is cleared and loop's boundary is copied into this. </p>

<p>Reimplemented from <a class="el" href="class_m_g_boundary.html#a82fed4d90fa65d6680136a62623bf7ea">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="ac70c682ac66faf7a7d0ffa0f72550c3c"></a><!-- doxytag: member="MGLoop::curves" ref="ac70c682ac66faf7a7d0ffa0f72550c3c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGLoop::curves </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain vector of curves(TrimmedCurve) of the loop. </p>
<p>The curves are of parameter space expression. </p>

</div>
</div>
<a class="anchor" id="ab4a245a80a9cbd78955a5dd7835c19bf"></a><!-- doxytag: member="MGLoop::curves_world" ref="ab4a245a80a9cbd78955a5dd7835c19bf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGLoop::curves_world </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain vector of curves(world coordinate expression) of the loop. </p>
<p>Output curves are <a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a> of edge's binders. When some of the edges do not have binders, they will be created. </p>

</div>
</div>
<a class="anchor" id="a05d8db5b9ee44632ef57c145fdf25d24"></a><!-- doxytag: member="MGLoop::edge_num" ref="a05d8db5b9ee44632ef57c145fdf25d24" args="(const MGEdge *e) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGLoop::edge_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get edge number in this loop. </p>
<p>If e is not a member of this loop, 0 will be returned. </p>

</div>
</div>
<a class="anchor" id="ae87fa0caf81b0dc0baeb3f4178d0c746"></a><!-- doxytag: member="MGLoop::end_LPoint" ref="ae87fa0caf81b0dc0baeb3f4178d0c746" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> MGLoop::end_LPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return end point of this loop as <a class="el" href="class_m_g_l_e_point.html" title="MGLEPoint is to represent Loop&#39;s point.">MGLEPoint</a>. </p>
<p>loop must include at least one edge, or this output is undefined. </p>

</div>
</div>
<a class="anchor" id="a265214dd962eacfcc1ee2bfd5c7526f0"></a><!-- doxytag: member="MGLoop::end_point" ref="a265214dd962eacfcc1ee2bfd5c7526f0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGLoop::end_point </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return end point of this loop as <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>. </p>
<p>The point is of parameter space. </p>

</div>
</div>
<a class="anchor" id="ae5963f7adadcfc3d90d46e404d640639"></a><!-- doxytag: member="MGLoop::error" ref="ae5963f7adadcfc3d90d46e404d640639" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGLoop::error </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get error of this loop. </p>
<p>This is obtained from the parent surface. If parent surface did not exist, error=the box of the loop by relative zero. </p>

</div>
</div>
<a class="anchor" id="aa797a4406b8181d90682e3b028915de9"></a><!-- doxytag: member="MGLoop::face" ref="aa797a4406b8181d90682e3b028915de9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_face.html">MGFace</a>* MGLoop::face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return pointer of the face. </p>
<p>If the loop is not a boundary of any face, null will be returned. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="aae70334fe084842eb688aa861200c767"></a><!-- doxytag: member="MGLoop::get_loop_id_in_face" ref="aae70334fe084842eb688aa861200c767" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGLoop::get_loop_id_in_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the loop id of this loop in the star face baoundary. </p>
<p>Let face=face(), then face-&gt;loop(<a class="el" href="class_m_g_loop.html#aae70334fe084842eb688aa861200c767" title="Get the loop id of this loop in the star face baoundary.">get_loop_id_in_face()</a>)=this; When this does not have star face, or this is not a boundary of a face, -1 will be returned. </p>

</div>
</div>
<a class="anchor" id="a45217a39b3cfa214dcc4203ac76ec771"></a><!-- doxytag: member="MGLoop::inside" ref="a45217a39b3cfa214dcc4203ac76ec771" args="(double u, double v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGLoop::inside </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if parameter value (u,v) is inside this loop or not. </p>
<p>inside means inside face, that is, if the loop is inner, outside inner loops and if the loop is outer boundary loop, inside the outer boundary loop. This can be used for perimeter boundary loops. Returned is: 0:outside(not on the loop) 1:unknown 2:inside(not on the loop) otherwise:on the loop(size_t(MGEdge* of parameter edge))will be returned. </p>

</div>
</div>
<a class="anchor" id="a840a65261c222644cb7868c8a75ed9c0"></a><!-- doxytag: member="MGLoop::is_inner_boundary" ref="a840a65261c222644cb7868c8a75ed9c0" args="(const MGFSurface *srf=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::is_inner_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>srf</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this loop is inner boundary. </p>
<p>Inner boundary is: (1) closed loop. (2) the direction is clockwise. </p>

</div>
</div>
<a class="anchor" id="a3602898500be5639cbb1a2310aa4b902"></a><!-- doxytag: member="MGLoop::is_outer_boundary" ref="a3602898500be5639cbb1a2310aa4b902" args="(const MGFSurface *srf=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::is_outer_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>srf</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this loop is outer boundary. </p>
<p>outer boundary is: (1) closed loop. (2) the direction is anti-clockwise. </p>

</div>
</div>
<a class="anchor" id="a6669baf89c7944f0e1d012a6e29a6011"></a><!-- doxytag: member="MGLoop::is_perimeter_boundary" ref="a6669baf89c7944f0e1d012a6e29a6011" args="(const MGFSurface *srf=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::is_perimeter_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>srf</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this loop is perimeter boundary. </p>
<p>Perimeter boundary is: both ends are on the surface perimeter. </p>

</div>
</div>
<a class="anchor" id="a62cf90109654ee0f16d20b833450c05d"></a><!-- doxytag: member="MGLoop::isect" ref="a62cf90109654ee0f16d20b833450c05d" args="(const MGCurve &amp;param_curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_cisect__vector.html">MGLCisect_vector</a> MGLoop::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param_curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersections of this loop(parameter rep of a face) and param_curve. </p>

</div>
</div>
<a class="anchor" id="a1e64d7899323bb96498f68277ac0154d"></a><!-- doxytag: member="MGLoop::isect_1D" ref="a1e64d7899323bb96498f68277ac0154d" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a>&gt; MGLoop::isect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of 1D sub curves of the original loop. </p>
<p>Parameter values of intersection points(MGLEPoint's) will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f8ea24a0fd9672a66f2cc2156d66bc4"></a><!-- doxytag: member="MGLoop::isect_with_endpoints" ref="a7f8ea24a0fd9672a66f2cc2156d66bc4" args="(const MGCurve &amp;param_curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_cisect__vector.html">MGLCisect_vector</a> MGLoop::isect_with_endpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param_curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersections of this loop(parameter rep of the face) and param_curve. </p>
<p><a class="el" href="class_m_g_loop.html#a7f8ea24a0fd9672a66f2cc2156d66bc4" title="Compute intersections of this loop(parameter rep of the face) and param_curve.">isect_with_endpoints()</a> includes endpoints of both if they are close enough (within tolerance). </p>

</div>
</div>
<a class="anchor" id="a0520850fee6709a4616c95537277b144"></a><!-- doxytag: member="MGLoop::join" ref="a0520850fee6709a4616c95537277b144" args="(bool start, const MGLoop &amp;loop2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::join </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>loop2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join two loops. </p>
<p>start indicates which end of this loop loop2 should be connected to. start=true: connect start of this and loop2's end. start=false: connect end of this and loop2's start. The 2nd form takes the ownership of loop2, will delete loop2. </p>

</div>
</div>
<a class="anchor" id="a93c4e59ce176e84d0144c15a47e16ca5"></a><!-- doxytag: member="MGLoop::make_close" ref="a93c4e59ce176e84d0144c15a47e16ca5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::make_close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make this loop as closed. </p>
<p>This loop's 1st edge's start point must be the same as the last edge's end point. However, this is not tested in make_close. </p>

</div>
</div>
<a class="anchor" id="a259def63b0170a018a6e42f81b9de8f8"></a><!-- doxytag: member="MGLoop::make_vertex" ref="a259def63b0170a018a6e42f81b9de8f8" args="(const MGLEPoint &amp;lp, MGEdge *&amp;pre, MGEdge *&amp;aft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::make_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>aft</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a vertex at lp and subdivide the edge into two edges. </p>
<p>Returned is true if subdivision is done and false if no subdivision is done since lp was one of existed vertex. When function's return value is true, pre is always the same edge as lp's edge and the iterator is unchanged. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lp</em>&nbsp;</td><td>point to subdivide of this loop. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pre</em>&nbsp;</td><td>pre and aft-edge of the lp will be output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aft</em>&nbsp;</td><td>after make_vertex's execution, may be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a845e23d7051cd4ad9e436df37b6e6878"></a><!-- doxytag: member="MGLoop::merge_network" ref="a845e23d7051cd4ad9e436df37b6e6878" args="(const MGCurve &amp;param_curve)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::merge_network </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param_curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge with param_curve as a network loop. </p>
<p>Function's return value is: true: merge is done and param_curve is processed into this loop as a network. false: merge is not performed since no intersection with this loop were found. When false is returned, this loop does not have the input param_curve information as an edge information. This loop must not be empty loop, ant the kind is always changed to NETWORK. </p>

</div>
</div>
<a class="anchor" id="adb67f59a5de984160fe5c491912a5b09"></a><!-- doxytag: member="MGLoop::merge_trim" ref="adb67f59a5de984160fe5c491912a5b09" args="(const MGCurve &amp;param_curve)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::merge_trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param_curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge loop2 or param_curve to the existing loop data, and build a loop. </p>
<p>Returned is if merge was done(true) or not(false). When no intersection was found, merge is not executed. param_curve is parameter space representation of the face of which this loop will be a boundary, will make parameter cell. world_curve is world coordinate representation of the face of which this loop will be a boundary, will make binder cell. range1 is parameter range of the curve param_curve. When world_curve is input, it will be trimmed accordin to the range of param_curve. param_curve and world_curve may be opposite direction. When more than one closed loops are detected, first one from the old loop start point is employed, and other loops are discarded. </p>

</div>
</div>
<a class="anchor" id="a0217deb22f44c6c6f51545d18143b5a3"></a><!-- doxytag: member="MGLoop::mid_point" ref="a0217deb22f44c6c6f51545d18143b5a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGLoop::mid_point </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the mid point of this loop. </p>
<p>Mid point is the point of the mid point of m-th edge, where m=number_edges()/2. </p>

</div>
</div>
<a class="anchor" id="a3cb3edc035c3c2c7e04b6675e7d40952"></a><!-- doxytag: member="MGLoop::negate" ref="a3cb3edc035c3c2c7e04b6675e7d40952" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::negate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse the direction of the boundary. </p>
<p>(Coordinate transformation is not performed.) </p>

<p>Reimplemented from <a class="el" href="class_m_g_boundary.html#a50aa2454407bfe1876cb15df444be653">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="a9a86db2fa1dda6c240a1cea544f4ab97"></a><!-- doxytag: member="MGLoop::negate_as_boundary" ref="a9a86db2fa1dda6c240a1cea544f4ab97" args="(const MGCellNB *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::negate_as_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate the boundary according to the parent cell negation. </p>
<p>That is, 1. Transform the coordinates of the bondary cell. (This transfromation depends on how the parent cell is transformed when <a class="el" href="class_m_g_loop.html#a3cb3edc035c3c2c7e04b6675e7d40952" title="Reverse the direction of the boundary.">negate()</a> is invoked. So, the member cells of this boundary are transformed by negate_transoform of the parent cell.) 2. Reverse the direction of the parameter cells(negate each cell). 3. Reverse the ordering of the parameter cells. 4. Negate the binders. </p>

<p>Reimplemented from <a class="el" href="class_m_g_boundary.html#a5a367f41a49785616d35eefeb5288778">MGBoundary</a>.</p>

</div>
</div>
<a class="anchor" id="a2eeeed0bec56fced2d3b49570f63eea6"></a><!-- doxytag: member="MGLoop::on_perimeter_end" ref="a2eeeed0bec56fced2d3b49570f63eea6" args="(size_t &amp;pid_e, const MGFSurface *surf=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::on_perimeter_end </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>pid_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>surf</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if start or end point of the loop is on perimeter of the surface. </p>
<p>Returned is true when on perimeter, false if not. When on perimeter, perimeter number of the surface is returned in pid_x. </p>

</div>
</div>
<a class="anchor" id="a46a0215e6e93e93eb86cba0dd0cad332"></a><!-- doxytag: member="MGLoop::operator&lt;" ref="a46a0215e6e93e93eb86cba0dd0cad332" args="(const MGLoop &amp;gel2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGLoop::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This operator is to sort loops in the order: 1. </p>
<p>Perimeter boundary. 2. Outer boundary. 3. Inner boundary. 4. Inactive loop. </p>

</div>
</div>
<a class="anchor" id="a843f58910e6f890d5f415b3322cf69f5"></a><!-- doxytag: member="MGLoop::operator=" ref="a843f58910e6f890d5f415b3322cf69f5" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_loop.html">MGLoop</a>&amp; MGLoop::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and bnd2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_complex.html#a68677e75e2739903c83c9dc8d15bd27e">MGComplex</a>.</p>

</div>
</div>
<a class="anchor" id="a8d5e18eaf11165fd56287ecb94d5b007"></a><!-- doxytag: member="MGLoop::start_LPoint" ref="a8d5e18eaf11165fd56287ecb94d5b007" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> MGLoop::start_LPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return start point of this loop as <a class="el" href="class_m_g_l_e_point.html" title="MGLEPoint is to represent Loop&#39;s point.">MGLEPoint</a>. </p>
<p>loop must include at least one edge, or this output is undefined. </p>

</div>
</div>
<a class="anchor" id="ad878e5c041f7e30072987d9747315189"></a><!-- doxytag: member="MGLoop::start_point" ref="ad878e5c041f7e30072987d9747315189" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGLoop::start_point </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return start point of this loop as <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>. </p>
<p>The point is of parameter space. </p>

</div>
</div>
<a class="anchor" id="a9ac9667247fa8b84731f6badc230f1fd"></a><!-- doxytag: member="MGLoop::subdivide" ref="a9ac9667247fa8b84731f6badc230f1fd" args="(const std::vector&lt; MGLEPoint &gt; &amp;ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_m_g_edge.html">MGEdge</a>*&gt; MGLoop::subdivide </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ranges</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subdivide this loop so that one parameter range in ranges becomes one edge. </p>
<p>In ranges, parameter range of this loop is stored as: Let n=ranges.size()/2, then span from ranges[2*i] to ranges[2*i+1] is one parameter span that is supposed to be one edge for 0&lt;=i&lt;n. Returned are new edge pointers that correspond to ranges[2*i] to ranges[2*i+1] after subdivided for 0&lt;=i&lt;n. Currently this does not conform to non_manifold model. That is, this loop must not have partner edges already. </p>

</div>
</div>
<a class="anchor" id="ad57336bd9a4973b3a0b5c9aecc8b8df2"></a><!-- doxytag: member="MGLoop::subdivide" ref="ad57336bd9a4973b3a0b5c9aecc8b8df2" args="(MGLEPoint &amp;le1, MGLEPoint &amp;le2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGLoop::subdivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>le1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>le2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subdivide this loop so that one parameter range from le1 to le2 becomes one edge. </p>
<p>le1, and 2 must be of the same edge. new edge between le1 and le2 will be output. </p>

</div>
</div>
<a class="anchor" id="a53e96a6db30ca82c980107dd835ecaf3"></a><!-- doxytag: member="MGLoop::trim" ref="a53e96a6db30ca82c980107dd835ecaf3" args="(const MGLEPoint &amp;t1, const MGLEPoint &amp;t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGLoop::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the loop. </p>
<p>Result loop is from t1 to t2; The loop can be closed one. In this case, t1 can be &gt;t2. When not closed, t1 must be less than t2. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a1f81c374ac020347bd2b52ad8ab006f1"></a><!-- doxytag: member="MGLoop::eval" ref="a1f81c374ac020347bd2b52ad8ab006f1" args="(const MGLEPoint &amp;t, size_t nderi=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_e_point.html">MGLEPoint</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderi</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the loop at the point t. </p>
<p>When nderi=0, get a parameter (u,v) of the surface at the boundary point. </p>

</div>
</div>
<a class="anchor" id="a1a432c51bb0e630b2151e189d8547ef3"></a><!-- doxytag: member="MGLoop::inside_outer_loop" ref="a1a432c51bb0e630b2151e189d8547ef3" args="(const std::vector&lt; const MGLoop * &gt; &amp;loop, const MGSurface &amp;surf, const MGPosition &amp;uv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t inside_outer_loop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_loop.html">MGLoop</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if (u,v) is inside the outer boundary(of std::vector&lt;MGLoop*&gt;&amp; boundaries). </p>
<p>Inside the outer boundary means that inside outer_boudary_param() or not. This must not be used for faces that do not have perimeter or outer boundary loop. Function's return value is: 0:outside the outer boundary(not on a loop) 1:unknown 2:inside the outer boundary(not on a loop) otherwise:on the outer boundary loop </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Loop.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:25 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

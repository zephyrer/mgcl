<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGFace Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGFace Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGFace" --><!-- doxytag: inherits="MGCell,MGFSurface" -->
<p><a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> is a trimmed surface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Face.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGFace:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_face__inherit__graph.png" border="0" usemap="#_m_g_face_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_face_inherit__map" id="_m_g_face_inherit__map">
<area shape="rect" id="node2" href="class_m_g_cell.html" title="MGCell is a general cell that has bound." alt="" coords="27,469,91,499"/><area shape="rect" id="node4" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="17,392,100,421"/><area shape="rect" id="node6" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="12,315,105,344"/><area shape="rect" id="node8" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="12,237,105,267"/><area shape="rect" id="node10" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node12" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node14" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node16" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="115,469,208,499"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGFace:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_face__coll__graph.png" border="0" usemap="#_m_g_face_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_face_coll__map" id="_m_g_face_coll__map">
<area shape="rect" id="node2" href="class_m_g_cell.html" title="MGCell is a general cell that has bound." alt="" coords="271,773,335,803"/><area shape="rect" id="node4" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="140,677,223,707"/><area shape="rect" id="node6" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="61,773,155,803"/><area shape="rect" id="node8" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="5,485,99,515"/><area shape="rect" id="node34" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="57,581,151,611"/><area shape="rect" id="node10" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="47,373,127,403"/><area shape="rect" id="node25" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="175,581,273,611"/><area shape="rect" id="node12" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="9,85,116,115"/><area shape="rect" id="node18" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="117,181,195,211"/><area shape="rect" id="node14" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="32,5,93,35"/><area shape="rect" id="node16" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="100,261,212,291"/><area shape="rect" id="node21" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="140,85,273,115"/><area shape="rect" id="node28" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="259,485,325,515"/><area shape="rect" id="node30" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="251,373,333,403"/><area shape="rect" id="node32" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="253,261,331,291"/><area shape="rect" id="node39" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="409,773,503,803"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_face-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb2313dc21470f90066f31f2ba2f425"></a><!-- doxytag: member="MGFace::MGFace" ref="a3bb2313dc21470f90066f31f2ba2f425" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a3bb2313dc21470f90066f31f2ba2f425">MGFace</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Null face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34cfe2de6225d22b4d81be954d058904"></a><!-- doxytag: member="MGFace::MGFace" ref="a34cfe2de6225d22b4d81be954d058904" args="(const MGFace &amp;face, bool copy_boundary=true, bool no_binder=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a34cfe2de6225d22b4d81be954d058904">MGFace</a> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;face, bool copy_boundary=true, bool no_binder=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#adab7b92bc6a475182f2684c4d161663c">MGFace</a> (<a class="el" href="class_m_g_surface.html">MGSurface</a> *geo, std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;boundaries, <a class="el" href="class_m_g_cell.html">MGCell</a> *binder)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fundamental constructor.  <a href="#adab7b92bc6a475182f2684c4d161663c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e5404401d310d812ee738ae7106d32"></a><!-- doxytag: member="MGFace::MGFace" ref="ad4e5404401d310d812ee738ae7106d32" args="(const MGSurface &amp;surf)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad4e5404401d310d812ee738ae7106d32">MGFace</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Face of whole surface of no boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4fb0665d79bc71490c6fe4aae32f0d2"></a><!-- doxytag: member="MGFace::MGFace" ref="aa4fb0665d79bc71490c6fe4aae32f0d2" args="(const MGFSurface &amp;surf)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aa4fb0665d79bc71490c6fe4aae32f0d2">MGFace</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;surf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion constructor from <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a> to <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a597035ed7f4aa48b30143472fc091d33">MGFace</a> (<a class="el" href="class_m_g_surface.html">MGSurface</a> *surf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Face of whole surface of no boundary.  <a href="#a597035ed7f4aa48b30143472fc091d33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a8b32f18adc787d087f3e809e3d363321">MGFace</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf, const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;boundaries)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a face by copying boundaries(only parameter rep of the boundary) from argument boundaries.  <a href="#a8b32f18adc787d087f3e809e3d363321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a041641f9ac043fbe7d7dfe92c9a25e2a"></a><!-- doxytag: member="MGFace::MGFace" ref="a041641f9ac043fbe7d7dfe92c9a25e2a" args="(MGSurface *surf, const std::vector&lt; MGBoundary * &gt; &amp;boundaries)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGFace</b> (<a class="el" href="class_m_g_surface.html">MGSurface</a> *surf, const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;boundaries)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a383edd3d4d9ad804d06dd37d940ed5a7">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a383edd3d4d9ad804d06dd37d940ed5a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb8643ae95df239699d6b26e4f54cfdf"></a><!-- doxytag: member="MGFace::operator=" ref="abb8643ae95df239699d6b26e4f54cfdf" args="(const MGFace &amp;gel2)" -->
<a class="el" href="class_m_g_face.html">MGFace</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d8c3dd33c20f57deb168da3acc8da0a"></a><!-- doxytag: member="MGFace::operator+" ref="a5d8c3dd33c20f57deb168da3acc8da0a" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a5d8c3dd33c20f57deb168da3acc8da0a">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faceに平行移動を行ないオブジェクトを生成する。 Translation of the Face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aaff26536313edacde46c49cb17c116"></a><!-- doxytag: member="MGFace::operator&#45;" ref="a1aaff26536313edacde46c49cb17c116" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1aaff26536313edacde46c49cb17c116">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faceに逆方向の平行移動を行ないオブジェクトを生成する。 Translation of the Face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a330fe774c7fcbfe2e88d9582456252f4">operator*</a> (double s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faceのスケーリングを行い，Faceを作成する。 Scaling of the Face by a double.  <a href="#a330fe774c7fcbfe2e88d9582456252f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ab20c09437eace52e8b2099810637500a">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換でFaceの変換を行い，Faceを作成する。 Transformation of the Face by a matrix.  <a href="#ab20c09437eace52e8b2099810637500a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a27bd4ca908e81c8862b2900c224bbe67">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換によってトランスフォームをおこないFaceを生成する。 Transformation of the Face by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>.  <a href="#a27bd4ca908e81c8862b2900c224bbe67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a21d731491c4a437aed18b6334fa64f01">operator/</a> (double s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double.  <a href="#a21d731491c4a437aed18b6334fa64f01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e71778e0c3153f76c7605d4e2ae6ae3"></a><!-- doxytag: member="MGFace::operator&lt;" ref="a9e71778e0c3153f76c7605d4e2ae6ae3" args="(const MGFace &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a9e71778e0c3153f76c7605d4e2ae6ae3">operator&lt;</a> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e49ec691836fb4517dbc0c9e3cc1a1e"></a><!-- doxytag: member="MGFace::operator&lt;" ref="a7e49ec691836fb4517dbc0c9e3cc1a1e" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1f8bdde02b00a900d75e331007b5db6"></a><!-- doxytag: member="MGFace::out_to_IGES" ref="ad1f8bdde02b00a900d75e331007b5db6" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad1f8bdde02b00a900d75e331007b5db6">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PD144=MGFace. Output to PD144(Trimmed surface). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dca54d0e4267f27967184d66ee2d132"></a><!-- doxytag: member="MGFace::out" ref="a7dca54d0e4267f27967184d66ee2d132" args="(std::ostream &amp;ostrm) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a7dca54d0e4267f27967184d66ee2d132">out</a> (std::ostream &amp;ostrm) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a814da67419f30546b24eaa9bef78eb78"></a><!-- doxytag: member="MGFace::outFS" ref="a814da67419f30546b24eaa9bef78eb78" args="(std::ostream &amp;ostrm) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a814da67419f30546b24eaa9bef78eb78">outFS</a> (std::ostream &amp;ostrm) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a55c5c75795d6fa0f5dc35a13675009d4">add_boundary</a> (<a class="el" href="class_m_g_loop.html">MGLoop</a> *nloop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new loop to this face as aboundary.  <a href="#a55c5c75795d6fa0f5dc35a13675009d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a74b3b93a12a333d752020c1b49cf6db0">arrow</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate arrow data of the tangent along u and v and the normal at the parameter value (u,v) of the surface.  <a href="#a74b3b93a12a333d752020c1b49cf6db0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a997f22fac905c2b172caa89ce62a9f3a"></a><!-- doxytag: member="MGFace::arrow" ref="a997f22fac905c2b172caa89ce62a9f3a" args="(const MGPosition &amp;uv, MGPosition data[10]) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>arrow</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a50b9de439df79b17c709f148bfc945ea">append_boundary</a> (<a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bound)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append new one boundary to boundary vectors.  <a href="#a50b9de439df79b17c709f148bfc945ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad129cfba174eb8efac8ba3c30ae0126f">binder_face</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain binder face pointer.  <a href="#ad129cfba174eb8efac8ba3c30ae0126f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a48ce8a7adab1cb4f7c8fe9a04905d333">face_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the boundary curves(world coordinates representation) of the face.  <a href="#a48ce8a7adab1cb4f7c8fe9a04905d333"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a6fd7e35e48e1073fa35e79a7f60cd054">box_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return box of the parameter space of the face.  <a href="#a6fd7e35e48e1073fa35e79a7f60cd054"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a5ec7d4640196d2dcefc2ff9c65b86a55">box_param2</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return box of the parameter space of the FSurface.  <a href="#a5ec7d4640196d2dcefc2ff9c65b86a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#abdbb0f93833478fa597c7d01c985fe0a">build_loop</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a loop of this face, given a closed curve crv on this face.  <a href="#abdbb0f93833478fa597c7d01c985fe0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a06c758e6d7a93c47781c32197481d8aa">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of the cell.  <a href="#a06c758e6d7a93c47781c32197481d8aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c0c01c1399da5e2931543be3619070a"></a><!-- doxytag: member="MGFace::clone_without_boundaries" ref="a1c0c01c1399da5e2931543be3619070a" args="() const " -->
<a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>clone_without_boundaries</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b1f2d7adb04d4676d1a4b4c63bf959"></a><!-- doxytag: member="MGFace::clone_fsurface" ref="ac3b1f2d7adb04d4676d1a4b4c63bf959" args="() const " -->
<a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ac3b1f2d7adb04d4676d1a4b4c63bf959">clone_fsurface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the clone of this <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ac324ccb46e913738c3370c015a7f5bb3">clone_as_face</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the clone of this as a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>.  <a href="#ac324ccb46e913738c3370c015a7f5bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1932e4c29acbd2e22b0bc9b2341c1959">clone_binder</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;f) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of this(this is a binder), and set binder and parameter cell relation between the new binder and the parameter cell f.  <a href="#a1932e4c29acbd2e22b0bc9b2341c1959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aa316bfc80da17272e5af026758de0957">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute closest point from a point.  <a href="#aa316bfc80da17272e5af026758de0957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a57ee47cb85783c02acb714f6f7806c25">closest_on_boundary</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute closest point from a line to the boundary of the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>.  <a href="#a57ee47cb85783c02acb714f6f7806c25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76145f726c775ef15e607ead8a639b60"></a><!-- doxytag: member="MGFace::display_arrows" ref="a76145f726c775ef15e607ead8a639b60" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_arrows</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e8f418aa3866e3f5200752894376d93"></a><!-- doxytag: member="MGFace::display_control_polygon" ref="a4e8f418aa3866e3f5200752894376d93" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_control_polygon</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a99b98caf25eb34bbd8f4ef75ab6ea7cf">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#a99b98caf25eb34bbd8f4ef75ab6ea7cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a7e335291d107ca99cb14b424bcd4486b">draw3DVertex</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D point(vertex) in world coordinates.  <a href="#a7e335291d107ca99cb14b424bcd4486b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a505374b4568be40dfcedaf0b1a585549">shade</a> (double span_length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shade the object in world coordinates.  <a href="#a505374b4568be40dfcedaf0b1a585549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#af2ffcdfe9e259e94475d2d8ec888bbd5">equal_direction</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;wcurves, const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;pcurves, size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if directions of parameter curve and world curve of the face boundary is equal or not.  <a href="#af2ffcdfe9e259e94475d2d8ec888bbd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a9cd3a45812dab6f742c64017e7fef985">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase i-th loop.  <a href="#a9cd3a45812dab6f742c64017e7fef985"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a36fc03dc036fcb63ddf1a35a6aaf4282">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a471bdcf6ccc61c1f7ca33d622947b1d9"></a><!-- doxytag: member="MGFace::extract_loops" ref="a471bdcf6ccc61c1f7ca33d622947b1d9" args="(std::vector&lt; const MGLoop * &gt; &amp;loops) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a471bdcf6ccc61c1f7ca33d622947b1d9">extract_loops</a> (std::vector&lt; const <a class="el" href="class_m_g_loop.html">MGLoop</a> * &gt; &amp;loops) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract all the loops of this face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a03f68dcb99233d60ea30e9f0b057683d">extract_sub_face</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;networks, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, std::auto_ptr&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;face) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract sub face that is bounded by networks loops.  <a href="#a03f68dcb99233d60ea30e9f0b057683d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93af63cff23d5c7aa7e98667b397f61f"></a><!-- doxytag: member="MGFace::face" ref="a93af63cff23d5c7aa7e98667b397f61f" args="()" -->
<a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a93af63cff23d5c7aa7e98667b397f61f">face</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> pointer if this <a class="el" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element.">MGGel</a> is an <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, else return null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56c1ed5f5ad884c8428c6c6a08eed716"></a><!-- doxytag: member="MGFace::face" ref="a56c1ed5f5ad884c8428c6c6a08eed716" args="() const " -->
const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>face</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab42156c50dac956f65b21ec7527804ec"></a><!-- doxytag: member="MGFace::fsurface" ref="ab42156c50dac956f65b21ec7527804ec" args="() const " -->
const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ab42156c50dac956f65b21ec7527804ec">fsurface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a> pointer if this is <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> or <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af44a0831fd6610d041959fa0652d4d14"></a><!-- doxytag: member="MGFace::fsurface" ref="af44a0831fd6610d041959fa0652d4d14" args="()" -->
<a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fsurface</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad035a0522e4c56209765b05a58fcd15d"></a><!-- doxytag: member="MGFace::get_inner_boundary_loops" ref="ad035a0522e4c56209765b05a58fcd15d" args="(const MGBox &amp;uvbox) const " -->
std::vector&lt; const <a class="el" href="class_m_g_loop.html">MGLoop</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad035a0522e4c56209765b05a58fcd15d">get_inner_boundary_loops</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get inner_aboundary loops included in the input box. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a9c2f66854145f83f6ee9b44cdd9108"></a><!-- doxytag: member="MGFace::get_face_pointer" ref="a6a9c2f66854145f83f6ee9b44cdd9108" args="()" -->
<a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a6a9c2f66854145f83f6ee9b44cdd9108">get_face_pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get face pointer if this is <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, else null will be returned. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7272d1227d37bb1e5651edf28616feb"></a><!-- doxytag: member="MGFace::get_face_pointer" ref="ac7272d1227d37bb1e5651edf28616feb" args="() const " -->
const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_face_pointer</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#afb1f8eab3ce637b3ef956b985c3e9857">get_surface_pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get surface pointer.  <a href="#afb1f8eab3ce637b3ef956b985c3e9857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c688596e6905d6ff1d2e2390e6a0e7f"></a><!-- doxytag: member="MGFace::get_surface_pointer" ref="a8c688596e6905d6ff1d2e2390e6a0e7f" args="() const " -->
const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_surface_pointer</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7812b5fcfc6008d4a8841d69b0563b62"></a><!-- doxytag: member="MGFace::get_number_of_boundaries" ref="a7812b5fcfc6008d4a8841d69b0563b62" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a7812b5fcfc6008d4a8841d69b0563b62">get_number_of_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of inner boundaries as the output of the function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a8b0d13a3a28e3aeba4fbe274c4bf8f97">has_commonFS</a> (const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;obj2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this and 2nd object has common area about their <a class="el" href="class_m_g_cell.html#a6208ba39228367ea6bc04dca269e805a" title="Obtain the box of the cell.">box()</a>, taking error into account.  <a href="#a8b0d13a3a28e3aeba4fbe274c4bf8f97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#abf14a3f17bfc5316c91f7151aabe81ff">hasLoop</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this face has boundary loops or not in the specified box.  <a href="#abf14a3f17bfc5316c91f7151aabe81ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a4f2d1dda9774fb3071816d488ff4e437">hasInactiveLoop</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this face has an inactive loop.  <a href="#a4f2d1dda9774fb3071816d488ff4e437"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a50c3379c45f4b77dc1979623e2ac2ffd">hasOuterBoundaryLoop</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this face has the outer boundary loop instead of perimeter boundary loops.  <a href="#a50c3379c45f4b77dc1979623e2ac2ffd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a83aaa0258bac065c85b1c6cd95336009">hasPerimeterBoundaryLoop</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this face has perimeter boundary loops or not.  <a href="#a83aaa0258bac065c85b1c6cd95336009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ab4639dd5c517155abcb4e1009643d5ea">inner_boundary</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th inner_boundary curves(world coordinates representation) of the face.  <a href="#ab4639dd5c517155abcb4e1009643d5ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a266c6b35a20839f81aa761f59c373de9">inner_boundary_param</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th inner_boundary curves(world coordinates representation) of the face.  <a href="#a266c6b35a20839f81aa761f59c373de9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de0215681b80028685daa41b5f6e246"></a><!-- doxytag: member="MGFace::identify_type" ref="a4de0215681b80028685daa41b5f6e246" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a4de0215681b80028685daa41b5f6e246">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc1eb7fe1e3a85596d89b5b2a0573886"></a><!-- doxytag: member="MGFace::in_range" ref="afc1eb7fe1e3a85596d89b5b2a0573886" args="(double u, double v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#afc1eb7fe1e3a85596d89b5b2a0573886">in_range</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is in the range of the face parameter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec5f3601f81bc9feda0f6e176f372ac3"></a><!-- doxytag: member="MGFace::in_range" ref="aec5f3601f81bc9feda0f6e176f372ac3" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aa1e1ab61b25423b5a6b01b389d560692">in_range_with_on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if (u,v) is inside the face.  <a href="#aa1e1ab61b25423b5a6b01b389d560692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#adc57465c1f06b0603511fd8dff487c28">intersection</a> (const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;obj2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersections of two objects.  <a href="#adc57465c1f06b0603511fd8dff487c28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a765c6c36936c41621a4aed568f68f42a"></a><!-- doxytag: member="MGFace::intersection" ref="a765c6c36936c41621a4aed568f68f42a" args="(const MGCurve &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a764b01e069aaf371886b46d5ba080991"></a><!-- doxytag: member="MGFace::intersection" ref="a764b01e069aaf371886b46d5ba080991" args="(const MGFSurface &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae82454a16b3bbc7eeca575234d293ec6"></a><!-- doxytag: member="MGFace::intersection" ref="ae82454a16b3bbc7eeca575234d293ec6" args="(const MGSurface &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fdbbd5fe1a9275f9b3662bd8c5d6aeb"></a><!-- doxytag: member="MGFace::intersection" ref="a1fdbbd5fe1a9275f9b3662bd8c5d6aeb" args="(const MGFace &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1544cf63408eec834279cf862dff9f7c"></a><!-- doxytag: member="MGFace::intersection" ref="a1544cf63408eec834279cf862dff9f7c" args="(const MGShell &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac91d079bda8cd391694c66207d14d805"></a><!-- doxytag: member="MGFace::isect" ref="ac91d079bda8cd391694c66207d14d805" args="(const MGCurve &amp;curv) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ac91d079bda8cd391694c66207d14d805">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99751ef29ab8de39b8da1bfaaee95079"></a><!-- doxytag: member="MGFace::isect" ref="a99751ef29ab8de39b8da1bfaaee95079" args="(const MGFSurface &amp;fsurf) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;fsurf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72185b097110643821fd09fb489d9772"></a><!-- doxytag: member="MGFace::isect" ref="a72185b097110643821fd09fb489d9772" args="(const MGFace &amp;fsurf) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;fsurf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4a5bbb5b9856314ae679506d7b8a2b6"></a><!-- doxytag: member="MGFace::isect" ref="ae4a5bbb5b9856314ae679506d7b8a2b6" args="(const MGSurface &amp;fsurf) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;fsurf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a404a3e117ac55dc67ea80d48478c65dc"></a><!-- doxytag: member="MGFace::isect" ref="a404a3e117ac55dc67ea80d48478c65dc" args="(const MGShell &amp;shell2) const " -->
<a class="el" href="class_m_g_h_hisect__vector.html">MGHHisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a404a3e117ac55dc67ea80d48478c65dc">isect</a> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;shell2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8466445d8390b229965cd9074b68f7c"></a><!-- doxytag: member="MGFace::knot_u" ref="ae8466445d8390b229965cd9074b68f7c" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ae8466445d8390b229965cd9074b68f7c">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa9f06f77100c18eec306e9e5513363f"></a><!-- doxytag: member="MGFace::knot_v" ref="afa9f06f77100c18eec306e9e5513363f" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#afa9f06f77100c18eec306e9e5513363f">knot_v</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d83139a2842d22145965f068b223e93"></a><!-- doxytag: member="MGFace::knot_vector_u" ref="a4d83139a2842d22145965f068b223e93" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a4d83139a2842d22145965f068b223e93">knot_vector_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850c9abe48b031e80f0886f5633d6e5f"></a><!-- doxytag: member="MGFace::knot_vector_u" ref="a850c9abe48b031e80f0886f5633d6e5f" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae371c5f486f4509ab99800c9b4744560"></a><!-- doxytag: member="MGFace::knot_vector_v" ref="ae371c5f486f4509ab99800c9b4744560" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ae371c5f486f4509ab99800c9b4744560">knot_vector_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a114c00f244894359e41128c18731ce23"></a><!-- doxytag: member="MGFace::knot_vector_v" ref="a114c00f244894359e41128c18731ce23" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a868910afb6174e5d21e76228751ed456"></a><!-- doxytag: member="MGFace::loop" ref="a868910afb6174e5d21e76228751ed456" args="(size_t i)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a868910afb6174e5d21e76228751ed456">loop</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th boundary loop of the face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49209eb1b670778b6e481d9927eec640"></a><!-- doxytag: member="MGFace::loop" ref="a49209eb1b670778b6e481d9927eec640" args="(iterator i)" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>loop</b> (iterator i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a199073754e004532c646344d0fc43cd3"></a><!-- doxytag: member="MGFace::loop" ref="a199073754e004532c646344d0fc43cd3" args="(size_t i) const " -->
const <a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>loop</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0842fb771627a0fcdfce3b5e5c0332aa"></a><!-- doxytag: member="MGFace::loop" ref="a0842fb771627a0fcdfce3b5e5c0332aa" args="(const_iterator i) const " -->
const <a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>loop</b> (const_iterator i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a5ad8f9f64018e6475544c0713ee2a495">make_binder</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a binder cell of this parameter cell.  <a href="#a5ad8f9f64018e6475544c0713ee2a495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a02490326533d8115499bbd9d90dc8fa3">make_face</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> or <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> object.  <a href="#a02490326533d8115499bbd9d90dc8fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a0b1cbe2127936a6cd94c1950704c8ae2">make_display_list_to_hilight</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a display list without color of this gel.  <a href="#a0b1cbe2127936a6cd94c1950704c8ae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a430966202db5b42385cf53dcfe4fc41e"></a><!-- doxytag: member="MGFace::make_outer_boundary" ref="a430966202db5b42385cf53dcfe4fc41e" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a430966202db5b42385cf53dcfe4fc41e">make_outer_boundary</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make outer boundary if not existed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeecf1962655184e5eccc6997f43c15a6"></a><!-- doxytag: member="MGFace::manifold_dimension" ref="aeecf1962655184e5eccc6997f43c15a6" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aeecf1962655184e5eccc6997f43c15a6">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac75f09b84ed606f7b16221ca14f837ab"></a><!-- doxytag: member="MGFace::member_partner_face" ref="ac75f09b84ed606f7b16221ca14f837ab" args="(size_t i) const " -->
const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ac75f09b84ed606f7b16221ca14f837ab">member_partner_face</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the i-th member partner face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e7b68297c17e5317d0eb32e1afe4b5"></a><!-- doxytag: member="MGFace::negate" ref="aa9e7b68297c17e5317d0eb32e1afe4b5" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aa9e7b68297c17e5317d0eb32e1afe4b5">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15b8c6a99c7db83cb3c01c310c900c8d"></a><!-- doxytag: member="MGFace::negateFS" ref="a15b8c6a99c7db83cb3c01c310c900c8d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a15b8c6a99c7db83cb3c01c310c900c8d">negateFS</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the FSurface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee978db4742ca7504d22e20499b79dd0"></a><!-- doxytag: member="MGFace::normal" ref="aee978db4742ca7504d22e20499b79dd0" args="(const MGPosition &amp;uv) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aee978db4742ca7504d22e20499b79dd0">normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e14d9ae274fb0634025f81838385f3d"></a><!-- doxytag: member="MGFace::normal" ref="a1e14d9ae274fb0634025f81838385f3d" args="(double u, double v) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1e14d9ae274fb0634025f81838385f3d">normal</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at (u,v). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1750e020a8d527281fbf16e3fe40c1ce">no_outer_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if no outer boundary except the surface perimeters.  <a href="#a1750e020a8d527281fbf16e3fe40c1ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a339809934e2c7c4465735bff3b2e9202"></a><!-- doxytag: member="MGFace::number_of_inner_boundaries" ref="a339809934e2c7c4465735bff3b2e9202" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a339809934e2c7c4465735bff3b2e9202">number_of_inner_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of inner boundaries as the output of the function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a00b66eeb37e11fe2cc467db54ee70b2a">number_of_inner_boundaries</a> (size_t &amp;i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of inner boundary loops.  <a href="#a00b66eeb37e11fe2cc467db54ee70b2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec20e81b7ea792f5556a045127038f15"></a><!-- doxytag: member="MGFace::number_of_loops" ref="aec20e81b7ea792f5556a045127038f15" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aec20e81b7ea792f5556a045127038f15">number_of_loops</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute number of active loops. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3254f98397f48810ac2a8442824380d"></a><!-- doxytag: member="MGFace::number_of_perimeter_boundaries" ref="af3254f98397f48810ac2a8442824380d" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#af3254f98397f48810ac2a8442824380d">number_of_perimeter_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of perimeter boundary loop. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58b4ad46e6cfe406262342066aa1e0f3"></a><!-- doxytag: member="MGFace::object_pointer" ref="a58b4ad46e6cfe406262342066aa1e0f3" args="()" -->
<a class="el" href="class_m_g_object.html">MGObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a58b4ad46e6cfe406262342066aa1e0f3">object_pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology.">MGObject</a> pointer if this <a class="el" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element.">MGGel</a> is an <a class="el" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology.">MGObject</a>, else return null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a878a8198d1e61408e0d3862b607465cd"></a><!-- doxytag: member="MGFace::object_pointer" ref="a878a8198d1e61408e0d3862b607465cd" args="() const " -->
const <a class="el" href="class_m_g_object.html">MGObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a878a8198d1e61408e0d3862b607465cd">object_pointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the object point of this <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ae9064d4a3b94551188f6b09a94988f19">offset</a> (double distance, int &amp;error) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset.  <a href="#ae9064d4a3b94551188f6b09a94988f19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a32a8980bc7537503b5ef2ecbf5fa3bf1">offset</a> (double distance, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;vecOfsFace) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset.  <a href="#a32a8980bc7537503b5ef2ecbf5fa3bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a089a79463cfee5437116befa4617805d">offset_fs</a> (double distance, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;vecOfsFSurface) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset.  <a href="#a089a79463cfee5437116befa4617805d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1c9f497b50bf50385981168ed7dbfa47">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a point P is on the face.  <a href="#a1c9f497b50bf50385981168ed7dbfa47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#acd0750672d25306e9ab936ff6695b6c6">on_a_perimeter</a> (double &amp;u, double &amp;v, size_t &amp;perim_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is parameter value on a perimeter of the base surface.  <a href="#acd0750672d25306e9ab936ff6695b6c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad058ef7eac06bfb0a208333a23deab53">outer_boundary</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain outer_boundary curves(world coordinates representation) of the face.  <a href="#ad058ef7eac06bfb0a208333a23deab53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad838db2cb35beb4d2abbec5a68f17682">outer_boundary_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain boundary curves(parameter space representation) of the face.  <a href="#ad838db2cb35beb4d2abbec5a68f17682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afdeb841e576873c3589ca75e3fc36f"></a><!-- doxytag: member="MGFace::param" ref="a2afdeb841e576873c3589ca75e3fc36f" args="(const MGPosition &amp;P) const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a2afdeb841e576873c3589ca75e3fc36f">param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value of the face whose world coordinates are P. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#abf1b5eff232aae520497d5c87b486707">parameter_curves</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter curves.  <a href="#abf1b5eff232aae520497d5c87b486707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a638df4048d455eb7f7fbb4b597d4a6b0">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range.  <a href="#a638df4048d455eb7f7fbb4b597d4a6b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af5927be754be5c189e94c80bb088b4"></a><!-- doxytag: member="MGFace::param_e_u" ref="a1af5927be754be5c189e94c80bb088b4" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1af5927be754be5c189e94c80bb088b4">param_e_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a313c339f7d5e6edbaf9b5f757d0b6581"></a><!-- doxytag: member="MGFace::param_e_v" ref="a313c339f7d5e6edbaf9b5f757d0b6581" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5022c15f2d6fd9228cc95eb991cbb01f"></a><!-- doxytag: member="MGFace::param_s_u" ref="a5022c15f2d6fd9228cc95eb991cbb01f" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a5022c15f2d6fd9228cc95eb991cbb01f">param_s_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value of the base surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba66fa2b56b119a84825a0d6aa64e0e9"></a><!-- doxytag: member="MGFace::param_s_v" ref="aba66fa2b56b119a84825a0d6aa64e0e9" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a646b62e448a8506ae7d218f47193c9b1"></a><!-- doxytag: member="MGFace::parent_shell" ref="a646b62e448a8506ae7d218f47193c9b1" args="()" -->
<a class="el" href="class_m_g_shell.html">MGShell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a646b62e448a8506ae7d218f47193c9b1">parent_shell</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parent shell that this face belongs to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f0970cdc24af093330faaac60aee4e3"></a><!-- doxytag: member="MGFace::parent_shell" ref="a2f0970cdc24af093330faaac60aee4e3" args="() const " -->
const <a class="el" href="class_m_g_shell.html">MGShell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>parent_shell</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a2c1757ea6b160669d636e3c1994d74fb">PBloop_curves</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain perimeter boundadary loop's curve representation.  <a href="#a2c1757ea6b160669d636e3c1994d74fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aae09aeef4e29317364bcad7e90063bf3">perp_guess</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the foot of the perpendicular straight line from P.  <a href="#aae09aeef4e29317364bcad7e90063bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aa27d36bec2da95cc046cbccdc095921c">perp_guess</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, double tguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perpendicular points of a curve and the face, given guess starting paramter values.  <a href="#aa27d36bec2da95cc046cbccdc095921c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a5349eea0914e4a56cb431574ae50bcb6">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, const <a class="el" href="class_m_g_position.html">MGPosition</a> *uvguess=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定点から最も近い、垂線の足とパラメータ値を返す。 Return the foot of the perpendicular straight line from p that is nearest to point p.  <a href="#a5349eea0914e4a56cb431574ae50bcb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aefc5b3715a2b98236ac8b3af59019c53">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perpendicular points on the face from a point P((x,y,z)).  <a href="#aefc5b3715a2b98236ac8b3af59019c53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#aacb980328dcbd6469fe91a1c7ad950b1">pick_closest</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parameter value of the closest point from the straight to this object.  <a href="#aacb980328dcbd6469fe91a1c7ad950b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#acf4a1206a6fbf1ce9fc50ecf1fac45aa">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the input parameter (u,v) of the face to the nearest point of the face parameter range.  <a href="#acf4a1206a6fbf1ce9fc50ecf1fac45aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22a386fec1d01b08a679ab28b3d7fb71"></a><!-- doxytag: member="MGFace::remove_inactive_loops" ref="a22a386fec1d01b08a679ab28b3d7fb71" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a22a386fec1d01b08a679ab28b3d7fb71">remove_inactive_loops</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove inactive loops from this face. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e505b340fcf7ac57e5414c55b0f4aa"></a><!-- doxytag: member="MGFace::shell" ref="af8e505b340fcf7ac57e5414c55b0f4aa" args="()" -->
<a class="el" href="class_m_g_shell.html">MGShell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#af8e505b340fcf7ac57e5414c55b0f4aa">shell</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the shell pointer if this belongs to a shell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4216cee5706618c75cf6babdc603f18"></a><!-- doxytag: member="MGFace::shell" ref="ae4216cee5706618c75cf6babdc603f18" args="() const " -->
const <a class="el" href="class_m_g_shell.html">MGShell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>shell</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#afc3b80c6bc3b7f0c4d7b24301d402798">shrink_base_surface_to_knot</a> (int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shrink the base surface of this face to the part limitted by the parameter range of uvbx.  <a href="#afc3b80c6bc3b7f0c4d7b24301d402798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a487a88b5d7a91ff52e2f61384e190abd">sort_boundaries</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort boundary occurreces in m_boundaries.  <a href="#a487a88b5d7a91ff52e2f61384e190abd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a99e3712ae4c1f583f5128403d0a06bf5">split</a> (double param, bool is_u, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;surfaces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">split this fsurface at the parameter param.  <a href="#a99e3712ae4c1f583f5128403d0a06bf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ae70d3a8a6d8a7bfe72da6ae13c7205bc">split</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;networks, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;faces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split the face giving networks loops.  <a href="#ae70d3a8a6d8a7bfe72da6ae13c7205bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab355de9cf8c851ab2abb7c074d7c10d0"></a><!-- doxytag: member="MGFace::surface" ref="ab355de9cf8c851ab2abb7c074d7c10d0" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ab355de9cf8c851ab2abb7c074d7c10d0">surface</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get surface pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1faea04e3d2871974bea39cc921ed315"></a><!-- doxytag: member="MGFace::surface" ref="a1faea04e3d2871974bea39cc921ed315" args="() const " -->
const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>surface</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a1d695a31bc598f20cfac1add521b1acf">trim_projection</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;direction=mgNULL_VEC)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the face by the projection of a curve along a vector direction.  <a href="#a1d695a31bc598f20cfac1add521b1acf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ae99752d02e15c01d066a0798df2e55a1">trim</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;pcrv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the face giving parameter curve and world curve of a curve on the face.  <a href="#ae99752d02e15c01d066a0798df2e55a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a6c4db2375b0acb3971425cd357415d93">trim</a> (const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;new_loop_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the face giving a loop new_loop that does not have the parent face.  <a href="#a6c4db2375b0acb3971425cd357415d93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#ad230516b40b5e101b78cd5b5f5fc5903">trim</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;networks, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;faces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the face giving networks loops.  <a href="#ad230516b40b5e101b78cd5b5f5fc5903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b271a51284ba4cf0f9823c26751da37"></a><!-- doxytag: member="MGFace::unit_normal" ref="a8b271a51284ba4cf0f9823c26751da37" args="(const MGPosition &amp;uv) const " -->
<a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a8b271a51284ba4cf0f9823c26751da37">unit_normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute unit normal vector at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe1715443e0db7599d57905debaf67de"></a><!-- doxytag: member="MGFace::unit_normal" ref="abe1715443e0db7599d57905debaf67de" args="(double u, double v) const " -->
<a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#abe1715443e0db7599d57905debaf67de">unit_normal</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute unit normal vector at (u,v). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a619cafba7f17c35e6f12738442b51ee1"></a><!-- doxytag: member="MGFace::whoami" ref="a619cafba7f17c35e6f12738442b51ee1" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94630dd02d5b3fedfdacf7b393388c05"></a><!-- doxytag: member="MGFace::WriteMembers" ref="a94630dd02d5b3fedfdacf7b393388c05" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a94630dd02d5b3fedfdacf7b393388c05">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc048dea9c4931d238ed4d0dfd045fee"></a><!-- doxytag: member="MGFace::ReadMembers" ref="acc048dea9c4931d238ed4d0dfd045fee" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#acc048dea9c4931d238ed4d0dfd045fee">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9601a8abe679cfa1f64420c54c027d1a"></a><!-- doxytag: member="MGFace::MGShell" ref="a9601a8abe679cfa1f64420c54c027d1a" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a9601a8abe679cfa1f64420c54c027d1a">MGShell</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe000bc8a2d7a96c44aedb2bbe2f1280"></a><!-- doxytag: member="MGFace::MGSurface" ref="afe000bc8a2d7a96c44aedb2bbe2f1280" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#afe000bc8a2d7a96c44aedb2bbe2f1280">MGSurface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_face.html">MGFace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_face.html#a6b65a776196d2de198f0793ebf6d0d41">operator*</a> (double s, const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;face)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faceのスケーリングを行い，Faceを作成する。 Scaling of the Face by a double.  <a href="#a6b65a776196d2de198f0793ebf6d0d41"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> is a trimmed surface. </p>
<p><a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> is an instance of <a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a>, can be a constituent of <a class="el" href="class_m_g_shell.html" title="MGShell is a composition of MGFace&#39;s(trimmed surface).">MGShell</a>. Many useful functions are provided in <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. See <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adab7b92bc6a475182f2684c4d161663c"></a><!-- doxytag: member="MGFace::MGFace" ref="adab7b92bc6a475182f2684c4d161663c" args="(MGSurface *geo, std::vector&lt; MGBoundary * &gt; &amp;boundaries, MGCell *binder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGFace::MGFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>geo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td>
          <td class="paramname"> <em>binder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fundamental constructor. </p>
<p>Construct a face from geometry of manifold dimension 2 and the boundaries. The constructor takes the ownership of geo and <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a> in boundaries. boundaries must be loops. </p>

</div>
</div>
<a class="anchor" id="a597035ed7f4aa48b30143472fc091d33"></a><!-- doxytag: member="MGFace::MGFace" ref="a597035ed7f4aa48b30143472fc091d33" args="(MGSurface *surf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGFace::MGFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td>
          <td class="paramname"> <em>surf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Face of whole surface of no boundary. </p>
<p>Ownership of surf is transfered to the face. (that is surf must be a newed object.) </p>

</div>
</div>
<a class="anchor" id="a8b32f18adc787d087f3e809e3d363321"></a><!-- doxytag: member="MGFace::MGFace" ref="a8b32f18adc787d087f3e809e3d363321" args="(const MGSurface &amp;surf, const std::vector&lt; MGBoundary * &gt; &amp;boundaries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGFace::MGFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a face by copying boundaries(only parameter rep of the boundary) from argument boundaries. </p>
<p>Second form is to input a newed surface. The constructor takes the ownership of the surf. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a55c5c75795d6fa0f5dc35a13675009d4"></a><!-- doxytag: member="MGFace::add_boundary" ref="a55c5c75795d6fa0f5dc35a13675009d4" args="(MGLoop *nloop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::add_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td>
          <td class="paramname"> <em>nloop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new loop to this face as aboundary. </p>
<p>When the old loops that are outside the nloop will be removed from this. nloop can be inner or outer. </p>

</div>
</div>
<a class="anchor" id="a50b9de439df79b17c709f148bfc945ea"></a><!-- doxytag: member="MGFace::append_boundary" ref="a50b9de439df79b17c709f148bfc945ea" args="(MGBoundary *bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGFace::append_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td>
          <td class="paramname"> <em>bound</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append new one boundary to boundary vectors. </p>
<p>Returned is the number of boudaries after appending. bound must be a newed <a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a>, and the ownership is transfered to this. append_boundary does not check validity with other loops (e.x. already existed loops will be outside the new boudanry bound). If the validity check is necessary, use add_boudanry(). </p>

</div>
</div>
<a class="anchor" id="a74b3b93a12a333d752020c1b49cf6db0"></a><!-- doxytag: member="MGFace::arrow" ref="a74b3b93a12a333d752020c1b49cf6db0" args="(double u, double v, MGPosition data[10]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::arrow </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>[10]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate arrow data of the tangent along u and v and the normal at the parameter value (u,v) of the surface. </p>
<p>data[0] is the origin of the u-tangent arrow, data[1] is the top of the u-tangent arrow, data[2], [3] are two bottoms of u-tangent arrowhead. data[0], [4], [5], [6] are the points of v-tangent arrow. data[0], [7], [8], [9] are the points of v-tangent arrow. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a17e4c4cfd0c528657426629f3dc8fc24">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad129cfba174eb8efac8ba3c30ae0126f"></a><!-- doxytag: member="MGFace::binder_face" ref="ad129cfba174eb8efac8ba3c30ae0126f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGFace::binder_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain binder face pointer. </p>
<p>Null when this does not have binder. </p>

</div>
</div>
<a class="anchor" id="a6fd7e35e48e1073fa35e79a7f60cd054"></a><!-- doxytag: member="MGFace::box_param" ref="a6fd7e35e48e1073fa35e79a7f60cd054" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_box.html">MGBox</a>&amp; MGFace::box_param </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return box of the parameter space of the face. </p>
<p>After trimmed one. </p>

</div>
</div>
<a class="anchor" id="a5ec7d4640196d2dcefc2ff9c65b86a55"></a><!-- doxytag: member="MGFace::box_param2" ref="a5ec7d4640196d2dcefc2ff9c65b86a55" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_box.html">MGBox</a> MGFace::box_param2 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return box of the parameter space of the FSurface. </p>
<p>After trimmed one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a027f707b72095b5a4038dc5410e50ce2">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="abdbb0f93833478fa597c7d01c985fe0a"></a><!-- doxytag: member="MGFace::build_loop" ref="abdbb0f93833478fa597c7d01c985fe0a" args="(const MGCurve &amp;crv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_loop.html">MGLoop</a>&gt; MGFace::build_loop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a loop of this face, given a closed curve crv on this face. </p>
<p>Although crv is generally a <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>, this may be not the case. Returned <a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a> is not added into this face as a boundary. User must add it after the direction is adjusted. That is, the output loop can be an outer or inner loop. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>curve of world coordinates. Generally this is not on face and always is projectd onto the face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06c758e6d7a93c47781c32197481d8aa"></a><!-- doxytag: member="MGFace::clone" ref="a06c758e6d7a93c47781c32197481d8aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGFace::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of the cell. </p>
<p><a class="el" href="class_m_g_face.html#a06c758e6d7a93c47781c32197481d8aa" title="Make a clone of the cell.">clone()</a>, clone_without_boundaries() does not copy the binder cell relation. </p>

</div>
</div>
<a class="anchor" id="ac324ccb46e913738c3370c015a7f5bb3"></a><!-- doxytag: member="MGFace::clone_as_face" ref="ac324ccb46e913738c3370c015a7f5bb3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGFace::clone_as_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the clone of this as a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. </p>
<p>If this is <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, it is converted to <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a4a39743914b8e15d32c27740aa6d8c79">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1932e4c29acbd2e22b0bc9b2341c1959"></a><!-- doxytag: member="MGFace::clone_binder" ref="a1932e4c29acbd2e22b0bc9b2341c1959" args="(const MGCellBase &amp;f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGFace::clone_binder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of this(this is a binder), and set binder and parameter cell relation between the new binder and the parameter cell f. </p>

</div>
</div>
<a class="anchor" id="aa316bfc80da17272e5af026758de0957"></a><!-- doxytag: member="MGFace::closest" ref="aa316bfc80da17272e5af026758de0957" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGFace::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute closest point from a point. </p>
<p>Returned is the parameter value of the face that is closest to point. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a44385215d7089b9f2ad42792aad0d3f7">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a57ee47cb85783c02acb714f6f7806c25"></a><!-- doxytag: member="MGFace::closest_on_boundary" ref="a57ee47cb85783c02acb714f6f7806c25" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGFace::closest_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute closest point from a line to the boundary of the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. </p>
<p>Returned is the parameter value of the FSurface that is closest to point. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a7f41b0c00f61627312776bfe06366bdb">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7e335291d107ca99cb14b424bcd4486b"></a><!-- doxytag: member="MGFace::draw3DVertex" ref="a7e335291d107ca99cb14b424bcd4486b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::draw3DVertex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D point(vertex) in world coordinates. </p>
<p>The object is converted to point(s) and is drawn. This is valid only for topology objects or <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>. </p>

</div>
</div>
<a class="anchor" id="a99b98caf25eb34bbd8f4ef75ab6ea7cf"></a><!-- doxytag: member="MGFace::drawWire" ref="a99b98caf25eb34bbd8f4ef75ab6ea7cf" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2ffcdfe9e259e94475d2d8ec888bbd5"></a><!-- doxytag: member="MGFace::equal_direction" ref="af2ffcdfe9e259e94475d2d8ec888bbd5" args="(const MGPvector&lt; MGCurve &gt; &amp;wcurves, const MGPvector&lt; MGCurve &gt; &amp;pcurves, size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::equal_direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>wcurves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pcurves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if directions of parameter curve and world curve of the face boundary is equal or not. </p>
<p>This function can be used to test the pair of the output of <a class="el" href="class_m_g_face.html#ad058ef7eac06bfb0a208333a23deab53" title="Obtain outer_boundary curves(world coordinates representation) of the face.">outer_boundary()</a> and <a class="el" href="class_m_g_face.html#ad838db2cb35beb4d2abbec5a68f17682" title="Obtain boundary curves(parameter space representation) of the face.">outer_boundary_param()</a>, or the pair of <a class="el" href="class_m_g_face.html#ab4639dd5c517155abcb4e1009643d5ea" title="Obtain i-th inner_boundary curves(world coordinates representation) of the face.">inner_boundary()</a> and <a class="el" href="class_m_g_face.html#a266c6b35a20839f81aa761f59c373de9" title="Obtain i-th inner_boundary curves(world coordinates representation) of the face.">inner_boundary_param()</a>. Return is: true if equal direction, false if opposite direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wcurves</em>&nbsp;</td><td>output of <a class="el" href="class_m_g_face.html#ad058ef7eac06bfb0a208333a23deab53" title="Obtain outer_boundary curves(world coordinates representation) of the face.">outer_boundary()</a> or <a class="el" href="class_m_g_face.html#ab4639dd5c517155abcb4e1009643d5ea" title="Obtain i-th inner_boundary curves(world coordinates representation) of the face.">inner_boundary()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcurves</em>&nbsp;</td><td>output of <a class="el" href="class_m_g_face.html#ad838db2cb35beb4d2abbec5a68f17682" title="Obtain boundary curves(parameter space representation) of the face.">outer_boundary_param()</a> or <a class="el" href="class_m_g_face.html#a266c6b35a20839f81aa761f59c373de9" title="Obtain i-th inner_boundary curves(world coordinates representation) of the face.">inner_boundary_param()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>id of the curve in wcurves and pcurves to test the direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cd3a45812dab6f742c64017e7fef985"></a><!-- doxytag: member="MGFace::eval" ref="a9cd3a45812dab6f742c64017e7fef985" args="(double u, double v, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGFace::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase i-th loop. </p>
<p>void erase_boundary(size_t i); Evaluate. Input parameter value is not checked if it is <a class="el" href="class_m_g_face.html#afc1eb7fe1e3a85596d89b5b2a0573886" title="Test if parameter value (u,v) is in the range of the face parameter.">in_range()</a> or not. Even if it is not <a class="el" href="class_m_g_face.html#afc1eb7fe1e3a85596d89b5b2a0573886" title="Test if parameter value (u,v) is in the range of the face parameter.">in_range()</a>, surface evaluation will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Face parameter value(u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a827522c3a515722c10a945c4eb25b8f0">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a36fc03dc036fcb63ddf1a35a6aaf4282"></a><!-- doxytag: member="MGFace::eval" ref="a36fc03dc036fcb63ddf1a35a6aaf4282" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGFace::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Face parameter value(u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a0a681a39c5dc1107447b3399b110fdea">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a03f68dcb99233d60ea30e9f0b057683d"></a><!-- doxytag: member="MGFace::extract_sub_face" ref="a03f68dcb99233d60ea30e9f0b057683d" args="(const MGPvector&lt; MGLoop &gt; &amp;networks, const MGPosition &amp;uv, std::auto_ptr&lt; MGFace &gt; &amp;face) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::extract_sub_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>networks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::auto_ptr&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>face</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract sub face that is bounded by networks loops. </p>
<p>Extracted sub face is the smallest closed part of this face bounded by the networks that includes the parameter position uv(u,v). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>networks</em>&nbsp;</td><td>(u,v) representation networks. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face</em>&nbsp;</td><td>Result extracted face will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48ce8a7adab1cb4f7c8fe9a04905d333"></a><!-- doxytag: member="MGFace::face_boundaries" ref="a48ce8a7adab1cb4f7c8fe9a04905d333" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::face_boundaries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain all the boundary curves(world coordinates representation) of the face. </p>
<p>That is, all of the outer boundaries and all of the inner boundaries. </p>

</div>
</div>
<a class="anchor" id="afb1f8eab3ce637b3ef956b985c3e9857"></a><!-- doxytag: member="MGFace::get_surface_pointer" ref="afb1f8eab3ce637b3ef956b985c3e9857" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGFace::get_surface_pointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get surface pointer. </p>
<p>Null will never be returned if this is valid <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. That is, if this is <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, base surface will be returned. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#ad9f377eb6f6e2d22e5b1e4ba93ef866a">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8b0d13a3a28e3aeba4fbe274c4bf8f97"></a><!-- doxytag: member="MGFace::has_commonFS" ref="a8b0d13a3a28e3aeba4fbe274c4bf8f97" args="(const MGObject &amp;obj2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::has_commonFS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this and 2nd object has common area about their <a class="el" href="class_m_g_cell.html#a6208ba39228367ea6bc04dca269e805a" title="Obtain the box of the cell.">box()</a>, taking error into account. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a49a378f0e540171dd62b4c62b60b30f2">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2d1dda9774fb3071816d488ff4e437"></a><!-- doxytag: member="MGFace::hasInactiveLoop" ref="a4f2d1dda9774fb3071816d488ff4e437" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::hasInactiveLoop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this face has an inactive loop. </p>
<p>If this has one, return true. </p>

</div>
</div>
<a class="anchor" id="abf14a3f17bfc5316c91f7151aabe81ff"></a><!-- doxytag: member="MGFace::hasLoop" ref="abf14a3f17bfc5316c91f7151aabe81ff" args="(const MGBox &amp;uvbox) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::hasLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this face has boundary loops or not in the specified box. </p>
<p>If this has one, return true. </p>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#ac871fe28de2080e9d9dd08b9334fcea6">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a50c3379c45f4b77dc1979623e2ac2ffd"></a><!-- doxytag: member="MGFace::hasOuterBoundaryLoop" ref="a50c3379c45f4b77dc1979623e2ac2ffd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::hasOuterBoundaryLoop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this face has the outer boundary loop instead of perimeter boundary loops. </p>
<p>If this has the outer boundary loop and has not perimeter boundary loops, return true. </p>

</div>
</div>
<a class="anchor" id="a83aaa0258bac065c85b1c6cd95336009"></a><!-- doxytag: member="MGFace::hasPerimeterBoundaryLoop" ref="a83aaa0258bac065c85b1c6cd95336009" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::hasPerimeterBoundaryLoop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this face has perimeter boundary loops or not. </p>
<p>If this has one, return true. </p>

</div>
</div>
<a class="anchor" id="aa1e1ab61b25423b5a6b01b389d560692"></a><!-- doxytag: member="MGFace::in_range_with_on" ref="aa1e1ab61b25423b5a6b01b389d560692" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::in_range_with_on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if (u,v) is inside the face. </p>
<p>Function's return value is: 0:outside the face. 1:unknown. 2:inside the face, not on a boundary. &lt;0:(u,v) is on an inner boundary, and abs(return code) is the loop id. 4:(u,v) is on the outer boundary. &gt;=10: (u,v) is on a perimeter, (10+perimeter number) will be returned. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab4639dd5c517155abcb4e1009643d5ea"></a><!-- doxytag: member="MGFace::inner_boundary" ref="ab4639dd5c517155abcb4e1009643d5ea" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::inner_boundary </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th inner_boundary curves(world coordinates representation) of the face. </p>
<p>Let the output of inner_boundary(i) be wcurves and of inner_boundary_param(i) be pcurves, then wcurves[j] corresponds to pcurves[j] one to one. Number of inner_boundary can be obtained by the function number_of_inner_boundary(). </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a959f466f07e68676b3ca976ae4a02ff4">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a266c6b35a20839f81aa761f59c373de9"></a><!-- doxytag: member="MGFace::inner_boundary_param" ref="a266c6b35a20839f81aa761f59c373de9" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::inner_boundary_param </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th inner_boundary curves(world coordinates representation) of the face. </p>
<p>Let the output of inner_boundary(i) be wcurves and of inner_boundary_param(i) be pcurves, then wcurves[j] corresponds to pcurves[j] one to one. Number of inner_boundary can be obtained by the function number_of_inner_boundary(). </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a58c5b3bbb657bbfe80bbb5fd65a11da3">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="adc57465c1f06b0603511fd8dff487c28"></a><!-- doxytag: member="MGFace::intersection" ref="adc57465c1f06b0603511fd8dff487c28" args="(const MGObject &amp;obj2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_gisects.html">MGisects</a> MGFace::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersections of two objects. </p>
<p>Intersections are obtained from two objects, which are known using the <a class="el" href="class_m_gisects.html#af38c1dac073591a6405efb080957f094" title="Get the 1st object pointer of the i-th intersection.">MGisects::object1()</a> and object2(). NOTE**** When two objects' manifold dimension are the same, object1 is this object at the invocation of <a class="el" href="class_m_g_object.html#ad20afa7e5b85f49d80e53a2a9377438b" title="Compute the intersections of two objects.">MGObject::intersection()</a>, and object2 is the argument object. However, their manifold dimension are not the same, object1 is always the lower dimension's object and object2 is the higer dimension's object. </p>

</div>
</div>
<a class="anchor" id="a5ad8f9f64018e6475544c0713ee2a495"></a><!-- doxytag: member="MGFace::make_binder" ref="a5ad8f9f64018e6475544c0713ee2a495" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>* MGFace::make_binder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a binder cell of this parameter cell. </p>
<p>Returned is the binder pointer generated by new. The binder has no geometry, only has binder and parameter cell relationship. </p>

</div>
</div>
<a class="anchor" id="a0b1cbe2127936a6cd94c1950704c8ae2"></a><!-- doxytag: member="MGFace::make_display_list_to_hilight" ref="a0b1cbe2127936a6cd94c1950704c8ae2" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGFace::make_display_list_to_hilight </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a display list without color of this gel. </p>
<p>Return is the display list name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>span length to approximate by polyline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02490326533d8115499bbd9d90dc8fa3"></a><!-- doxytag: member="MGFace::make_face" ref="a02490326533d8115499bbd9d90dc8fa3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGFace::make_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> or <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> object. </p>
<p>If this is a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, returns this pointer. If this is a <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, construct a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> using this newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, and returns the MGFace*. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a521de8eaa8905bf5e14c6af77af56d0a">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1750e020a8d527281fbf16e3fe40c1ce"></a><!-- doxytag: member="MGFace::no_outer_boundaries" ref="a1750e020a8d527281fbf16e3fe40c1ce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::no_outer_boundaries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if no outer boundary except the surface perimeters. </p>
<p>That is, test if the following two conditions are satisfied: 1. no perimeter boundaries. 2. no outer boundary. </p>

</div>
</div>
<a class="anchor" id="a00b66eeb37e11fe2cc467db54ee70b2a"></a><!-- doxytag: member="MGFace::number_of_inner_boundaries" ref="a00b66eeb37e11fe2cc467db54ee70b2a" args="(size_t &amp;i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGFace::number_of_inner_boundaries </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of inner boundary loops. </p>
<p>Returned i is the id of the first inner boundary loop if inner boundaries exist. </p>

</div>
</div>
<a class="anchor" id="a32a8980bc7537503b5ef2ecbf5fa3bf1"></a><!-- doxytag: member="MGFace::offset" ref="a32a8980bc7537503b5ef2ecbf5fa3bf1" args="(double distance, MGPvector&lt; MGFace &gt; &amp;vecOfsFace) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::offset </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vecOfsFace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset. </p>
<p>distance is plus value if the direction is toward normal vector of the face. Minus if against the normal vector. エラーコード 0:成功 -1:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </p>

</div>
</div>
<a class="anchor" id="ae9064d4a3b94551188f6b09a94988f19"></a><!-- doxytag: member="MGFace::offset" ref="ae9064d4a3b94551188f6b09a94988f19" args="(double distance, int &amp;error) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a> MGFace::offset </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset. </p>
<p>distance is plus value if the direction is toward normal vector of the face. Minus if against the normal vector. エラーコード 0:成功 -1:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </p>

</div>
</div>
<a class="anchor" id="a089a79463cfee5437116befa4617805d"></a><!-- doxytag: member="MGFace::offset_fs" ref="a089a79463cfee5437116befa4617805d" args="(double distance, MGPvector&lt; MGFSurface &gt; &amp;vecOfsFSurface) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::offset_fs </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vecOfsFSurface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset. </p>
<p>distance is plus value if the direction is toward normal vector of the FSurface. Minus if against the normal vector. エラーコード 0:成功 -1:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a18926f742ba0ae8b3a41a263d8897628">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1c9f497b50bf50385981168ed7dbfa47"></a><!-- doxytag: member="MGFace::on" ref="a1c9f497b50bf50385981168ed7dbfa47" args="(const MGPosition &amp;P, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a point P is on the face. </p>
<p>Returned is true if the point P is on the face. false(0) if P was not on the face. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the face is returrned. Even if P is not on the face, nearest point parameter value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#afb6217a5d69beda117240ae8867ecea8">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="acd0750672d25306e9ab936ff6695b6c6"></a><!-- doxytag: member="MGFace::on_a_perimeter" ref="acd0750672d25306e9ab936ff6695b6c6" args="(double &amp;u, double &amp;v, size_t &amp;perim_num) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::on_a_perimeter </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is parameter value on a perimeter of the base surface. </p>
<p>If u or v is on a perimeter, they will be updated to the perimeter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returns true, the perimete number is output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a73978585a34a380507af9e44113a2287">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a27bd4ca908e81c8862b2900c224bbe67"></a><!-- doxytag: member="MGFace::operator*" ref="a27bd4ca908e81c8862b2900c224bbe67" args="(const MGTransf &amp;tr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a> MGFace::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換によってトランスフォームをおこないFaceを生成する。 Transformation of the Face by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>. </p>

</div>
</div>
<a class="anchor" id="a330fe774c7fcbfe2e88d9582456252f4"></a><!-- doxytag: member="MGFace::operator*" ref="a330fe774c7fcbfe2e88d9582456252f4" args="(double s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a> MGFace::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Faceのスケーリングを行い，Faceを作成する。 Scaling of the Face by a double. </p>

</div>
</div>
<a class="anchor" id="ab20c09437eace52e8b2099810637500a"></a><!-- doxytag: member="MGFace::operator*" ref="ab20c09437eace52e8b2099810637500a" args="(const MGMatrix &amp;mat) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a> MGFace::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換でFaceの変換を行い，Faceを作成する。 Transformation of the Face by a matrix. </p>

</div>
</div>
<a class="anchor" id="a21d731491c4a437aed18b6334fa64f01"></a><!-- doxytag: member="MGFace::operator/" ref="a21d731491c4a437aed18b6334fa64f01" args="(double s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a> MGFace::operator/ </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double. </p>

</div>
</div>
<a class="anchor" id="a383edd3d4d9ad804d06dd37d940ed5a7"></a><!-- doxytag: member="MGFace::operator=" ref="a383edd3d4d9ad804d06dd37d940ed5a7" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>&amp; MGFace::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and cell2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="ad058ef7eac06bfb0a208333a23deab53"></a><!-- doxytag: member="MGFace::outer_boundary" ref="ad058ef7eac06bfb0a208333a23deab53" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::outer_boundary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain outer_boundary curves(world coordinates representation) of the face. </p>
<p>Let the output of <a class="el" href="class_m_g_face.html#ad058ef7eac06bfb0a208333a23deab53" title="Obtain outer_boundary curves(world coordinates representation) of the face.">outer_boundary()</a> be wcurves and of <a class="el" href="class_m_g_face.html#ad838db2cb35beb4d2abbec5a68f17682" title="Obtain boundary curves(parameter space representation) of the face.">outer_boundary_param()</a> be pcurves, then wcurves[i] corresponds to pcurves[i] one to one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a8fc539b6e3ce0d7328aedd7c42c201ee">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad838db2cb35beb4d2abbec5a68f17682"></a><!-- doxytag: member="MGFace::outer_boundary_param" ref="ad838db2cb35beb4d2abbec5a68f17682" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::outer_boundary_param </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain boundary curves(parameter space representation) of the face. </p>
<p>Let the output of <a class="el" href="class_m_g_cell.html#a609e88343f5d4e5e00e50448246a1476" title="Obtain i-th boundary pointer.">boundary()</a> be wcurves and of boundary_parameter() be pcurves, then wcurves[i] corresponds to pcurves[i] one to one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a424bdd8b98a5c4eec9239da4dc689004">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a638df4048d455eb7f7fbb4b597d4a6b0"></a><!-- doxytag: member="MGFace::param_range" ref="a638df4048d455eb7f7fbb4b597d4a6b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGFace::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a97b26afbbe3a66b95e3c7ef85e0af8b2">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="abf1b5eff232aae520497d5c87b486707"></a><!-- doxytag: member="MGFace::parameter_curves" ref="abf1b5eff232aae520497d5c87b486707" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::parameter_curves </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter curves. </p>
<p>In the case of surface, parameter curve is only one. However, in the case of face, number of parameter curves are more than one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>True(!=0) if x is u-value.(i.e. obtain u=const line) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>parameter value. u or v-value accordint to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a250b40652b5c0400bd5d5f4f350b85a0">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a2c1757ea6b160669d636e3c1994d74fb"></a><!-- doxytag: member="MGFace::PBloop_curves" ref="a2c1757ea6b160669d636e3c1994d74fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFace::PBloop_curves </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain perimeter boundadary loop's curve representation. </p>
<p>Returned are curves of perimeter boundaries, do not contain perimeter of the surface. </p>

</div>
</div>
<a class="anchor" id="aae09aeef4e29317364bcad7e90063bf3"></a><!-- doxytag: member="MGFace::perp_guess" ref="aae09aeef4e29317364bcad7e90063bf3" args="(const MGPosition &amp;P, const MGPosition &amp;uvguess, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the foot of the perpendicular straight line from P. </p>
<p>Computation is done from the guess parameter value. Function's return value is whether point is obtained(true) or not(false). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of the shell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a388cb2b317aff6476993f3a19d6601c1">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aa27d36bec2da95cc046cbccdc095921c"></a><!-- doxytag: member="MGFace::perp_guess" ref="aa27d36bec2da95cc046cbccdc095921c" args="(const MGCurve &amp;curve, const MGPosition &amp;uvguess, double tguess, MGPosition &amp;uv, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFace::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perpendicular points of a curve and the face, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>Guess parameter value of the face. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tguess</em>&nbsp;</td><td>Guess parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>perpendicular point's parameter values of the shell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a8d747b59a0f1209147a7e3f5e1ffbdad">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a5349eea0914e4a56cb431574ae50bcb6"></a><!-- doxytag: member="MGFace::perp_point" ref="a5349eea0914e4a56cb431574ae50bcb6" args="(const MGPosition &amp;p, MGPosition &amp;uv, const MGPosition *uvguess=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td>
          <td class="paramname"> <em>uvguess</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定点から最も近い、垂線の足とパラメータ値を返す。 Return the foot of the perpendicular straight line from p that is nearest to point p. </p>
<p>Function's return value is whether point is obtained(1) or not(0) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>指定点(point) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of surface </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a487baf864df83faad23c2326b591a1ed">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aefc5b3715a2b98236ac8b3af59019c53"></a><!-- doxytag: member="MGFace::perps" ref="aefc5b3715a2b98236ac8b3af59019c53" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGFace::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perpendicular points on the face from a point P((x,y,z)). </p>
<p><a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> uv in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> is: uv(0): u parameter, and uv(1): v parameter of the face. Generally number of uv are more than one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a82802a49466e8a9a60c15d20103490bb">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aacb980328dcbd6469fe91a1c7ad950b1"></a><!-- doxytag: member="MGFace::pick_closest" ref="aacb980328dcbd6469fe91a1c7ad950b1" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGFace::pick_closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parameter value of the closest point from the straight to this object. </p>
<p>sl is the eye projection line whose direction is from yon to hither, and if sl had multiple intersection points, The closest point to the eye will be selected. </p>

</div>
</div>
<a class="anchor" id="acf4a1206a6fbf1ce9fc50ecf1fac45aa"></a><!-- doxytag: member="MGFace::range" ref="acf4a1206a6fbf1ce9fc50ecf1fac45aa" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGFace::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Round the input parameter (u,v) of the face to the nearest point of the face parameter range. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a13fb86a7db29413a40795bdb2522bb38">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a505374b4568be40dfcedaf0b1a585549"></a><!-- doxytag: member="MGFace::shade" ref="a505374b4568be40dfcedaf0b1a585549" args="(double span_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::shade </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shade the object in world coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc3b80c6bc3b7f0c4d7b24301d402798"></a><!-- doxytag: member="MGFace::shrink_base_surface_to_knot" ref="afc3b80c6bc3b7f0c4d7b24301d402798" args="(int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::shrink_base_surface_to_knot </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrink the base surface of this face to the part limitted by the parameter range of uvbx. </p>
<p>New parameter range uvbx2 is so determined that uvbx2 is the smallest box tha includes uvbx, and all of the u or v values of uvbx2 is one of the values of u or v knots of the surface knotvector. uvbx(0) is the parameter (us,ue) and uvbx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a487a88b5d7a91ff52e2f61384e190abd"></a><!-- doxytag: member="MGFace::sort_boundaries" ref="a487a88b5d7a91ff52e2f61384e190abd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::sort_boundaries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort boundary occurreces in m_boundaries. </p>
<p>Sorting is done according to operator&lt; of <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a>. parameter space box will be set. </p>

</div>
</div>
<a class="anchor" id="ae70d3a8a6d8a7bfe72da6ae13c7205bc"></a><!-- doxytag: member="MGFace::split" ref="ae70d3a8a6d8a7bfe72da6ae13c7205bc" args="(const MGPvector&lt; MGLoop &gt; &amp;networks, MGPvector&lt; MGFace &gt; &amp;faces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>networks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>faces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split the face giving networks loops. </p>
<p>Splitting is done by finding the smallest closed areas out of networks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>faces</em>&nbsp;</td><td>Result trimmed face(s) will be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99e3712ae4c1f583f5128403d0a06bf5"></a><!-- doxytag: member="MGFace::split" ref="a99e3712ae4c1f583f5128403d0a06bf5" args="(double param, bool is_u, MGPvector&lt; MGFSurface &gt; &amp;surfaces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::split </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>surfaces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>split this fsurface at the parameter param. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of this fsurface. if is_u is true, param is u-value, else v-value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>indicates if param is u or v of the surface parameter (u,v). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>surfaces</em>&nbsp;</td><td>splitted surfaces will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a7566ec759dec2037106a0a0b53a0a922">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad230516b40b5e101b78cd5b5f5fc5903"></a><!-- doxytag: member="MGFace::trim" ref="ad230516b40b5e101b78cd5b5f5fc5903" args="(const MGPvector&lt; MGLoop &gt; &amp;networks, const MGPosition &amp;uv, MGPvector&lt; MGFace &gt; &amp;faces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFace::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_loop.html">MGLoop</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>networks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>faces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the face giving networks loops. </p>
<p>Trimming is done by removing the smallest closed area out of networks that includes the parameter position uv(u,v). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>faces</em>&nbsp;</td><td>Result trimmed face(s) will be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c4db2375b0acb3971425cd357415d93"></a><!-- doxytag: member="MGFace::trim" ref="a6c4db2375b0acb3971425cd357415d93" args="(const MGLoop &amp;new_loop_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_loop.html">MGLoop</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>new_loop_in</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the face giving a loop new_loop that does not have the parent face. </p>
<p>new_loop mus be parrameter representaion of this face and must not have intersections with the loops of this face except the end points of new_loop.</p>
<p>Function's return value is error code: 0= normal return (not error, this includes the case of inactive loop generation). 2= tried to generate outer boundary loop inside perimeter boudary. 3= tried to generate inner boundary loop that incudes active loop inside. 4= tried to generate perimeter boudary loop that inactivates perimeter boundary loops existed. 5= tried to generate a loop outside the face. </p>

</div>
</div>
<a class="anchor" id="ae99752d02e15c01d066a0798df2e55a1"></a><!-- doxytag: member="MGFace::trim" ref="ae99752d02e15c01d066a0798df2e55a1" args="(const MGCurve &amp;pcrv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pcrv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the face giving parameter curve and world curve of a curve on the face. </p>
<p>crv has a direction. That is, when this face is divided into two faces, left part face of the crv is the face selected.</p>
<p>When the pcrv is connected to already existed boundary curve, no new boundary is generated, and inserted(connected) to the old boundary. However, new projection is floating, that is, not connected to any old boundaries, or this boundary is the first boundary, new boundary is generated. Function's return value is error code: 0= normal return (not error, this includes the case of inactive loop generation). 1= input pcrv includes a part that is outside surface parameter range. 2= tried to generate outer boundary loop inside perimeter boudary. 3= tried to generate inner boundary loop that incudes active loop inside. 4= tried to generate perimeter boudary loop that inactivates perimeter boundary loops existed. 5= tried to generate a loop outside the face. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcrv</em>&nbsp;</td><td>parameter(u,v) space curve of the face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d695a31bc598f20cfac1add521b1acf"></a><!-- doxytag: member="MGFace::trim_projection" ref="a1d695a31bc598f20cfac1add521b1acf" args="(const MGCurve &amp;crv, const MGVector &amp;direction=mgNULL_VEC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFace::trim_projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the face by the projection of a curve along a vector direction. </p>
<p>If mgNULL_VEC is specified as direction, surface normal projection will be employed. crv has a direction. That is, when this face is divided into two faces, left part face of the crv is the face selected.</p>
<p>When the projected curve on the face is connected to already existed boundary curve, no new boundary is generated, and inserted(connected) to the old boundary. However new projection is floating, that is, not connected to any old boundaries, or this boundary is the first boundary, new boundary is generated. Function's return value is error code: 0= normal return (not error, this includes the case of inactive loop generation) 2= tried to generate outer boundary loop inside perimeter boudary. 3= tried to generate inner boundary loop that incudes active loop inside. 4= tried to generate perimeter boudary loop that inactivates perimeter boundary loops existed. 5= tried to generate a loop outside the face. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>curve of world coordinates. Generally this is not on face and always is projectd to the face. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>Projection directin vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a6b65a776196d2de198f0793ebf6d0d41"></a><!-- doxytag: member="MGFace::operator*" ref="a6b65a776196d2de198f0793ebf6d0d41" args="(double s, const MGFace &amp;face)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_face.html">MGFace</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Faceのスケーリングを行い，Faceを作成する。 Scaling of the Face by a double. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Face.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:21 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

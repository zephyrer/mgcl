<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGCompositeCurve Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGCompositeCurve Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGCompositeCurve" --><!-- doxytag: inherits="MGCurve" -->
<p><a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> is a composite of other leaf curves.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;CompositeCurve.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGCompositeCurve:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_composite_curve__inherit__graph.png" border="0" usemap="#_m_g_composite_curve_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_composite_curve_inherit__map" id="_m_g_composite_curve_inherit__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="36,315,111,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="24,237,123,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="33,160,113,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="20,83,127,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="43,5,104,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGCompositeCurve:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_composite_curve__coll__graph.png" border="0" usemap="#_m_g_composite_curve_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_composite_curve_coll__map" id="_m_g_composite_curve_coll__map">
<area shape="rect" id="node2" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="224,581,299,611"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="212,501,311,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_composite_curve-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a065f872afb6869fbe0d0cbf7b7511643"></a><!-- doxytag: member="MGCompositeCurve::container_type" ref="a065f872afb6869fbe0d0cbf7b7511643" args="" -->
typedef std::deque&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ed1e3c32c24d707c8b0f0de75986f96"></a><!-- doxytag: member="MGCompositeCurve::iterator" ref="a3ed1e3c32c24d707c8b0f0de75986f96" args="" -->
typedef container_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30fc2d77c3cfbcb7865a5e0fb9ec087a"></a><!-- doxytag: member="MGCompositeCurve::const_iterator" ref="a30fc2d77c3cfbcb7865a5e0fb9ec087a" args="" -->
typedef <br class="typebreak"/>
container_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4040f00d87f08ddc075613080eef961f"></a><!-- doxytag: member="MGCompositeCurve::reverse_iterator" ref="a4040f00d87f08ddc075613080eef961f" args="" -->
typedef <br class="typebreak"/>
container_type::reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52fc41b4a9caf9c2313e4b5b6550aba0"></a><!-- doxytag: member="MGCompositeCurve::const_reverse_iterator" ref="a52fc41b4a9caf9c2313e4b5b6550aba0" args="" -->
typedef <br class="typebreak"/>
container_type::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af88b1e2430fc740c68d6c1ae2d24c8cc"></a><!-- doxytag: member="MGCompositeCurve::MGCompositeCurve" ref="af88b1e2430fc740c68d6c1ae2d24c8cc" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#af88b1e2430fc740c68d6c1ae2d24c8cc">MGCompositeCurve</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor(初期化なしでオブジェクトを作成する。). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a8639e3e0b8adbbfd28f4c7940fb3dff4">MGCompositeCurve</a> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *crv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of no curves.  <a href="#a8639e3e0b8adbbfd28f4c7940fb3dff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a893ab2443f44d2de70ce3cd2ab85e245"></a><!-- doxytag: member="MGCompositeCurve::MGCompositeCurve" ref="a893ab2443f44d2de70ce3cd2ab85e245" args="(const MGCompositeCurve &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a893ab2443f44d2de70ce3cd2ab85e245">MGCompositeCurve</a> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa67d0ec0e496fcbf2706015c6f1a2e"></a><!-- doxytag: member="MGCompositeCurve::‾MGCompositeCurve" ref="a1fa67d0ec0e496fcbf2706015c6f1a2e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGCompositeCurve</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a651ec01e8b248151e391938f9b9928f5">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a651ec01e8b248151e391938f9b9928f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66c42a926d1c5963e5dac4000f309f1"></a><!-- doxytag: member="MGCompositeCurve::operator=" ref="aa66c42a926d1c5963e5dac4000f309f1" args="(const MGCompositeCurve &amp;original)" -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d032e1cb3b50f370cc18585e6c58937"></a><!-- doxytag: member="MGCompositeCurve::operator+" ref="a2d032e1cb3b50f370cc18585e6c58937" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a2d032e1cb3b50f370cc18585e6c58937">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation object construction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd0ee3fa2249bcfa351edc71dc0017fc"></a><!-- doxytag: member="MGCompositeCurve::operator&#45;" ref="acd0ee3fa2249bcfa351edc71dc0017fc" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10b71fc277278cd9828cf2d420c01f8c"></a><!-- doxytag: member="MGCompositeCurve::operator*" ref="a10b71fc277278cd9828cf2d420c01f8c" args="(double scale) const " -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7c32b72a53e4e2b389dd4e4b0fe390c"></a><!-- doxytag: member="MGCompositeCurve::operator*" ref="ac7c32b72a53e4e2b389dd4e4b0fe390c" args="(const MGMatrix &amp;mat) const " -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9392d01e53f3c21088a04f97a0693e6"></a><!-- doxytag: member="MGCompositeCurve::operator*" ref="af9392d01e53f3c21088a04f97a0693e6" args="(const MGTransf &amp;tr) const " -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addcf945779e89f81ec4a45c87129e1df"></a><!-- doxytag: member="MGCompositeCurve::operator+=" ref="addcf945779e89f81ec4a45c87129e1df" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#addcf945779e89f81ec4a45c87129e1df">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71fd2ea45e5f3077987542b4cb9ad4b0"></a><!-- doxytag: member="MGCompositeCurve::operator&#45;=" ref="a71fd2ea45e5f3077987542b4cb9ad4b0" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a184c05046d1866b400d9fdb7333258f7"></a><!-- doxytag: member="MGCompositeCurve::operator*=" ref="a184c05046d1866b400d9fdb7333258f7" args="(double scale)" -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48446d30f3be8ba50c2242e2a20ff5cc"></a><!-- doxytag: member="MGCompositeCurve::operator*=" ref="a48446d30f3be8ba50c2242e2a20ff5cc" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5cf6b3eda1c8ebf22074a7442ff6bcc"></a><!-- doxytag: member="MGCompositeCurve::operator*=" ref="ab5cf6b3eda1c8ebf22074a7442ff6bcc" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a865dd2e1e6ffa3b5cc17899b5f6224b7"></a><!-- doxytag: member="MGCompositeCurve::is_same_curve" ref="a865dd2e1e6ffa3b5cc17899b5f6224b7" args="(const MGCurve &amp;curve2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a865dd2e1e6ffa3b5cc17899b5f6224b7">is_same_curve</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8a17e461bcd21062ed50ed50ea532d"></a><!-- doxytag: member="MGCompositeCurve::operator==" ref="aff8a17e461bcd21062ed50ed50ea532d" args="(const MGCompositeCurve &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aff8a17e461bcd21062ed50ed50ea532d">operator==</a> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac157f7d33719a89289dd9cb489ab0f1a"></a><!-- doxytag: member="MGCompositeCurve::operator==" ref="ac157f7d33719a89289dd9cb489ab0f1a" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#ac157f7d33719a89289dd9cb489ab0f1a">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0741e2c3494959ccac4497fdf7a29e66"></a><!-- doxytag: member="MGCompositeCurve::operator==" ref="a0741e2c3494959ccac4497fdf7a29e66" args="(const MGTrimmedCurve &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfa08f7875b499686a2da15178734753"></a><!-- doxytag: member="MGCompositeCurve::operator&lt;" ref="acfa08f7875b499686a2da15178734753" args="(const MGCompositeCurve &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a2312fd3061d101bf7cae4a1a1da49"></a><!-- doxytag: member="MGCompositeCurve::operator&lt;" ref="ae0a2312fd3061d101bf7cae4a1a1da49" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#af94744aa990f6158f01fad35de5fd9f7">bdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension.  <a href="#af94744aa990f6158f01fad35de5fd9f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f30a91bd177f392bfd893587aece475"></a><!-- doxytag: member="MGCompositeCurve::begin" ref="a3f30a91bd177f392bfd893587aece475" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93221d23c16bacb3d10647863e465204"></a><!-- doxytag: member="MGCompositeCurve::begin" ref="a93221d23c16bacb3d10647863e465204" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aa5aea51fdbd510b2684306e5feb1c10d">box_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum box that includes the curve of parameter interval.  <a href="#aa5aea51fdbd510b2684306e5feb1c10d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a856e0b3cf84cb6790ced42fc0e881e0e">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#a856e0b3cf84cb6790ced42fc0e881e0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a386f1dc34e78ee3641b09b46f69f09b6">change_range</a> (double t0, double t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a386f1dc34e78ee3641b09b46f69f09b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312175c9e827a984a60979fd6fd615f2"></a><!-- doxytag: member="MGCompositeCurve::closest" ref="a312175c9e827a984a60979fd6fd615f2" args="(const MGPosition &amp;point) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a312175c9e827a984a60979fd6fd615f2">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value of this curve from a point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa1ecab10ce767907b4476f3d0583b82"></a><!-- doxytag: member="MGCompositeCurve::common" ref="aaa1ecab10ce767907b4476f3d0583b82" args="(const MGCurve &amp;crv2, std::vector&lt; double &gt; &amp;vecComSpan, MGCCisect_list &amp;isect) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aaa1ecab10ce767907b4476f3d0583b82">common</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2, std::vector&lt; double &gt; &amp;vecComSpan, <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> &amp;isect) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">関数名： common 目的： 与えられた曲線と自身の交点もしくは共通部分があるかどうか調べる。 引数： const <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>&amp; crv2, (I/ ) 与えられる曲線 std::vector&lt;double&gt;&amp; vec_param ( /O) 共通部分のパラメータ範囲 <a class="el" href="class_m_g_c_cisect__list.html" title="MGCCisect_list defines linked list of MGCCisect.">MGCCisect_list</a>&amp; isect ( /O) 交点 4nの配列で、t(4*i+0),t(4*i+1)が自身のパラメータ範囲(t(4*i+0) &lt; t(4*i+1))、 t(4*i+2),t(4*i+3)が与曲線のパラメータ範囲(f(t(4*i+0))=f(t(4*i+2)) 戻り値： 3:交点も共通部分も求まった 2:交点のみが求まった 1:共通部分のみが求まった 0:交点も共通部分もなかった -1:共通エッジの収束計算エラー -2:共通エッジが４個以上求まった(のっていないと見なす) 追記： 曲線が共通かどうかの誤差にはline_zero()、をパラメータ範囲の収束計算の 誤差には、パラメータ範囲*rc_zero()を使用した <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e942e0f75340de45fe2c95ee0e002e2"></a><!-- doxytag: member="MGCompositeCurve::common" ref="a4e942e0f75340de45fe2c95ee0e002e2" args="(const MGCurve &amp;crv2, std::vector&lt; double &gt; &amp;vecComSpan) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a4e942e0f75340de45fe2c95ee0e002e2">common</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2, std::vector&lt; double &gt; &amp;vecComSpan) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">関数名： common 目的： 与えられた曲線と自身の共通部分があるかどうか調べる。 引数： const <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>&amp; crv2, (I/ ) 与えられる曲線 std::vector&lt;double&gt;&amp; vec_param ( /O) 共通部分のパラメータ範囲 4nの配列で、t(4*i+0),t(4*i+1)が自身のパラメータ範囲(t(4*i+0) &lt; t(4*i+1))、 t(4*i+2),t(4*i+3)が与曲線のパラメータ範囲(f(t(4*i+0))=f(t(4*i+2)) 戻り値： 共通部分の数: 共通部分が求まった 0: 共通部分がなかった -1: 共通エッジの収束計算エラー -2: 共通エッジが４個以上求まった(のっていないと見なす) 追記： 曲線が共通かどうかの誤差にはline_zero()を、パラメータ範囲の収束計算の誤差には、 パラメータ範囲*rc_zero()を使用した <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_interval.html">MGInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a53e71dc68cd3df6fa309f6b8bd523969">connect</a> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *add_curve)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the input curve to the end(to_end) or start(to_start) of this curve.  <a href="#a53e71dc68cd3df6fa309f6b8bd523969"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4aea37a1150f82548b6a88b8675c118"></a><!-- doxytag: member="MGCompositeCurve::connect_to_end" ref="ae4aea37a1150f82548b6a88b8675c118" args="(MGCurve *add_curve)" -->
<a class="el" href="class_m_g_interval.html">MGInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>connect_to_end</b> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *add_curve)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8fc765371f9e89baf2f460863d8838e"></a><!-- doxytag: member="MGCompositeCurve::connect_to_start" ref="ac8fc765371f9e89baf2f460863d8838e" args="(MGCurve *add_curve)" -->
<a class="el" href="class_m_g_interval.html">MGInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>connect_to_start</b> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *add_curve)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a56bdf1853a0f1f6a66a6cab99144e058">coordinate_exchange</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange ordering of the coordinates.  <a href="#a56bdf1853a0f1f6a66a6cab99144e058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a9080da1dad5b9859e2c7713b172f7051">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area.  <a href="#a9080da1dad5b9859e2c7713b172f7051"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a8706fd7a2f9afe340744d24c78c3e86d">copy_as_nurbs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy as a newed curve.  <a href="#a8706fd7a2f9afe340744d24c78c3e86d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aa5b9e15a8c90226f8a6a8bf03947b8bd">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by changing the original object's space dimension.  <a href="#aa5b9e15a8c90226f8a6a8bf03947b8bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f1d9f98fb745d0b5fd09617c201de43"></a><!-- doxytag: member="MGCompositeCurve::curve" ref="a7f1d9f98fb745d0b5fd09617c201de43" args="(size_t i) const " -->
const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a7f1d9f98fb745d0b5fd09617c201de43">curve</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the i-th curve in this CompositeCurve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7086f45607ea532f128cf14c221d6991"></a><!-- doxytag: member="MGCompositeCurve::curve" ref="a7086f45607ea532f128cf14c221d6991" args="(size_t i)" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>curve</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a468603ad144e943de392e2dae8f7d379">curvilinear_integral</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvilinear integral of the 1st two coordinates from parameter t0 to t1.  <a href="#a468603ad144e943de392e2dae8f7d379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aef07dacf4d40ca1ae4494e202f26a99b">curvilinear_integral</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute curvilinear integral of the 1st two coordinates.  <a href="#aef07dacf4d40ca1ae4494e202f26a99b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59263a8fb45d6e8df64541944ca0ec4c"></a><!-- doxytag: member="MGCompositeCurve::display_break_points" ref="a59263a8fb45d6e8df64541944ca0ec4c" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_break_points</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace4a92067c8c3cdf17662d5b1f310298"></a><!-- doxytag: member="MGCompositeCurve::display_control_polygon" ref="ace4a92067c8c3cdf17662d5b1f310298" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_control_polygon</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aa61f977b457956d2ba99ac1a603cd9a0">display_curvatures</a> (double scale, int density, bool use_radius) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a63f0d3b8aa9ce5cd260e54d2161e23cc">divide_multi</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;crv_list, int multiplicity=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide this curve at the designated knot multiplicity point.  <a href="#a63f0d3b8aa9ce5cd260e54d2161e23cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a17c6c44a4e4cb1edf26e5d3ff5165304">drawSE</a> (double span_length, double t0, double t1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0001a2ec428a3cb14f35425f8544688"></a><!-- doxytag: member="MGCompositeCurve::end" ref="ad0001a2ec428a3cb14f35425f8544688" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a907953b522cbbe94a96de27b4485ea93"></a><!-- doxytag: member="MGCompositeCurve::end" ref="a907953b522cbbe94a96de27b4485ea93" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#ae70e0a06dd6e59b8847db4ad3804803d">eval</a> (double t, size_t nderiv=0, int left=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate n'th derivative data. n=0 means positional data evaluation.  <a href="#ae70e0a06dd6e59b8847db4ad3804803d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a518c7815e70c63691305648cc0ab9eef">extend</a> (double length, bool start=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate this curve by an (approximate) chord length.  <a href="#a518c7815e70c63691305648cc0ab9eef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a3a46b31dfd69edb2b14eb887607dd6ca">find</a> (double t, bool right_continuous=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find which curve parameter range input t belongs to.  <a href="#a3a46b31dfd69edb2b14eb887607dd6ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93f3e72bc3567e0e5c2d61777528370c"></a><!-- doxytag: member="MGCompositeCurve::identify_type" ref="a93f3e72bc3567e0e5c2d61777528370c" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a93f3e72bc3567e0e5c2d61777528370c">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a90dab13643364ec1d650c7a43f5bedb1">is_planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is planar or not.  <a href="#a90dab13643364ec1d650c7a43f5bedb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a322adce68276ce14e185b5b9a8ddbe1c"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a322adce68276ce14e185b5b9a8ddbe1c" args="(const MGCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a322adce68276ce14e185b5b9a8ddbe1c">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of CompositeCurve and another curve crv2. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1debcbeeed1c64a96a7c61db6fa318a7"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a1debcbeeed1c64a96a7c61db6fa318a7" args="(const MGStraight &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b75a4e609235a4814c5082e54c7b063"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a9b75a4e609235a4814c5082e54c7b063" args="(const MGRLBRep &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dc0b739418d10b0049193c04f955635"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a4dc0b739418d10b0049193c04f955635" args="(const MGEllipse &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afba6e86a43c1418289c1939ac0726584"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="afba6e86a43c1418289c1939ac0726584" args="(const MGLBRep &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02125568f01ed0a67321aed7634fc85a"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a02125568f01ed0a67321aed7634fc85a" args="(const MGSurfCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c07a0f059d5963bb35f597459fb484"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a01c07a0f059d5963bb35f597459fb484" args="(const MGBSumCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76d2789804a205bb30c0dab68f34edb5"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a76d2789804a205bb30c0dab68f34edb5" args="(const MGTrimmedCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a077744e74275fec7178802ed2db01e5c"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a077744e74275fec7178802ed2db01e5c" args="(const MGCompositeCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a8996f7506c2eb39164e41b22fede14"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a3a8996f7506c2eb39164e41b22fede14" args="(const MGSurface &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a3a8996f7506c2eb39164e41b22fede14">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection with a Surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8965e8a211ff5ebd92229e16a5af0390"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a8965e8a211ff5ebd92229e16a5af0390" args="(const MGPlane &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad55c7bd2a9b102ab2eaee84a73d9c9a4"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="ad55c7bd2a9b102ab2eaee84a73d9c9a4" args="(const MGSphere &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65994f203ec929f799cc615e12206f6a"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="a65994f203ec929f799cc615e12206f6a" args="(const MGCylinder &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3db6066aac9a8aee45a4cfcb787e12c"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="aa3db6066aac9a8aee45a4cfcb787e12c" args="(const MGSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9cbcae72ce79054d3cafcd16a26b30f"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="af9cbcae72ce79054d3cafcd16a26b30f" args="(const MGRSBRep &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae45196bc092df933b2574a87320e4052"></a><!-- doxytag: member="MGCompositeCurve::isect" ref="ae45196bc092df933b2574a87320e4052" args="(const MGBSumSurf &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;surf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d36a894808a8d5d577763dbb9d3fac9"></a><!-- doxytag: member="MGCompositeCurve::knot" ref="a0d36a894808a8d5d577763dbb9d3fac9" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a0d36a894808a8d5d577763dbb9d3fac9">knot</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a54213ac6427614d55dcc51f3ba1c14ec">knot_vector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector of the curve.  <a href="#a54213ac6427614d55dcc51f3ba1c14ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a36b7c3ff5554deb40246556eece68e79">length</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cmpute curve length of the interval.  <a href="#a36b7c3ff5554deb40246556eece68e79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a576dac2f6b30658123a818b2a8eff153">length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute whole curve length.  <a href="#a576dac2f6b30658123a818b2a8eff153"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a6b41bbe5be20ad5c7ed55133a986ec8f">limit</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;rng)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update this by limiting the parameter range of the curve.  <a href="#a6b41bbe5be20ad5c7ed55133a986ec8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a546fd87ba29cbd5a7b12b1fd96bf81b4"></a><!-- doxytag: member="MGCompositeCurve::negate" ref="a546fd87ba29cbd5a7b12b1fd96bf81b4" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a546fd87ba29cbd5a7b12b1fd96bf81b4">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the curve direction(曲線の方向を反転する). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8afd2a447867f66395745ec8462321b"></a><!-- doxytag: member="MGCompositeCurve::negate_param" ref="ae8afd2a447867f66395745ec8462321b" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#ae8afd2a447867f66395745ec8462321b">negate_param</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this curve is negated by "negate()". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecee9f4329a5dc540716aac266c48e82"></a><!-- doxytag: member="MGCompositeCurve::number_of_curves" ref="aecee9f4329a5dc540716aac266c48e82" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aecee9f4329a5dc540716aac266c48e82">number_of_curves</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of included curves in this CompositeCurve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#abafbfcc532a41f1baa23d931c5dd7e58">offset</a> (double ofs_value, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 costant offset curve.  <a href="#abafbfcc532a41f1baa23d931c5dd7e58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a8ae94ef9a2ffe4ac3d5464de109853f7">offset</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;ofs_value_lb, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 valuable offset curve.  <a href="#a8ae94ef9a2ffe4ac3d5464de109853f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#ab153a2ed89bfde7a9081eb27cbdc2a30">offset_c2</a> (double ofs_value, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C2連続曲線の一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 costant offset curve of C2 continuous curve.  <a href="#ab153a2ed89bfde7a9081eb27cbdc2a30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#acc36307fc9a9ed9a4993052ff4440d60">offset_c2</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;ofs_value_lb, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C2連続曲線の可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 valuable offset curveof C2 continuous curve.  <a href="#acc36307fc9a9ed9a4993052ff4440d60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a084ec1ac18765a7efe299057101888d2">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;, double &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if given point is on the curve or not.  <a href="#a084ec1ac18765a7efe299057101888d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a7a2ab4336545fd728f0d85dbd7390644">order</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order.  <a href="#a7a2ab4336545fd728f0d85dbd7390644"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ae6ae50cc233072d55a53c97e939106"></a><!-- doxytag: member="MGCompositeCurve::param_e" ref="a9ae6ae50cc233072d55a53c97e939106" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a9ae6ae50cc233072d55a53c97e939106">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a6776cd9d6a863e9a9dc76276456a7a4d">param_normalize</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize parameter value t to the nearest knot if their distance is within tolerance.  <a href="#a6776cd9d6a863e9a9dc76276456a7a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3270142964db19b3dd1a138585bbdbc7"></a><!-- doxytag: member="MGCompositeCurve::param_s" ref="a3270142964db19b3dd1a138585bbdbc7" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a3270142964db19b3dd1a138585bbdbc7">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a61403250aa73926bc39f201c1d160da2">part</a> (double t0, double t1, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of this curve from parameter t0 to t1.  <a href="#a61403250aa73926bc39f201c1d160da2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#acd3b0f1986340bbf61c71740c76fb124">perp_guess</a> (double t0, double t1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, double tg, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return perpendicular point from a point P, given guess starting paramter values.  <a href="#acd3b0f1986340bbf61c71740c76fb124"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aa3b520111edea13098c37e59f2fca784">perp_guess</a> (double s0, double s1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, double t0, double t1, double sg, double tg, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;st) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return perpendicular points of two curves, given guess starting paramter values.  <a href="#aa3b520111edea13098c37e59f2fca784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a930789d4ab17ec5c96c22666d01ef018">perps</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the perpendicular points of this curve and the second one.  <a href="#a930789d4ab17ec5c96c22666d01ef018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a749eb6172dd4593bbc45c02f0ae200e6"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="a749eb6172dd4593bbc45c02f0ae200e6" args="(const MGStraight &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f8a427422b195acd73508601264f569"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="a3f8a427422b195acd73508601264f569" args="(const MGRLBRep &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a25599a4c7bd2d8bcde10f6723da1c"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="af4a25599a4c7bd2d8bcde10f6723da1c" args="(const MGEllipse &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48209e8914f7b3f7d770caaee0dc8ba2"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="a48209e8914f7b3f7d770caaee0dc8ba2" args="(const MGLBRep &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af12e15c44ef5f0700635dd9c0791a5ea"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="af12e15c44ef5f0700635dd9c0791a5ea" args="(const MGSurfCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2703d1e191dec0f8b5f292fefb696c17"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="a2703d1e191dec0f8b5f292fefb696c17" args="(const MGBSumCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a17a7f0e2cf78fdba77d67a4db958c6ba">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all foot points of the perpendicular line from point to the curve.  <a href="#a17a7f0e2cf78fdba77d67a4db958c6ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#ac78529fe1fe3c7d35276fdfb700ed159">project_onto_surface</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;srf, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv_uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the projected curve of this onto the surface srf.  <a href="#ac78529fe1fe3c7d35276fdfb700ed159"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a623f2832a05a343b3ce6f7999aa13b38">release_back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the pointer of the last curve.  <a href="#a623f2832a05a343b3ce6f7999aa13b38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a5a7b9b1b02ec9fd1f978ccdf2661d117">release_front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the pointer of the 1st curve.  <a href="#a5a7b9b1b02ec9fd1f978ccdf2661d117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a701310f7adc15b7b57062f7a63fa2d7c">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数(B表現曲線のみ) トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい Remove redundant knot, and reduce the b-rep dimension.  <a href="#a701310f7adc15b7b57062f7a63fa2d7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a58c466999f78d0ec7237c735e94e4d41">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the space dimension.  <a href="#a58c466999f78d0ec7237c735e94e4d41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#af036bcf3358598d97dce155888e9d140">sweep</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sweep surface from crv Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted.  <a href="#af036bcf3358598d97dce155888e9d140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca174703718cb0c59c6b05b03ed0b16"></a><!-- doxytag: member="MGCompositeCurve::type" ref="a3ca174703718cb0c59c6b05b03ed0b16" args="() const " -->
<a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a3ca174703718cb0c59c6b05b03ed0b16">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve type(曲線のタイプを返す). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88cc1031f01a1941d72f68298f785074"></a><!-- doxytag: member="MGCompositeCurve::unlimit" ref="a88cc1031f01a1941d72f68298f785074" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a88cc1031f01a1941d72f68298f785074">unlimit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve(limitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3265d331a8c17384ffd1159ddcc703e2"></a><!-- doxytag: member="MGCompositeCurve::unlimit_end" ref="a3265d331a8c17384ffd1159ddcc703e2" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a3265d331a8c17384ffd1159ddcc703e2">unlimit_end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the end point direction (終点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d888c52fb133aae933986abf19d509f"></a><!-- doxytag: member="MGCompositeCurve::unlimit_start" ref="a3d888c52fb133aae933986abf19d509f" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a3d888c52fb133aae933986abf19d509f">unlimit_start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the start point direction (始点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18d901892914afed6ec434913fbb46d3"></a><!-- doxytag: member="MGCompositeCurve::out" ref="a18d901892914afed6ec434913fbb46d3" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a18d901892914afed6ec434913fbb46d3">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12b195c27aae7430fb0618dbec74a3de"></a><!-- doxytag: member="MGCompositeCurve::out_to_IGES" ref="a12b195c27aae7430fb0618dbec74a3de" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a12b195c27aae7430fb0618dbec74a3de">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output to IGES stream file. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#acf017375394a888f602d6fe8c7b047c2">intersect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection point of 1D sub curve of original curve.  <a href="#acf017375394a888f602d6fe8c7b047c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#ade5a13acfd3b6c9fcc280da56f76efb1">oneD</a> (const double g[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve.  <a href="#ade5a13acfd3b6c9fcc280da56f76efb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7581e21fc6d1547037019924dce5108"></a><!-- doxytag: member="MGCompositeCurve::ReadMembers" ref="aa7581e21fc6d1547037019924dce5108" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#aa7581e21fc6d1547037019924dce5108">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み出す関数 戻り値boolは正常に読み出しが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb8795b02cca1424b3aead01353d6835"></a><!-- doxytag: member="MGCompositeCurve::WriteMembers" ref="abb8795b02cca1424b3aead01353d6835" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#abb8795b02cca1424b3aead01353d6835">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 戻り値boolは正常に書き込みが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59c5518734ea18942e1431f29fa08caa"></a><!-- doxytag: member="MGCompositeCurve::MGHHisect" ref="a59c5518734ea18942e1431f29fa08caa" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_composite_curve.html#a59c5518734ea18942e1431f29fa08caa">MGHHisect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7116cd46ee9971afe7e3cd9149280aa"></a><!-- doxytag: member="MGCompositeCurve::operator+" ref="ab7116cd46ee9971afe7e3cd9149280aa" args="(const MGVector &amp;v, const MGCompositeCurve &amp;lb)" -->
MGDECL friend <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;lb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a1442249033e945f2891bbc74314358"></a><!-- doxytag: member="MGCompositeCurve::operator*" ref="a5a1442249033e945f2891bbc74314358" args="(double scale, const MGCompositeCurve &amp;)" -->
MGDECL friend <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale, const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> is a composite of other leaf curves. </p>
<p>Assumedly they are connected as C0 continuity. However, <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> does not check their continuity, but only put first or last as the user says (in connect_to_end or in connect_to_start). Parameter ranges of the member curves are always continuous. <a class="el" href="class_m_g_composite_curve.html#a3270142964db19b3dd1a138585bbdbc7" title="Return starting parameter value.">param_s()</a> of the 1st curve to <a class="el" href="class_m_g_composite_curve.html#a9ae6ae50cc233072d55a53c97e939106" title="Return ending parameter value.">param_e()</a> of the last form MGCompositeCurve's paramter range. <a class="el" href="class_m_g_composite_curve.html#aecee9f4329a5dc540716aac266c48e82" title="Get the number of included curves in this CompositeCurve.">number_of_curves()</a> indicates the number of leaf curves(in other words, element curves to construct the <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>). </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8639e3e0b8adbbfd28f4c7940fb3dff4"></a><!-- doxytag: member="MGCompositeCurve::MGCompositeCurve" ref="a8639e3e0b8adbbfd28f4c7940fb3dff4" args="(MGCurve *crv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCompositeCurve::MGCompositeCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>crv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor of no curves. </p>
<p>Constructor of one curve. crv is a newed object pointer and <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> takes the ownership. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af94744aa990f6158f01fad35de5fd9f7"></a><!-- doxytag: member="MGCompositeCurve::bdim" ref="af94744aa990f6158f01fad35de5fd9f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGCompositeCurve::bdim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns B-Rep Dimension. </p>
<p>bdim of <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> is the sum of each member curves. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ad553529eb25955542f06bcea46ad3b0f">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa5aea51fdbd510b2684306e5feb1c10d"></a><!-- doxytag: member="MGCompositeCurve::box_limitted" ref="aa5aea51fdbd510b2684306e5feb1c10d" args="(const MGInterval &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGCompositeCurve::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return minimum box that includes the curve of parameter interval. </p>
<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a680d824802125a83533362f05ee84b71">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a856e0b3cf84cb6790ced42fc0e881e0e"></a><!-- doxytag: member="MGCompositeCurve::change_dimension" ref="a856e0b3cf84cb6790ced42fc0e881e0e" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&amp; MGCompositeCurve::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac83a24a002d65e6339859e51321fff57">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a386f1dc34e78ee3641b09b46f69f09b6"></a><!-- doxytag: member="MGCompositeCurve::change_range" ref="a386f1dc34e78ee3641b09b46f69f09b6" args="(double t0, double t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCompositeCurve::change_range </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a260ff34df53249e6887a09553f84058b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a9080da1dad5b9859e2c7713b172f7051"></a><!-- doxytag: member="MGCompositeCurve::clone" ref="a9080da1dad5b9859e2c7713b172f7051" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>* MGCompositeCurve::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae85e37def31262577515e70078fb92e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a53e71dc68cd3df6fa309f6b8bd523969"></a><!-- doxytag: member="MGCompositeCurve::connect" ref="a53e71dc68cd3df6fa309f6b8bd523969" args="(MGCurve *add_curve)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_interval.html">MGInterval</a> MGCompositeCurve::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>add_curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the input curve to the end(to_end) or start(to_start) of this curve. </p>
<p>(1) End(start) point of this curve is assumedly the same as the start(end) point of add_curve. However, connect_to_xxx does not check the continuity except when connecting two curves are both <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. (2) add_curve must be a newed object pointer and connect_to_end takes the ownership. (3) add_curve can be a <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. In this case each curves in add_curve become members of this <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. (4) When add_curve is a SurfCurve, or a TrimmedCurve, it is changed to non SurfCurve or non TrimmedCurve. Thus the original surface or curve can be deleted or modified. (5) When <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a> was not an empty curve, the original part of the MGCompositeCurve's parameter range will not be changed by this connect_to_end. Instead add_curve's parameter range will be so modified that the magnitude of 1st derivatives of the two curves are the same at the connecting point and the modified add_curve's parameter range is continuous to the original. (6) connect_to_end(start) will change add_curve's direction if necessary. Function's return value is the new parameter range of add_curve after added. <a class="el" href="class_m_g_composite_curve.html#a53e71dc68cd3df6fa309f6b8bd523969" title="Connect the input curve to the end(to_end) or start(to_start) of this curve.">connect()</a> connects to either start or end of this depending the distance of the start or end points of this curve to the start or end points of add_curve. connect_to_end() connects either start or end points of add_curve to the end to this curve. connect_to_start() connects either start or end points of add_curve to the start to this curve. </p>

</div>
</div>
<a class="anchor" id="a56bdf1853a0f1f6a66a6cab99144e058"></a><!-- doxytag: member="MGCompositeCurve::coordinate_exchange" ref="a56bdf1853a0f1f6a66a6cab99144e058" args="(size_t i, size_t j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&amp; MGCompositeCurve::coordinate_exchange </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange ordering of the coordinates. </p>
<p>Exchange coordinates (i) and (j). </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ae8c6cb11b641e5b6f596867672bfda66">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8706fd7a2f9afe340744d24c78c3e86d"></a><!-- doxytag: member="MGCompositeCurve::copy_as_nurbs" ref="a8706fd7a2f9afe340744d24c78c3e86d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCompositeCurve::copy_as_nurbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy as a newed curve. </p>
<p>The new curve will be <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> or <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. When original curve was a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>, the new curve will be a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. Otherwise, the new curve will be a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. Returned object must be deleted. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a9ef3806ddfd62edf9b7b9c59626caf5a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa5b9e15a8c90226f8a6a8bf03947b8bd"></a><!-- doxytag: member="MGCompositeCurve::copy_change_dimension" ref="aa5b9e15a8c90226f8a6a8bf03947b8bd" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>* MGCompositeCurve::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a84add0aaacbc189dd584dbf9f5670d99">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a468603ad144e943de392e2dae8f7d379"></a><!-- doxytag: member="MGCompositeCurve::curvilinear_integral" ref="a468603ad144e943de392e2dae8f7d379" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGCompositeCurve::curvilinear_integral </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvilinear integral of the 1st two coordinates from parameter t0 to t1. </p>
<p>This integral can be used to compute area sorrounded by the curve. The sum of all the member curve's curvilinear_integral. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a27b4724616d26b4b6aa076b010645a26">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aef07dacf4d40ca1ae4494e202f26a99b"></a><!-- doxytag: member="MGCompositeCurve::curvilinear_integral" ref="aef07dacf4d40ca1ae4494e202f26a99b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGCompositeCurve::curvilinear_integral </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute curvilinear integral of the 1st two coordinates. </p>
<p>(All the parameter range of the curve.) This integral can be used to compute area sorrounded by the curve. The sum of all the member curve's curvilinear_integral. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa61f977b457956d2ba99ac1a603cd9a0"></a><!-- doxytag: member="MGCompositeCurve::display_curvatures" ref="aa61f977b457956d2ba99ac1a603cd9a0" args="(double scale, int density, bool use_radius) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCompositeCurve::display_curvatures </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>scaling of the graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>density</em>&nbsp;</td><td>densitiy of the graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_radius</em>&nbsp;</td><td>true:radius display, false:curvature display. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a736b00ca1d84ec5285aac7d081f6cd05">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a63f0d3b8aa9ce5cd260e54d2161e23cc"></a><!-- doxytag: member="MGCompositeCurve::divide_multi" ref="a63f0d3b8aa9ce5cd260e54d2161e23cc" args="(MGPvector&lt; MGCurve &gt; &amp;crv_list, int multiplicity=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGCompositeCurve::divide_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>crv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiplicity</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide this curve at the designated knot multiplicity point. </p>
<p>Function's return value is the number of the curves after divided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv_list</em>&nbsp;</td><td>divided curves will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiplicity</em>&nbsp;</td><td>designates the multiplicity of the knot to divide at. When multiplicity&lt;=0, <a class="el" href="class_m_g_composite_curve.html#a7a2ab4336545fd728f0d85dbd7390644" title="Returns the order.">order()</a>-1 is assumed. When multiplicity&gt;=order(), <a class="el" href="class_m_g_composite_curve.html#a7a2ab4336545fd728f0d85dbd7390644" title="Returns the order.">order()</a> is assumed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a1ee0ed7b28c40b502d4eeec470368b4d">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a17c6c44a4e4cb1edf26e5d3ff5165304"></a><!-- doxytag: member="MGCompositeCurve::drawSE" ref="a17c6c44a4e4cb1edf26e5d3ff5165304" args="(double span_length, double t0, double t1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCompositeCurve::drawSE </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>Start parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>End parameter value of the curve. Draw will be performed from t0 to t1. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a20497e172065788e673b771f018d90af">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ae70e0a06dd6e59b8847db4ad3804803d"></a><!-- doxytag: member="MGCompositeCurve::eval" ref="ae70e0a06dd6e59b8847db4ad3804803d" args="(double t, size_t nderiv=0, int left=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGCompositeCurve::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate n'th derivative data. n=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>Left continuous(left=true) or right continuous(left=false). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#acbcbb8f812be257921ef63c71afdedcf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a518c7815e70c63691305648cc0ab9eef"></a><!-- doxytag: member="MGCompositeCurve::extend" ref="a518c7815e70c63691305648cc0ab9eef" args="(double length, bool start=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCompositeCurve::extend </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate this curve by an (approximate) chord length. </p>
<p>The extrapolation is C2 continuous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>approximate chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of which point to extend, start or end point of the line. If start is true extend on the start point. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#af0e8206d530257d27910d0676ba0be01">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a3a46b31dfd69edb2b14eb887607dd6ca"></a><!-- doxytag: member="MGCompositeCurve::find" ref="a3a46b31dfd69edb2b14eb887607dd6ca" args="(double t, bool right_continuous=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGCompositeCurve::find </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>right_continuous</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find which curve parameter range input t belongs to. </p>
<p>Function's return value m is the id of m_composite which satisfy m_composite[m]&lt;=t&lt;m_composite[m+1]; m_composite.size() should be &gt;=1, or find will abort. </p>

</div>
</div>
<a class="anchor" id="acf017375394a888f602d6fe8c7b047c2"></a><!-- doxytag: member="MGCompositeCurve::intersect_1D" ref="acf017375394a888f602d6fe8c7b047c2" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGCompositeCurve::intersect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection point of 1D sub curve of original curve. </p>
<p>Parameter values of intersection point will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7da60650ad1b0c4823eeb1c3ce8be722">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a90dab13643364ec1d650c7a43f5bedb1"></a><!-- doxytag: member="MGCompositeCurve::is_planar" ref="a90dab13643364ec1d650c7a43f5bedb1" args="(MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCompositeCurve::is_planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is planar or not. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be output to plane if this is planar. Function's return value is true if planar. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a3e6f96416ab574420cbed88ebfc414e9">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a54213ac6427614d55dcc51f3ba1c14ec"></a><!-- doxytag: member="MGCompositeCurve::knot_vector" ref="a54213ac6427614d55dcc51f3ba1c14ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a>&amp; MGCompositeCurve::knot_vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the knot vector of the curve. </p>
<p>This should not be used. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a6b0a611b67e7de7e6763de85a869eacc">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a36b7c3ff5554deb40246556eece68e79"></a><!-- doxytag: member="MGCompositeCurve::length" ref="a36b7c3ff5554deb40246556eece68e79" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGCompositeCurve::length </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cmpute curve length of the interval. </p>
<p>If t1 is greater than t2, return negative value. パラメータが昇順で与えられたときは正値、降順のときは負値を返す。 The sum of all the member curve's length. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a7d7c4dd68f29d059515a267023f50ddf">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a576dac2f6b30658123a818b2a8eff153"></a><!-- doxytag: member="MGCompositeCurve::length" ref="a576dac2f6b30658123a818b2a8eff153" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGCompositeCurve::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute whole curve length. </p>
<p>If the curve is infinite, return -1. 自身の曲線が有界の場合、その曲線の距離を返却する。非有界の場 合はー１を返却をする。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a1873bf48b6b84ba4e5c0b41fc5d10b18">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a6b41bbe5be20ad5c7ed55133a986ec8f"></a><!-- doxytag: member="MGCompositeCurve::limit" ref="a6b41bbe5be20ad5c7ed55133a986ec8f" args="(const MGInterval &amp;rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&amp; MGCompositeCurve::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rng</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update this by limiting the parameter range of the curve. </p>
<p>自身に指定したパラメータ範囲のｌｉｍｉｔをつける。 </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a4f5e376f184379038ebac06536962e32">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="abafbfcc532a41f1baa23d931c5dd7e58"></a><!-- doxytag: member="MGCompositeCurve::offset" ref="abafbfcc532a41f1baa23d931c5dd7e58" args="(double ofs_value, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGCompositeCurve::offset </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 costant offset curve. </p>
<p>if the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a04c8f0af36fd4efea083189ab3aaa7a7">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8ae94ef9a2ffe4ac3d5464de109853f7"></a><!-- doxytag: member="MGCompositeCurve::offset" ref="a8ae94ef9a2ffe4ac3d5464de109853f7" args="(const MGLBRep &amp;ofs_value_lb, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGCompositeCurve::offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ofs_value_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 valuable offset curve. </p>
<p>if the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value_lb</em>&nbsp;</td><td>空間次元１の線B表現で示したオフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a904ef6006545f9056dedc9ea5578365a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="acc36307fc9a9ed9a4993052ff4440d60"></a><!-- doxytag: member="MGCompositeCurve::offset_c2" ref="acc36307fc9a9ed9a4993052ff4440d60" args="(const MGLBRep &amp;ofs_value_lb, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> MGCompositeCurve::offset_c2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ofs_value_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C2連続曲線の可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 valuable offset curveof C2 continuous curve. </p>
<p>if the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value_lb</em>&nbsp;</td><td>空間次元１の線B表現で示したオフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a48dc1aea71c5b63db5495beac40fa59c">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ab153a2ed89bfde7a9081eb27cbdc2a30"></a><!-- doxytag: member="MGCompositeCurve::offset_c2" ref="ab153a2ed89bfde7a9081eb27cbdc2a30" args="(double ofs_value, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> MGCompositeCurve::offset_c2 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C2連続曲線の一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 costant offset curve of C2 continuous curve. </p>
<p>if the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a857248909351f001fa13238bfb3452aa">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a084ec1ac18765a7efe299057101888d2"></a><!-- doxytag: member="MGCompositeCurve::on" ref="a084ec1ac18765a7efe299057101888d2" args="(const MGPosition &amp;, double &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCompositeCurve::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if given point is on the curve or not. </p>
<p>If yes, return parameter value of the curve. Even if not, return nearest point's parameter. 指定点が自身上にあるかを調べる。曲線上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Function's return value is &gt;0 if the point is on the curve, and 0 if the point is not on the curve. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ad2c08f169d6d447464d73d4d6b33ae1d">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ade5a13acfd3b6c9fcc280da56f76efb1"></a><!-- doxytag: member="MGCompositeCurve::oneD" ref="ade5a13acfd3b6c9fcc280da56f76efb1" args="(const double g[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGCompositeCurve::oneD </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>g</em>[4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve. </p>
<p>This is used to compute intersections with a plane g[4]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>Plane expression(a,b,c,d) where ax+by+cz=d. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ac0d98232c1251692db526e28d65a6f7e">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a651ec01e8b248151e391938f9b9928f5"></a><!-- doxytag: member="MGCompositeCurve::operator=" ref="a651ec01e8b248151e391938f9b9928f5" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a>&amp; MGCompositeCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and crv2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="a7a2ab4336545fd728f0d85dbd7390644"></a><!-- doxytag: member="MGCompositeCurve::order" ref="a7a2ab4336545fd728f0d85dbd7390644" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MGCompositeCurve::order </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the order. </p>
<p>Returns the maximum order among the curves. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#aaedfb7d4914191ad41182305ff2c0603">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a6776cd9d6a863e9a9dc76276456a7a4d"></a><!-- doxytag: member="MGCompositeCurve::param_normalize" ref="a6776cd9d6a863e9a9dc76276456a7a4d" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGCompositeCurve::param_normalize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize parameter value t to the nearest knot if their distance is within tolerance. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#ab8d6aac48fea5813393870bcbd6a1e78">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a61403250aa73926bc39f201c1d160da2"></a><!-- doxytag: member="MGCompositeCurve::part" ref="a61403250aa73926bc39f201c1d160da2" args="(double t0, double t1, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCompositeCurve::part </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of this curve from parameter t0 to t1. </p>
<p>Returned is the pointer to newed object, and so should be deleted by calling program, or memory leaked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#a57c9d6e7f929b0d77c75cc6417daba2b">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa3b520111edea13098c37e59f2fca784"></a><!-- doxytag: member="MGCompositeCurve::perp_guess" ref="aa3b520111edea13098c37e59f2fca784" args="(double s0, double s1, const MGCurve &amp;curve2, double t0, double t1, double sg, double tg, MGPosition &amp;st) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGCompositeCurve::perp_guess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>st</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return perpendicular points of two curves, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>parameter range of this. When s0&gt;=s1, no limit for this parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curve2</em>&nbsp;</td><td>2nd curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of curve2. When t0&gt;=t1, no limit for curve2 parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tg</em>&nbsp;</td><td>Guess parameter values of the two curves sg: this curve's parameter, tg:curve2's parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>perpendicular points' parameter values will be output. st(0): this curve's parameter, st(1):curve2's parameter. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ab64b507359c80bcbb55550f2df8a7c62">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="acd3b0f1986340bbf61c71740c76fb124"></a><!-- doxytag: member="MGCompositeCurve::perp_guess" ref="acd3b0f1986340bbf61c71740c76fb124" args="(double t0, double t1, const MGPosition &amp;P, double tg, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGCompositeCurve::perp_guess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return perpendicular point from a point P, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of this. (t0&gt;=t1) indicates no range specified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tg</em>&nbsp;</td><td>Guess parameter values of this curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#a31249d89ab8ecc07a0d7f617f165df8a">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a17a7f0e2cf78fdba77d67a4db958c6ba"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="a17a7f0e2cf78fdba77d67a4db958c6ba" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGCompositeCurve::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all foot points of the perpendicular line from point to the curve. </p>
<p>与ポイントから曲線へ下ろした垂線の足の，曲線のパラメータ値を すべて求める。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#ad94d161f9e243e1a47bf0ebe7b5dcf29">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a930789d4ab17ec5c96c22666d01ef018"></a><!-- doxytag: member="MGCompositeCurve::perps" ref="a930789d4ab17ec5c96c22666d01ef018" args="(const MGCurve &amp;crv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCompositeCurve::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the perpendicular points of this curve and the second one. </p>
<p>That is, if f(s) and g(t) are the points of the two curves f and g, then obtains points where the following conditions are satisfied: fs*(f-g)=0. gt*(g-f)=0. Here fs and gt are 1st derivatives at s and t of f and g. <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv2's parameter value. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#a0da4a6809840a951581a99174dbebbab">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac78529fe1fe3c7d35276fdfb700ed159"></a><!-- doxytag: member="MGCompositeCurve::project_onto_surface" ref="ac78529fe1fe3c7d35276fdfb700ed159" args="(const MGFSurface &amp;srf, MGPvector&lt; MGCurve &gt; &amp;vec_crv_uv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGCompositeCurve::project_onto_surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv_uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the projected curve of this onto the surface srf. </p>
<p>The direction of the projection is along the vector vec if the vec is not NULL, and normal to the surface if the vec is NULL. Output of 'project' is two kind of curves: one is general world coordinate curves('vec_crv'), and the other is (u,v) curves of the parameter space of the surfaces(vec_crv_uv). vec_crv_uv.size() is equal to vec_crv.size(). Let the size be n, then (vec_crv_uv[i], vec_crv[i]) is one pair for 0&lt;=i&lt;n. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec_crv_uv</em>&nbsp;</td><td>Projected curve(surface parameter (u,v) representation) will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv</em>&nbsp;</td><td>Projected curve(world coordinate(x,y,z) representation) will be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a623f2832a05a343b3ce6f7999aa13b38"></a><!-- doxytag: member="MGCompositeCurve::release_back" ref="a623f2832a05a343b3ce6f7999aa13b38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCompositeCurve::release_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the pointer of the last curve. </p>
<p>Returned will be the released <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a> pointer. </p>

</div>
</div>
<a class="anchor" id="a5a7b9b1b02ec9fd1f978ccdf2661d117"></a><!-- doxytag: member="MGCompositeCurve::release_front" ref="a5a7b9b1b02ec9fd1f978ccdf2661d117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCompositeCurve::release_front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the pointer of the 1st curve. </p>
<p>Returned will be the released <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a> pointer. </p>

</div>
</div>
<a class="anchor" id="a701310f7adc15b7b57062f7a63fa2d7c"></a><!-- doxytag: member="MGCompositeCurve::remove_knot" ref="a701310f7adc15b7b57062f7a63fa2d7c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCompositeCurve::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数(B表現曲線のみ) トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい Remove redundant knot, and reduce the b-rep dimension. </p>
<p>The tolerance used is <a class="el" href="class_m_g_tolerance.html#a10b55492588f36f67c17352ef77ae08f" title="Return m_line_zero. m_line_zeroを返却する。.">MGTolerance::line_zero()</a>. </p>

<p>Reimplemented from <a class="el" href="class_m_g_curve.html#aac3a1862056a9ea5e662e692f2fcebbb">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a58c466999f78d0ec7237c735e94e4d41"></a><!-- doxytag: member="MGCompositeCurve::sdim" ref="a58c466999f78d0ec7237c735e94e4d41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGCompositeCurve::sdim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the space dimension. </p>
<p>It is the maximum space dimension of the member curves. </p>

<p>Implements <a class="el" href="class_m_g_curve.html#af2aee3fba31ba245bc9618baf27f8237">MGCurve</a>.</p>

</div>
</div>
<a class="anchor" id="af036bcf3358598d97dce155888e9d140"></a><!-- doxytag: member="MGCompositeCurve::sweep" ref="af036bcf3358598d97dce155888e9d140" args="(const MGUnit_vector &amp;uvec, double start_dist, double end_dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGCompositeCurve::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sweep surface from crv Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted. </p>
<p>The sweep surface is defined as: This curve(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_curve.html#ab444253d2ae843173c03d0dc2c79e814">MGCurve</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>CompositeCurve.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:19 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

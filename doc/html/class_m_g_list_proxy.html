<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGListProxy&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGListProxy&lt; T &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGListProxy" -->
<p><a href="class_m_g_list_proxy-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c158d7d20d5d8cb832223d09e289e2f"></a><!-- doxytag: member="MGListProxy::value_type" ref="a8c158d7d20d5d8cb832223d09e289e2f" args="" -->
typedef std::list&lt; T &gt;::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f975e341a045d73530d75657e2e1afd"></a><!-- doxytag: member="MGListProxy::reference" ref="a6f975e341a045d73530d75657e2e1afd" args="" -->
typedef std::list&lt; T &gt;::reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0480ac1d3f30ffc4d14b850f2f01251c"></a><!-- doxytag: member="MGListProxy::const_reference" ref="a0480ac1d3f30ffc4d14b850f2f01251c" args="" -->
typedef std::list&lt; T &gt;<br class="typebreak"/>
::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0dff6069feb6a0de8d8e35049cb7937"></a><!-- doxytag: member="MGListProxy::size_type" ref="ad0dff6069feb6a0de8d8e35049cb7937" args="" -->
typedef std::list&lt; T &gt;::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77239e3a8fcb0efe50cc7e8e153d15b"></a><!-- doxytag: member="MGListProxy::difference_type" ref="ad77239e3a8fcb0efe50cc7e8e153d15b" args="" -->
typedef std::list&lt; T &gt;<br class="typebreak"/>
::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a085a4ded7e73a012163b6f1bd230b32e"></a><!-- doxytag: member="MGListProxy::iterator" ref="a085a4ded7e73a012163b6f1bd230b32e" args="" -->
typedef std::list&lt; T &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf27af9fe2a8bfa4bcb74437f7341902"></a><!-- doxytag: member="MGListProxy::const_iterator" ref="acf27af9fe2a8bfa4bcb74437f7341902" args="" -->
typedef std::list&lt; T &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a028d6a832ec417e1b9b45fa9d5c3a215"></a><!-- doxytag: member="MGListProxy::reverse_iterator" ref="a028d6a832ec417e1b9b45fa9d5c3a215" args="" -->
typedef std::list&lt; T &gt;<br class="typebreak"/>
::reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92bb091e826bb6dcc63c0bd77e393efb"></a><!-- doxytag: member="MGListProxy::const_reverse_iterator" ref="a92bb091e826bb6dcc63c0bd77e393efb" args="" -->
typedef std::list&lt; T &gt;<br class="typebreak"/>
::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa116a532944dd9ecf6b5039024a0bed8"></a><!-- doxytag: member="MGListProxy::MGListProxy" ref="aa116a532944dd9ecf6b5039024a0bed8" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#aa116a532944dd9ecf6b5039024a0bed8">MGListProxy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an empty list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5eae4981a05dc33356c8a4654d482d8"></a><!-- doxytag: member="MGListProxy::MGListProxy" ref="af5eae4981a05dc33356c8a4654d482d8" args="(const MGListProxy &amp;ls)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#af5eae4981a05dc33356c8a4654d482d8">MGListProxy</a> (const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9a74cd41e033ec322a5577f40f36cf5"></a><!-- doxytag: member="MGListProxy::MGListProxy" ref="ab9a74cd41e033ec322a5577f40f36cf5" args="(size_type n, const T &amp;val=T())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ab9a74cd41e033ec322a5577f40f36cf5">MGListProxy</a> (size_type n, const T &amp;val=T())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a list with n copies of val. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac77ce2a7a87e3b5ea4cfeae854e4ff0c"></a><!-- doxytag: member="MGListProxy::MGListProxy" ref="ac77ce2a7a87e3b5ea4cfeae854e4ff0c" args="(const std::list&lt; T &gt; &amp;ls)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ac77ce2a7a87e3b5ea4cfeae854e4ff0c">MGListProxy</a> (const std::list&lt; T &gt; &amp;ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a list with std::list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af948aee3fe1f3d34e486afa0308fb5ca"></a><!-- doxytag: member="MGListProxy::‾MGListProxy" ref="af948aee3fe1f3d34e486afa0308fb5ca" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#af948aee3fe1f3d34e486afa0308fb5ca">‾MGListProxy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a7ec71d250f1a160dfa88919b18438248">operator=</a> (const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operators overload.  <a href="#a7ec71d250f1a160dfa88919b18438248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a2a9a4646483dabb376b3c72056137bdd">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Member functions.  <a href="#a2a9a4646483dabb376b3c72056137bdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905b972c7229a747ed301fea138e3041"></a><!-- doxytag: member="MGListProxy::begin" ref="a905b972c7229a747ed301fea138e3041" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a905b972c7229a747ed301fea138e3041">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_iterator pointing to the beginning of the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab24b2bf7b751e7f1c78e9f38c59e1098"></a><!-- doxytag: member="MGListProxy::end" ref="ab24b2bf7b751e7f1c78e9f38c59e1098" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ab24b2bf7b751e7f1c78e9f38c59e1098">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator pointing to the end of the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff1f4d62713e17ffa81839a602561506"></a><!-- doxytag: member="MGListProxy::end" ref="aff1f4d62713e17ffa81839a602561506" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#aff1f4d62713e17ffa81839a602561506">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const_iterator pointing to the end of the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5e98bdb9ba3686da3c6fccb967e10e1"></a><!-- doxytag: member="MGListProxy::rbegin" ref="ac5e98bdb9ba3686da3c6fccb967e10e1" args="()" -->
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ac5e98bdb9ba3686da3c6fccb967e10e1">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse_iterator pointing to the beginning of the reversed list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bbae3341afc951dbc0cbcf60c5661b0"></a><!-- doxytag: member="MGListProxy::rbegin" ref="a1bbae3341afc951dbc0cbcf60c5661b0" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a1bbae3341afc951dbc0cbcf60c5661b0">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse_const_iterator pointing to the beginning of the reversed list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34f29b68347b1f3050563de21140c32d"></a><!-- doxytag: member="MGListProxy::rend" ref="a34f29b68347b1f3050563de21140c32d" args="()" -->
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a34f29b68347b1f3050563de21140c32d">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse_iterator pointing to the end of the reversed list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0304d29f014ba07acb762a146be2f38f"></a><!-- doxytag: member="MGListProxy::rend" ref="a0304d29f014ba07acb762a146be2f38f" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a0304d29f014ba07acb762a146be2f38f">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse_const_iterator pointing to the end of the reversed list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b019842b1e6748ce0c118c4dc480df"></a><!-- doxytag: member="MGListProxy::front" ref="ab8b019842b1e6748ce0c118c4dc480df" args="()" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ab8b019842b1e6748ce0c118c4dc480df">front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb2ddda28e7c79fcd5463fd423e4ce85"></a><!-- doxytag: member="MGListProxy::front" ref="abb2ddda28e7c79fcd5463fd423e4ce85" args="() const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>front</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e90e1f89c1b555f66e882051b9889eb"></a><!-- doxytag: member="MGListProxy::back" ref="a9e90e1f89c1b555f66e882051b9889eb" args="()" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a9e90e1f89c1b555f66e882051b9889eb">back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f8adfd67942db9b22fb33c31974f65c"></a><!-- doxytag: member="MGListProxy::back" ref="a5f8adfd67942db9b22fb33c31974f65c" args="() const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>back</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9098770089983ad279c3fab8d61598e1"></a><!-- doxytag: member="MGListProxy::push_front" ref="a9098770089983ad279c3fab8d61598e1" args="(const T &amp;val)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a9098770089983ad279c3fab8d61598e1">push_front</a> (const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a new element at the beginning. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4b7c5f6a7aaf0f8ac58e0c4473367c3"></a><!-- doxytag: member="MGListProxy::push_back" ref="ae4b7c5f6a7aaf0f8ac58e0c4473367c3" args="(const T &amp;val)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ae4b7c5f6a7aaf0f8ac58e0c4473367c3">push_back</a> (const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a new element at the end. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada6d202c465895ad2f570184061c0358"></a><!-- doxytag: member="MGListProxy::pop_front" ref="ada6d202c465895ad2f570184061c0358" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ada6d202c465895ad2f570184061c0358">pop_front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the first element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6b7057f94db746dd58b793ab1958238"></a><!-- doxytag: member="MGListProxy::pop_back" ref="ae6b7057f94db746dd58b793ab1958238" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ae6b7057f94db746dd58b793ab1958238">pop_back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the last element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568bd21b610e02ec5d10f9b53317439e"></a><!-- doxytag: member="MGListProxy::size" ref="a568bd21b610e02ec5d10f9b53317439e" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01830b6d998b844a637c336c84497da"></a><!-- doxytag: member="MGListProxy::max_size" ref="ac01830b6d998b844a637c336c84497da" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ac01830b6d998b844a637c336c84497da">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the largest possible size of the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2660f8723567b1e14676cea9dad62fbc"></a><!-- doxytag: member="MGListProxy::empty" ref="a2660f8723567b1e14676cea9dad62fbc" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a2660f8723567b1e14676cea9dad62fbc">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the list's size is 0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1dc27d2a8d667dd384cde338c1233d3"></a><!-- doxytag: member="MGListProxy::swap" ref="aa1dc27d2a8d667dd384cde338c1233d3" args="(MGListProxy &amp;ls)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#aa1dc27d2a8d667dd384cde338c1233d3">swap</a> (<a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the contents of two lists. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac00e575cf5ded2bd9454857428a656d9"></a><!-- doxytag: member="MGListProxy::insert" ref="ac00e575cf5ded2bd9454857428a656d9" args="(iterator pos, const T &amp;val)" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ac00e575cf5ded2bd9454857428a656d9">insert</a> (iterator pos, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts x before pos. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a9680e087a9284a5e14a43e977a700"></a><!-- doxytag: member="MGListProxy::insert" ref="ae0a9680e087a9284a5e14a43e977a700" args="(iterator pos, size_type n, const T &amp;val)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ae0a9680e087a9284a5e14a43e977a700">insert</a> (iterator pos, size_type n, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts n copies of x before pos. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad575bc1476900474c56f9ae51ef8268b"></a><!-- doxytag: member="MGListProxy::erase" ref="ad575bc1476900474c56f9ae51ef8268b" args="(iterator pos)" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ad575bc1476900474c56f9ae51ef8268b">erase</a> (iterator pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the element at position pos. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fa61492b7c4ae5004521ad74c13952c"></a><!-- doxytag: member="MGListProxy::erase" ref="a2fa61492b7c4ae5004521ad74c13952c" args="(iterator first, iterator last)" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a2fa61492b7c4ae5004521ad74c13952c">erase</a> (iterator first, iterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the range [first, last). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92867fe6d240e8b91c279dc0632cd6f6"></a><!-- doxytag: member="MGListProxy::clear" ref="a92867fe6d240e8b91c279dc0632cd6f6" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a92867fe6d240e8b91c279dc0632cd6f6">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all of the elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae639b6c36cd4f98922cac5f91fecab82"></a><!-- doxytag: member="MGListProxy::resize" ref="ae639b6c36cd4f98922cac5f91fecab82" args="(size_type n, const T &amp;val=T())" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ae639b6c36cd4f98922cac5f91fecab82">resize</a> (size_type n, const T &amp;val=T())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts or erases elements at the end such that the size becomes n. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a57707bf0b4c223296eb78f04bb58f46c">splice</a> (iterator pos, const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pos must be a valid iterator in *this, and ls must be a list that is distinct from *this.  <a href="#a57707bf0b4c223296eb78f04bb58f46c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#aaed2fc1035fe5759b0c8a9a31b450fe4">splice</a> (iterator pos, const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls, iterator i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pos must be a valid iterator in *this, and i must be a dereferenceable iterator in ls.  <a href="#aaed2fc1035fe5759b0c8a9a31b450fe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a4077e1ffe8cc51bb121adb3c11660351">splice</a> (iterator pos, const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls, iterator first, iterator last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pos must be a valid iterator in *this, and [first, last) must be a valid range in ls.  <a href="#a4077e1ffe8cc51bb121adb3c11660351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#abd8a800b5e303d912a490cfa67fc29e2">remove</a> (const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all elements that compare equal to val.  <a href="#abd8a800b5e303d912a490cfa67fc29e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ad5b11bc031e3b33a6b2e92d4ae0f0931">remove_if</a> (Predicate p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all elements *i such that p(*i) is true.  <a href="#ad5b11bc031e3b33a6b2e92d4ae0f0931"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a0d75a684347a924a08db524e8f27ee07">unique</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all but the first element in every consecutive group of equal elements.  <a href="#a0d75a684347a924a08db524e8f27ee07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a2986eab599aab960849964affb3d097a">unique</a> (BinaryPredicate p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all but the first element in every consecutive group of equivalent elements, where two elements *i and *j are considered equivalent if p(*i, *j) is true.  <a href="#a2986eab599aab960849964affb3d097a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#abea038259a2a188af5fb2a0eb23fe224">merge</a> (<a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Both *this and ls must be sorted according to operator&lt;, and they must be distinct.  <a href="#abea038259a2a188af5fb2a0eb23fe224"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a7335302c531ce411c56139c2da504af7">merge</a> (<a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls, BinaryPredicate comp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comp must be a comparison function that induces a strict weak ordering (as defined in the LessThan Comparable requirements) on objects of type T, and both *this and ls must be sorted according to that ordering.  <a href="#a7335302c531ce411c56139c2da504af7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a70feba6327834ff285457ff19e14d276">sort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts *this according to operator&lt;.  <a href="#a70feba6327834ff285457ff19e14d276"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#a3a2bac164bf04a87694e738705171abe">reverse</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses the order of elements in the list.  <a href="#a3a2bac164bf04a87694e738705171abe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac181eef6867c11132d3619e6a7c7a612"></a><!-- doxytag: member="MGListProxy::std_container" ref="ac181eef6867c11132d3619e6a7c7a612" args="()" -->
std::list&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ac181eef6867c11132d3619e6a7c7a612">std_container</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns std::deque object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac52741905366b76569aa08680f786e17"></a><!-- doxytag: member="MGListProxy::std_container" ref="ac52741905366b76569aa08680f786e17" args="() const " -->
const std::list&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>std_container</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91a124b4f8969a97d5e03aaf71e9fd8"></a><!-- doxytag: member="MGListProxy::operator==" ref="ae91a124b4f8969a97d5e03aaf71e9fd8" args="(const MGListProxy &amp;ls1, const MGListProxy &amp;ls2)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#ae91a124b4f8969a97d5e03aaf71e9fd8">operator==</a> (const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls1, const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests two lists for equality. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf54451af41603ff82af447493de0ad9"></a><!-- doxytag: member="MGListProxy::operator&lt;" ref="adf54451af41603ff82af447493de0ad9" args="(const MGListProxy &amp;ls1, const MGListProxy &amp;ls2)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_list_proxy.html#adf54451af41603ff82af447493de0ad9">operator&lt;</a> (const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls1, const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexicographical comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7df2949182dbe11330eec36381c8cac"></a><!-- doxytag: member="MGListProxy::swap" ref="ae7df2949182dbe11330eec36381c8cac" args="(MGListProxy &amp;ls1, MGListProxy &amp;ls2)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls1, <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a> &amp;ls2)</td></tr>
</table>
<h3>template&lt;class T&gt;<br/>
 class MGListProxy&lt; T &gt;</h3>

<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2a9a4646483dabb376b3c72056137bdd"></a><!-- doxytag: member="MGListProxy::begin" ref="a2a9a4646483dabb376b3c72056137bdd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Member functions. </p>
<p>Returns an iterator pointing to the beginning of the list. </p>

</div>
</div>
<a class="anchor" id="abea038259a2a188af5fb2a0eb23fe224"></a><!-- doxytag: member="MGListProxy::merge" ref="abea038259a2a188af5fb2a0eb23fe224" args="(MGListProxy &amp;ls)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ls</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Both *this and ls must be sorted according to operator&lt;, and they must be distinct. </p>
<p>(That is, it is required that &amp;x != this.) This function removes all of ls's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from ls, then the element from *this will precede the one from ls. All iterators to elements in *this and ls remain valid. This function is linear time: it performs at most <a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e" title="Returns the size of the list.">size()</a> + x.size() - 1 comparisons. </p>

</div>
</div>
<a class="anchor" id="a7335302c531ce411c56139c2da504af7"></a><!-- doxytag: member="MGListProxy::merge" ref="a7335302c531ce411c56139c2da504af7" args="(MGListProxy &amp;ls, BinaryPredicate comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>comp must be a comparison function that induces a strict weak ordering (as defined in the LessThan Comparable requirements) on objects of type T, and both *this and ls must be sorted according to that ordering. </p>
<p>The lists ls and *this must be distinct. (That is, it is required that &amp;x != this.) This function removes all of ls's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from ls, then the element from *this will precede the one from ls. All iterators to elements in *this and ls remain valid. This function is linear time: it performs at most <a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e" title="Returns the size of the list.">size()</a> + ls.size() - 1 applications of comp. </p>

</div>
</div>
<a class="anchor" id="a7ec71d250f1a160dfa88919b18438248"></a><!-- doxytag: member="MGListProxy::operator=" ref="a7ec71d250f1a160dfa88919b18438248" args="(const MGListProxy &amp;ls)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&amp; <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ls</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operators overload. </p>
<p>The assignment operator. </p>

</div>
</div>
<a class="anchor" id="abd8a800b5e303d912a490cfa67fc29e2"></a><!-- doxytag: member="MGListProxy::remove" ref="abd8a800b5e303d912a490cfa67fc29e2" args="(const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all elements that compare equal to val. </p>
<p>The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e" title="Returns the size of the list.">size()</a> comparisons for equality. </p>

</div>
</div>
<a class="anchor" id="ad5b11bc031e3b33a6b2e92d4ae0f0931"></a><!-- doxytag: member="MGListProxy::remove_if" ref="ad5b11bc031e3b33a6b2e92d4ae0f0931" args="(Predicate p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all elements *i such that p(*i) is true. </p>
<p>The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e" title="Returns the size of the list.">size()</a> applications of p. </p>

</div>
</div>
<a class="anchor" id="a3a2bac164bf04a87694e738705171abe"></a><!-- doxytag: member="MGListProxy::reverse" ref="a3a2bac164bf04a87694e738705171abe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the order of elements in the list. </p>
<p>All iterators remain valid and continue to point to the same elements. This function is linear time. </p>

</div>
</div>
<a class="anchor" id="a70feba6327834ff285457ff19e14d276"></a><!-- doxytag: member="MGListProxy::sort" ref="a70feba6327834ff285457ff19e14d276" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts *this according to operator&lt;. </p>
<p>The sort is stable, that is, the relative order of equivalent elements is preserved. All iterators remain valid and continue to point to the same elements. The number of comparisons is approximately N log N, where N is the list's size. </p>

</div>
</div>
<a class="anchor" id="aaed2fc1035fe5759b0c8a9a31b450fe4"></a><!-- doxytag: member="MGListProxy::splice" ref="aaed2fc1035fe5759b0c8a9a31b450fe4" args="(iterator pos, const MGListProxy &amp;ls, iterator i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pos must be a valid iterator in *this, and i must be a dereferenceable iterator in ls. </p>
<p>Splice moves the element pointed to by i from ls to *this, inserting it before position. All iterators remain valid, including iterators that point to elements of ls. If pos == i or pos == ++i, this function is a null operation. This function is constant time. </p>

</div>
</div>
<a class="anchor" id="a4077e1ffe8cc51bb121adb3c11660351"></a><!-- doxytag: member="MGListProxy::splice" ref="a4077e1ffe8cc51bb121adb3c11660351" args="(iterator pos, const MGListProxy &amp;ls, iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pos must be a valid iterator in *this, and [first, last) must be a valid range in ls. </p>
<p>pos may not be an iterator in the range [first, last). Splice moves the elements in [first, last) from ls to *this, inserting them before position. All iterators remain valid, including iterators that point to elements of ls. This function is constant time. </p>

</div>
</div>
<a class="anchor" id="a57707bf0b4c223296eb78f04bb58f46c"></a><!-- doxytag: member="MGListProxy::splice" ref="a57707bf0b4c223296eb78f04bb58f46c" args="(iterator pos, const MGListProxy &amp;ls)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pos must be a valid iterator in *this, and ls must be a list that is distinct from *this. </p>
<p>(That is, it is required that &amp;x != this.) All of the elements of ls are inserted before position and removed from pos. All iterators remain valid, including iterators that point to elements of ls. This function is constant time. </p>

</div>
</div>
<a class="anchor" id="a0d75a684347a924a08db524e8f27ee07"></a><!-- doxytag: member="MGListProxy::unique" ref="a0d75a684347a924a08db524e8f27ee07" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all but the first element in every consecutive group of equal elements. </p>
<p>The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e" title="Returns the size of the list.">size()</a> - 1 comparisons for equality. </p>

</div>
</div>
<a class="anchor" id="a2986eab599aab960849964affb3d097a"></a><!-- doxytag: member="MGListProxy::unique" ref="a2986eab599aab960849964affb3d097a" args="(BinaryPredicate p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_list_proxy.html">MGListProxy</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all but the first element in every consecutive group of equivalent elements, where two elements *i and *j are considered equivalent if p(*i, *j) is true. </p>
<p>The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly <a class="el" href="class_m_g_list_proxy.html#a568bd21b610e02ec5d10f9b53317439e" title="Returns the size of the list.">size()</a> - 1 comparisons for equality. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ListProxy.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:25 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

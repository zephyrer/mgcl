<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGFSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGFSurface Class Reference<br/>
<small>
[<a class="el" href="group___m_g_object_related.html">Object Related class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGFSurface" -->
<p>Define <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a> Class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;FSurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGFSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_f_surface__inherit__graph.png" border="0" usemap="#_m_g_f_surface_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_f_surface_inherit__map" id="_m_g_f_surface_inherit__map">
<area shape="rect" id="node3" href="class_m_g_face.html" title="MGFace is a trimmed surface." alt="" coords="197,83,269,112"/><area shape="rect" id="node5" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="293,83,379,112"/><area shape="rect" id="node7" href="class_m_g_b_sum_surf.html" title="Defines Boolean sum surface." alt="" coords="5,160,107,189"/><area shape="rect" id="node9" href="class_m_g_cylinder.html" title="MGCylinder is a Cylinder in 3D space." alt="" coords="131,160,221,189"/><area shape="rect" id="node11" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space." alt="" coords="245,160,320,189"/><area shape="rect" id="node13" href="class_m_g_r_s_b_rep.html" title="Defines Surface B&#45;Representation of rational form." alt="" coords="344,160,437,189"/><area shape="rect" id="node15" href="class_m_g_s_b_rep.html" title="Defines Surface B&#45;Representation, that is , B&#45;Spline surface." alt="" coords="461,160,544,189"/><area shape="rect" id="node17" href="class_m_g_sphere.html" title="MGSphere is a Sphere in 3D space." alt="" coords="568,160,651,189"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_f_surface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addb7479ec806a4dce535b4ebdadcf2f6"></a><!-- doxytag: member="MGFSurface::MGFSurface" ref="addb7479ec806a4dce535b4ebdadcf2f6" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#addb7479ec806a4dce535b4ebdadcf2f6">MGFSurface</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Null FSurface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeec0354fdd5815ff9211d8a5c68d94e3"></a><!-- doxytag: member="MGFSurface::MGFSurface" ref="aeec0354fdd5815ff9211d8a5c68d94e3" args="(const MGFSurface &amp;fsurf)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#aeec0354fdd5815ff9211d8a5c68d94e3">MGFSurface</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;fsurf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2303a61a76495f3224646d43a8692797"></a><!-- doxytag: member="MGFSurface::‾MGFSurface" ref="a2303a61a76495f3224646d43a8692797" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGFSurface</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d74ef99ae69a6a4b4d4707facc79fc"></a><!-- doxytag: member="MGFSurface::operator&lt;" ref="af4d74ef99ae69a6a4b4d4707facc79fc" args="(const MGFSurface &amp;f2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#af4d74ef99ae69a6a4b4d4707facc79fc">operator&lt;</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;f2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1521832dcdfa64a087e1c28fcf1cd6a"></a><!-- doxytag: member="MGFSurface::operator&gt;" ref="af1521832dcdfa64a087e1c28fcf1cd6a" args="(const MGFSurface &amp;f2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;f2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a17e4c4cfd0c528657426629f3dc8fc24">arrow</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate arrow data of the tangent along u and v and the normal at the parameter value (u,v) of the FSurface.  <a href="#a17e4c4cfd0c528657426629f3dc8fc24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d5ccb85458f1d13a93c22d1d2680c57"></a><!-- doxytag: member="MGFSurface::arrow" ref="a0d5ccb85458f1d13a93c22d1d2680c57" args="(const MGPosition &amp;uv, MGPosition data[10]) const =0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>arrow</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fa56ab8d84d1c55bcb8a7cabceae96c"></a><!-- doxytag: member="MGFSurface::get_box" ref="a6fa56ab8d84d1c55bcb8a7cabceae96c" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a6fa56ab8d84d1c55bcb8a7cabceae96c">get_box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the box of the object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a027f707b72095b5a4038dc5410e50ce2">box_param2</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return box of the parameter space of the FSurface.  <a href="#a027f707b72095b5a4038dc5410e50ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a819d7ab7dae6ad7a1978b4388f00386b"></a><!-- doxytag: member="MGFSurface::clone_fsurface" ref="a819d7ab7dae6ad7a1978b4388f00386b" args="() const =0" -->
virtual <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a819d7ab7dae6ad7a1978b4388f00386b">clone_fsurface</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the clone of this <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a4a39743914b8e15d32c27740aa6d8c79">clone_as_face</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the clone of this as a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>.  <a href="#a4a39743914b8e15d32c27740aa6d8c79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a44385215d7089b9f2ad42792aad0d3f7">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute closest point from a point.  <a href="#a44385215d7089b9f2ad42792aad0d3f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7f41b0c00f61627312776bfe06366bdb">closest_on_boundary</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute closest point from a line to the boundary of the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>.  <a href="#a7f41b0c00f61627312776bfe06366bdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a44c3eb3132d0a54a89447615a793f5d3">drawWireFS</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#a44c3eb3132d0a54a89447615a793f5d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30d1bec2c09c1060a9de9eff9bfe473f"></a><!-- doxytag: member="MGFSurface::drawWireFS_to_highlight" ref="a30d1bec2c09c1060a9de9eff9bfe473f" args="(double span_length, int line_density) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>drawWireFS_to_highlight</b> (double span_length, int line_density) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a827522c3a515722c10a945c4eb25b8f0">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation Input parameter value is not checked if it is <a class="el" href="class_m_g_f_surface.html#ae8482cbcaa7cd6dcbdc2981043892f66" title="Test if parameter value (u,v) is in the range of the FSurface parameter.">in_range()</a> or not.  <a href="#a827522c3a515722c10a945c4eb25b8f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a0a681a39c5dc1107447b3399b110fdea">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a137ebd00cf79e059a5f1f49682ef4438">eval_discrete_deviation</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, std::vector&lt; <a class="el" href="class_m_g_position.html">MGPosition</a> &gt; &amp;uvuvs, int npoint=20, double tolerance=0.1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate deviations of two faces(this and face2) at npoint discrete points.  <a href="#a137ebd00cf79e059a5f1f49682ef4438"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ed28ccbcaafcafdef672c7e8baa1ad1"></a><!-- doxytag: member="MGFSurface::get_all_boundaries" ref="a7ed28ccbcaafcafdef672c7e8baa1ad1" args="(void) const " -->
<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7ed28ccbcaafcafdef672c7e8baa1ad1">get_all_boundaries</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the boundaries(i.e., outer boundary and all the inner boundaries). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8583bacdf2b89596ffc49760dcdfccff"></a><!-- doxytag: member="MGFSurface::get_face_pointer" ref="a8583bacdf2b89596ffc49760dcdfccff" args="()=0" -->
virtual <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a8583bacdf2b89596ffc49760dcdfccff">get_face_pointer</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get face pointer if this is <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, else null will be returned. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d9ff88b6c2d37c77ac5c743a8215437"></a><!-- doxytag: member="MGFSurface::get_face_pointer" ref="a4d9ff88b6c2d37c77ac5c743a8215437" args="() const =0" -->
virtual const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_face_pointer</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4977984c1fb4e77ba2d6c94f00e88274"></a><!-- doxytag: member="MGFSurface::get_number_of_boundaries" ref="a4977984c1fb4e77ba2d6c94f00e88274" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a4977984c1fb4e77ba2d6c94f00e88274">get_number_of_boundaries</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of inner boundaries as the output of the function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ad9f377eb6f6e2d22e5b1e4ba93ef866a">get_surface_pointer</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get surface pointer.  <a href="#ad9f377eb6f6e2d22e5b1e4ba93ef866a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc2a0cb2ed9315d1f12fec72d94149e4"></a><!-- doxytag: member="MGFSurface::get_surface_pointer" ref="adc2a0cb2ed9315d1f12fec72d94149e4" args="() const =0" -->
virtual const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_surface_pointer</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a49a378f0e540171dd62b4c62b60b30f2">has_commonFS</a> (const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;obj2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this and 2nd object has common area about their box(), taking error into account.  <a href="#a49a378f0e540171dd62b4c62b60b30f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7e9009568012f1a8140fb6a9dc0952ca">hasInnerBoundaryLoop</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this FSurface has inner boundary loops or not.  <a href="#a7e9009568012f1a8140fb6a9dc0952ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ac871fe28de2080e9d9dd08b9334fcea6">hasLoop</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this FSurface has boundary loops or not in the specified box.  <a href="#ac871fe28de2080e9d9dd08b9334fcea6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a959f466f07e68676b3ca976ae4a02ff4">inner_boundary</a> (size_t i) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface.  <a href="#a959f466f07e68676b3ca976ae4a02ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a58c5b3bbb657bbfe80bbb5fd65a11da3">inner_boundary_param</a> (size_t i) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface.  <a href="#a58c5b3bbb657bbfe80bbb5fd65a11da3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8482cbcaa7cd6dcbdc2981043892f66"></a><!-- doxytag: member="MGFSurface::in_range" ref="ae8482cbcaa7cd6dcbdc2981043892f66" args="(double u, double v) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ae8482cbcaa7cd6dcbdc2981043892f66">in_range</a> (double u, double v) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is in the range of the FSurface parameter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac934f4344874a700c254761bbcb8faae"></a><!-- doxytag: member="MGFSurface::in_range" ref="ac934f4344874a700c254761bbcb8faae" args="(const MGPosition &amp;uv) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ada7927bcf688f99df7c8a5d1f0981b2e">in_range_with_on</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if (u,v) is inside the face.  <a href="#ada7927bcf688f99df7c8a5d1f0981b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9f2c15ca51ee46913afb3f3dc75866a"></a><!-- doxytag: member="MGFSurface::in_range_with_on" ref="aa9f2c15ca51ee46913afb3f3dc75866a" args="(const MGPosition &amp;uv) const =0" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range_with_on</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2467d1e95d1d5a39e3208dd084a71163"></a><!-- doxytag: member="MGFSurface::isect" ref="a2467d1e95d1d5a39e3208dd084a71163" args="(const MGShell &amp;shell2) const =0" -->
virtual <a class="el" href="class_m_g_h_hisect__vector.html">MGHHisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a2467d1e95d1d5a39e3208dd084a71163">isect</a> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;shell2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194022dc5fc752c2a80a0ebd4ab7f814"></a><!-- doxytag: member="MGFSurface::isect" ref="a194022dc5fc752c2a80a0ebd4ab7f814" args="(const MGFSurface &amp;fsurf) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;fsurf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab74d1756f9300d69557d89df18e5b8b1"></a><!-- doxytag: member="MGFSurface::isect" ref="ab74d1756f9300d69557d89df18e5b8b1" args="(const MGFace &amp;fsurf) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;fsurf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd7d763abc80dcd09cb05c22e2583648"></a><!-- doxytag: member="MGFSurface::isect" ref="abd7d763abc80dcd09cb05c22e2583648" args="(const MGSurface &amp;fsurf) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;fsurf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d1a03e267f415837db86d5c577eadb"></a><!-- doxytag: member="MGFSurface::isect" ref="ad2d1a03e267f415837db86d5c577eadb" args="(const MGCurve &amp;curv) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curv) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7856641031c79064b250b955edfba528">intersect12Boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the intersection points of this face's boundaries(out or inner) with face2, and vice versa.  <a href="#a7856641031c79064b250b955edfba528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a0936671424c065e29984938cd240d00c">isect_boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuvs, size_t id1=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of this face's boundary(outer and inners) with face2.  <a href="#a0936671424c065e29984938cd240d00c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ab492a3900dd067dab5668f0b7c0470c0">isect_incurves</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, size_t iid, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, size_t id1) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points between the boundary of iid-th inner boundary of this face and face2 to compute intersections of face with face2.  <a href="#ab492a3900dd067dab5668f0b7c0470c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a3d7bbd977a593d3987bd38b9bcadb201">isect_outcurves</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, size_t id1) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of outer boundary curves of this face with face2 to compute intersections.  <a href="#a3d7bbd977a593d3987bd38b9bcadb201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7a34135d9b1dc717d1526ef49e43592f">isect_guess</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvi, double ti, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve.  <a href="#a7a34135d9b1dc717d1526ef49e43592f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a1a615c03754e90ca6394f34e2944b1c4">isect_guess</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvi, double ti, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve.  <a href="#a1a615c03754e90ca6394f34e2944b1c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a0a9f1a5d5fd69cb2d14e613b12330ef6">isect_guess</a> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;crv, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvi, double ti, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve.  <a href="#a0a9f1a5d5fd69cb2d14e613b12330ef6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a350a0375a65d5262a31f75608db5da07">isect_guess_composite</a> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;crv, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvi, double ti, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve.  <a href="#a350a0375a65d5262a31f75608db5da07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#abd6b3b5e4473febc189bfd9b8517e1d9">isect_guess_straight</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, double ti, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvi, double &amp;t, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_guess_straight" computes one intersection point of surface and a straight line, given initail guess parameter values of the surface and the straight line.  <a href="#abd6b3b5e4473febc189bfd9b8517e1d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144cce36bb60ba28191ff647d0ca4b85"></a><!-- doxytag: member="MGFSurface::knot_u" ref="a144cce36bb60ba28191ff647d0ca4b85" args="(size_t i) const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a144cce36bb60ba28191ff647d0ca4b85">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe01c7562af9716a1dbf8fd066ef0393"></a><!-- doxytag: member="MGFSurface::knot_v" ref="afe01c7562af9716a1dbf8fd066ef0393" args="(size_t i) const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#afe01c7562af9716a1dbf8fd066ef0393">knot_v</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae881bf172b3101cf1a7d6f75b51a98c2"></a><!-- doxytag: member="MGFSurface::knot_vector_u" ref="ae881bf172b3101cf1a7d6f75b51a98c2" args="() const =0" -->
virtual const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ae881bf172b3101cf1a7d6f75b51a98c2">knot_vector_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f28aaff47f99b40c450ee0acb78933b"></a><!-- doxytag: member="MGFSurface::knot_vector_u" ref="a4f28aaff47f99b40c450ee0acb78933b" args="()=0" -->
virtual <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4a4b6e154d59f5758afb60aa4fc1e34"></a><!-- doxytag: member="MGFSurface::knot_vector_v" ref="ad4a4b6e154d59f5758afb60aa4fc1e34" args="() const =0" -->
virtual const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ad4a4b6e154d59f5758afb60aa4fc1e34">knot_vector_v</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6d494000e3418df1d1263eabd97f29"></a><!-- doxytag: member="MGFSurface::knot_vector_v" ref="afa6d494000e3418df1d1263eabd97f29" args="()=0" -->
virtual <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a521de8eaa8905bf5e14c6af77af56d0a">make_face</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> or <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> object.  <a href="#a521de8eaa8905bf5e14c6af77af56d0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a642b08244ba552668c1b8758b17abb4a">make_display_list_to_hilightFS</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a display list without color of this gel.  <a href="#a642b08244ba552668c1b8758b17abb4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b076f8f82cf565734e9e98369669370"></a><!-- doxytag: member="MGFSurface::negateFS" ref="a9b076f8f82cf565734e9e98369669370" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a9b076f8f82cf565734e9e98369669370">negateFS</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the FSurface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea43f83cad8db39861814351bd3030c"></a><!-- doxytag: member="MGFSurface::normal" ref="afea43f83cad8db39861814351bd3030c" args="(const MGPosition &amp;uv) const =0" -->
virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#afea43f83cad8db39861814351bd3030c">normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33cfd86010b682a72fcfcbd118b39bc3"></a><!-- doxytag: member="MGFSurface::normal" ref="a33cfd86010b682a72fcfcbd118b39bc3" args="(double u, double v) const =0" -->
virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a33cfd86010b682a72fcfcbd118b39bc3">normal</a> (double u, double v) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at (u,v). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa769c5b1af223d3aa88cf087ac17b94f"></a><!-- doxytag: member="MGFSurface::number_of_inner_boundaries" ref="aa769c5b1af223d3aa88cf087ac17b94f" args="() const " -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#aa769c5b1af223d3aa88cf087ac17b94f">number_of_inner_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of inner boundaries as the output of the function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a513ce1c371dd77cf273bf5da35171ea4"></a><!-- doxytag: member="MGFSurface::object_pointer" ref="a513ce1c371dd77cf273bf5da35171ea4" args="() const =0" -->
virtual const <a class="el" href="class_m_g_object.html">MGObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a513ce1c371dd77cf273bf5da35171ea4">object_pointer</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the object point of this <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cbd9b2ae37fb00554895d1146a6a22d"></a><!-- doxytag: member="MGFSurface::object_pointer" ref="a6cbd9b2ae37fb00554895d1146a6a22d" args="()=0" -->
virtual <a class="el" href="class_m_g_object.html">MGObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>object_pointer</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a18926f742ba0ae8b3a41a263d8897628">offset_fs</a> (double distance, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;vecOfsFSurface) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset.  <a href="#a18926f742ba0ae8b3a41a263d8897628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#afb6217a5d69beda117240ae8867ecea8">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a point P is on the FSurface.  <a href="#afb6217a5d69beda117240ae8867ecea8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a73978585a34a380507af9e44113a2287">on_a_perimeter</a> (double &amp;u, double &amp;v, size_t &amp;perim_num) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is parameter value on a perimeter of the base surface.  <a href="#a73978585a34a380507af9e44113a2287"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a187b8df52c309ffc695a298dcd676a11"></a><!-- doxytag: member="MGFSurface::outFS" ref="a187b8df52c309ffc695a298dcd676a11" args="(std::ostream &amp;ostrm) const =0" -->
virtual std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a187b8df52c309ffc695a298dcd676a11">outFS</a> (std::ostream &amp;ostrm) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a8fc539b6e3ce0d7328aedd7c42c201ee">outer_boundary</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain outer_boundary curves(world coordinates representation) of the FSurface.  <a href="#a8fc539b6e3ce0d7328aedd7c42c201ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a424bdd8b98a5c4eec9239da4dc689004">outer_boundary_param</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain boundary curves(parameter space representation) of the FSurface.  <a href="#a424bdd8b98a5c4eec9239da4dc689004"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25e4519221c8e8c34d5f9110d8a95439"></a><!-- doxytag: member="MGFSurface::param" ref="a25e4519221c8e8c34d5f9110d8a95439" args="(const MGPosition &amp;P) const =0" -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a25e4519221c8e8c34d5f9110d8a95439">param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value of the FSurface whose world coordinates are P. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8581b1c0e0495a96fa6016a6054ef5"></a><!-- doxytag: member="MGFSurface::param_e_u" ref="aff8581b1c0e0495a96fa6016a6054ef5" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#aff8581b1c0e0495a96fa6016a6054ef5">param_e_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5ff1f15b70e3a454d799af3cf752f2"></a><!-- doxytag: member="MGFSurface::param_e_v" ref="a8d5ff1f15b70e3a454d799af3cf752f2" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ab2b5a49bacf9c241f3ad34e72353e3"></a><!-- doxytag: member="MGFSurface::param_s_u" ref="a9ab2b5a49bacf9c241f3ad34e72353e3" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a9ab2b5a49bacf9c241f3ad34e72353e3">param_s_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value of the base surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6b5317d1dd4bdfbe26973da371828af"></a><!-- doxytag: member="MGFSurface::param_s_v" ref="aa6b5317d1dd4bdfbe26973da371828af" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a250b40652b5c0400bd5d5f4f350b85a0">parameter_curves</a> (int is_u, double x) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter curves.  <a href="#a250b40652b5c0400bd5d5f4f350b85a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9d65f35210cb54292106ecc963babe"></a><!-- doxytag: member="MGFSurface::param_error" ref="abe9d65f35210cb54292106ecc963babe" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#abe9d65f35210cb54292106ecc963babe">param_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter space error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00142030d1d0a6b742fe59c1d89782e8"></a><!-- doxytag: member="MGFSurface::param_error_u" ref="a00142030d1d0a6b742fe59c1d89782e8" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_error_u</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0cc18f2b3d62763bb1cf75a87785fd2"></a><!-- doxytag: member="MGFSurface::param_error_v" ref="ae0cc18f2b3d62763bb1cf75a87785fd2" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_error_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a97b26afbbe3a66b95e3c7ef85e0af8b2">param_range</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range.  <a href="#a97b26afbbe3a66b95e3c7ef85e0af8b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a388cb2b317aff6476993f3a19d6601c1">perp_guess</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the foot of the perpendicular straight line from P.  <a href="#a388cb2b317aff6476993f3a19d6601c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a8d747b59a0f1209147a7e3f5e1ffbdad">perp_guess</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, double tguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perpendicular points of a curve and the FSurface, given guess starting paramter values.  <a href="#a8d747b59a0f1209147a7e3f5e1ffbdad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a487baf864df83faad23c2326b591a1ed">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, const <a class="el" href="class_m_g_position.html">MGPosition</a> *uvguess=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定点から最も近い、垂線の足とパラメータ値を返す。 Return the foot of the perpendicular straight line from p that is nearest to point p.  <a href="#a487baf864df83faad23c2326b591a1ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a82802a49466e8a9a60c15d20103490bb">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perpendicular points on the FSurface from a point P((x,y,z)).  <a href="#a82802a49466e8a9a60c15d20103490bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#aff035ddc5ce758d5839d652054a1f627">perp_one</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定点から最も近い、垂線の足とパラメータ値を返す。 Return the foot of the perpendicular straight line from p that is nearest to point P.  <a href="#aff035ddc5ce758d5839d652054a1f627"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#affc560a90dfcc2d65c31737d8c82abfc">project</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv_uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める。引数vecが与えられないとき、面直投影する。 投影曲線は面上のパラメータ曲線と3次元曲線としてそれぞれ順番に、vec_crv_uv, vec_crvに格納される。 uv曲線のトレランスはrc_zero()を、3次元曲線はline_zero()をそれぞれ使用している。 戻り値： 投影曲線の数: 投影曲線が求まった 0: 投影曲線が求まらなかった -1: 内部処理エラー -2: 収束処理エラー（収束しなかった） Obtain the projected curve of a curve onto the FSurface.  <a href="#affc560a90dfcc2d65c31737d8c82abfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ae69e0eb803f2f7c70c75ef7ea0fdf2e5">project</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める。引数vecが与えられないとき、面直投影する。 投影曲線は3次元曲線としてvec_crvに格納される。 uv曲線のトレランスはline_zero()を使用している。 戻り値： 投影曲線の数: 投影曲線が求まった 0: 投影曲線が求まらなかった -1: 内部処理エラー -2: 収束処理エラー（収束しなかった） Obtain the projected curve of a curve onto the FSurface.  <a href="#ae69e0eb803f2f7c70c75ef7ea0fdf2e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ac07962f4b9f60859fe657b6e0b7e2712">project_normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;pos, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv_guess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">面直に投影した点を返却する 戻り値は、交点または面直点が求まったときは1、求まらなかったときは0を返却する  <a href="#ac07962f4b9f60859fe657b6e0b7e2712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a13fb86a7db29413a40795bdb2522bb38">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the input parameter (u,v) of the FSurface to the nearest point of the FSurface parameter range.  <a href="#a13fb86a7db29413a40795bdb2522bb38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb092395bb74785320ea9b7f39156c17"></a><!-- doxytag: member="MGFSurface::inner_skeleton" ref="aeb092395bb74785320ea9b7f39156c17" args="(int density) const " -->
<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>inner_skeleton</b> (int density) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a24ce3062df19bd896a864d54826a2ab2">skeleton</a> (int density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain boundary and main parameter lines of the FSurface.  <a href="#a24ce3062df19bd896a864d54826a2ab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f831dd95ab34bf8b0300ef35a7dcf8f"></a><!-- doxytag: member="MGFSurface::skeleton_at_knots" ref="a9f831dd95ab34bf8b0300ef35a7dcf8f" args="() const " -->
virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a9f831dd95ab34bf8b0300ef35a7dcf8f">skeleton_at_knots</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the parameter curves at knots of u and v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7566ec759dec2037106a0a0b53a0a922">split</a> (double param, bool is_u, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;surfaces) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">split this fsurface at the parameter param.  <a href="#a7566ec759dec2037106a0a0b53a0a922"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2a1e56325a7dd53b5d04e97bdd3936f"></a><!-- doxytag: member="MGFSurface::split" ref="ac2a1e56325a7dd53b5d04e97bdd3936f" args="(const std::vector&lt; const MGCurve * &gt; &amp;splitters, const MGVector &amp;dir, MGPvector&lt; MGFace &gt; &amp;faces) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ac2a1e56325a7dd53b5d04e97bdd3936f">split</a> (const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;splitters, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;dir, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;faces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">split this fsurface with splitters. splitters are 2D (u,v) surfaces's parameter curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a2f46fb7d63dfda4d98f32efdf0dfc"></a><!-- doxytag: member="MGFSurface::split" ref="a95a2f46fb7d63dfda4d98f32efdf0dfc" args="(const MGPvector&lt; MGCurve &gt; &amp;splitters, MGPvector&lt; MGFace &gt; &amp;faces) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a95a2f46fb7d63dfda4d98f32efdf0dfc">split</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;splitters, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;faces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">split this fsurface with splitters. splitters are 2D (u,v) surfaces's parameter curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a9aecbb2cc4cb0655910b3d283329c184">extract</a> (const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;trimmers, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;dir, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, std::auto_ptr&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;eface) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a sub surface with trimmers.  <a href="#a9aecbb2cc4cb0655910b3d283329c184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#af917a8cfb6e8448fd307b1916ac56798">trim</a> (const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;trimmers, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;dir, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;faces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim this fsurface with trimmers.  <a href="#af917a8cfb6e8448fd307b1916ac56798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a622353a4b8dc0c9f029ea65689e650c9"></a><!-- doxytag: member="MGFSurface::unit_normal" ref="a622353a4b8dc0c9f029ea65689e650c9" args="(const MGPosition &amp;uv) const =0" -->
virtual <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a622353a4b8dc0c9f029ea65689e650c9">unit_normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute unit normal vector at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad42006866630e1c4acc859780d257ac4"></a><!-- doxytag: member="MGFSurface::unit_normal" ref="ad42006866630e1c4acc859780d257ac4" args="(double u, double v) const =0" -->
virtual <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ad42006866630e1c4acc859780d257ac4">unit_normal</a> (double u, double v) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute unit normal vector at (u,v). <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a0bdea946f6f1707b23aac826aa7aee91">coef_sdim</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain coefficient's space dimension.  <a href="#a0bdea946f6f1707b23aac826aa7aee91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a21533abf8615e4c29f3f73058176f067">isect_area_length</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_f_surface.html#a21533abf8615e4c29f3f73058176f067" title="isect_area_length() returns initial area length for the intersection line.">isect_area_length()</a> returns initial area length for the intersection line.  <a href="#a21533abf8615e4c29f3f73058176f067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a147d5f67a2945555c5dfa346c713455f">isect_direction</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, size_t m1, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuvS, double &amp;du, double &amp;dv, double acuRatio=1.) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_f_surface.html#a147d5f67a2945555c5dfa346c713455f" title="isect_direction() is used by isect_startPt() to define which constant parameter line...">isect_direction()</a> is used by <a class="el" href="class_m_g_f_surface.html#a2951bc0d2d4705be6d570bccd60f9ab0" title="isect_startPt compute an array of parameter value pairs of this surf and sf2 for...">isect_startPt()</a> to define which constant parameter line should be used to compute intersection, and what incremental value be used for the parameter.  <a href="#a147d5f67a2945555c5dfa346c713455f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a36e2c0880130eb2161ec4b6418f2001c">isect_direction_with_direction</a> (double u, double v, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;tangent, double &amp;du, double &amp;dv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_f_surface.html#a36e2c0880130eb2161ec4b6418f2001c" title="isect_direction_with_direction() is used by isect_start() to define which constant...">isect_direction_with_direction()</a> is used by <a class="el" href="class_m_g_f_surface.html#adaa7b4eb86cdc84c88d64b34bba38b1c" title="isect_start compute one intersection line of two surfaces, this and sf2, given starting...">isect_start()</a> to define which constant parameter line should be use to compute intersection, and what incremental value be used for the parameter.  <a href="#a36e2c0880130eb2161ec4b6418f2001c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ae1d7cd77e8cfc9ccebd03f48bf2765c9">isect_dt</a> (double u, double v, double &amp;du, double &amp;dv, double acuRatio=1.) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_dt computes incremental values du and dv for the intersection computation at parameter position (u,v).  <a href="#ae1d7cd77e8cfc9ccebd03f48bf2765c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a7d2432ce1d438c0f245b92e05d1383ad">isect_inner_dt</a> (size_t n, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvnow, double &amp;du, double &amp;dv, int &amp;kdt, double acuRatio=1.) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_inner_dt" is a dedicated function of isect_startPt, comutes adequate incremental parameter value(du,dv) and parameter line kind kdt(u=const or v=const).  <a href="#a7d2432ce1d438c0f245b92e05d1383ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a503a55ee5d805ba7f8491cbca6b964fc">isect_dt_coef</a> (size_t n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_dt_coef provides coef of how fine parameter increment should be, given num of intersection points computed so far.  <a href="#a503a55ee5d805ba7f8491cbca6b964fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#afe84f4e95712bb9b395e18e71f525ae8">isect_div_id_max</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_div_id_max is maximum id of array of sect_div defined in isect_dt_coef.  <a href="#afe84f4e95712bb9b395e18e71f525ae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ac230405620009b9c2ca54fba019b56a6">isect_incr_pline</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int kdt, double du, double dv, double &amp;u, double &amp;v, size_t incr=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect1_incr_pline" is a dedicated function of isect_start_incr, will get shortest parameter line necessary to compute intersection.  <a href="#ac230405620009b9c2ca54fba019b56a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#adaa7b4eb86cdc84c88d64b34bba38b1c">isect_start</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_startIn, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, <a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;ssi, MGPosition_list::iterator &amp;uvuv_id, int &amp;m1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_start compute one intersection line of two surfaces, this and sf2, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2) and direction(stan).  <a href="#adaa7b4eb86cdc84c88d64b34bba38b1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a947810aee4fddb658e435389d0262e69">isect_start_boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_pre, int kdt, double du, double dv, size_t lid1, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_now) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_start_boundary" is a dedicated function of isect_start.  <a href="#a947810aee4fddb658e435389d0262e69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a800a13e72ca8ac738eb26ada897b68cb">isect_start_dif</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;line, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the maximum difference between the intersection line and the two surfaces, this and sr2.  <a href="#a800a13e72ca8ac738eb26ada897b68cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a259ed89035aa5fb405481064e00a345b">isect_start_incr</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_pre, int kdt, double du, double dv, size_t lid1, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_now) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_start_incr compute one intersection point of two surfaces, this surface's parameter line at uv1+dt(according to kdt) and sf2, given previous intersetion point(uv1,uv2) and incremental value dt.  <a href="#a259ed89035aa5fb405481064e00a345b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a2951bc0d2d4705be6d570bccd60f9ab0">isect_startPt</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_startIn, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, double acuRatio, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;point, MGPosition_list::iterator &amp;uvuv_id, int &amp;m1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_startPt compute an array of parameter value pairs of this surf and sf2 for one intersection line of the two surfaces, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2) and direction(stan).  <a href="#a2951bc0d2d4705be6d570bccd60f9ab0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#ac42b323bc943679e94efcb0f5f39de3e">isect_startPlane</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuvS, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl, <a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;ssi, MGPosition_list::iterator &amp;uvuv_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute an intersection line of this surface(a surface that is converted to 1D SBRep surface(sf1d)) and a plane pl.  <a href="#ac42b323bc943679e94efcb0f5f39de3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a03623143fba87120480109e275b2f0d0">isect_startPlanePt</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_startIn, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl2, double acuRatio, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;point, MGPosition_list::iterator &amp;uvuv_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_startPlanePt compute an array of parameter value pairs of this surf and pl2 for one intersection line of a surface and a plane, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of pl2) and direction in uvuv_startI(4-6) (optionally).  <a href="#a03623143fba87120480109e275b2f0d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a5a059f5b908d6aeee4a99b172b3f9fa9">isect_with_surf</a> (<a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersection lines of this surface and srf2(both are not planes).  <a href="#a5a059f5b908d6aeee4a99b172b3f9fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#aeac7b016c41ad5ea8bf7f6e71e01b698">isect_with_plane</a> (<a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;fsrf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersection lines of this(is not a plane) surface and a plane pl.  <a href="#aeac7b016c41ad5ea8bf7f6e71e01b698"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a536d0d734b5c205be3e08c2f0762f861"></a><!-- doxytag: member="MGFSurface::projVector" ref="a536d0d734b5c205be3e08c2f0762f861" args="(const MGCurve &amp;crv, MGPvector&lt; MGCurve &gt; &amp;vec_crv_uv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a536d0d734b5c205be3e08c2f0762f861">projVector</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv_uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクトル投影は、カーブを折れで分割して行い、後で接続する <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6e5cc99c9f14d029d61a74031ded4e"></a><!-- doxytag: member="MGFSurface::MGFace" ref="a1f6e5cc99c9f14d029d61a74031ded4e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#a1f6e5cc99c9f14d029d61a74031ded4e">MGFace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe000bc8a2d7a96c44aedb2bbe2f1280"></a><!-- doxytag: member="MGFSurface::MGSurface" ref="afe000bc8a2d7a96c44aedb2bbe2f1280" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_f_surface.html#afe000bc8a2d7a96c44aedb2bbe2f1280">MGSurface</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Define <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a> Class. </p>
<p><a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a> is an abstract class to provide the comman interfaces to <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> and <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a17e4c4cfd0c528657426629f3dc8fc24"></a><!-- doxytag: member="MGFSurface::arrow" ref="a17e4c4cfd0c528657426629f3dc8fc24" args="(double u, double v, MGPosition data[10]) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGFSurface::arrow </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>[10]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate arrow data of the tangent along u and v and the normal at the parameter value (u,v) of the FSurface. </p>
<p>data[0] is the origin of the u-tangent arrow, data[1] is the top of the u-tangent arrow, data[2], [3] are two bottoms of u-tangent arrowhead. data[0], [4], [5], [6] are the points of v-tangent arrow. data[0], [7], [8], [9] are the points of v-tangent arrow. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a0df52ab736aa74ae2da517bd0484be03">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a74b3b93a12a333d752020c1b49cf6db0">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a027f707b72095b5a4038dc5410e50ce2"></a><!-- doxytag: member="MGFSurface::box_param2" ref="a027f707b72095b5a4038dc5410e50ce2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_m_g_box.html">MGBox</a> MGFSurface::box_param2 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return box of the parameter space of the FSurface. </p>
<p>After trimmed one. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#ad0b4d8c8eb52d145ba1128936d2a0e1e">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a5ec7d4640196d2dcefc2ff9c65b86a55">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a4a39743914b8e15d32c27740aa6d8c79"></a><!-- doxytag: member="MGFSurface::clone_as_face" ref="a4a39743914b8e15d32c27740aa6d8c79" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_face.html">MGFace</a>* MGFSurface::clone_as_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the clone of this as a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. </p>
<p>If this is <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, it is converted to <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a4a623309eb1cc5105400dda4aa003efe">MGSurface</a>, and <a class="el" href="class_m_g_face.html#ac324ccb46e913738c3370c015a7f5bb3">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a44385215d7089b9f2ad42792aad0d3f7"></a><!-- doxytag: member="MGFSurface::closest" ref="a44385215d7089b9f2ad42792aad0d3f7" args="(const MGPosition &amp;point) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGFSurface::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute closest point from a point. </p>
<p>Returned is the parameter value of the FSurface that is closest to point. </p>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#a8cfc205e727c9d77cb3c393a4bdf925d">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a4a947f099c9866e3d76fd6e80fd0296b">MGPlane</a>, <a class="el" href="class_m_g_sphere.html#afa2bf9455d696da90d888dd7449fcfe4">MGSphere</a>, <a class="el" href="class_m_g_surface.html#a968d690be2c0009a282ac74085b95422">MGSurface</a>, and <a class="el" href="class_m_g_face.html#aa316bfc80da17272e5af026758de0957">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a7f41b0c00f61627312776bfe06366bdb"></a><!-- doxytag: member="MGFSurface::closest_on_boundary" ref="a7f41b0c00f61627312776bfe06366bdb" args="(const MGStraight &amp;sl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGFSurface::closest_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute closest point from a line to the boundary of the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. </p>
<p>Returned is the parameter value of the FSurface that is closest to point. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a389583b74836a7496f7ead774fe1d6f5">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a57ee47cb85783c02acb714f6f7806c25">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a0bdea946f6f1707b23aac826aa7aee91"></a><!-- doxytag: member="MGFSurface::coef_sdim" ref="a0bdea946f6f1707b23aac826aa7aee91" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGFSurface::coef_sdim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain coefficient's space dimension. </p>
<p>This function is used in isect_start etc. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#adfdb3b6a71739d4003fa3ec2d840a034">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a44c3eb3132d0a54a89447615a793f5d3"></a><!-- doxytag: member="MGFSurface::drawWireFS" ref="a44c3eb3132d0a54a89447615a793f5d3" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFSurface::drawWireFS </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>Line segment span length.line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a827522c3a515722c10a945c4eb25b8f0"></a><!-- doxytag: member="MGFSurface::eval" ref="a827522c3a515722c10a945c4eb25b8f0" args="(double u, double v, size_t ndu=0, size_t ndv=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_vector.html">MGVector</a> MGFSurface::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation Input parameter value is not checked if it is <a class="el" href="class_m_g_f_surface.html#ae8482cbcaa7cd6dcbdc2981043892f66" title="Test if parameter value (u,v) is in the range of the FSurface parameter.">in_range()</a> or not. </p>
<p>Even if it is not <a class="el" href="class_m_g_f_surface.html#ae8482cbcaa7cd6dcbdc2981043892f66" title="Test if parameter value (u,v) is in the range of the FSurface parameter.">in_range()</a>, surFSurface evaluation will be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>FSurface parameter value(u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#aa88d8ee7066981625215a47e77948417">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a151bc0f63249fe878740eb16e5d7c457">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a349a162d7e65af4e52a6d049b069f665">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a01bf003a29ccd6bdc004ca3028506f96">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a16d04d8d8da3f8068ee958c93a0f02a9">MGSBRep</a>, <a class="el" href="class_m_g_sphere.html#a38667e0405d3b3d7cb50a2ddd8055779">MGSphere</a>, <a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a9cd3a45812dab6f742c64017e7fef985">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a0a681a39c5dc1107447b3399b110fdea"></a><!-- doxytag: member="MGFSurface::eval" ref="a0a681a39c5dc1107447b3399b110fdea" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_vector.html">MGVector</a> MGFSurface::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>FSurface parameter value(u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a4e011c4af6d79a793fbf9f652f59d4c1">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a6288008dc36129da70f17870a05a5902">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a1b246aa1ff1ae915cf8fc068dac5ab74">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a6ad9b9fbb8558192e37e71308ff691bd">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a4a84a30a177df8c06d2e692968f43323">MGSBRep</a>, <a class="el" href="class_m_g_sphere.html#a1b5a6e9f2820a9db9da6a13dd113ab7f">MGSphere</a>, <a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a36fc03dc036fcb63ddf1a35a6aaf4282">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a137ebd00cf79e059a5f1f49682ef4438"></a><!-- doxytag: member="MGFSurface::eval_discrete_deviation" ref="a137ebd00cf79e059a5f1f49682ef4438" args="(const MGFSurface &amp;face2, std::vector&lt; MGPosition &gt; &amp;uvuvs, int npoint=20, double tolerance=0.1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFSurface::eval_discrete_deviation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_position.html">MGPosition</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>npoint</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em> = <code>0.1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate deviations of two faces(this and face2) at npoint discrete points. </p>
<p>(1)Search the common edges which have the distance within tolerance. (2)Compute the nearest points from npoint discrete points of this to face2. Let uvuvi=uvuvs[i], then uvuvi[0], [1] are this face's parameter value(u1,v1), and uvuvi[2], [3] are parameter value(u2,v2) of face2 which is the nearest point from the point (u1, v1). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>npoint</em>&nbsp;</td><td>indicates how many discrete points be obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>tolerance to get two edge to compute deviation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aecbb2cc4cb0655910b3d283329c184"></a><!-- doxytag: member="MGFSurface::extract" ref="a9aecbb2cc4cb0655910b3d283329c184" args="(const std::vector&lt; const MGCurve * &gt; &amp;trimmers, const MGVector &amp;dir, const MGPosition &amp;uv, std::auto_ptr&lt; MGFace &gt; &amp;eface) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFSurface::extract </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>trimmers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::auto_ptr&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>eface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub surface with trimmers. </p>
<p>trimmers are 3D curves and will be projected onto this surface tword the direction dir. If dir is null vector, surface normal prjection will be performed. Extraction is so performed that the smallest region enclosed by trimmers that includes the surface point uv will be extracted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>trimmers</em>&nbsp;</td><td>Trimmer curves </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>trimmers projection direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>surface parameter (u,v) that indicates the region to extract. The smallest region that inclued uv will be extracted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eface</em>&nbsp;</td><td>Result extracted face will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9f377eb6f6e2d22e5b1e4ba93ef866a"></a><!-- doxytag: member="MGFSurface::get_surface_pointer" ref="ad9f377eb6f6e2d22e5b1e4ba93ef866a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGFSurface::get_surface_pointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get surface pointer. </p>
<p>Null will never be returned if this is valid <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. That is, if this is <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, base surface will be returned. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a8c24da8133fbbef6f02284939d1caaa5">MGSurface</a>, and <a class="el" href="class_m_g_face.html#afb1f8eab3ce637b3ef956b985c3e9857">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a49a378f0e540171dd62b4c62b60b30f2"></a><!-- doxytag: member="MGFSurface::has_commonFS" ref="a49a378f0e540171dd62b4c62b60b30f2" args="(const MGObject &amp;obj2) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGFSurface::has_commonFS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this and 2nd object has common area about their box(), taking error into account. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a75f016363f801103239789e75fd34972">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a8b0d13a3a28e3aeba4fbe274c4bf8f97">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a7e9009568012f1a8140fb6a9dc0952ca"></a><!-- doxytag: member="MGFSurface::hasInnerBoundaryLoop" ref="a7e9009568012f1a8140fb6a9dc0952ca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGFSurface::hasInnerBoundaryLoop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this FSurface has inner boundary loops or not. </p>
<p>If this has one, return true. </p>

</div>
</div>
<a class="anchor" id="ac871fe28de2080e9d9dd08b9334fcea6"></a><!-- doxytag: member="MGFSurface::hasLoop" ref="ac871fe28de2080e9d9dd08b9334fcea6" args="(const MGBox &amp;uvbox) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGFSurface::hasLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this FSurface has boundary loops or not in the specified box. </p>
<p>If this has one, return true. </p>

<p>Reimplemented in <a class="el" href="class_m_g_face.html#abf14a3f17bfc5316c91f7151aabe81ff">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="ada7927bcf688f99df7c8a5d1f0981b2e"></a><!-- doxytag: member="MGFSurface::in_range_with_on" ref="ada7927bcf688f99df7c8a5d1f0981b2e" args="(double u, double v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::in_range_with_on </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if (u,v) is inside the face. </p>
<p>Function's return value is: 0:outside the face. 1:unknown. 2:inside the face, not on a boundary. &lt;0:(u,v) is on an inner boundary, and abs(return code) is the loop id. 4:(u,v) is on the outer boundary. &gt;=10: (u,v) is on a perimeter, (10+perimeter number) will be returned. </p>

</div>
</div>
<a class="anchor" id="a959f466f07e68676b3ca976ae4a02ff4"></a><!-- doxytag: member="MGFSurface::inner_boundary" ref="a959f466f07e68676b3ca976ae4a02ff4" args="(size_t i) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFSurface::inner_boundary </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface. </p>
<p>Let the output of inner_boundary(i) be wcurves and of inner_boundary_param(i) be pcurves, then wcurves[j] corresponds to pcurves[j] one to one. Number of inner_boundary can be obtained by the function number_of_inner_boundary(). </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a1da72edf6bf5bea0bb56864266258ce0">MGSurface</a>, and <a class="el" href="class_m_g_face.html#ab4639dd5c517155abcb4e1009643d5ea">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a58c5b3bbb657bbfe80bbb5fd65a11da3"></a><!-- doxytag: member="MGFSurface::inner_boundary_param" ref="a58c5b3bbb657bbfe80bbb5fd65a11da3" args="(size_t i) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFSurface::inner_boundary_param </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface. </p>
<p>Let the output of inner_boundary(i) be wcurves and of inner_boundary_param(i) be pcurves, then wcurves[j] corresponds to pcurves[j] one to one. Number of inner_boundary can be obtained by the function number_of_inner_boundary(). </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a866b006d84096d32762b7dec7611d67f">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a266c6b35a20839f81aa761f59c373de9">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a7856641031c79064b250b955edfba528"></a><!-- doxytag: member="MGFSurface::intersect12Boundary" ref="a7856641031c79064b250b955edfba528" args="(const MGFSurface &amp;face2, MGPosition_list &amp;uvuv_list) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFSurface::intersect12Boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the intersection points of this face's boundaries(out or inner) with face2, and vice versa. </p>
<p>These intersection points are used to compute surface to surface intersection lines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>face2</em>&nbsp;</td><td>The second surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>The intersection points will be output, One member of uvuv_list is (u1,v1,u2,v2), where (u1,v1) is a parameter of this surface and (u2,v2) is a parameter of surf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21533abf8615e4c29f3f73058176f067"></a><!-- doxytag: member="MGFSurface::isect_area_length" ref="a21533abf8615e4c29f3f73058176f067" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGFSurface::isect_area_length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_m_g_f_surface.html#a21533abf8615e4c29f3f73058176f067" title="isect_area_length() returns initial area length for the intersection line.">isect_area_length()</a> returns initial area length for the intersection line. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a7c5f81bf50ebafb185d53341e9b9aa4e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a0936671424c065e29984938cd240d00c"></a><!-- doxytag: member="MGFSurface::isect_boundary" ref="a0936671424c065e29984938cd240d00c" args="(const MGFSurface &amp;face2, MGPosition_list &amp;uvuvs, size_t id1=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGFSurface::isect_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of this face's boundary(outer and inners) with face2. </p>
<p>If intersection points are found and the boundary is a loop, the point's edge pointer(of this) will be stored in a member uvuv of uvuvs. uvuv[7] is the edge pointer. If the boundary is not a loop(that is, a perimeter of Surfaces), uvuv.sdim()==7 and an edge pointer is not returned. When uvuv.sdim()==8, the edge pointer of uvuv[7] is accessed through union mgEdgeP. uvuvs[i] is i-th intersection points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuvs</em>&nbsp;</td><td>id1 and id2 are the ids of uvuv where this face's and f2's parameters are to be stored in a member of uvuvs. This face's (u,v) is stored in uvuv(id1) and (id1+1). f2's (u,v) is stored in uvuv(id2) and (id2+1). id2=0 if id1=2, and id2=2 if id1=0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a84499b9e91ee9d02e1cf2c8c911805c2">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a147d5f67a2945555c5dfa346c713455f"></a><!-- doxytag: member="MGFSurface::isect_direction" ref="a147d5f67a2945555c5dfa346c713455f" args="(const MGFSurface &amp;sf2, size_t m1, MGPosition &amp;uvuvS, double &amp;du, double &amp;dv, double acuRatio=1.) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::isect_direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuvS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em> = <code>1.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_m_g_f_surface.html#a147d5f67a2945555c5dfa346c713455f" title="isect_direction() is used by isect_startPt() to define which constant parameter line...">isect_direction()</a> is used by <a class="el" href="class_m_g_f_surface.html#a2951bc0d2d4705be6d570bccd60f9ab0" title="isect_startPt compute an array of parameter value pairs of this surf and sf2 for...">isect_startPt()</a> to define which constant parameter line should be used to compute intersection, and what incremental value be used for the parameter. </p>
<p>Function's return value is direction to get next intersection(with dt). When =1: u=const direction, =0: v=const, =-1: cannot get intersection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>Second surface for the intersection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m1</em>&nbsp;</td><td>id of uvuvS that indicates this surface's parameter position in uvuvS. (uvuvS(m1), uvuvS(m1+1))=(u,v) of this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuvS</em>&nbsp;</td><td>start parameter (u,v) pair of this surface and sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>du</em>&nbsp;</td><td>Incremental value of the parameter kind of kdt will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Right dt will be output according to the function's output =0,1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>acuracy ratio. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_surface.html#a7eb99b357d5acfa389b24e902f58f77f">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a36e2c0880130eb2161ec4b6418f2001c"></a><!-- doxytag: member="MGFSurface::isect_direction_with_direction" ref="a36e2c0880130eb2161ec4b6418f2001c" args="(double u, double v, const MGVector &amp;tangent, double &amp;du, double &amp;dv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_direction_with_direction </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_m_g_f_surface.html#a36e2c0880130eb2161ec4b6418f2001c" title="isect_direction_with_direction() is used by isect_start() to define which constant...">isect_direction_with_direction()</a> is used by <a class="el" href="class_m_g_f_surface.html#adaa7b4eb86cdc84c88d64b34bba38b1c" title="isect_start compute one intersection line of two surfaces, this and sf2, given starting...">isect_start()</a> to define which constant parameter line should be use to compute intersection, and what incremental value be used for the parameter. </p>
<p>Function's return value <a class="el" href="class_m_g_f_surface.html#a147d5f67a2945555c5dfa346c713455f" title="isect_direction() is used by isect_startPt() to define which constant parameter line...">isect_direction()</a> is 1 for u=const parameter line, and 0 for v=const parameter line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>start parameter (u,v) of this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tangent</em>&nbsp;</td><td>To indicate which direction isect line should march toward. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>du</em>&nbsp;</td><td>Incremental value sign of the parameter kind of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>isect_direction_with_direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe84f4e95712bb9b395e18e71f525ae8"></a><!-- doxytag: member="MGFSurface::isect_div_id_max" ref="afe84f4e95712bb9b395e18e71f525ae8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGFSurface::isect_div_id_max </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_div_id_max is maximum id of array of sect_div defined in isect_dt_coef. </p>
<p>That is, isect_div_id_max+1 is the length of the array sect_div. </p>

<p>Reimplemented in <a class="el" href="class_m_g_surface.html#a68d207fd08c45db618304b0ee367b668">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae1d7cd77e8cfc9ccebd03f48bf2765c9"></a><!-- doxytag: member="MGFSurface::isect_dt" ref="ae1d7cd77e8cfc9ccebd03f48bf2765c9" args="(double u, double v, double &amp;du, double &amp;dv, double acuRatio=1.) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFSurface::isect_dt </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em> = <code>1.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_dt computes incremental values du and dv for the intersection computation at parameter position (u,v). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>acuracy ratio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a503a55ee5d805ba7f8491cbca6b964fc"></a><!-- doxytag: member="MGFSurface::isect_dt_coef" ref="a503a55ee5d805ba7f8491cbca6b964fc" args="(size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGFSurface::isect_dt_coef </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_dt_coef provides coef of how fine parameter increment should be, given num of intersection points computed so far. </p>

</div>
</div>
<a class="anchor" id="a7a34135d9b1dc717d1526ef49e43592f"></a><!-- doxytag: member="MGFSurface::isect_guess" ref="a7a34135d9b1dc717d1526ef49e43592f" args="(const MGCurve &amp;crv, const MGPosition &amp;uvi, double ti, MGPosition &amp;uv, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::isect_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve. </p>
<p>Function's return value is 1(true) if i.p. obtained, and 0(false) if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>Curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvi</em>&nbsp;</td><td>Input initial guess parameter value of the i.p. of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>Input initial guess parameter value of the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a615c03754e90ca6394f34e2944b1c4"></a><!-- doxytag: member="MGFSurface::isect_guess" ref="a1a615c03754e90ca6394f34e2944b1c4" args="(const MGStraight &amp;sl, const MGPosition &amp;uvi, double ti, MGPosition &amp;uv, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::isect_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve. </p>
<p>Function's return value is 1(true) if i.p. obtained, and 0(false) if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sl</em>&nbsp;</td><td>Curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvi</em>&nbsp;</td><td>Input initial guess parameter value of the i.p. of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>Input initial guess parameter value of the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a9f1a5d5fd69cb2d14e613b12330ef6"></a><!-- doxytag: member="MGFSurface::isect_guess" ref="a0a9f1a5d5fd69cb2d14e613b12330ef6" args="(const MGCompositeCurve &amp;crv, const MGPosition &amp;uvi, double ti, MGPosition &amp;uv, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::isect_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve. </p>
<p>Function's return value is 1(true) if i.p. obtained, and 0(false) if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>Curve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvi</em>&nbsp;</td><td>Input initial guess parameter value of the i.p. of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>Input initial guess parameter value of the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a350a0375a65d5262a31f75608db5da07"></a><!-- doxytag: member="MGFSurface::isect_guess_composite" ref="a350a0375a65d5262a31f75608db5da07" args="(const MGCompositeCurve &amp;crv, const MGPosition &amp;uvi, double ti, MGPosition &amp;uv, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::isect_guess_composite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_guess" computes one intersection point of surface and a curve, given initail guess parameter values of surface and curve. </p>
<p>Function's return value is 1(true) if i.p. obtained, and 0(false) if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>Curve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvi</em>&nbsp;</td><td>Input initial guess parameter value of the i.p. of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>Input initial guess parameter value of the line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter value obtained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd6b3b5e4473febc189bfd9b8517e1d9"></a><!-- doxytag: member="MGFSurface::isect_guess_straight" ref="abd6b3b5e4473febc189bfd9b8517e1d9" args="(const MGStraight &amp;sl, double ti, const MGPosition &amp;uvi, double &amp;t, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::isect_guess_straight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_guess_straight" computes one intersection point of surface and a straight line, given initail guess parameter values of the surface and the straight line. </p>
<p>Function's return value is 1(true) if i.p. obtained, and 0(false) if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sl</em>&nbsp;</td><td>Straight line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>Initial guess parameter value of the straight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvi</em>&nbsp;</td><td>Input initial guess parameter value of the i.p. of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Straight parameter obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Surface parameter value obtained(u,v). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac230405620009b9c2ca54fba019b56a6"></a><!-- doxytag: member="MGFSurface::isect_incr_pline" ref="ac230405620009b9c2ca54fba019b56a6" args="(const MGPosition &amp;uv, int kdt, double du, double dv, double &amp;u, double &amp;v, size_t incr=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGFSurface::isect_incr_pline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>incr</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect1_incr_pline" is a dedicated function of isect_start_incr, will get shortest parameter line necessary to compute intersection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>last intersection point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdt</em>&nbsp;</td><td>Input if u=const v-parameter line or not. true:u=const, false:v=const. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Incremental parameter length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>next u value will be output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>next v value will be output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>Incremental valuse of B-coef's id. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a73bb5133b684226cb8bca310cfdf152e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab492a3900dd067dab5668f0b7c0470c0"></a><!-- doxytag: member="MGFSurface::isect_incurves" ref="ab492a3900dd067dab5668f0b7c0470c0" args="(const MGFSurface &amp;face2, size_t iid, MGPosition_list &amp;uvuv_list, size_t id1) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGFSurface::isect_incurves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points between the boundary of iid-th inner boundary of this face and face2 to compute intersections of face with face2. </p>
<p>Function's return value is the number of ip's obtained before appending into uvuv_list, may not be equal to the enlarged size of uvuv_list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iid</em>&nbsp;</td><td>Inner loop id of this face(from 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>intersection points will be appended, One member in the list is of sdim 8, (4,5,6) is the direction vector, and (7) is Edge pointer of the point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id1</em>&nbsp;</td><td>id of uvuv(a member of uvuv_list), uvuv(id1) for this face parameter uvuv(id2) for face2 parameter, id2=0 if id1=2, and id2=2 if id1=0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a01bca74c9479d189a5b49c331414a77e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7d2432ce1d438c0f245b92e05d1383ad"></a><!-- doxytag: member="MGFSurface::isect_inner_dt" ref="a7d2432ce1d438c0f245b92e05d1383ad" args="(size_t n, const MGPosition &amp;uvnow, double &amp;du, double &amp;dv, int &amp;kdt, double acuRatio=1.) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGFSurface::isect_inner_dt </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvnow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>kdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em> = <code>1.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_inner_dt" is a dedicated function of isect_startPt, comutes adequate incremental parameter value(du,dv) and parameter line kind kdt(u=const or v=const). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>num of i.p. obtained so far(not include uvnow). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvnow</em>&nbsp;</td><td>intersection point obtained last(of this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>incremental length from previous to uvnow is input. New du or dv will be output according to kdt's return value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdt</em>&nbsp;</td><td>Parameter kind used so far is input, will be output as: =1:parameter line kind(u=const), =0: v=const, =-1:should halt computation since incremental value is zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>Accurate ratio. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_surface.html#a577846dde31c5f63f0bc8854e0fe0b10">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a3d7bbd977a593d3987bd38b9bcadb201"></a><!-- doxytag: member="MGFSurface::isect_outcurves" ref="a3d7bbd977a593d3987bd38b9bcadb201" args="(const MGFSurface &amp;face2, MGPosition_list &amp;uvuv_list, size_t id1) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGFSurface::isect_outcurves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of outer boundary curves of this face with face2 to compute intersections. </p>
<p>Function's return value is the number of ip's obtained(appended) into uvuv_list, may not be equal to the enlarged size of uvuv_list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>intersection points will be appended, One member in the list is of sdim 7, and the last three elements are the ip direction vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id1</em>&nbsp;</td><td>id of uvuv(a member of uvuv_list), uvuv(id1) for this face parameter uvuv(id2) for srf or face2 parameter, id2=0 if id1=2, and id2=2 if id1=0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#af7ed14b2843adc1468aaca7328f71a0b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="adaa7b4eb86cdc84c88d64b34bba38b1c"></a><!-- doxytag: member="MGFSurface::isect_start" ref="adaa7b4eb86cdc84c88d64b34bba38b1c" args="(const MGPosition &amp;uvuv_startIn, MGPosition_list &amp;uvuv_list, const MGFSurface &amp;sf2, MGSSisect &amp;ssi, MGPosition_list::iterator &amp;uvuv_id, int &amp;m1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ssi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGPosition_list::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_start compute one intersection line of two surfaces, this and sf2, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2) and direction(stan). </p>
<p>isect_start halts the computation when intersection reached to a boundary of this or sf2, or reached to one of the points in uvuv_list. The function's return value is: =0: Intersection was not obtained. !=0: Intersection was obtained as follows: =1: End point is a point on a perimeter of one of the surfaces. =3: End point is one of boundary points in uvuv_list. =4: End point is the starting point. =7: isect_start halted the computation since intersection was lost during the computation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_startIn</em>&nbsp;</td><td>Starting point of the intersection line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>isect_start will halt when ip reached one of the point in uvuv_list. isect_start does not change uvuv_list(actually uvuv_list is const.) uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>2nd surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssi</em>&nbsp;</td><td>Surface-surface intersection line will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_id</em>&nbsp;</td><td>When the end point of ip was one of the points of uvuv_list, uvuv_list's iterator of the point will be returned, that is, when the function's return value was 3 or 5. When was not a point of uvuv_list, end() of uvuv_list will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m1</em>&nbsp;</td><td>id that indicates which surface was used as the main surface. m1=0: this surface, m1=2: sf2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a947810aee4fddb658e435389d0262e69"></a><!-- doxytag: member="MGFSurface::isect_start_boundary" ref="a947810aee4fddb658e435389d0262e69" args="(const MGFSurface &amp;sf2, const MGPosition &amp;uvuv_pre, int kdt, double du, double dv, size_t lid1, MGPosition &amp;uvuv_now) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_start_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>lid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_now</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_start_boundary" is a dedicated function of isect_start. </p>
<p>"isect_start_boundary" computes one intersection point of two surfaces, this surface's parameter line at uv+dt(according to kdt) and sb2, given previous intersetion point(uv) and incremental value dt. "isect_start_boundary" is used only when no intersection found at dt. Function's return value is 0: ip not found. 2: ip found as intersection line end point. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>2nd surface b-rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_pre</em>&nbsp;</td><td>Starting parameter values of ip. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdt</em>&nbsp;</td><td>kdt=true: u=const parameter line, else: v=const parameter line of this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Incremental parameter length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lid1</em>&nbsp;</td><td>id of parameter of this surface in uvuv_pre or uvuv_now. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_now</em>&nbsp;</td><td>New parameter values of ip will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a800a13e72ca8ac738eb26ada897b68cb"></a><!-- doxytag: member="MGFSurface::isect_start_dif" ref="a800a13e72ca8ac738eb26ada897b68cb" args="(const MGNDDArray &amp;tau, const MGLBRep &amp;line, const MGFSurface &amp;sf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGFSurface::isect_start_dif </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the maximum difference between the intersection line and the two surfaces, this and sr2. </p>
<p>The difference evaluation is done at the data point tau. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>data points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>the intersection line of this and sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>second surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a259ed89035aa5fb405481064e00a345b"></a><!-- doxytag: member="MGFSurface::isect_start_incr" ref="a259ed89035aa5fb405481064e00a345b" args="(const MGFSurface &amp;sf2, const MGPosition &amp;uvuv_pre, int kdt, double du, double dv, size_t lid1, MGPosition &amp;uvuv_now) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_start_incr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>lid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_now</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_start_incr compute one intersection point of two surfaces, this surface's parameter line at uv1+dt(according to kdt) and sf2, given previous intersetion point(uv1,uv2) and incremental value dt. </p>
<p>Here uv1 is uvuv_pre(lid1, lid1+1), and uv2 is other two values of uvuvpre. isect_start_incr is a dedicated function of isect_start and isect_start_boundary. Function's return value is true: if ip found, false: if ip not found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>2nd surface b-rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_pre</em>&nbsp;</td><td>Starting parameter values of ip. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdt</em>&nbsp;</td><td>kdt=true: u=const parameter line, else: v=const parameter line of this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Incremental parameter length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lid1</em>&nbsp;</td><td>id of parameter of this surface in uvuv_pre or uvuv_now. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_now</em>&nbsp;</td><td>New parameter values of ip will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac42b323bc943679e94efcb0f5f39de3e"></a><!-- doxytag: member="MGFSurface::isect_startPlane" ref="ac42b323bc943679e94efcb0f5f39de3e" args="(const MGPosition &amp;uvuvS, MGPosition_list &amp;uvuv_list, const MGPlane &amp;pl, MGSSisect &amp;ssi, MGPosition_list::iterator &amp;uvuv_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_startPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuvS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ssi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGPosition_list::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute an intersection line of this surface(a surface that is converted to 1D SBRep surface(sf1d)) and a plane pl. </p>
<p>sf1D is so converted that pl be x=0. plane. This surface is the original surface and pl is the original plane. The function's return value is: =0: Intersection was not obtained. !=0: Intersection was obtained as follows: =1: End point is a point on a perimeter of one of the surfaces. =3: End point is one of boundary points in uvuv_list. =4: End point is the starting point. =7: isect_start halted the computation since intersection was lost during the computation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuvS</em>&nbsp;</td><td>Starting parameter value of the intersection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>isect_startPlane will halt when ip reached one of the point in uvuv_list. isect_startPlane does not change uvuv_list(actually uvuv_list is const.) uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of pl. When uvuv's space dimension is more than 4, it indicates that the uvuv is used to input approcimate tangent of the intersection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pl</em>&nbsp;</td><td>Plane expression(2nd surface for the intersection). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssi</em>&nbsp;</td><td>Surface-surface intersection line will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_id</em>&nbsp;</td><td>When the end point of ip was one of the points of uvuv_list, uvuv_list's iterator of the point will be returned, that is, when the function's return value was 3 or 5. When was not a point of uvuv_list, end() of uvuv_list will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03623143fba87120480109e275b2f0d0"></a><!-- doxytag: member="MGFSurface::isect_startPlanePt" ref="a03623143fba87120480109e275b2f0d0" args="(const MGPosition &amp;uvuv_startIn, MGPosition_list &amp;uvuv_list, const MGPlane &amp;pl2, double acuRatio, MGBPointSeq &amp;point, MGPosition_list::iterator &amp;uvuv_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_startPlanePt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pl2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGPosition_list::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_startPlanePt compute an array of parameter value pairs of this surf and pl2 for one intersection line of a surface and a plane, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of pl2) and direction in uvuv_startI(4-6) (optionally). </p>
<p>isect_startPlanePt is a dedicated function for isect_startPlane. isect_startPlanePt halts the computation when intersection reached to a boundary of this, or reached to one of the points in uvuv_list. The function's return value is: =0: Intersection was not obtained. !=0: Intersection was obtained as follows: =1: End point is a point on a perimeter of this surfaces. =3: End point is one of boundary points in uvuv_list. =4: End point is the starting point. =7: isect_startPlanePt halted the computation since intersection was lost during the computation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_startIn</em>&nbsp;</td><td>Starting point of the intersection line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>isect_startPlanePt will halt when ip reached one of the point in uvuv_list. isect_startPlanePt does not change uvuv_list(actually uvuv_list is const.) uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of pl2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pl2</em>&nbsp;</td><td>2nd surface(MGPlane). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>Accurate ratio, should be decreased by multiplyng .2 (or a number less than 1.). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Surface-surface intersection parameter values will be returned as:point(.,0) and point(.,1) for(u,v) of this surface point(.,2) and point(.,3) for(u,v) of pl2. point will have the dimension of(.,7). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_id</em>&nbsp;</td><td>When the end point of ip was one of the points of uvuv_list, uvuv_list's iterator of the point will be returned, that is, when the function's return value was 3. When was not a point of uvuv_list, end() of uvuv_list will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2951bc0d2d4705be6d570bccd60f9ab0"></a><!-- doxytag: member="MGFSurface::isect_startPt" ref="a2951bc0d2d4705be6d570bccd60f9ab0" args="(const MGPosition &amp;uvuv_startIn, MGPosition_list &amp;uvuv_list, const MGFSurface &amp;sf2, double acuRatio, MGBPointSeq &amp;point, MGPosition_list::iterator &amp;uvuv_id, int &amp;m1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::isect_startPt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGPosition_list::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_startPt compute an array of parameter value pairs of this surf and sf2 for one intersection line of the two surfaces, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2) and direction(stan). </p>
<p>isect_startPt is a dedicated function for isect_start. isect_startPt halts the computation when intersection reached to a boundary of this or sf2, or reached to one of the points in uvuv_list. The function's return value is: =0: Intersection was not obtained. !=0: Intersection was obtained as follows: =1: End point is a point on a perimeter of one of the surfaces. =3: End point is one of boundary points in uvuv_list. =4: End point is the starting point. =7: isect_start halted the computation since intersection was lost during the computation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_startIn</em>&nbsp;</td><td>Starting point of the intersection line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>isect_startPt will halt when ip reached one of the point in uvuv_list. isect_startPt does not change uvuv_list(actually uvuv_list is const.) uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>2nd surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>Accurate ratio, should be decreased by multiplyng .2 (or a number less than 1.). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>Surface-surface intersection parameter values will be returned as:point(.,0) and point(.,1) for(u,v) of this surface point(.,2) and point(.,3) for(u,v) of this surface. point has the dimension of(.,7). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_id</em>&nbsp;</td><td>When the end point of ip was one of the points of uvuv_list, uvuv_list's iterator of the point will be returned, that is, when the function's return value was 3 or 5, When was not a point of uvuv_list, end() of uvuv_list will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m1</em>&nbsp;</td><td>id that indicates which surface was used as the main surface, m1=0: this surface, m1=2: sf2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeac7b016c41ad5ea8bf7f6e71e01b698"></a><!-- doxytag: member="MGFSurface::isect_with_plane" ref="aeac7b016c41ad5ea8bf7f6e71e01b698" args="(MGPosition_list &amp;uvuv_list, const MGPlane &amp;pl, const MGFSurface &amp;fsrf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGFSurface::isect_with_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fsrf2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersection lines of this(is not a plane) surface and a plane pl. </p>
<p>sd1D that is converted to surf1D() about pl is necessary to input. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>Let a member of uvuv_list be uvuv. Then, uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of pl. When uvuv's space dimension is more than 4, it indicates that the uvuv is used to input approximate tangent of the intersection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pl</em>&nbsp;</td><td>Plane expression(2nd surface for the intersection). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fsrf2</em>&nbsp;</td><td>Original FSurface before casting to plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a059f5b908d6aeee4a99b172b3f9fa9"></a><!-- doxytag: member="MGFSurface::isect_with_surf" ref="a5a059f5b908d6aeee4a99b172b3f9fa9" args="(MGPosition_list &amp;uvuv_list, const MGFSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGFSurface::isect_with_surf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersection lines of this surface and srf2(both are not planes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>Let a member of uvuv_list be uvuv. Then, uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of srf2. When uvuv's space dimension is more than 4, it indicates that the uvuv is used to input approximate tangent of the intersection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srf2</em>&nbsp;</td><td>2nd surface for the intersection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a642b08244ba552668c1b8758b17abb4a"></a><!-- doxytag: member="MGFSurface::make_display_list_to_hilightFS" ref="a642b08244ba552668c1b8758b17abb4a" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGFSurface::make_display_list_to_hilightFS </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a display list without color of this gel. </p>
<p>Return is the display list name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>span length to approximate by polyline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a521de8eaa8905bf5e14c6af77af56d0a"></a><!-- doxytag: member="MGFSurface::make_face" ref="a521de8eaa8905bf5e14c6af77af56d0a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_face.html">MGFace</a>* MGFSurface::make_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> or <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> object. </p>
<p>If this is a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, returns this pointer. If this is a <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, construct a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> using this newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, and returns the MGFace*. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a5c88f614bd2981dd988ba77a06005244">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a02490326533d8115499bbd9d90dc8fa3">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a18926f742ba0ae8b3a41a263d8897628"></a><!-- doxytag: member="MGFSurface::offset_fs" ref="a18926f742ba0ae8b3a41a263d8897628" args="(double distance, MGPvector&lt; MGFSurface &gt; &amp;vecOfsFSurface) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::offset_fs </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vecOfsFSurface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset. </p>
<p>distance is plus value if the direction is toward normal vector of the FSurface. Minus if against the normal vector. エラーコード 0:成功 -1:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a12a83c8c316f114b5eac5bb9fdac12bf">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a089a79463cfee5437116befa4617805d">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="afb6217a5d69beda117240ae8867ecea8"></a><!-- doxytag: member="MGFSurface::on" ref="afb6217a5d69beda117240ae8867ecea8" args="(const MGPosition &amp;P, MGPosition &amp;uv) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGFSurface::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a point P is on the FSurface. </p>
<p>Returned is true if the point P is on the FSurface. false(0) if P was not on the FSurface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the FSurface is returrned, Even if P is not on the FSurface, nearest point parameter value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#a3b9680f36113090ae96029b2714f1bec">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a5e57c1ce7722e2d66cfe07bfae5fe662">MGPlane</a>, <a class="el" href="class_m_g_sphere.html#a90a678f3eab870fd5d9ce67da2ce48d7">MGSphere</a>, <a class="el" href="class_m_g_surface.html#a409507f5dcc86cab92e3448529a94196">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a1c9f497b50bf50385981168ed7dbfa47">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a73978585a34a380507af9e44113a2287"></a><!-- doxytag: member="MGFSurface::on_a_perimeter" ref="a73978585a34a380507af9e44113a2287" args="(double &amp;u, double &amp;v, size_t &amp;perim_num) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGFSurface::on_a_perimeter </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is parameter value on a perimeter of the base surface. </p>
<p>If u or v is on a perimeter, they will be updated to the perimeter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returns true, the perimete number is output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#a04414ee9c8cf9e6d48952922c0fae42f">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a626af4d4de5e4c8fca9d020c48458e6d">MGPlane</a>, <a class="el" href="class_m_g_surface.html#a6f773b2759f1b0c66b20ed8888aae990">MGSurface</a>, and <a class="el" href="class_m_g_face.html#acd0750672d25306e9ab936ff6695b6c6">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a8fc539b6e3ce0d7328aedd7c42c201ee"></a><!-- doxytag: member="MGFSurface::outer_boundary" ref="a8fc539b6e3ce0d7328aedd7c42c201ee" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFSurface::outer_boundary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain outer_boundary curves(world coordinates representation) of the FSurface. </p>
<p>Let the output of <a class="el" href="class_m_g_f_surface.html#a8fc539b6e3ce0d7328aedd7c42c201ee" title="Obtain outer_boundary curves(world coordinates representation) of the FSurface.">outer_boundary()</a> be wcurves and of <a class="el" href="class_m_g_f_surface.html#a424bdd8b98a5c4eec9239da4dc689004" title="Obtain boundary curves(parameter space representation) of the FSurface.">outer_boundary_param()</a> be pcurves, then wcurves[i] corresponds to pcurves[i] one to one. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#af348d7e9562dce2b9d435e4960ff1ac5">MGSurface</a>, and <a class="el" href="class_m_g_face.html#ad058ef7eac06bfb0a208333a23deab53">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a424bdd8b98a5c4eec9239da4dc689004"></a><!-- doxytag: member="MGFSurface::outer_boundary_param" ref="a424bdd8b98a5c4eec9239da4dc689004" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFSurface::outer_boundary_param </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain boundary curves(parameter space representation) of the FSurface. </p>
<p>Let the output of boundary() be wcurves and of boundary_parameter() be pcurves, then wcurves[i] corresponds to pcurves[i] one to one. </p>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a58d900e6d0b1f91aa0e9ce7857bd07b8">MGSurface</a>, and <a class="el" href="class_m_g_face.html#ad838db2cb35beb4d2abbec5a68f17682">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a97b26afbbe3a66b95e3c7ef85e0af8b2"></a><!-- doxytag: member="MGFSurface::param_range" ref="a97b26afbbe3a66b95e3c7ef85e0af8b2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_box.html">MGBox</a> MGFSurface::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a59e3f02d6c5da744e739180674befdf3">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a94e4819a42abd37f1caa2fd0962476df">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#ad01034704a0cdb64e7bb3e1530389b33">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a16e184aac814e3be6f0c2b08d53d3e3d">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a6ab8517d3fb63eddcc8b1a8bb1545174">MGSBRep</a>, <a class="el" href="class_m_g_sphere.html#aff650f278660186bc2ba84bc9c1fd845">MGSphere</a>, <a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a638df4048d455eb7f7fbb4b597d4a6b0">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a250b40652b5c0400bd5d5f4f350b85a0"></a><!-- doxytag: member="MGFSurface::parameter_curves" ref="a250b40652b5c0400bd5d5f4f350b85a0" args="(int is_u, double x) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFSurface::parameter_curves </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter curves. </p>
<p>In the case of <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, parameter curve is only one. However, in the case of <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, number of parameter curves are more than one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>True(!=0) if x is u-value.(i.e. obtain u=const line) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>parameter value. u or v-value accordint to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a47ed9e72cb270f3edfe14d28df1a8e28">MGSurface</a>, and <a class="el" href="class_m_g_face.html#abf1b5eff232aae520497d5c87b486707">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a388cb2b317aff6476993f3a19d6601c1"></a><!-- doxytag: member="MGFSurface::perp_guess" ref="a388cb2b317aff6476993f3a19d6601c1" args="(const MGPosition &amp;P, const MGPosition &amp;uvguess, MGPosition &amp;uv) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGFSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the foot of the perpendicular straight line from P. </p>
<p>Computation is done from the guess parameter value. Function's return value is whether point is obtained(true) or not(false). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of the shell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a20678e5bff86bc76a04add72aa002eac">MGSurface</a>, and <a class="el" href="class_m_g_face.html#aae09aeef4e29317364bcad7e90063bf3">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a8d747b59a0f1209147a7e3f5e1ffbdad"></a><!-- doxytag: member="MGFSurface::perp_guess" ref="a8d747b59a0f1209147a7e3f5e1ffbdad" args="(const MGCurve &amp;curve, const MGPosition &amp;uvguess, double tguess, MGPosition &amp;uv, double &amp;t) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGFSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perpendicular points of a curve and the FSurface, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>Guess parameter value of the FSurface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tguess</em>&nbsp;</td><td>Guess parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>perpendicular point's parameter values of the shell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_surface.html#a824d86bf1baa1ed5ee16cdf839c04f71">MGSurface</a>, and <a class="el" href="class_m_g_face.html#aa27d36bec2da95cc046cbccdc095921c">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="aff035ddc5ce758d5839d652054a1f627"></a><!-- doxytag: member="MGFSurface::perp_one" ref="aff035ddc5ce758d5839d652054a1f627" args="(const MGPosition &amp;P, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::perp_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定点から最も近い、垂線の足とパラメータ値を返す。 Return the foot of the perpendicular straight line from p that is nearest to point P. </p>
<p>Function's return value is whether point is obtained(&gt;0) or not(0) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>指定点(point) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the FSurface will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a487baf864df83faad23c2326b591a1ed"></a><!-- doxytag: member="MGFSurface::perp_point" ref="a487baf864df83faad23c2326b591a1ed" args="(const MGPosition &amp;p, MGPosition &amp;uv, const MGPosition *uvguess=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td>
          <td class="paramname"> <em>uvguess</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定点から最も近い、垂線の足とパラメータ値を返す。 Return the foot of the perpendicular straight line from p that is nearest to point p. </p>
<p>Function's return value is whether point is obtained(1) or not(0) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>指定点(point) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surFSurface will be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of surFSurface </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#af2afc495f138ff58e03088e847236d5f">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a14e8bdacc9586ab1981f1d0ca1abb632">MGPlane</a>, <a class="el" href="class_m_g_sphere.html#ae27787efac00f3e2b7d3de1ceaa55f63">MGSphere</a>, <a class="el" href="class_m_g_surface.html#ac94884f1674a06f476c417511a93eb2a">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a5349eea0914e4a56cb431574ae50bcb6">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a82802a49466e8a9a60c15d20103490bb"></a><!-- doxytag: member="MGFSurface::perps" ref="a82802a49466e8a9a60c15d20103490bb" args="(const MGPosition &amp;P) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGFSurface::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perpendicular points on the FSurface from a point P((x,y,z)). </p>
<p><a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> uv in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> is: uv(0): u parameter, and uv(1): v parameter of the FSurface. Generally number of uv are more than one. </p>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#a38776f8959055ad54283c6be587bc1e5">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a12dddf55a74e756d3d0de147e930e694">MGPlane</a>, <a class="el" href="class_m_g_sphere.html#a67aec64f8ad44dc182da791208bd7534">MGSphere</a>, <a class="el" href="class_m_g_surface.html#aed36001c59550de9c2054564844c638f">MGSurface</a>, and <a class="el" href="class_m_g_face.html#aefc5b3715a2b98236ac8b3af59019c53">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="ae69e0eb803f2f7c70c75ef7ea0fdf2e5"></a><!-- doxytag: member="MGFSurface::project" ref="ae69e0eb803f2f7c70c75ef7ea0fdf2e5" args="(const MGCurve &amp;crv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める。引数vecが与えられないとき、面直投影する。 投影曲線は3次元曲線としてvec_crvに格納される。 uv曲線のトレランスはline_zero()を使用している。 戻り値： 投影曲線の数: 投影曲線が求まった 0: 投影曲線が求まらなかった -1: 内部処理エラー -2: 収束処理エラー（収束しなかった） Obtain the projected curve of a curve onto the FSurface. </p>
<p>The direction of the projection is along the vector vec if the vec is not NULL, and normal to the FSurface if the vec is NULL. Output of 'project' is general world coordinate curves('vec_crv') </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>given curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv</em>&nbsp;</td><td>Projected curve(world coordinate(x,y,z) representation) will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>if vec = NULL then calculate perpendicular project. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a830ba3065209fb0a1c281162b07fe9bd">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="affc560a90dfcc2d65c31737d8c82abfc"></a><!-- doxytag: member="MGFSurface::project" ref="affc560a90dfcc2d65c31737d8c82abfc" args="(const MGCurve &amp;crv, MGPvector&lt; MGCurve &gt; &amp;vec_crv_uv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGFSurface::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv_uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める。引数vecが与えられないとき、面直投影する。 投影曲線は面上のパラメータ曲線と3次元曲線としてそれぞれ順番に、vec_crv_uv, vec_crvに格納される。 uv曲線のトレランスはrc_zero()を、3次元曲線はline_zero()をそれぞれ使用している。 戻り値： 投影曲線の数: 投影曲線が求まった 0: 投影曲線が求まらなかった -1: 内部処理エラー -2: 収束処理エラー（収束しなかった） Obtain the projected curve of a curve onto the FSurface. </p>
<p>The direction of the projection is along the vector vec if the vec is not NULL, and normal to the FSurface if the vec is NULL. Output of 'project' is two kind of curves: one is general world coordinate curves('vec_crv'), and the other is (u,v) curves of the parameter space of the FSurface(vec_crv_uv). vec_crv_uv.size() is equal to vec_crv.size(). Let the size be n, then (vec_crv_uv[i], vec_crv[i]) is one pair for 0&lt;=i&lt;n. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>given curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv_uv</em>&nbsp;</td><td>Projected curve(surface parameter (u,v) representation) will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv</em>&nbsp;</td><td>Projected curve(world coordinate(x,y,z) representation) will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>projection vector, if vec = NULL then calculate perpendicular project. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a9e03edbc435b5770d8314fb06d51b3a7">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="ac07962f4b9f60859fe657b6e0b7e2712"></a><!-- doxytag: member="MGFSurface::project_normal" ref="ac07962f4b9f60859fe657b6e0b7e2712" args="(const MGPosition &amp;pos, const MGPosition &amp;uv_guess, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGFSurface::project_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>面直に投影した点を返却する 戻り値は、交点または面直点が求まったときは1、求まらなかったときは0を返却する </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv_guess</em>&nbsp;</td><td>推量パラメータ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13fb86a7db29413a40795bdb2522bb38"></a><!-- doxytag: member="MGFSurface::range" ref="a13fb86a7db29413a40795bdb2522bb38" args="(const MGPosition &amp;uv) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGFSurface::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Round the input parameter (u,v) of the FSurface to the nearest point of the FSurface parameter range. </p>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#a2e0654da4bfe2b9d45ae86c1c4a8a842">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#aefe8f7187ede379cb7528bef93a111a0">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a545928d1e952ea264a6ef83f9a43359e">MGRSBRep</a>, <a class="el" href="class_m_g_sphere.html#ac531ee66ce206379acf8754492413d66">MGSphere</a>, <a class="el" href="class_m_g_surface.html#a8966c7e15642175de66afee13234dfc5">MGSurface</a>, and <a class="el" href="class_m_g_face.html#acf4a1206a6fbf1ce9fc50ecf1fac45aa">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="a24ce3062df19bd896a864d54826a2ab2"></a><!-- doxytag: member="MGFSurface::skeleton" ref="a24ce3062df19bd896a864d54826a2ab2" args="(int density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGFSurface::skeleton </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>density</em> = <code>1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain boundary and main parameter lines of the FSurface. </p>
<p>skeleton includes boundary() and inner parameter lines. density indicates how many inner parameter lines are necessary for both u and v directions. </p>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a98581c81192065133fa2c26253c152ce">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a7566ec759dec2037106a0a0b53a0a922"></a><!-- doxytag: member="MGFSurface::split" ref="a7566ec759dec2037106a0a0b53a0a922" args="(double param, bool is_u, MGPvector&lt; MGFSurface &gt; &amp;surfaces) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGFSurface::split </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>surfaces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>split this fsurface at the parameter param. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of this fsurface. if is_u is true, param is u-value, else v-value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>indicates if param is u or v of the surface parameter (u,v). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>surfaces</em>&nbsp;</td><td>splitted surfaces will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_plane.html#a10de314e84981bdcc18a049b917e9d73">MGPlane</a>, <a class="el" href="class_m_g_surface.html#aa42207d63b66cb594cf5329597657eec">MGSurface</a>, and <a class="el" href="class_m_g_face.html#a99e3712ae4c1f583f5128403d0a06bf5">MGFace</a>.</p>

</div>
</div>
<a class="anchor" id="af917a8cfb6e8448fd307b1916ac56798"></a><!-- doxytag: member="MGFSurface::trim" ref="af917a8cfb6e8448fd307b1916ac56798" args="(const std::vector&lt; const MGCurve * &gt; &amp;trimmers, const MGVector &amp;dir, const MGPosition &amp;uv, MGPvector&lt; MGFace &gt; &amp;faces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGFSurface::trim </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>trimmers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_face.html">MGFace</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>faces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim this fsurface with trimmers. </p>
<p>trimmers are 3D curves and will be projected onto this surface tword the direction dir. If dir is null vector, surface normal prjection will be performed. Trimming is so performed that the smallest region enclosed by trimmers that includes the surface point uv will be removed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>trimmers</em>&nbsp;</td><td>Trimmer curves </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>trimmers projection direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>surface parameter (u,v) that indicates the region to remove, The smallest region that inclued uv will be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>faces</em>&nbsp;</td><td>Result trimmed face(s) will be appended, If no trimming was performed, no faces will be appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>FSurface.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:21 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

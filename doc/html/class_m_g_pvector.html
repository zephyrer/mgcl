<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGPvector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGPvector&lt; T &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGPvector" -->
<p>Defines Vector of newed object pointers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Pvector.h&gt;</code></p>

<p><a href="class_m_g_pvector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias.  <a href="#ab73bee7f10fc4c26ce5f5f337c0ef96e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cc9d34c89bda6dce2378b4e1526968d"></a><!-- doxytag: member="MGPvector::const_iterator" ref="a6cc9d34c89bda6dce2378b4e1526968d" args="" -->
typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9edf14080417109e2a75c1d60c999f01"></a><!-- doxytag: member="MGPvector::reverse_iterator" ref="a9edf14080417109e2a75c1d60c999f01" args="" -->
typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69088a34b077250bd3bf62e069f8bd7f"></a><!-- doxytag: member="MGPvector::const_reverse_iterator" ref="a69088a34b077250bd3bf62e069f8bd7f" args="" -->
typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22edb94724db7fa171011b38de11ee69"></a><!-- doxytag: member="MGPvector::reference" ref="a22edb94724db7fa171011b38de11ee69" args="" -->
typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb9a9d134f2a4053b3b4663f3b9026ee"></a><!-- doxytag: member="MGPvector::const_reference" ref="adb9a9d134f2a4053b3b4663f3b9026ee" args="" -->
typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f68f21ceb64f2fb31a84500d7f8400a"></a><!-- doxytag: member="MGPvector::size_type" ref="a0f68f21ceb64f2fb31a84500d7f8400a" args="" -->
typedef std::vector&lt; T * &gt;<br class="typebreak"/>
::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4a29509c748ea959a63e5ff8e807f2"></a><!-- doxytag: member="MGPvector::MGPvector" ref="a6c4a29509c748ea959a63e5ff8e807f2" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a6c4a29509c748ea959a63e5ff8e807f2">MGPvector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">void constructor <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ac15e778e7d61f52ed1f66c9569418cb8">MGPvector</a> (size_type len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default constructor Create a vector whose size is n.  <a href="#ac15e778e7d61f52ed1f66c9569418cb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84c85214ebafac45311833d681c00b2f"></a><!-- doxytag: member="MGPvector::MGPvector" ref="a84c85214ebafac45311833d681c00b2f" args="(T *ptr)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a84c85214ebafac45311833d681c00b2f">MGPvector</a> (T *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct <a class="el" href="class_m_g_pvector.html" title="Defines Vector of newed object pointers.">MGPvector</a> of length 1 that contains ptr. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a1415a8fc948177b741158b6d32ce87e0">MGPvector</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor The argument rhs will be cleared, since the ownership of all data of rhs should be transfered to this object.  <a href="#a1415a8fc948177b741158b6d32ce87e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad185dcfe76008fc0ece6e110f3a44011"></a><!-- doxytag: member="MGPvector::MGPvector" ref="ad185dcfe76008fc0ece6e110f3a44011" args="(const std::vector&lt; const T * &gt; &amp;rhs)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ad185dcfe76008fc0ece6e110f3a44011">MGPvector</a> (const std::vector&lt; const T * &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion constructor. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab53a6b3a2655d6c8da3231ead6e027de"></a><!-- doxytag: member="MGPvector::MGPvector" ref="ab53a6b3a2655d6c8da3231ead6e027de" args="(InputIter first, InputIter last)" -->
template&lt;class InputIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ab53a6b3a2655d6c8da3231ead6e027de">MGPvector</a> (InputIter first, InputIter last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a vector with given range [first, last). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_a_s_e.html#ga1f729fa4ba42a5aba0a84a21e6e9e784">‾MGPvector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the object and delete all pointers that this object holds.  <a href="group___b_a_s_e.html#ga1f729fa4ba42a5aba0a84a21e6e9e784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a1b36d3f2e6b11316a2a8055f4074b6b0">operator[]</a> (size_type pos) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subscript access.  <a href="#a1b36d3f2e6b11316a2a8055f4074b6b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a3f4e10def992b686efda0fe373efbded">operator[]</a> (size_type pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_a_s_e.html#gacadaa28472269be2c31ea44b9ee92139">operator=</a> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assignment operator The argument rhs will be empty after assignment, and transfer the ownership of all pointers to this object.  <a href="group___b_a_s_e.html#gacadaa28472269be2c31ea44b9ee92139"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a437c2bccf91ea6a300764e2f9c518c45">assign</a> (InputIter first, InputIter last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment that takes a range.  <a href="#a437c2bccf91ea6a300764e2f9c518c45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b9ade146e8856a3f7e85d280ba6c76"></a><!-- doxytag: member="MGPvector::assign" ref="a16b9ade146e8856a3f7e85d280ba6c76" args="(size_type pos, T *ptr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>assign</b> (size_type pos, T *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7a41afdbd4ff5516af229ea4e34614f"></a><!-- doxytag: member="MGPvector::at" ref="ad7a41afdbd4ff5516af229ea4e34614f" args="(size_type n) const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ad7a41afdbd4ff5516af229ea4e34614f">at</a> (size_type n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalent to call vector::at(n). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a158149495fb220c7c5dd5de085bf285b"></a><!-- doxytag: member="MGPvector::at" ref="a158149495fb220c7c5dd5de085bf285b" args="(size_type n)" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#aee6cc38453e166876a6fa71673a3bbb8">back</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the reference to the last element in the sequence.  <a href="#aee6cc38453e166876a6fa71673a3bbb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1c43d7bfef64f7f9a919b5db4116bf6"></a><!-- doxytag: member="MGPvector::back" ref="af1c43d7bfef64f7f9a919b5db4116bf6" args="()" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>back</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a8a0f1cf3436bda636fb5b734796b2d"></a><!-- doxytag: member="MGPvector::begin" ref="a3a8a0f1cf3436bda636fb5b734796b2d" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a3a8a0f1cf3436bda636fb5b734796b2d">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const_iterator that points to the first element in the sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121b95eb3b6439681b9a94e89beb3c83"></a><!-- doxytag: member="MGPvector::begin" ref="a121b95eb3b6439681b9a94e89beb3c83" args="()" -->
<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a121b95eb3b6439681b9a94e89beb3c83">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator that points to the first element in the sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8bc0424aa4ada44ca6dec26095be1b4"></a><!-- doxytag: member="MGPvector::capacity" ref="ab8bc0424aa4ada44ca6dec26095be1b4" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ab8bc0424aa4ada44ca6dec26095be1b4">capacity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equivalent to call vector::capacity(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d9c398d3af439e75fdf297cbfcf8b65"></a><!-- doxytag: member="MGPvector::clear" ref="a3d9c398d3af439e75fdf297cbfcf8b65" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a3d9c398d3af439e75fdf297cbfcf8b65">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clear Sequence, that is, erase all the elements in the sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a16fe246183dc5c0e9464c30e844a7af2">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true (1) if there are no items in the vector, false(0) otherwise.  <a href="#a16fe246183dc5c0e9464c30e844a7af2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf1f18f8b1ff7fe2c5e69ea71321f0fc"></a><!-- doxytag: member="MGPvector::end" ref="adf1f18f8b1ff7fe2c5e69ea71321f0fc" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#adf1f18f8b1ff7fe2c5e69ea71321f0fc">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const_iterator that points one past the last element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35832ac9b4c39be31c627a3db3e56c70"></a><!-- doxytag: member="MGPvector::end" ref="a35832ac9b4c39be31c627a3db3e56c70" args="()" -->
<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a35832ac9b4c39be31c627a3db3e56c70">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator that points one past the last element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75b8bb1a938ea1ec93d02f40d2edfa39"></a><!-- doxytag: member="MGPvector::erase" ref="a75b8bb1a938ea1ec93d02f40d2edfa39" args="(iterator x)" -->
<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a75b8bb1a938ea1ec93d02f40d2edfa39">erase</a> (<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">erase the element at x. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad97409e004ee35295089b8d94ff91ff5"></a><!-- doxytag: member="MGPvector::erase" ref="ad97409e004ee35295089b8d94ff91ff5" args="(size_type i)" -->
<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ad97409e004ee35295089b8d94ff91ff5">erase</a> (size_type i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">erase i-th element x. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6d04edc369888aec9153b44850598e"></a><!-- doxytag: member="MGPvector::erase" ref="a4d6d04edc369888aec9153b44850598e" args="(iterator first, iterator last)" -->
<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a4d6d04edc369888aec9153b44850598e">erase</a> (<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> first, <a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">erase sequence [first, last). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a0c22929cb67c349f2a137dc81012e1d3">front</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the reference to first element in the vector.  <a href="#a0c22929cb67c349f2a137dc81012e1d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecd4571f11af685b1dccdcf8d727ffce"></a><!-- doxytag: member="MGPvector::front" ref="aecd4571f11af685b1dccdcf8d727ffce" args="()" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>front</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab688ce8ee9c76fc09cc6612d06714b3a"></a><!-- doxytag: member="MGPvector::get" ref="ab688ce8ee9c76fc09cc6612d06714b3a" args="(size_type i) const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ab688ce8ee9c76fc09cc6612d06714b3a">get</a> (size_type i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ただのポインタを返す。所有権は放棄しないので このポインタを解放してはならない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a469eed15bfd832a2a2d5902795fe02"></a><!-- doxytag: member="MGPvector::get" ref="a4a469eed15bfd832a2a2d5902795fe02" args="(size_type i)" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><b>get</b> (size_type i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0fca6f734b403cef9e6e8e4fae0fb76"></a><!-- doxytag: member="MGPvector::insert" ref="ae0fca6f734b403cef9e6e8e4fae0fb76" args="(iterator pos, T *ptr)" -->
<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#ae0fca6f734b403cef9e6e8e4fae0fb76">insert</a> (<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> pos, T *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert ptr into vector at pos. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a43cafd99bc4d152084475087b034b15f"></a><!-- doxytag: member="MGPvector::insert" ref="a43cafd99bc4d152084475087b034b15f" args="(iterator pos, InputIter first, InputIter last)" -->
template&lt;class InputIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a43cafd99bc4d152084475087b034b15f">insert</a> (<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> pos, InputIter first, InputIter last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert the range [first, last) into the vector at pos. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d937f0f1c58bc7ce1f061b6be7744e"></a><!-- doxytag: member="MGPvector::is_null" ref="a00d937f0f1c58bc7ce1f061b6be7744e" args="(size_type i) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a00d937f0f1c58bc7ce1f061b6be7744e">is_null</a> (size_type i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if i-th element is null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39528fbeb5c3d18cda5cc8df9da4c26a"></a><!-- doxytag: member="MGPvector::max_size" ref="a39528fbeb5c3d18cda5cc8df9da4c26a" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a39528fbeb5c3d18cda5cc8df9da4c26a">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of maximum size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6ebc5020db25c96ad3554f3e9d7df2"></a><!-- doxytag: member="MGPvector::pop_back" ref="a3f6ebc5020db25c96ad3554f3e9d7df2" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a3f6ebc5020db25c96ad3554f3e9d7df2">pop_back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pop last element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d900202d7b29966ae1a194fd3d63ae2"></a><!-- doxytag: member="MGPvector::push_back" ref="a2d900202d7b29966ae1a194fd3d63ae2" args="(T *x)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a2d900202d7b29966ae1a194fd3d63ae2">push_back</a> (T *x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">push element x at the end. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a783444d3fdf4bbfaf47d72fee792cbea">push_back</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;dst)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">push element x at the end.  <a href="#a783444d3fdf4bbfaf47d72fee792cbea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a108f7a37eccb2e25536a9e011d26fa1f"></a><!-- doxytag: member="MGPvector::rbegin" ref="a108f7a37eccb2e25536a9e011d26fa1f" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a108f7a37eccb2e25536a9e011d26fa1f">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const_reverse_iterator that points the end of the sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d61deb6d110384890888b31c99c8f54"></a><!-- doxytag: member="MGPvector::rbegin" ref="a5d61deb6d110384890888b31c99c8f54" args="()" -->
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a5d61deb6d110384890888b31c99c8f54">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reverse_iterator that points the end of the sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a27b379a643012e32e96fed8c57c71c6d">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const_reverse_iterator that points to one before the first element in the vector.  <a href="#a27b379a643012e32e96fed8c57c71c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a0595e2d0306cbd8dde8091ee4c721934">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reverse_iterator that points to one before the first element in the vector.  <a href="#a0595e2d0306cbd8dde8091ee4c721934"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26933aa3b1e17af71bf9973ba193c561"></a><!-- doxytag: member="MGPvector::release" ref="a26933aa3b1e17af71bf9973ba193c561" args="(size_type i)" -->
T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a26933aa3b1e17af71bf9973ba193c561">release</a> (size_type i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">現在の所有権を放棄し、ただのポインタを返す。 この処理の後はget(i)==nullとなる。 ベクトルの要素自体は削除されません。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d27aee7b3597ee6d82a003476e83645"></a><!-- doxytag: member="MGPvector::release_all" ref="a6d27aee7b3597ee6d82a003476e83645" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a6d27aee7b3597ee6d82a003476e83645">release_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">現在の所有権をすべて放棄する。 この処理の後はget(i)==nullとなる。 ベクトルの要素自体は削除されない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a37c61e39818ee2511785a6b6ad2f21a6">removeAt</a> (<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the T* and return the T*.  <a href="#a37c61e39818ee2511785a6b6ad2f21a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#aaff6151b784ed9722a48d16c043619f3">removeAt</a> (size_type i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the i-th T* in the vector and return the T*.  <a href="#aaff6151b784ed9722a48d16c043619f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b75674f366cad7e8b1d61bfc4ce016"></a><!-- doxytag: member="MGPvector::reverse_sequence" ref="a05b75674f366cad7e8b1d61bfc4ce016" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a05b75674f366cad7e8b1d61bfc4ce016">reverse_sequence</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse the sequence of the elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a7743d1d9366eeaf7e1120291f7ef3cb6">reserve</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preallocate memory for specified number of elements if necessary.  <a href="#a7743d1d9366eeaf7e1120291f7ef3cb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a688eadd7c6c954697135154cdf725063"></a><!-- doxytag: member="MGPvector::reset" ref="a688eadd7c6c954697135154cdf725063" args="(size_type i, T *ptr=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a688eadd7c6c954697135154cdf725063">reset</a> (size_type i, T *ptr=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete the i-th element and replace it with ptr. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_a_s_e.html#ga9a5e9d176f8f440272e6367bafcc1346">resize</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the vector.  <a href="group___b_a_s_e.html#ga9a5e9d176f8f440272e6367bafcc1346"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa325aa9d05a5d991a8a456aa8d575f86"></a><!-- doxytag: member="MGPvector::size" ref="aa325aa9d05a5d991a8a456aa8d575f86" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#aa325aa9d05a5d991a8a456aa8d575f86">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of items that are in the sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3e84308bf0fae41625a1bc8931f403a"></a><!-- doxytag: member="MGPvector::swap" ref="ac3e84308bf0fae41625a1bc8931f403a" args="(MGPvector&lt; T &gt; &amp;x)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;x)</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47b2e67bc65da5014ce518d9fa0857b1"></a><!-- doxytag: member="MGPvector::m_vector" ref="a47b2e67bc65da5014ce518d9fa0857b1" args="" -->
std::vector&lt; T * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a47b2e67bc65da5014ce518d9fa0857b1">m_vector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Member data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a71eeb35d848a5bd54739a812bf4de71a"></a><!-- doxytag: member="MGPvector::operator&lt;&lt;" ref="a71eeb35d848a5bd54739a812bf4de71a" args="(std::ostream &amp;out, const MGPvector&lt; T &gt; &amp;vector)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">MGDECL friend std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_g_pvector.html#a71eeb35d848a5bd54739a812bf4de71a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug out. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class MGPvector&lt; T &gt;</h3>

<p>Defines Vector of newed object pointers. </p>
<p><a class="el" href="class_m_g_pvector.html" title="Defines Vector of newed object pointers.">MGPvector</a> is a list of std::auto_ptr&lt;class T&gt;. The member pointers of newed objects will be destructed when MGPList object is destructed. That is, the ownerships of the members all of the ownerships will be transfered to the copied or assigned new <a class="el" href="class_m_g_pvector.html" title="Defines Vector of newed object pointers.">MGPvector</a>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ab73bee7f10fc4c26ce5f5f337c0ef96e"></a><!-- doxytag: member="MGPvector::iterator" ref="ab73bee7f10fc4c26ce5f5f337c0ef96e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;T*&gt;::<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a> <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::<a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alias. </p>
<p>別名定義 </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac15e778e7d61f52ed1f66c9569418cb8"></a><!-- doxytag: member="MGPvector::MGPvector" ref="ac15e778e7d61f52ed1f66c9569418cb8" args="(size_type len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::<a class="el" href="class_m_g_pvector.html">MGPvector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>len</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default constructor Create a vector whose size is n. </p>
<p>長さlenのベクトルを作成します。 すべての要素はNULLで初期化されます。 </p>

</div>
</div>
<a class="anchor" id="a1415a8fc948177b741158b6d32ce87e0"></a><!-- doxytag: member="MGPvector::MGPvector" ref="a1415a8fc948177b741158b6d32ce87e0" args="(const MGPvector&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::<a class="el" href="class_m_g_pvector.html">MGPvector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy constructor The argument rhs will be cleared, since the ownership of all data of rhs should be transfered to this object. </p>
<p>所有権はすべて、新しいオブジェクトに移るので rhsのすべての要素はNULLになります。(sizeは変わりません) </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a437c2bccf91ea6a300764e2f9c518c45"></a><!-- doxytag: member="MGPvector::assign" ref="a437c2bccf91ea6a300764e2f9c518c45" args="(InputIter first, InputIter last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment that takes a range. </p>
<p>The intersection of this object and [first, last) must be empty. </p>

</div>
</div>
<a class="anchor" id="aee6cc38453e166876a6fa71673a3bbb8"></a><!-- doxytag: member="MGPvector::back" ref="aee6cc38453e166876a6fa71673a3bbb8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the reference to the last element in the sequence. </p>
<p>If the vector is empty, behavior is undefined. </p>

</div>
</div>
<a class="anchor" id="a16fe246183dc5c0e9464c30e844a7af2"></a><!-- doxytag: member="MGPvector::empty" ref="a16fe246183dc5c0e9464c30e844a7af2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true (1) if there are no items in the vector, false(0) otherwise. </p>

</div>
</div>
<a class="anchor" id="a0c22929cb67c349f2a137dc81012e1d3"></a><!-- doxytag: member="MGPvector::front" ref="a0c22929cb67c349f2a137dc81012e1d3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the reference to first element in the vector. </p>
<p>If the vector is empty, behavior is undefined. </p>

</div>
</div>
<a class="anchor" id="a1b36d3f2e6b11316a2a8055f4074b6b0"></a><!-- doxytag: member="MGPvector::operator[]" ref="a1b36d3f2e6b11316a2a8055f4074b6b0" args="(size_type pos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscript access. </p>

<p><p>if(pos&gt;=size()) return 0; </p>
</p>

</div>
</div>
<a class="anchor" id="a3f4e10def992b686efda0fe373efbded"></a><!-- doxytag: member="MGPvector::operator[]" ref="a3f4e10def992b686efda0fe373efbded" args="(size_type pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>if(pos&gt;=size()) return 0; </p>
</p>

</div>
</div>
<a class="anchor" id="a783444d3fdf4bbfaf47d72fee792cbea"></a><!-- doxytag: member="MGPvector::push_back" ref="a783444d3fdf4bbfaf47d72fee792cbea" args="(MGPvector&lt; T &gt; &amp;dst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>push element x at the end. </p>
<p>All the ownership of the elements in dst are transfered to this Pvector. </p>

</div>
</div>
<a class="anchor" id="a37c61e39818ee2511785a6b6ad2f21a6"></a><!-- doxytag: member="MGPvector::removeAt" ref="a37c61e39818ee2511785a6b6ad2f21a6" args="(iterator i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::removeAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html#ab73bee7f10fc4c26ce5f5f337c0ef96e">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the T* and return the T*. </p>
<p>If i is no valid, behavior is undefined. </p>

</div>
</div>
<a class="anchor" id="aaff6151b784ed9722a48d16c043619f3"></a><!-- doxytag: member="MGPvector::removeAt" ref="aaff6151b784ed9722a48d16c043619f3" args="(size_type i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::removeAt </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the i-th T* in the vector and return the T*. </p>
<p>If i is not valid, the behavior is undefined. </p>

</div>
</div>
<a class="anchor" id="a27b379a643012e32e96fed8c57c71c6d"></a><!-- doxytag: member="MGPvector::rend" ref="a27b379a643012e32e96fed8c57c71c6d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return const_reverse_iterator that points to one before the first element in the vector. </p>

</div>
</div>
<a class="anchor" id="a0595e2d0306cbd8dde8091ee4c721934"></a><!-- doxytag: member="MGPvector::rend" ref="a0595e2d0306cbd8dde8091ee4c721934" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return reverse_iterator that points to one before the first element in the vector. </p>

</div>
</div>
<a class="anchor" id="a7743d1d9366eeaf7e1120291f7ef3cb6"></a><!-- doxytag: member="MGPvector::reserve" ref="a7743d1d9366eeaf7e1120291f7ef3cb6" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preallocate memory for specified number of elements if necessary. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Pvector.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:27 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: mgTLRect Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>mgTLRect Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mgTLRect" -->
<p><a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> is a proprietry class for Face tessellation.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;TLRect.h&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mgTLRect:</div>
<div class="dyncontent">
<div class="center"><img src="classmg_t_l_rect__coll__graph.png" border="0" usemap="#mg_t_l_rect_coll__map" alt="Collaboration graph"/></div>
<map name="mg_t_l_rect_coll__map" id="mg_t_l_rect_coll__map">
<area shape="rect" id="node2" href="classmg_t_l_recisects.html" title="mgTLRecisects is a proprietry class for Face tessellation." alt="" coords="5,5,117,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classmg_t_l_rect-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d77433772a61b7ea10d38413d5d2664"></a><!-- doxytag: member="mgTLRect::container_type" ref="a8d77433772a61b7ea10d38413d5d2664" args="" -->
typedef std::list&lt; <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c832cafc2aa42ed33a3f76875979ba"></a><!-- doxytag: member="mgTLRect::RecNItr" ref="a46c832cafc2aa42ed33a3f76875979ba" args="" -->
typedef container_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a46c832cafc2aa42ed33a3f76875979ba">RecNItr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for m_neighbours. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97822646211df8b40b8aa4ad0bb7c4e6"></a><!-- doxytag: member="mgTLRect::CRecNItr" ref="a97822646211df8b40b8aa4ad0bb7c4e6" args="" -->
typedef <br class="typebreak"/>
container_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>CRecNItr</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6701ea09bcbc4bc607340212d04240"></a><!-- doxytag: member="mgTLRect::mgTLRect" ref="a6a6701ea09bcbc4bc607340212d04240" args="(double u0, double u1, double v0, double v1)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a6a6701ea09bcbc4bc607340212d04240">mgTLRect</a> (double u0, double u1, double v0, double v1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from the parameter box (u0, v0) - (u1, v1). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#afa6eb3cb71bc05c855f24f3aa47e7e50">mgTLRect</a> (bool uDirection, <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;rect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a higher parameter value <a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> by subdividing the input rect along u(uDirection=ture) or v direction.  <a href="#afa6eb3cb71bc05c855f24f3aa47e7e50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a21b8b6a81e4ee234f41d98da551a1afe">add_boundary_vertices</a> (double crvTol, size_t iss, <a class="el" href="classmg_t_l_triangle.html">mgTLTriangle</a> &amp;polygon, <a class="el" href="classmg_t_l_points.html">mgTLPoints</a> &amp;Tlpoints) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add vertices of the trimming line(boundary line) from isects()[sztRectIndex] to [sztRectIndex+1], converting the boundary line to a polyline.  <a href="#a21b8b6a81e4ee234f41d98da551a1afe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a41b380f54b8460f8a6ed3483d0533341">add_neighbor_vertices</a> (size_t peri, double s1, double s2, <a class="el" href="classmg_t_l_triangle.html">mgTLTriangle</a> &amp;polygon) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add vertices of the neighboring rectangles' vertices at the perimeter peri from parameter s1 to s2.  <a href="#a41b380f54b8460f8a6ed3483d0533341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a29aabc32db9b698202dd720059c44801">add_rect_point</a> (size_t pnum, double u, double v, <a class="el" href="classmg_t_l_rects.html">mgTLRects</a> &amp;rects)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add (u,v) to by add_point of rects.  <a href="#a29aabc32db9b698202dd720059c44801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c328f3e13b75bf58b986655cbae206"></a><!-- doxytag: member="mgTLRect::center_uv" ref="a78c328f3e13b75bf58b986655cbae206" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a78c328f3e13b75bf58b986655cbae206">center_uv</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get center(surface parameter) of this rect. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a8bdf63cc21f4807e1f64930d6f59ca9c">compare</a> (size_t perim, double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compare which is greater, t1 or t2 at the perimeter perim.  <a href="#a8bdf63cc21f4807e1f64930d6f59ca9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d6383966f555aa97d9315954971e8f8"></a><!-- doxytag: member="mgTLRect::compute_plane" ref="a2d6383966f555aa97d9315954971e8f8" args="(const MGSurface &amp;surf) const " -->
<a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a2d6383966f555aa97d9315954971e8f8">compute_plane</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closeset plane of this rect. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a4d55d4b651c1a7037c69694cb129a4bc">compute_perimeter_tex_coord</a> (const <a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata, size_t i, const <a class="el" href="class_m_g_position.html">MGPosition</a> uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute texture coordinates of the point world coord point xyz.  <a href="#a4d55d4b651c1a7037c69694cb129a4bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a83414efe7fa44e19425c897f894eaba6">compute_texture_by_triangles</a> (<a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assurme this is not textured yet, and at least one of the neighboring perimeter is textured.  <a href="#a83414efe7fa44e19425c897f894eaba6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a3dae03b1bacf678cb6049f1f5817f263">compute_texture_from_neighbor</a> (<a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata, <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;neighbor, size_t nperim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">neighbor is already textured, and neighbor and this is connected along neghbor's perimeter number nperim.  <a href="#a3dae03b1bacf678cb6049f1f5817f263"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63759cf2b491e3513d655663fafc89cb"></a><!-- doxytag: member="mgTLRect::compute_texture_of_non_corner" ref="a63759cf2b491e3513d655663fafc89cb" args="(mgTLData &amp;tldata)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a63759cf2b491e3513d655663fafc89cb">compute_texture_of_non_corner</a> (<a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assume four corner vertices are textured, texture other vertices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09bc65e9f86f7f0e2a6995de8b002950"></a><!-- doxytag: member="mgTLRect::createPolygon" ref="a09bc65e9f86f7f0e2a6995de8b002950" args="(mgTLparameter &amp;param, mgTLTriangles &amp;polygons)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a09bc65e9f86f7f0e2a6995de8b002950">createPolygon</a> (<a class="el" href="classmg_t_lparameter.html">mgTLparameter</a> &amp;param, <a class="el" href="classmg_t_l_triangles.html">mgTLTriangles</a> &amp;polygons)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">矩形交点からトリムポリゴンを作成し polygons に追加する トリムされている場合の処理を行う。頂点は <a class="el" href="classmg_t_l_points.html" title="mgTLPoints holds the vector of the surface parameter (u,v).">mgTLPoints</a> に追加する <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#afa7e392d0860d58fbd24ed3807e7985a">end_point</a> (size_t peri) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the end point parameter value of the perimeter peri.  <a href="#afa7e392d0860d58fbd24ed3807e7985a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ae77d252010327f6818785f943a6f972d">find_neighbour</a> (size_t peri, double t, <a class="el" href="classmg_t_l_rect.html#a46c832cafc2aa42ed33a3f76875979ba">RecNItr</a> &amp;i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the 1st neighbour iterator i whose minimum value at the perimeter peri is less or equal to t and the maximum value is greater than t.  <a href="#ae77d252010327f6818785f943a6f972d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a5ea929b44e039713507f5297a21ba784">find_neighbor_rect</a> (double errorSurf, int id_hhis, const <a class="el" href="class_m_g_h_hisect.html">MGHHisect</a> &amp;hhis, int perim_into, <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> *&amp;rect_next, int &amp;perim_going_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the neighbor rect or face of rect_next following the line of fpoints.  <a href="#a5ea929b44e039713507f5297a21ba784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#af6e9a81a33b3a44de5db4d0b267eb7e6">get_point_id</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="classmg_t_l_points.html">mgTLPoints</a> &amp;Tlpoints) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the point id of uv.  <a href="#af6e9a81a33b3a44de5db4d0b267eb7e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a74f51f5b6df790bfbddca163499fa39a">get_tex_coord</a> (const <a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute texture coordinates of the point world coord point xyz.  <a href="#a74f51f5b6df790bfbddca163499fa39a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#aa837b1decf9526aea19e4923a3f647e5">is_on_perimeter</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test if the parameter uv is on a perimeter of this rect.  <a href="#aa837b1decf9526aea19e4923a3f647e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a4e17ed2bdaa197ebb1ab78f7a7b7ff6b">get_corner_id</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test if the parameter uv is on a corner of this rect.  <a href="#a4e17ed2bdaa197ebb1ab78f7a7b7ff6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9a316ec4f2590e623c022685d23e40"></a><!-- doxytag: member="mgTLRect::is_triangled" ref="abe9a316ec4f2590e623c022685d23e40" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#abe9a316ec4f2590e623c022685d23e40">is_triangled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if finish triangulation, return true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad86de2939e379b3af4296a66e53a3a92"></a><!-- doxytag: member="mgTLRect::triangle_id" ref="ad86de2939e379b3af4296a66e53a3a92" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ad86de2939e379b3af4296a66e53a3a92">triangle_id</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the starting triangle id. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9ca7de35f05859e2606c58df53d84de"></a><!-- doxytag: member="mgTLRect::hasStripCondition" ref="ae9ca7de35f05859e2606c58df53d84de" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ae9ca7de35f05859e2606c58df53d84de">hasStripCondition</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rectがストリップになる条件を持っているかどうか調べる 条件 ・隣り合うrectが1以下 ・トリムされていない ・triangulationされていない <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa45f1b97a23ba6226986faf6d023254"></a><!-- doxytag: member="mgTLRect::has_trim" ref="aaa45f1b97a23ba6226986faf6d023254" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#aaa45f1b97a23ba6226986faf6d023254">has_trim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this rect has trimming intersection or not(for the 4 perimeters). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a388e71f118f527bb8c8af9ddc083e3e4"></a><!-- doxytag: member="mgTLRect::has_trim" ref="a388e71f118f527bb8c8af9ddc083e3e4" args="(size_t peri) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a388e71f118f527bb8c8af9ddc083e3e4">has_trim</a> (size_t peri) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this rect has trimming intersection or not on the perimeter peri. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a421da83bf8aa09f8c4478bbaec687382"></a><!-- doxytag: member="mgTLRect::getNeighborPoint" ref="a421da83bf8aa09f8c4478bbaec687382" args="(size_t peri, std::vector&lt; size_t &gt; &amp;vecPoint) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a421da83bf8aa09f8c4478bbaec687382">getNeighborPoint</a> (size_t peri, std::vector&lt; size_t &gt; &amp;vecPoint) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">隣のrectの頂点を求める。頂点はパラメータの小さい順に並んでいる。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ac158eac9dfb7a0ca2caea76a91147350">includes</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this rectangle includes the parameter value uv.  <a href="#ac158eac9dfb7a0ca2caea76a91147350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1537c4273eea7dd30f4e9917d8843119"></a><!-- doxytag: member="mgTLRect::includes2" ref="a1537c4273eea7dd30f4e9917d8843119" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a1537c4273eea7dd30f4e9917d8843119">includes2</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is another version of includes, and takes care of tolerance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b165a8cd1dade9facd1052239ec6109"></a><!-- doxytag: member="mgTLRect::make_included" ref="a0b165a8cd1dade9facd1052239ec6109" args="(MGPosition &amp;uv) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a0b165a8cd1dade9facd1052239ec6109">make_included</a> (<a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the uv included in this rectangle's parameter space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a591c71f92a9fafa4aeed18efc8ef9e39">NextStartIsect</a> (size_t peri, double p, size_t periS, double sS, size_t &amp;index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ペリメタ番号とパラメータ値を与えて次のスタート交点を求める 求まったときtrueが返却されindexに交点インデックスが入る  <a href="#a591c71f92a9fafa4aeed18efc8ef9e39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a25b3ad9ba59e6681c4999c3d7ac576d5">get_trim_point</a> (<a class="el" href="classmg_t_lparameter.html">mgTLparameter</a> &amp;param, double t, size_t kcod, double s0, double s1, <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;rect2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute trimming points(intersections with trimming loops with the rectangle) at the newly generated adjacent perimeters when old rectangle is subdivided into half at the parameter t(u or v according to the coordinate kind kcod).  <a href="#a25b3ad9ba59e6681c4999c3d7ac576d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1a4f9fd222b81e421d64a8b87d1966"></a><!-- doxytag: member="mgTLRect::neighbours" ref="a2a1a4f9fd222b81e421d64a8b87d1966" args="(size_t i) const " -->
const std::list&lt; <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a2a1a4f9fd222b81e421d64a8b87d1966">neighbours</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return i-th perimeter's neighbours. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae30eb582e660559b25e7830798f93eda"></a><!-- doxytag: member="mgTLRect::opposite_perim" ref="ae30eb582e660559b25e7830798f93eda" args="(size_t i)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>opposite_perim</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b93cdbaa842fb736aa4fd478b7e997e"></a><!-- doxytag: member="mgTLRect::Pid" ref="a6b93cdbaa842fb736aa4fd478b7e997e" args="(size_t i) const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>Pid</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2116c5bf715f8fadb1db5c4b7f641d37"></a><!-- doxytag: member="mgTLRect::Pid" ref="a2116c5bf715f8fadb1db5c4b7f641d37" args="() const " -->
const size_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>Pid</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0b1c669ca3f16f3b21d93d0e152939f"></a><!-- doxytag: member="mgTLRect::Pin" ref="ad0b1c669ca3f16f3b21d93d0e152939f" args="(size_t i) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>Pin</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21998cd9c6f2626015c8d620c2f611c6"></a><!-- doxytag: member="mgTLRect::Pin" ref="a21998cd9c6f2626015c8d620c2f611c6" args="() const " -->
const bool *&nbsp;</td><td class="memItemRight" valign="bottom"><b>Pin</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d0c43f4f3b3c564ed545d5288bfc4e"></a><!-- doxytag: member="mgTLRect::print_neighbours" ref="af4d0c43f4f3b3c564ed545d5288bfc4e" args="(std::ostream &amp;out) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>print_neighbours</b> (std::ostream &amp;out) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43e06b7dfb8170da853f6aae5b7f409a"></a><!-- doxytag: member="mgTLRect::print_triangles" ref="a43e06b7dfb8170da853f6aae5b7f409a" args="(std::ostream &amp;out, mgTLData &amp;tldata) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>print_triangles</b> (std::ostream &amp;out, <a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79b8fb2d7fbc700cf998417016a3663d"></a><!-- doxytag: member="mgTLRect::ratio_sqr" ref="a79b8fb2d7fbc700cf998417016a3663d" args="(const mgTLparameter &amp;param) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a79b8fb2d7fbc700cf998417016a3663d">ratio_sqr</a> (const <a class="el" href="classmg_t_lparameter.html">mgTLparameter</a> &amp;param) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute ratio square of du/dv of the rectangle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">mgTLRecisects::ReciItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a0dcd4ba593cf2020247248d0151705e6">reci_aft</a> (mgTLRecisects::ReciItr i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain previous or aft ReciItr of i in the ReciItr loop of this rectangle.  <a href="#a0dcd4ba593cf2020247248d0151705e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217952df946c8f1f14a159f16c91e05e"></a><!-- doxytag: member="mgTLRect::reci_pre" ref="a217952df946c8f1f14a159f16c91e05e" args="(mgTLRecisects::ReciItr i)" -->
mgTLRecisects::ReciItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>reci_pre</b> (mgTLRecisects::ReciItr i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#aa2fe5ec235d4b9bcb51177c7fe60a711">set_initial_tex_from_1point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;xyz1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;st1, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;xaxis, <a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all the texture coordinates data of this rect's vertex.  <a href="#aa2fe5ec235d4b9bcb51177c7fe60a711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a64fd558c1b672afa98edb945ecaca8d3">set_status</a> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the new m_status of <a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> after subdivided.  <a href="#a64fd558c1b672afa98edb945ecaca8d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a204e6bbb367b562098cc52e6b6345d6a">set_neighbor_tex_coord_data</a> (<a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;tldata, std::deque&lt; <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> * &gt; &amp;rects)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assuming this is already textured, set all the neighboring rect's texture coordinates data invoking <a class="el" href="classmg_t_l_rect.html#a83414efe7fa44e19425c897f894eaba6" title="Assurme this is not textured yet, and at least one of the neighboring perimeter is...">compute_texture_by_triangles()</a>.  <a href="#a204e6bbb367b562098cc52e6b6345d6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae63ca5c9b8108dcf8518c6503dab07c0"></a><!-- doxytag: member="mgTLRect::set_triangled" ref="ae63ca5c9b8108dcf8518c6503dab07c0" args="(int tri)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ae63ca5c9b8108dcf8518c6503dab07c0">set_triangled</a> (int tri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set triangled flag. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#af04f81148e5ccc8815ea8c1bbb6f71e7">start_point</a> (size_t peri) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the start point parameter value of the perimeter peri.  <a href="#af04f81148e5ccc8815ea8c1bbb6f71e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5c4f14e973b7238e4cff5c559cfbe29"></a><!-- doxytag: member="mgTLRect::status" ref="ad5c4f14e973b7238e4cff5c559cfbe29" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ad5c4f14e973b7238e4cff5c559cfbe29">status</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the rectangle. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9f5e70616943395a4ac7c528ab51830"></a><!-- doxytag: member="mgTLRect::isects" ref="ab9f5e70616943395a4ac7c528ab51830" args="() const " -->
const <a class="el" href="classmg_t_l_recisects.html">mgTLRecisects</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#ab9f5e70616943395a4ac7c528ab51830">isects</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the m_Recisects reference. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b74b63af2b70e6464311ea228df4590"></a><!-- doxytag: member="mgTLRect::isects" ref="a0b74b63af2b70e6464311ea228df4590" args="()" -->
<a class="el" href="classmg_t_l_recisects.html">mgTLRecisects</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>isects</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a164542434ec5de1236acccd8f6545741">normalize_trim_points</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize trimming points.  <a href="#a164542434ec5de1236acccd8f6545741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmg_t_l_rect.html">mgTLRect</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#af09dd013d641ff3ced19a0ce970c2fb0">subdivide</a> (<a class="el" href="classmg_t_l_rects.html">mgTLRects</a> &amp;rects, bool uDirection)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide into two parts at the middle of u(uDirection=true) or v(uDirection=false) parameter.  <a href="#af09dd013d641ff3ced19a0ce970c2fb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c38456dce3508b235cd9e05142dca9"></a><!-- doxytag: member="mgTLRect::is_textured" ref="a94c38456dce3508b235cd9e05142dca9" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a94c38456dce3508b235cd9e05142dca9">is_textured</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if texture coord data is already set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334ea6a4ee32d63d15d9921da12b53de"></a><!-- doxytag: member="mgTLRect::uv" ref="a334ea6a4ee32d63d15d9921da12b53de" args="(size_t i) const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a334ea6a4ee32d63d15d9921da12b53de">uv</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return this rectangle's corner point i's (u,v). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a169a62adb46947389214e38bd7824668"></a><!-- doxytag: member="mgTLRect::umin" ref="a169a62adb46947389214e38bd7824668" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a169a62adb46947389214e38bd7824668">umin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return corner point (u,v) data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7ec7d9650de9aad4178c5c92c3bc5b1"></a><!-- doxytag: member="mgTLRect::umax" ref="ab7ec7d9650de9aad4178c5c92c3bc5b1" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>umax</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa64ddb6b53aa89e52704a911890b618"></a><!-- doxytag: member="mgTLRect::uspan" ref="afa64ddb6b53aa89e52704a911890b618" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>uspan</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0638023e86bd97ca8157615e4c5aeb8"></a><!-- doxytag: member="mgTLRect::vmin" ref="ad0638023e86bd97ca8157615e4c5aeb8" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>vmin</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3af8cee946d4c4bed8bcf0ba09fac336"></a><!-- doxytag: member="mgTLRect::vmax" ref="a3af8cee946d4c4bed8bcf0ba09fac336" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>vmax</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27447818384a28810c09e8cc1358f79b"></a><!-- doxytag: member="mgTLRect::vspan" ref="a27447818384a28810c09e8cc1358f79b" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>vspan</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0dfdb52bef3c50260a47ac18844b677"></a><!-- doxytag: member="mgTLRect::set_tex_within_tol" ref="ac0dfdb52bef3c50260a47ac18844b677" args="(bool within_tol=true)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_tex_within_tol</b> (bool within_tol=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1fb2647c2e916dbdeb1c2a173e78f3"></a><!-- doxytag: member="mgTLRect::tex_within_tol" ref="a0d1fb2647c2e916dbdeb1c2a173e78f3" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>tex_within_tol</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d8904b825f37dcf6938cd9232cfb931"></a><!-- doxytag: member="mgTLRect::set_texture_level" ref="a5d8904b825f37dcf6938cd9232cfb931" args="(int level)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_texture_level</b> (int level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e7f3fc654fe831c11ba83b68138c2f1"></a><!-- doxytag: member="mgTLRect::texture_level" ref="a1e7f3fc654fe831c11ba83b68138c2f1" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>texture_level</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmg_t_l_recisects.html">mgTLRecisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#aa727902b7cd01f8c6116b69bde2becea">m_Recisects</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">m_Recisects are intersections of the rectangle with a loop.  <a href="#aa727902b7cd01f8c6116b69bde2becea"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ad13ce0003a43cd11981c2d127c0b92"></a><!-- doxytag: member="mgTLRect::mgTLRects" ref="a8ad13ce0003a43cd11981c2d127c0b92" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#a8ad13ce0003a43cd11981c2d127c0b92">mgTLRects</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1a842cb25a5d910964f369f6ddd546"></a><!-- doxytag: member="mgTLRect::mgTLData" ref="acc1a842cb25a5d910964f369f6ddd546" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmg_t_l_rect.html#acc1a842cb25a5d910964f369f6ddd546">mgTLData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c7a7d2541e466c22ccc9882bd3d6b8a"></a><!-- doxytag: member="mgTLRect::operator&lt;&lt;" ref="a1c7a7d2541e466c22ccc9882bd3d6b8a" args="(std::ostream &amp;out, const mgTLRect &amp;rect)" -->
MGDECL friend std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;rect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ab366d3567c1ba130ffb5ef75199f4"></a><!-- doxytag: member="mgTLRect::change_neighbours" ref="a37ab366d3567c1ba130ffb5ef75199f4" args="(mgTLRect *rect2, size_t peri, std::list&lt; mgTLRect * &gt; &amp;neibrs1, mgTLRect::RecNItr N1Itr)" -->
MGDECL friend void&nbsp;</td><td class="memItemRight" valign="bottom"><b>change_neighbours</b> (<a class="el" href="classmg_t_l_rect.html">mgTLRect</a> *rect2, size_t peri, std::list&lt; <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> * &gt; &amp;neibrs1, <a class="el" href="classmg_t_l_rect.html#a46c832cafc2aa42ed33a3f76875979ba">mgTLRect::RecNItr</a> N1Itr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> is a proprietry class for Face tessellation. </p>
<p><a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> holds all the necessary information for the triangulation of a retangle face parameter space. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afa6eb3cb71bc05c855f24f3aa47e7e50"></a><!-- doxytag: member="mgTLRect::mgTLRect" ref="afa6eb3cb71bc05c855f24f3aa47e7e50" args="(bool uDirection, mgTLRect &amp;rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mgTLRect::mgTLRect </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a higher parameter value <a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> by subdividing the input rect along u(uDirection=ture) or v direction. </p>
<p>This constructor builds the following data: m_urange, m_vrange, m_Pid, m_Pin, m_status. m_Pin[0], [3] (when uDirection=true) or m_Pin[0], [1] are not set. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a21b8b6a81e4ee234f41d98da551a1afe"></a><!-- doxytag: member="mgTLRect::add_boundary_vertices" ref="a21b8b6a81e4ee234f41d98da551a1afe" args="(double crvTol, size_t iss, mgTLTriangle &amp;polygon, mgTLPoints &amp;Tlpoints) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::add_boundary_vertices </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>crvTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_triangle.html">mgTLTriangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_points.html">mgTLPoints</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Tlpoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add vertices of the trimming line(boundary line) from isects()[sztRectIndex] to [sztRectIndex+1], converting the boundary line to a polyline. </p>

</div>
</div>
<a class="anchor" id="a41b380f54b8460f8a6ed3483d0533341"></a><!-- doxytag: member="mgTLRect::add_neighbor_vertices" ref="a41b380f54b8460f8a6ed3483d0533341" args="(size_t peri, double s1, double s2, mgTLTriangle &amp;polygon) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::add_neighbor_vertices </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>peri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_triangle.html">mgTLTriangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>polygon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add vertices of the neighboring rectangles' vertices at the perimeter peri from parameter s1 to s2. </p>
<p>s1 and s2 are in the order of the rectangle. That is if peri==0 or 1, in the order of the u or v parameter value, and if peri==2 or 3, in the reverse order or the u or v parameter value. </p>

</div>
</div>
<a class="anchor" id="a29aabc32db9b698202dd720059c44801"></a><!-- doxytag: member="mgTLRect::add_rect_point" ref="a29aabc32db9b698202dd720059c44801" args="(size_t pnum, double u, double v, mgTLRects &amp;rects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mgTLRect::add_rect_point </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>pnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rects.html">mgTLRects</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rects</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>add (u,v) to by add_point of rects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pnum</em>&nbsp;</td><td>perimeter number of this rect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rects</em>&nbsp;</td><td><a class="el" href="classmg_t_l_rects.html" title="mgTLRects is a proprietry class for Face tessellation.">mgTLRects</a> into which all the rects are stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bdf63cc21f4807e1f64930d6f59ca9c"></a><!-- doxytag: member="mgTLRect::compare" ref="a8bdf63cc21f4807e1f64930d6f59ca9c" args="(size_t perim, double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mgTLRect::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>perim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare which is greater, t1 or t2 at the perimeter perim. </p>
<p>latter position around the anti-clockwise round of the rectangle is greater. If t1 is greater or equal to t2 return true. </p>

</div>
</div>
<a class="anchor" id="a4d55d4b651c1a7037c69694cb129a4bc"></a><!-- doxytag: member="mgTLRect::compute_perimeter_tex_coord" ref="a4d55d4b651c1a7037c69694cb129a4bc" args="(const mgTLData &amp;tldata, size_t i, const MGPosition uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> mgTLRect::compute_perimeter_tex_coord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute texture coordinates of the point world coord point xyz. </p>
<p>This is valid only after texutured. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>perimeter number where uv lies on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>parameter value to get the texture, which must be on the perimeter i. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83414efe7fa44e19425c897f894eaba6"></a><!-- doxytag: member="mgTLRect::compute_texture_by_triangles" ref="a83414efe7fa44e19425c897f894eaba6" args="(mgTLData &amp;tldata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::compute_texture_by_triangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tldata</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assurme this is not textured yet, and at least one of the neighboring perimeter is textured. </p>
<p>Then compute_texture_by_triangles will perform texture computation by invoking mgTriangle::texture. </p>

</div>
</div>
<a class="anchor" id="a3dae03b1bacf678cb6049f1f5817f263"></a><!-- doxytag: member="mgTLRect::compute_texture_from_neighbor" ref="a3dae03b1bacf678cb6049f1f5817f263" args="(mgTLData &amp;tldata, mgTLRect &amp;neighbor, size_t nperim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::compute_texture_from_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nperim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>neighbor is already textured, and neighbor and this is connected along neghbor's perimeter number nperim. </p>
<p>Then compute_texture_from_neighbor will texture-compute this rect. </p>

</div>
</div>
<a class="anchor" id="afa7e392d0860d58fbd24ed3807e7985a"></a><!-- doxytag: member="mgTLRect::end_point" ref="afa7e392d0860d58fbd24ed3807e7985a" args="(size_t peri) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mgTLRect::end_point </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>peri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the end point parameter value of the perimeter peri. </p>
<p>End point means in the order of the rectangle' anti-cloclwise order. </p>

</div>
</div>
<a class="anchor" id="a5ea929b44e039713507f5297a21ba784"></a><!-- doxytag: member="mgTLRect::find_neighbor_rect" ref="a5ea929b44e039713507f5297a21ba784" args="(double errorSurf, int id_hhis, const MGHHisect &amp;hhis, int perim_into, mgTLRect *&amp;rect_next, int &amp;perim_going_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mgTLRect::find_neighbor_rect </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>errorSurf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id_hhis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_h_hisect.html">MGHHisect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hhis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>perim_into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rect.html">mgTLRect</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>rect_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_going_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the neighbor rect or face of rect_next following the line of fpoints. </p>
<p>Function's return value is id of hhis to process the next face(mgTLData). When hhis moves to a different face, rect_next=0 and the proper next hhis id will be output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errorSurf</em>&nbsp;</td><td>surface parameter space error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id_hhis</em>&nbsp;</td><td>id of hhis that defines the current priority line of uv is input. When id_hhis&gt;=hhis.size(), no priority lines are input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_into</em>&nbsp;</td><td>The perimeter number(of this) that came into this rect. perim_into=-1 when no previous rect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect_next</em>&nbsp;</td><td>next rect will be output. When rect_next=0 is output, no next in this face. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_going_out</em>&nbsp;</td><td>rect_next's perimeter number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae77d252010327f6818785f943a6f972d"></a><!-- doxytag: member="mgTLRect::find_neighbour" ref="ae77d252010327f6818785f943a6f972d" args="(size_t peri, double t, RecNItr &amp;i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mgTLRect::find_neighbour </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>peri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rect.html#a46c832cafc2aa42ed33a3f76875979ba">RecNItr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the 1st neighbour iterator i whose minimum value at the perimeter peri is less or equal to t and the maximum value is greater than t. </p>
<p>Function's return value is true if t is equal to minimum value of the perimeter. </p>

</div>
</div>
<a class="anchor" id="a4e17ed2bdaa197ebb1ab78f7a7b7ff6b"></a><!-- doxytag: member="mgTLRect::get_corner_id" ref="a4e17ed2bdaa197ebb1ab78f7a7b7ff6b" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mgTLRect::get_corner_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if the parameter uv is on a corner of this rect. </p>
<p>returned is: =-1: when not on any corner, &gt;=0: when on a corner, the corner id will be returned. </p>

</div>
</div>
<a class="anchor" id="af6e9a81a33b3a44de5db4d0b267eb7e6"></a><!-- doxytag: member="mgTLRect::get_point_id" ref="af6e9a81a33b3a44de5db4d0b267eb7e6" args="(const MGPosition &amp;uv, mgTLPoints &amp;Tlpoints) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mgTLRect::get_point_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_points.html">mgTLPoints</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Tlpoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the point id of uv. </p>
<p>get_point_id will() tests if uv is equal to a corner data of this rect, and if the same, the corner point id will be returned, else uv will be added to Tlpoints. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>parameter value to get the texture, which may not be on the perimeter i. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74f51f5b6df790bfbddca163499fa39a"></a><!-- doxytag: member="mgTLRect::get_tex_coord" ref="a74f51f5b6df790bfbddca163499fa39a" args="(const mgTLData &amp;tldata, const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> mgTLRect::get_tex_coord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute texture coordinates of the point world coord point xyz. </p>
<p>This is valid only after texutured. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>parameter value to get the texture, which may not be on the perimeter i. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25b3ad9ba59e6681c4999c3d7ac576d5"></a><!-- doxytag: member="mgTLRect::get_trim_point" ref="a25b3ad9ba59e6681c4999c3d7ac576d5" args="(mgTLparameter &amp;param, double t, size_t kcod, double s0, double s1, mgTLRect &amp;rect2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::get_trim_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmg_t_lparameter.html">mgTLparameter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>kcod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rect.html">mgTLRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute trimming points(intersections with trimming loops with the rectangle) at the newly generated adjacent perimeters when old rectangle is subdivided into half at the parameter t(u or v according to the coordinate kind kcod). </p>
<p>Trimming points will be recomputed and stored in this and rect2's m_Recisects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>Tessellation parameter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Subdividing parameter value u or v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kcod</em>&nbsp;</td><td>t's coordinate kind. 0:u, 1:v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>parameter range of the other coordinate than t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect2</em>&nbsp;</td><td>2nd rectangle after subdivided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac158eac9dfb7a0ca2caea76a91147350"></a><!-- doxytag: member="mgTLRect::includes" ref="ac158eac9dfb7a0ca2caea76a91147350" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mgTLRect::includes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this rectangle includes the parameter value uv. </p>
<p>Returns true if includes uv, false if not. </p>

</div>
</div>
<a class="anchor" id="aa837b1decf9526aea19e4923a3f647e5"></a><!-- doxytag: member="mgTLRect::is_on_perimeter" ref="aa837b1decf9526aea19e4923a3f647e5" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mgTLRect::is_on_perimeter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>test if the parameter uv is on a perimeter of this rect. </p>
<p>returned is: =-1: when not on any perimeter, &gt;=0: when on a perimeter, perimeter id will be returned. </p>

</div>
</div>
<a class="anchor" id="a591c71f92a9fafa4aeed18efc8ef9e39"></a><!-- doxytag: member="mgTLRect::NextStartIsect" ref="a591c71f92a9fafa4aeed18efc8ef9e39" args="(size_t peri, double p, size_t periS, double sS, size_t &amp;index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mgTLRect::NextStartIsect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>peri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>periS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ペリメタ番号とパラメータ値を与えて次のスタート交点を求める 求まったときtrueが返却されindexに交点インデックスが入る </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peri</em>&nbsp;</td><td>perimeter number to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>last isect's parameter value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periS</em>&nbsp;</td><td>polygon's starting perimeter number and </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sS</em>&nbsp;</td><td>the parameter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a164542434ec5de1236acccd8f6545741"></a><!-- doxytag: member="mgTLRect::normalize_trim_points" ref="a164542434ec5de1236acccd8f6545741" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::normalize_trim_points </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize trimming points. </p>
<p>Re-order the recisect seq </p>

</div>
</div>
<a class="anchor" id="a0dcd4ba593cf2020247248d0151705e6"></a><!-- doxytag: member="mgTLRect::reci_aft" ref="a0dcd4ba593cf2020247248d0151705e6" args="(mgTLRecisects::ReciItr i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mgTLRecisects::ReciItr mgTLRect::reci_aft </td>
          <td>(</td>
          <td class="paramtype">mgTLRecisects::ReciItr&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain previous or aft ReciItr of i in the ReciItr loop of this rectangle. </p>

</div>
</div>
<a class="anchor" id="aa2fe5ec235d4b9bcb51177c7fe60a711"></a><!-- doxytag: member="mgTLRect::set_initial_tex_from_1point" ref="aa2fe5ec235d4b9bcb51177c7fe60a711" args="(const MGPosition &amp;xyz1, const MGPosition &amp;st1, const MGUnit_vector &amp;xaxis, mgTLData &amp;tldata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::set_initial_tex_from_1point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xyz1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>st1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xaxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tldata</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all the texture coordinates data of this rect's vertex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xyz1</em>&nbsp;</td><td>parameter value of the surfaceof texture st1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st1</em>&nbsp;</td><td>texture coordinates of uv1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xaxis</em>&nbsp;</td><td>texture x-axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a204e6bbb367b562098cc52e6b6345d6a"></a><!-- doxytag: member="mgTLRect::set_neighbor_tex_coord_data" ref="a204e6bbb367b562098cc52e6b6345d6a" args="(mgTLData &amp;tldata, std::deque&lt; mgTLRect * &gt; &amp;rects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mgTLRect::set_neighbor_tex_coord_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmg_t_l_data.html">mgTLData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; <a class="el" href="classmg_t_l_rect.html">mgTLRect</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rects</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming this is already textured, set all the neighboring rect's texture coordinates data invoking <a class="el" href="classmg_t_l_rect.html#a83414efe7fa44e19425c897f894eaba6" title="Assurme this is not textured yet, and at least one of the neighboring perimeter is...">compute_texture_by_triangles()</a>. </p>
<p>Function's return value is true if some are textured. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rects</em>&nbsp;</td><td>modified rects will be prepended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64fd558c1b672afa98edb945ecaca8d3"></a><!-- doxytag: member="mgTLRect::set_status" ref="a64fd558c1b672afa98edb945ecaca8d3" args="(const MGFace &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mgTLRect::set_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the new m_status of <a class="el" href="classmg_t_l_rect.html" title="mgTLRect is a proprietry class for Face tessellation.">mgTLRect</a> after subdivided. </p>
<p>m_box, m_Rectisects, and m_Pin[0] must be updated before use. These are referenced in <a class="el" href="classmg_t_l_rect.html#a64fd558c1b672afa98edb945ecaca8d3" title="Set the new m_status of mgTLRect after subdivided.">set_status()</a>. old m_status is referenced also. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Original face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af04f81148e5ccc8815ea8c1bbb6f71e7"></a><!-- doxytag: member="mgTLRect::start_point" ref="af04f81148e5ccc8815ea8c1bbb6f71e7" args="(size_t peri) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mgTLRect::start_point </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>peri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the start point parameter value of the perimeter peri. </p>
<p>Start point means in the order of the rectangle' anti-cloclwise order. </p>

</div>
</div>
<a class="anchor" id="af09dd013d641ff3ced19a0ce970c2fb0"></a><!-- doxytag: member="mgTLRect::subdivide" ref="af09dd013d641ff3ced19a0ce970c2fb0" args="(mgTLRects &amp;rects, bool uDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmg_t_l_rect.html">mgTLRect</a>* mgTLRect::subdivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmg_t_l_rects.html">mgTLRects</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uDirection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide into two parts at the middle of u(uDirection=true) or v(uDirection=false) parameter. </p>
<p>The divided two are put in this and function's return value. The new this will be located first in the sequence of the uv rectangle list <a class="el" href="classmg_t_l_rects.html" title="mgTLRects is a proprietry class for Face tessellation.">mgTLRects</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rects</em>&nbsp;</td><td><a class="el" href="classmg_t_l_rects.html" title="mgTLRects is a proprietry class for Face tessellation.">mgTLRects</a> into which all the rects are stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uDirection</em>&nbsp;</td><td>direction of sibdivision. =true:udirection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa727902b7cd01f8c6116b69bde2becea"></a><!-- doxytag: member="mgTLRect::m_Recisects" ref="aa727902b7cd01f8c6116b69bde2becea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmg_t_l_recisects.html">mgTLRecisects</a> <a class="el" href="classmg_t_l_rect.html#aa727902b7cd01f8c6116b69bde2becea">mgTLRect::m_Recisects</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>m_Recisects are intersections of the rectangle with a loop. </p>
<p>In m_Recisects, intersections are sorted in the anti-clock-wise along the rectangle perimeter. On return from <a class="el" href="classmg_t_l_rects.html" title="mgTLRects is a proprietry class for Face tessellation.">mgTLRects</a> constructor, m_Recisects[2*j] is the point that is going into the rectangle and m_Recisects[2*j+1] is going out. These two points always makes a pair. (This is not the fact during the construction process of <a class="el" href="classmg_t_l_rects.html" title="mgTLRects is a proprietry class for Face tessellation.">mgTLRects</a>. <a class="el" href="classmg_t_l_rect.html#a164542434ec5de1236acccd8f6545741" title="Normalize trimming points.">mgTLRect::normalize_trim_points</a> in the constructor will take care the sequence.) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>TLRect.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:30 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

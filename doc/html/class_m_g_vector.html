<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGVector Class Reference<br/>
<small>
[<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGVector" -->
<p>Vector of a general n space dimension.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Vector.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGVector:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_vector__inherit__graph.png" border="0" usemap="#_m_g_vector_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_vector_inherit__map" id="_m_g_vector_inherit__map">
<area shape="rect" id="node3" href="class_m_g_unit__vector.html" title="Define a unit vector, is a MGVector." alt="" coords="5,83,112,112"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_vector-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35b7de4b1781eeebcd678fa7f9d9f431"></a><!-- doxytag: member="MGVector::MGVector" ref="a35b7de4b1781eeebcd678fa7f9d9f431" args="(size_t sdim=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a35b7de4b1781eeebcd678fa7f9d9f431">MGVector</a> (size_t sdim=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c16ead68ba0b98d325f93e6be4f20e"></a><!-- doxytag: member="MGVector::MGVector" ref="a00c16ead68ba0b98d325f93e6be4f20e" args="(double x, double y)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a00c16ead68ba0b98d325f93e6be4f20e">MGVector</a> (double x, double y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 2D vector by providing each element data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23995d0ef8f9484448e82db1e18ac194"></a><!-- doxytag: member="MGVector::MGVector" ref="a23995d0ef8f9484448e82db1e18ac194" args="(double x, double y, double z)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a23995d0ef8f9484448e82db1e18ac194">MGVector</a> (double x, double y, double z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 3D vector by providing each element data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b6df6a1cfd90a1f70b20b99575ed86"></a><!-- doxytag: member="MGVector::MGVector" ref="a84b6df6a1cfd90a1f70b20b99575ed86" args="(double x, double y, double z, double w)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a84b6df6a1cfd90a1f70b20b99575ed86">MGVector</a> (double x, double y, double z, double w)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct 4D vector by providing each element data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a7d40bafb924f206db03b1192aadabf48">MGVector</a> (size_t sdim, double v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">初期値　v ですべてのエレメントを初期化してベクトルを生成する。 Vector of same value for each coordinate element.  <a href="#a7d40bafb924f206db03b1192aadabf48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#af71bae9f818a04a3f7702a43b1415477">MGVector</a> (size_t sdim, const double *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double の配列でエレメントを初期化してベクトルを生成する。 Vector from array of double v[sdim].  <a href="#af71bae9f818a04a3f7702a43b1415477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a26ef09cd86ab397f1a6ff8abba6de40c">MGVector</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a vector from a class <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>.  <a href="#a26ef09cd86ab397f1a6ff8abba6de40c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b6df327af14d90dbaff9433bc1e3361"></a><!-- doxytag: member="MGVector::MGVector" ref="a0b6df327af14d90dbaff9433bc1e3361" args="(const MGVector &amp;, const MGVector &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a0b6df327af14d90dbaff9433bc1e3361">MGVector</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a vector from a difference of two vectors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a6a4cfe24edb298274418adbcc0a8b0e6">MGVector</a> (size_t sdim, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Source point.  <a href="#a6a4cfe24edb298274418adbcc0a8b0e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a337fbc828941e1841e43159cb81627e8">MGVector</a> (const std::vector&lt; double &gt; &amp;darrays)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of vec2.  <a href="#a337fbc828941e1841e43159cb81627e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a9c73dc52c08e385142c9f9d25a0bac5b">MGVector</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from std::valarray&lt;double&gt; MGVector(const std::valarray&lt;double&gt;&amp; darrays);.  <a href="#a9c73dc52c08e385142c9f9d25a0bac5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0687152f1a84569aeee34e1bc0aca40e"></a><!-- doxytag: member="MGVector::‾MGVector" ref="a0687152f1a84569aeee34e1bc0aca40e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGVector</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e1725f1e9ac65e787b0078208e786e1"></a><!-- doxytag: member="MGVector::operator=" ref="a3e1725f1e9ac65e787b0078208e786e1" args="(const MGVector &amp;)" -->
<a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a3e1725f1e9ac65e787b0078208e786e1">operator=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe764bcd4a822314930d9c567969ec6e"></a><!-- doxytag: member="MGVector::operator()" ref="afe764bcd4a822314930d9c567969ec6e" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#afe764bcd4a822314930d9c567969ec6e">operator()</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return i-th element of the vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35326d4f11830cea742a1c251b16f4b7"></a><!-- doxytag: member="MGVector::operator[]" ref="a35326d4f11830cea742a1c251b16f4b7" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a35326d4f11830cea742a1c251b16f4b7">operator[]</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return i-th element of the vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a379767e626aa815c2611dd5e4d98ec68">operator()</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th Inteval.  <a href="#a379767e626aa815c2611dd5e4d98ec68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dcbd639fa6259e9051ae0543db95643"></a><!-- doxytag: member="MGVector::operator=" ref="a5dcbd639fa6259e9051ae0543db95643" args="(const double *)" -->
<a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a5dcbd639fa6259e9051ae0543db95643">operator=</a> (const double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update vector data by array of double. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a8e09651b39360f44a1dd3a6013d53fbe">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルに与えられたベクトルを加算して自身のベクトルとする Addition of two vectors.  <a href="#a8e09651b39360f44a1dd3a6013d53fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ad0908550d09e2facfc0c6c8f768ac26d">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">単項マイナス。自身のベクトルを反転し、オブジェクトを生成 Unary minus.  <a href="#ad0908550d09e2facfc0c6c8f768ac26d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#aa6d2237529b35cc165e5c91849a2b4b1">operator-=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルから与えられたベクトルを減算し自身のベクトルとする Subtraction of two vectors.  <a href="#aa6d2237529b35cc165e5c91849a2b4b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a6cee3879e4105976a12c88a6525a722e">operator*=</a> (double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スカラーの乗算を行い自身のベクトルとする Scalar multiplication.  <a href="#a6cee3879e4105976a12c88a6525a722e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a0ec35c9bd00d370146b36bb753cf72"></a><!-- doxytag: member="MGVector::operator*=" ref="a1a0ec35c9bd00d370146b36bb753cf72" args="(const MGVector &amp;vec2)" -->
<a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a1a0ec35c9bd00d370146b36bb753cf72">operator*=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update own vector by vector product output, changes to 3D vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ae52657fe71be244cdc9bed15c93e4ea0">operator/=</a> (double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スカラー除算を行い自身のベクトルとする Scalar division.  <a href="#ae52657fe71be244cdc9bed15c93e4ea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ac60759efea8d861604f14c3051debe7b">angle</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルと与えられたベクトルのなす角度を Radian で返却 Compute angle in radian of two vectors.  <a href="#ac60759efea8d861604f14c3051debe7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a90edca6095152b4d08b22bcb23cc6d83">anglepai</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute angle in radian of two vectors.  <a href="#a90edca6095152b4d08b22bcb23cc6d83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a37ffe784e505aacebf61a4e8243ee4b0">angle2pai</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;N) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the angle in radian that is measured from this to v2 around the normal N.  <a href="#a37ffe784e505aacebf61a4e8243ee4b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#af156c5d4ba217e1e90659a72d518f220">cangle</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルと与えられたベクトルのなす角度を cosΘ で返却する 自身か与えられたベクトルが零ベクトルの時は、cosΘは 1.0 とする Compute angle in cosine of two vectors.  <a href="#af156c5d4ba217e1e90659a72d518f220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d15ac32fe25b60868eb4c6f3609cd73"></a><!-- doxytag: member="MGVector::clear" ref="a3d15ac32fe25b60868eb4c6f3609cd73" args="(double init=0.0)" -->
<a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a3d15ac32fe25b60868eb4c6f3609cd73">clear</a> (double init=0.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all the element by the value init. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04354a5aa490df86236548fcedd8a0aa"></a><!-- doxytag: member="MGVector::data" ref="a04354a5aa490df86236548fcedd8a0aa" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a04354a5aa490df86236548fcedd8a0aa">data</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the 1st address of the array of the vector double data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01b13f28853703544d6f46dab118f46d"></a><!-- doxytag: member="MGVector::data" ref="a01b13f28853703544d6f46dab118f46d" args="()" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ad4a5456424cccf280c8f1d9e2fe230a7">interpolate</a> (double t, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a vector by interpolating two vectors.  <a href="#ad4a5456424cccf280c8f1d9e2fe230a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ab4269876ea21c24081da5a342f80f57d">interpolate_by_rotate</a> (double t, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2, double *ratio=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a vector by interpolating two vectors by rotation.  <a href="#ab4269876ea21c24081da5a342f80f57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a117e4c09d8e23f104fdd7a145dfae8cc">is_collinear</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this and v2 are on a single straight line.  <a href="#a117e4c09d8e23f104fdd7a145dfae8cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ab6e04641e32eb80fa4fe0b93fcc0c24e">is_collinear</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v3) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this, v2, and v3 are on a single straight line.  <a href="#ab6e04641e32eb80fa4fe0b93fcc0c24e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe47474f942912989a05cafd6ff56b21"></a><!-- doxytag: member="MGVector::is_null" ref="afe47474f942912989a05cafd6ff56b21" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#afe47474f942912989a05cafd6ff56b21">is_null</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a2feb9b007c737f6128802ca05fdc6652">is_unit_vector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルが単位ベクトルなら TRUE を返却 Test if the vector is unit.  <a href="#a2feb9b007c737f6128802ca05fdc6652"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bc57eed1705759c26c65bb8747df6de"></a><!-- doxytag: member="MGVector::is_zero_vector" ref="a2bc57eed1705759c26c65bb8747df6de" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a2bc57eed1705759c26c65bb8747df6de">is_zero_vector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true when the vector is a zero vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a8f8b35b309173674756b8996b06418b6">len</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクトルの長さを返却する。 Return vector length.  <a href="#a8f8b35b309173674756b8996b06418b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d41a4ec52d8c8f3c897501153712a71"></a><!-- doxytag: member="MGVector::negate" ref="a3d41a4ec52d8c8f3c897501153712a71" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a3d41a4ec52d8c8f3c897501153712a71">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ae348738ed3c393d800c7bac3ed796640">normalize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">一般ベクトルを単位ベクトル化しオブジェクトを生成 Generate unit vector from the vector.  <a href="#ae348738ed3c393d800c7bac3ed796640"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#adde0033879de1f9d336756121c2660eb">orthogonal</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルと与えられたベクトルが垂直かどうか返却 垂直のばあい TRUE Test if two vectors are orthogonal, i.e.  <a href="#adde0033879de1f9d336756121c2660eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a7083ac449a0b04fd88a2151e9cc89f1b">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PD123=Direction.  <a href="#a7083ac449a0b04fd88a2151e9cc89f1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#aacc4dfa8d140f967e9c1de6b7e2369d7">orthogonize</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the vector that is orthogonal to vec2 and is closest to this.  <a href="#aacc4dfa8d140f967e9c1de6b7e2369d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#afdb029a1cd52099e8fda4b3ae80dc95e">parallel</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルと与えられたベクトルが平行なら TRUE を返却 Test if two vectors are parallel.  <a href="#afdb029a1cd52099e8fda4b3ae80dc95e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affb67f71c2b3a665a14fee2e91a2110c"></a><!-- doxytag: member="MGVector::project" ref="affb67f71c2b3a665a14fee2e91a2110c" args="(const MGVector &amp;v2) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#affb67f71c2b3a665a14fee2e91a2110c">project</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルをベクトル(v2)に射影したベクトルを求める。 v2 が 零ベクトルのとき(*this)が返る。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb6f9f2e9ff0e065c3c16f06b92b3c7"></a><!-- doxytag: member="MGVector::ref" ref="a7eb6f9f2e9ff0e065c3c16f06b92b3c7" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a7eb6f9f2e9ff0e065c3c16f06b92b3c7">ref</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to i-th element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a85f2447c375b4b7ad61b87cce5b2f7f8">resize</a> (size_t new_sdim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the vector, that is , change space dimension.  <a href="#a85f2447c375b4b7ad61b87cce5b2f7f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a4bd30d71caa61c5c0163d32a9b1dd18a">sangle</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身のベクトルと与えられたベクトルのなす角度の sin値を返却 Compute angle in sine of two vectors.  <a href="#a4bd30d71caa61c5c0163d32a9b1dd18a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28db4857b197854fb414e9e847786138"></a><!-- doxytag: member="MGVector::sdim" ref="a28db4857b197854fb414e9e847786138" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a28db4857b197854fb414e9e847786138">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a65417f6adb21dec8581bd579e617c"></a><!-- doxytag: member="MGVector::set_null" ref="a03a65417f6adb21dec8581bd579e617c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a03a65417f6adb21dec8581bd579e617c">set_null</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this as a null vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33664a6b9f77f5bde824ff1ef4a42570"></a><!-- doxytag: member="MGVector::set_unit" ref="a33664a6b9f77f5bde824ff1ef4a42570" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a33664a6b9f77f5bde824ff1ef4a42570">set_unit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change this to a unit vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a7842a3323ff0cd1e368487c71e98b765">store_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2, size_t j=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store vec2 data into *this.  <a href="#a7842a3323ff0cd1e368487c71e98b765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a8ba1b5a583a62a06e7eb0033f7bff343">store_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2, size_t j, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Displacement of vec2.  <a href="#a8ba1b5a583a62a06e7eb0033f7bff343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#aad25f525355da5e9215b22ee2a657343">swap</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length to store.  <a href="#aad25f525355da5e9215b22ee2a657343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a34f5050a482f1683bae195de721a4864">dump_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Functions.  <a href="#a34f5050a482f1683bae195de721a4864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac830df9f11ddf22f862ce896e68c3811"></a><!-- doxytag: member="MGVector::dump" ref="ac830df9f11ddf22f862ce896e68c3811" args="(MGOfstream &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ac830df9f11ddf22f862ce896e68c3811">dump</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a073a5a8b1feac980ddb31801b89f6c"></a><!-- doxytag: member="MGVector::restore" ref="a2a073a5a8b1feac980ddb31801b89f6c" args="(MGIfstream &amp;)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a2a073a5a8b1feac980ddb31801b89f6c">restore</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore Function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ac9aabd86d47b429ffe506b88602f46a9">set</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To hold vector length if computed.  <a href="#ac9aabd86d47b429ffe506b88602f46a9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a687372d1a7dc9524d276fddb4f1bfa5a">m_sdim</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Friend Function.  <a href="#a687372d1a7dc9524d276fddb4f1bfa5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a361d710cdad2ae6ac1e15770e729cf30"></a><!-- doxytag: member="MGVector::m_element" ref="a361d710cdad2ae6ac1e15770e729cf30" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_element</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c2df5825e53233e94cee3202100e710"></a><!-- doxytag: member="MGVector::m_data" ref="a4c2df5825e53233e94cee3202100e710" args="[3]" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_data</b> [3]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad915b61a3c78445bc9e5a9b8b66f45d5"></a><!-- doxytag: member="MGVector::m_length" ref="ad915b61a3c78445bc9e5a9b8b66f45d5" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ad915b61a3c78445bc9e5a9b8b66f45d5">m_length</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For vector data of space dimension less or equal to 3. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23669e08ae9e6c150b0deb0d002fa39a"></a><!-- doxytag: member="MGVector::MGLBRep" ref="a23669e08ae9e6c150b0deb0d002fa39a" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a23669e08ae9e6c150b0deb0d002fa39a">MGLBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af11460e1f16d901b0f4ceeeee4b37047"></a><!-- doxytag: member="MGVector::MGSBRep" ref="af11460e1f16d901b0f4ceeeee4b37047" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#af11460e1f16d901b0f4ceeeee4b37047">MGSBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a56f613798d55d9d635d6a88e9f8e28dd">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクトルの加算 Addition of two vectors.  <a href="#a56f613798d55d9d635d6a88e9f8e28dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a6ae835588fce72b5118a8a165e3d7b6f">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクトルの減算 Subtraction of two vectors.  <a href="#a6ae835588fce72b5118a8a165e3d7b6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a883a9d243382165d68066e79478c0e8f">operator%</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクトルの内積 Inner product of two vectors.  <a href="#a883a9d243382165d68066e79478c0e8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a413afc198fc4b18e74883752b4e9d8c7">operator*</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクタの外積 vector product of two vectors.  <a href="#a413afc198fc4b18e74883752b4e9d8c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#ad07100f1de5115bbfa6f943cfd3e3e4b">operator*</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec1, double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スカラーの乗算を行いオブジェクトを生成 Scalar multiplication.  <a href="#ad07100f1de5115bbfa6f943cfd3e3e4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a9a206d70368218948d9864e776ce7f7e">operator*</a> (double, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ベクトルのスカラー乗算を行いオブジェクトを生成 Scalar multiplication.  <a href="#a9a206d70368218948d9864e776ce7f7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a8927f991e9e43e4c62dd0cbe3b90ff53">operator/</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec1, double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スカラー除算を行いオブジェクトを生成 Scalar division.  <a href="#a8927f991e9e43e4c62dd0cbe3b90ff53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#af4ec0737524dee9b0fd02c3feb795638">operator&lt;</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this vector is less than v2.  <a href="#af4ec0737524dee9b0fd02c3feb795638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59bf1fab19872c600b06550d013688ed"></a><!-- doxytag: member="MGVector::operator&lt;=" ref="a59bf1fab19872c600b06550d013688ed" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a31bc309e42f53348d303331eea072"></a><!-- doxytag: member="MGVector::operator&gt;" ref="a38a31bc309e42f53348d303331eea072" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69f6745c306c763c2fe5516c4d333a21"></a><!-- doxytag: member="MGVector::operator&gt;=" ref="a69f6745c306c763c2fe5516c4d333a21" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a990b6940c270a2d6acedb54ee3198a77">operator==</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたベクトルの成分の値を比較し、同じであれば TRUE を返却 Test if two vectors are equal.  <a href="#a990b6940c270a2d6acedb54ee3198a77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#adce3af49b50991f2cf1709e9258d2166">operator!=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたベクトルの成分の値を比較し、not equalのとき TRUE を返却 Test if two vectors are equal.  <a href="#adce3af49b50991f2cf1709e9258d2166"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b28490ee82aa1bf00d9055efce5da43"></a><!-- doxytag: member="MGVector::operator&lt;&lt;" ref="a1b28490ee82aa1bf00d9055efce5da43" args="(std::ostream &amp;, const MGVector &amp;)" -->
MGDECL friend std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a1b28490ee82aa1bf00d9055efce5da43">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String stream function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_vector.html#a9fec928867666525e815e862e362c197">MGDeterminant</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v1, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v2, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">３つのベクトルから求められる行列の行列式の値を返却する。 Determinant of 3 by 3 matrix of 3 vectors.  <a href="#a9fec928867666525e815e862e362c197"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Vector of a general n space dimension. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d40bafb924f206db03b1192aadabf48"></a><!-- doxytag: member="MGVector::MGVector" ref="a7d40bafb924f206db03b1192aadabf48" args="(size_t sdim, double v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGVector::MGVector </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>初期値　v ですべてのエレメントを初期化してベクトルを生成する。 Vector of same value for each coordinate element. </p>

</div>
</div>
<a class="anchor" id="af71bae9f818a04a3f7702a43b1415477"></a><!-- doxytag: member="MGVector::MGVector" ref="af71bae9f818a04a3f7702a43b1415477" args="(size_t sdim, const double *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGVector::MGVector </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>double の配列でエレメントを初期化してベクトルを生成する。 Vector from array of double v[sdim]. </p>
<p>This is the fundamental constructor.***** </p>

</div>
</div>
<a class="anchor" id="a26ef09cd86ab397f1a6ff8abba6de40c"></a><!-- doxytag: member="MGVector::MGVector" ref="a26ef09cd86ab397f1a6ff8abba6de40c" args="(const MGPosition &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGVector::MGVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a vector from a class <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a>. </p>
<p>Vector from a position. </p>

</div>
</div>
<a class="anchor" id="a6a4cfe24edb298274418adbcc0a8b0e6"></a><!-- doxytag: member="MGVector::MGVector" ref="a6a4cfe24edb298274418adbcc0a8b0e6" args="(size_t sdim, const MGVector &amp;vec2, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGVector::MGVector </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Source point. </p>
<p>Construct Vector by copying old Vector, changing space dimension and ordering of old coordinates. (*this)(start1+i)=vec2(start2+i). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>Space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Original vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>id of constructing vector that indicates from where to store the elements of vec2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a337fbc828941e1841e43159cb81627e8"></a><!-- doxytag: member="MGVector::MGVector" ref="a337fbc828941e1841e43159cb81627e8" args="(const std::vector&lt; double &gt; &amp;darrays)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGVector::MGVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>darrays</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>id of vec2. </p>
<p>Construct from std::vector&lt;double&gt; </p>

</div>
</div>
<a class="anchor" id="a9c73dc52c08e385142c9f9d25a0bac5b"></a><!-- doxytag: member="MGVector::MGVector" ref="a9c73dc52c08e385142c9f9d25a0bac5b" args="(const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGVector::MGVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct from std::valarray&lt;double&gt; MGVector(const std::valarray&lt;double&gt;&amp; darrays);. </p>
<p>Copy constructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac60759efea8d861604f14c3051debe7b"></a><!-- doxytag: member="MGVector::angle" ref="ac60759efea8d861604f14c3051debe7b" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGVector::angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルと与えられたベクトルのなす角度を Radian で返却 Compute angle in radian of two vectors. </p>
<p>0&lt;= angle &lt;pai. </p>

</div>
</div>
<a class="anchor" id="a37ffe784e505aacebf61a4e8243ee4b0"></a><!-- doxytag: member="MGVector::angle2pai" ref="a37ffe784e505aacebf61a4e8243ee4b0" args="(const MGVector &amp;v2, const MGVector &amp;N) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGVector::angle2pai </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the angle in radian that is measured from this to v2 around the normal N. </p>
<p>The angle's range is 0&lt;= angle &lt;2*pai. Although N is assumed to be parallel to N2=(*this)*v2, N may not perpendicular to v1 and v2, in which case, the projected N to N2 is used to measure the angle. v1.angle2pai(v2,N)+v2.angle2pai(v1,N)=2*pai always holds. </p>

</div>
</div>
<a class="anchor" id="a90edca6095152b4d08b22bcb23cc6d83"></a><!-- doxytag: member="MGVector::anglepai" ref="a90edca6095152b4d08b22bcb23cc6d83" args="(const MGVector &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGVector::anglepai </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute angle in radian of two vectors. </p>
<p>0&lt;= angle &lt;pai. </p>

</div>
</div>
<a class="anchor" id="af156c5d4ba217e1e90659a72d518f220"></a><!-- doxytag: member="MGVector::cangle" ref="af156c5d4ba217e1e90659a72d518f220" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGVector::cangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルと与えられたベクトルのなす角度を cosΘ で返却する 自身か与えられたベクトルが零ベクトルの時は、cosΘは 1.0 とする Compute angle in cosine of two vectors. </p>

</div>
</div>
<a class="anchor" id="a34f5050a482f1683bae195de721a4864"></a><!-- doxytag: member="MGVector::dump_size" ref="a34f5050a482f1683bae195de721a4864" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGVector::dump_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump Functions. </p>
<p>Calculate dump size </p>

</div>
</div>
<a class="anchor" id="ad4a5456424cccf280c8f1d9e2fe230a7"></a><!-- doxytag: member="MGVector::interpolate" ref="ad4a5456424cccf280c8f1d9e2fe230a7" args="(double t, const MGVector &amp;vec2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGVector::interpolate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by interpolating two vectors. </p>
<p>Input scalar is a ratio and when zero, output vector is a copy of *this. New vector vnew=(1-t)*(*this)+t*vec2. </p>

</div>
</div>
<a class="anchor" id="ab4269876ea21c24081da5a342f80f57d"></a><!-- doxytag: member="MGVector::interpolate_by_rotate" ref="ab4269876ea21c24081da5a342f80f57d" args="(double t, const MGVector &amp;vec2, double *ratio=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGVector::interpolate_by_rotate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>ratio</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by interpolating two vectors by rotation. </p>
<p>Input scalar t is a ratio and when t is zero, output vector is a copy of *this and when t=1., output is vec2. New vector vnew=a*(*this)+b*vec2, where a=sin(theta2)/sin(theta), b=sin(theta1)/sin(theta). Here, theta=angle of *this and vec2. theta1=t*theta, theta2=theta-theta1. theta may be zero. When ratio is not null, ratio[0]=a and ratio[1]=b will be returned. </p>

</div>
</div>
<a class="anchor" id="a117e4c09d8e23f104fdd7a145dfae8cc"></a><!-- doxytag: member="MGVector::is_collinear" ref="a117e4c09d8e23f104fdd7a145dfae8cc" args="(const MGVector &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGVector::is_collinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this and v2 are on a single straight line. </p>
<p>Function's return value is true if the three points are on a straight, false if not. </p>

</div>
</div>
<a class="anchor" id="ab6e04641e32eb80fa4fe0b93fcc0c24e"></a><!-- doxytag: member="MGVector::is_collinear" ref="ab6e04641e32eb80fa4fe0b93fcc0c24e" args="(const MGVector &amp;v2, const MGVector &amp;v3) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGVector::is_collinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this, v2, and v3 are on a single straight line. </p>
<p>Function's return value is true if the three points are on a straight, false if not. </p>

</div>
</div>
<a class="anchor" id="a2feb9b007c737f6128802ca05fdc6652"></a><!-- doxytag: member="MGVector::is_unit_vector" ref="a2feb9b007c737f6128802ca05fdc6652" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGVector::is_unit_vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルが単位ベクトルなら TRUE を返却 Test if the vector is unit. </p>

</div>
</div>
<a class="anchor" id="a8f8b35b309173674756b8996b06418b6"></a><!-- doxytag: member="MGVector::len" ref="a8f8b35b309173674756b8996b06418b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGVector::len </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ベクトルの長さを返却する。 Return vector length. </p>

</div>
</div>
<a class="anchor" id="ae348738ed3c393d800c7bac3ed796640"></a><!-- doxytag: member="MGVector::normalize" ref="ae348738ed3c393d800c7bac3ed796640" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> MGVector::normalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>一般ベクトルを単位ベクトル化しオブジェクトを生成 Generate unit vector from the vector. </p>

</div>
</div>
<a class="anchor" id="a379767e626aa815c2611dd5e4d98ec68"></a><!-- doxytag: member="MGVector::operator()" ref="a379767e626aa815c2611dd5e4d98ec68" args="(size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; MGVector::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access to i-th Inteval. </p>
<p>This is left hand side value operator. If only regference is needed, operator[] should be used. </p>

</div>
</div>
<a class="anchor" id="a6cee3879e4105976a12c88a6525a722e"></a><!-- doxytag: member="MGVector::operator*=" ref="a6cee3879e4105976a12c88a6525a722e" args="(double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>スカラーの乗算を行い自身のベクトルとする Scalar multiplication. </p>

</div>
</div>
<a class="anchor" id="a8e09651b39360f44a1dd3a6013d53fbe"></a><!-- doxytag: member="MGVector::operator+=" ref="a8e09651b39360f44a1dd3a6013d53fbe" args="(const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルに与えられたベクトルを加算して自身のベクトルとする Addition of two vectors. </p>

<p>Reimplemented in <a class="el" href="class_m_g_unit__vector.html#a3a1f90a95bb0b5d613b51c656670ff6a">MGUnit_vector</a>.</p>

</div>
</div>
<a class="anchor" id="ad0908550d09e2facfc0c6c8f768ac26d"></a><!-- doxytag: member="MGVector::operator&#45;" ref="ad0908550d09e2facfc0c6c8f768ac26d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGVector::operator- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>単項マイナス。自身のベクトルを反転し、オブジェクトを生成 Unary minus. </p>
<p>Negate all the elements of the vector. </p>

<p>Reimplemented in <a class="el" href="class_m_g_unit__vector.html#a3682f5f4fc79f11154e28c993a639673">MGUnit_vector</a>.</p>

</div>
</div>
<a class="anchor" id="aa6d2237529b35cc165e5c91849a2b4b1"></a><!-- doxytag: member="MGVector::operator&#45;=" ref="aa6d2237529b35cc165e5c91849a2b4b1" args="(const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルから与えられたベクトルを減算し自身のベクトルとする Subtraction of two vectors. </p>

<p>Reimplemented in <a class="el" href="class_m_g_unit__vector.html#a376ca905c348fcb52d7448395b086fbd">MGUnit_vector</a>.</p>

</div>
</div>
<a class="anchor" id="ae52657fe71be244cdc9bed15c93e4ea0"></a><!-- doxytag: member="MGVector::operator/=" ref="ae52657fe71be244cdc9bed15c93e4ea0" args="(double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGVector::operator/= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>スカラー除算を行い自身のベクトルとする Scalar division. </p>

</div>
</div>
<a class="anchor" id="adde0033879de1f9d336756121c2660eb"></a><!-- doxytag: member="MGVector::orthogonal" ref="adde0033879de1f9d336756121c2660eb" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGVector::orthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルと与えられたベクトルが垂直かどうか返却 垂直のばあい TRUE Test if two vectors are orthogonal, i.e. </p>
<p>cross at right angle. </p>

</div>
</div>
<a class="anchor" id="aacc4dfa8d140f967e9c1de6b7e2369d7"></a><!-- doxytag: member="MGVector::orthogonize" ref="aacc4dfa8d140f967e9c1de6b7e2369d7" args="(const MGVector &amp;vec2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGVector::orthogonize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the vector that is orthogonal to vec2 and is closest to this. </p>
<p>"closest" means that the angle of the two vectors is minimum and the two vector length are equal. </p>

</div>
</div>
<a class="anchor" id="a7083ac449a0b04fd88a2151e9cc89f1b"></a><!-- doxytag: member="MGVector::out_to_IGES" ref="a7083ac449a0b04fd88a2151e9cc89f1b" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGVector::out_to_IGES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>igesfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>SubordinateEntitySwitch</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PD123=Direction. </p>
<p>Function's return value is the directory entry id created. </p>

</div>
</div>
<a class="anchor" id="afdb029a1cd52099e8fda4b3ae80dc95e"></a><!-- doxytag: member="MGVector::parallel" ref="afdb029a1cd52099e8fda4b3ae80dc95e" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGVector::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルと与えられたベクトルが平行なら TRUE を返却 Test if two vectors are parallel. </p>

</div>
</div>
<a class="anchor" id="a85f2447c375b4b7ad61b87cce5b2f7f8"></a><!-- doxytag: member="MGVector::resize" ref="a85f2447c375b4b7ad61b87cce5b2f7f8" args="(size_t new_sdim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGVector::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>new_sdim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize the vector, that is , change space dimension. </p>
<p>When this is enlarged, the extra space will contain garbages. </p>

</div>
</div>
<a class="anchor" id="a4bd30d71caa61c5c0163d32a9b1dd18a"></a><!-- doxytag: member="MGVector::sangle" ref="a4bd30d71caa61c5c0163d32a9b1dd18a" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGVector::sangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身のベクトルと与えられたベクトルのなす角度の sin値を返却 Compute angle in sine of two vectors. </p>
<p>sanlge&gt;=0. </p>

</div>
</div>
<a class="anchor" id="ac9aabd86d47b429ffe506b88602f46a9"></a><!-- doxytag: member="MGVector::set" ref="ac9aabd86d47b429ffe506b88602f46a9" args="(size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; MGVector::set </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To hold vector length if computed. </p>
<p>When length not computed, negative value will be set. Set data at element i. This should be used with care, since m__length will not be set. Maintenance of m_length should be done by the user, that is, m_length=-1 must set if updated. </p>

</div>
</div>
<a class="anchor" id="a7842a3323ff0cd1e368487c71e98b765"></a><!-- doxytag: member="MGVector::store_at" ref="a7842a3323ff0cd1e368487c71e98b765" args="(size_t i, const MGVector &amp;vec2, size_t j=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGVector::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store vec2 data into *this. </p>
<p>Store length is vec2.len(). Storing will be done rap-around. That is, if id i or j reached to each <a class="el" href="class_m_g_vector.html#a28db4857b197854fb414e9e847786138" title="Get the space dimension.">sdim()</a>, the id will be changed to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>Displacement of *this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>j</em>&nbsp;</td><td>Vector 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ba1b5a583a62a06e7eb0033f7bff343"></a><!-- doxytag: member="MGVector::store_at" ref="a8ba1b5a583a62a06e7eb0033f7bff343" args="(size_t i, const MGVector &amp;vec2, size_t j, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGVector::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Displacement of vec2. </p>
<p>Store vec2 data into *this. Storing will be done rap-around. That is, if id i or j reached to each <a class="el" href="class_m_g_vector.html#a28db4857b197854fb414e9e847786138" title="Get the space dimension.">sdim()</a>, the id will be changed to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>Displacement of *this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>j</em>&nbsp;</td><td>Vector 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Displacement of vec2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad25f525355da5e9215b22ee2a657343"></a><!-- doxytag: member="MGVector::swap" ref="aad25f525355da5e9215b22ee2a657343" args="(size_t i, size_t j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGVector::swap </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Length to store. </p>
<p>swap two coordinates. swap coordinates (i) and (j). </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a9fec928867666525e815e862e362c197"></a><!-- doxytag: member="MGVector::MGDeterminant" ref="a9fec928867666525e815e862e362c197" args="(const MGVector &amp;v1, const MGVector &amp;v2, const MGVector &amp;v3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend double MGDeterminant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>３つのベクトルから求められる行列の行列式の値を返却する。 Determinant of 3 by 3 matrix of 3 vectors. </p>

</div>
</div>
<a class="anchor" id="adce3af49b50991f2cf1709e9258d2166"></a><!-- doxytag: member="MGVector::operator!=" ref="adce3af49b50991f2cf1709e9258d2166" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたベクトルの成分の値を比較し、not equalのとき TRUE を返却 Test if two vectors are equal. </p>

</div>
</div>
<a class="anchor" id="a883a9d243382165d68066e79478c0e8f"></a><!-- doxytag: member="MGVector::operator%" ref="a883a9d243382165d68066e79478c0e8f" args="(const MGVector &amp;vec1, const MGVector &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend double operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ベクトルの内積 Inner product of two vectors. </p>

</div>
</div>
<a class="anchor" id="a9a206d70368218948d9864e776ce7f7e"></a><!-- doxytag: member="MGVector::operator*" ref="a9a206d70368218948d9864e776ce7f7e" args="(double, const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ベクトルのスカラー乗算を行いオブジェクトを生成 Scalar multiplication. </p>

</div>
</div>
<a class="anchor" id="ad07100f1de5115bbfa6f943cfd3e3e4b"></a><!-- doxytag: member="MGVector::operator*" ref="ad07100f1de5115bbfa6f943cfd3e3e4b" args="(const MGVector &amp;vec1, double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>スカラーの乗算を行いオブジェクトを生成 Scalar multiplication. </p>

</div>
</div>
<a class="anchor" id="a413afc198fc4b18e74883752b4e9d8c7"></a><!-- doxytag: member="MGVector::operator*" ref="a413afc198fc4b18e74883752b4e9d8c7" args="(const MGVector &amp;vec1, const MGVector &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ベクタの外積 vector product of two vectors. </p>

</div>
</div>
<a class="anchor" id="a56f613798d55d9d635d6a88e9f8e28dd"></a><!-- doxytag: member="MGVector::operator+" ref="a56f613798d55d9d635d6a88e9f8e28dd" args="(const MGVector &amp;vec1, const MGVector &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ベクトルの加算 Addition of two vectors. </p>

</div>
</div>
<a class="anchor" id="a6ae835588fce72b5118a8a165e3d7b6f"></a><!-- doxytag: member="MGVector::operator&#45;" ref="a6ae835588fce72b5118a8a165e3d7b6f" args="(const MGVector &amp;vec1, const MGVector &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ベクトルの減算 Subtraction of two vectors. </p>

</div>
</div>
<a class="anchor" id="a8927f991e9e43e4c62dd0cbe3b90ff53"></a><!-- doxytag: member="MGVector::operator/" ref="a8927f991e9e43e4c62dd0cbe3b90ff53" args="(const MGVector &amp;vec1, double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_vector.html">MGVector</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>スカラー除算を行いオブジェクトを生成 Scalar division. </p>

</div>
</div>
<a class="anchor" id="af4ec0737524dee9b0fd02c3feb795638"></a><!-- doxytag: member="MGVector::operator&lt;" ref="af4ec0737524dee9b0fd02c3feb795638" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this vector is less than v2. </p>
<p>Comparison depends on two vectors' length. </p>

</div>
</div>
<a class="anchor" id="a990b6940c270a2d6acedb54ee3198a77"></a><!-- doxytag: member="MGVector::operator==" ref="a990b6940c270a2d6acedb54ee3198a77" args="(const MGVector &amp;v1, const MGVector &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたベクトルの成分の値を比較し、同じであれば TRUE を返却 Test if two vectors are equal. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a687372d1a7dc9524d276fddb4f1bfa5a"></a><!-- doxytag: member="MGVector::m_sdim" ref="a687372d1a7dc9524d276fddb4f1bfa5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_m_g_vector.html#a687372d1a7dc9524d276fddb4f1bfa5a">MGVector::m_sdim</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Friend Function. </p>
<p>Protected data member </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Vector.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:31 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

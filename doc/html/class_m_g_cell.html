<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGCell Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGCell Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGCell" --><!-- doxytag: inherits="MGCellNB" -->
<p><a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a> is a general cell that has bound.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Cell.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGCell:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_cell__inherit__graph.png" border="0" usemap="#_m_g_cell_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_cell_inherit__map" id="_m_g_cell_inherit__map">
<area shape="rect" id="node15" href="class_m_g_face.html" title="MGFace is a trimmed surface." alt="" coords="23,547,95,576"/><area shape="rect" id="node2" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="17,392,100,421"/><area shape="rect" id="node4" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="12,315,105,344"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="12,237,105,267"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGCell:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_cell__coll__graph.png" border="0" usemap="#_m_g_cell_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_cell_coll__map" id="_m_g_cell_coll__map">
<area shape="rect" id="node2" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="235,677,317,707"/><area shape="rect" id="node4" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="156,773,249,803"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="120,485,213,515"/><area shape="rect" id="node32" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="153,581,247,611"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="163,373,243,403"/><area shape="rect" id="node23" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="271,581,369,611"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node16" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node14" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,261,167,291"/><area shape="rect" id="node19" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node26" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="308,485,375,515"/><area shape="rect" id="node28" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="300,373,383,403"/><area shape="rect" id="node30" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="303,261,380,291"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_cell-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17831f5a8e8091be4c268c6769f90a47"></a><!-- doxytag: member="MGCell::boundaryItr" ref="a17831f5a8e8091be4c268c6769f90a47" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>boundaryItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeac764e6d702653a2b54939b8b4d0ba9"></a><!-- doxytag: member="MGCell::const_boundaryItr" ref="aeac764e6d702653a2b54939b8b4d0ba9" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_boundaryItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbbf066f7de06dcab11e1f9f6e405244"></a><!-- doxytag: member="MGCell::boundaryRItr" ref="acbbf066f7de06dcab11e1f9f6e405244" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt;<br class="typebreak"/>
::reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>boundaryRItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f270ecec1a3224cd3c184c5ad90894"></a><!-- doxytag: member="MGCell::const_boundaryRItr" ref="a58f270ecec1a3224cd3c184c5ad90894" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt;<br class="typebreak"/>
::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_boundaryRItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa97634483de4c4354471cdea3c6b0792"></a><!-- doxytag: member="MGCell::iterator" ref="aa97634483de4c4354471cdea3c6b0792" args="" -->
typedef boundaryItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c8c89068dba50ebaa492e97cd4dac69"></a><!-- doxytag: member="MGCell::const_iterator" ref="a1c8c89068dba50ebaa492e97cd4dac69" args="" -->
typedef const_boundaryItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64b546ee207b7d2d8bc653b925bec808"></a><!-- doxytag: member="MGCell::reverse_iterator" ref="a64b546ee207b7d2d8bc653b925bec808" args="" -->
typedef boundaryRItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9875ddfe7a3fec132e5f7d89d43c7d1"></a><!-- doxytag: member="MGCell::const_reverse_iterator" ref="af9875ddfe7a3fec132e5f7d89d43c7d1" args="" -->
typedef const_boundaryRItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d15ed9d9ada262da696c3848ed6f734"></a><!-- doxytag: member="MGCell::MGCell" ref="a9d15ed9d9ada262da696c3848ed6f734" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a9d15ed9d9ada262da696c3848ed6f734">MGCell</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor. Constructor of pcell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a5e0310787831ec092d8d6c2e5bcefdf2">MGCell</a> (const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;cell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a5e0310787831ec092d8d6c2e5bcefdf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a28a133843fdb5728a0ad1834f6a2e34c">MGCell</a> (const <a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;geo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a> of whole geometry(no boundary), under parent.  <a href="#a28a133843fdb5728a0ad1834f6a2e34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bdbac1eda0e3f8e542f960b932e6859"></a><!-- doxytag: member="MGCell::MGCell" ref="a3bdbac1eda0e3f8e542f960b932e6859" args="(MGGeometry *geo)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGCell</b> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> *geo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ad6d34cdc2276801b1f6799063f0a47da">MGCell</a> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> *geo, std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;boundaries, <a class="el" href="class_m_g_cell.html">MGCell</a> *binder)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a parameter cell from all the necessary data, geo, vector of boundaries, and the binder.  <a href="#ad6d34cdc2276801b1f6799063f0a47da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ae56cf0a63fb0122dbaf48434497246bd">MGCell</a> (const <a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;geo, const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;boundaries)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter Cell with boundaries.  <a href="#ae56cf0a63fb0122dbaf48434497246bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43ac3c8ea8df06d068ecbccac9ec9831"></a><!-- doxytag: member="MGCell::MGCell" ref="a43ac3c8ea8df06d068ecbccac9ec9831" args="(MGGeometry *geo, const std::vector&lt; MGBoundary * &gt; &amp;boundaries)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGCell</b> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> *geo, const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;boundaries)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0e090464d8444c72da4d8b30486e52"></a><!-- doxytag: member="MGCell::‾MGCell" ref="a2b0e090464d8444c72da4d8b30486e52" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGCell</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a69d64ba582d97f5bbdf456c5f537096f">operator=</a> (const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a69d64ba582d97f5bbdf456c5f537096f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07344732bb04f4f08de6a2d5f48ddbd4"></a><!-- doxytag: member="MGCell::operator&lt;" ref="a07344732bb04f4f08de6a2d5f48ddbd4" args="(const MGCell &amp;gel2) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a07344732bb04f4f08de6a2d5f48ddbd4">operator&lt;</a> (const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a2f6278e1b5cb91e55ffd11d190fa4909">append_boundary</a> (<a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bound)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append new one boundary to boundary vectors.  <a href="#a2f6278e1b5cb91e55ffd11d190fa4909"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a609e88343f5d4e5e00e50448246a1476"></a><!-- doxytag: member="MGCell::boundary" ref="a609e88343f5d4e5e00e50448246a1476" args="(size_t i)" -->
<a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a609e88343f5d4e5e00e50448246a1476">boundary</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th boundary pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008f9428b45374dc7e1d05dffe47fdf4"></a><!-- doxytag: member="MGCell::boundary" ref="a008f9428b45374dc7e1d05dffe47fdf4" args="(size_t i) const " -->
const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>boundary</b> (size_t i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005cd2071b1e859b2964945cb7b8efa8"></a><!-- doxytag: member="MGCell::boundaries" ref="a005cd2071b1e859b2964945cb7b8efa8" args="() const " -->
const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a005cd2071b1e859b2964945cb7b8efa8">boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain boundaries of this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ad31e261f2d53b990a36a07933cb4f188">boundary_direction</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th boundary's j-th pcell direction (direction of boundary measured by this cell's coordinate along the boundary).  <a href="#ad31e261f2d53b990a36a07933cb4f188"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb7e69741a0cd8a66cbae9f4012dd9c6"></a><!-- doxytag: member="MGCell::boundaryIterator" ref="aeb7e69741a0cd8a66cbae9f4012dd9c6" args="(const MGBoundary *bnd) const " -->
const_boundaryItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#aeb7e69741a0cd8a66cbae9f4012dd9c6">boundaryIterator</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bnd) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain iterator of m_boundaries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abebae9123766758fc6dc522aa47db9b8"></a><!-- doxytag: member="MGCell::boundaryIterator" ref="abebae9123766758fc6dc522aa47db9b8" args="(MGBoundary *bnd)" -->
boundaryItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>boundaryIterator</b> (<a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bnd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6208ba39228367ea6bc04dca269e805a"></a><!-- doxytag: member="MGCell::box" ref="a6208ba39228367ea6bc04dca269e805a" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a6208ba39228367ea6bc04dca269e805a">box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the box of the cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a335787e945ef91a7d048d04d1c62837e"></a><!-- doxytag: member="MGCell::center_param" ref="a335787e945ef91a7d048d04d1c62837e" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a335787e945ef91a7d048d04d1c62837e">center_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the center parameter value of this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a1b5ffbed1723670e566c5420c9663124">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of the cell.  <a href="#a1b5ffbed1723670e566c5420c9663124"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#aa3c8948a3af77ced7e2158182e9b2cfb">clone_without_boundaries</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of the cell without boundaries.  <a href="#aa3c8948a3af77ced7e2158182e9b2cfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ab0c8dab0a35dedf181eb6622ca8e757b">clone_binder</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;c) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of this(this is a binder), and set binder and parameter cell relation between the new binder and the parameter cell pcell.  <a href="#ab0c8dab0a35dedf181eb6622ca8e757b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ad90ebdefd2282e8a49af54d605bef7b7">connect</a> (size_t i1, size_t j1, <a class="el" href="class_m_g_cell.html">MGCell</a> *cell2, size_t i2, size_t j2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect i1-th boundary's j1-th pcell of this to i2-th boundary's j2-th pcell of cell2.  <a href="#ad90ebdefd2282e8a49af54d605bef7b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a76c43ff40d3fd3ea3655b5396eaf89c1">draw3DVertex</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D point(vertex) in world coordinates.  <a href="#a76c43ff40d3fd3ea3655b5396eaf89c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ac29dee9aea2b0b38432f163faa4417d3">erase_boundary</a> (iterator i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase i-th boundary.  <a href="#ac29dee9aea2b0b38432f163faa4417d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a543c22a29fb2565437dfe8e935ada743"></a><!-- doxytag: member="MGCell::erase_boundary" ref="a543c22a29fb2565437dfe8e935ada743" args="(size_t i)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>erase_boundary</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d296514b741eb7246f701c6d3cca444"></a><!-- doxytag: member="MGCell::erase_boundary" ref="a7d296514b741eb7246f701c6d3cca444" args="(MGBoundary *bnd)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a7d296514b741eb7246f701c6d3cca444">erase_boundary</a> (<a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bnd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">erase_boundary removes from this cell's bounary and destruct the boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ac06eebac0ed8e1cf6c002045b162a338">free_boundary</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bound)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free specified boundary(bound) from a member of parent cell's boundaries.  <a href="#ac06eebac0ed8e1cf6c002045b162a338"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36b70104dfc7833cf0c4f05d3a51ccd3"></a><!-- doxytag: member="MGCell::free_neighbourhood" ref="a36b70104dfc7833cf0c4f05d3a51ccd3" args="(size_t i, size_t j=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a36b70104dfc7833cf0c4f05d3a51ccd3">free_neighbourhood</a> (size_t i, size_t j=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free neighbourhood relation at j-th boundary's i-th pcell of this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75ff3c1c7fc343a4b0da51540c0cd699"></a><!-- doxytag: member="MGCell::identify_type" ref="a75ff3c1c7fc343a4b0da51540c0cd699" args="() const =0" -->
virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a75ff3c1c7fc343a4b0da51540c0cd699">identify_type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ad68606321567c22d2d908d3c4917ade3">make_binder</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a binder cell of this parameter cell.  <a href="#ad68606321567c22d2d908d3c4917ade3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b79cf7fac0350833a6a2e1833ec8935"></a><!-- doxytag: member="MGCell::manifold_dimension" ref="a5b79cf7fac0350833a6a2e1833ec8935" args="() const =0" -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a5b79cf7fac0350833a6a2e1833ec8935">manifold_dimension</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a24370a5c8ff67fc14de44dfd69dd705d">neighbours</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the neighbours.  <a href="#a24370a5c8ff67fc14de44dfd69dd705d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a1b1aca53a54cf1f562e363dc8a05c612">neighbours</a> (size_t i, size_t j=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return neighbours at the j-th boundary's i-th pcell.  <a href="#a1b1aca53a54cf1f562e363dc8a05c612"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61806ea4be0ed7f8975e4cfbe56263f5"></a><!-- doxytag: member="MGCell::number_of_boundaries" ref="a61806ea4be0ed7f8975e4cfbe56263f5" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a61806ea4be0ed7f8975e4cfbe56263f5">number_of_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of boundaries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dfd191502a52893cc4ae024dc5e2b3c"></a><!-- doxytag: member="MGCell::parameter_error" ref="a8dfd191502a52893cc4ae024dc5e2b3c" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a8dfd191502a52893cc4ae024dc5e2b3c">parameter_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter space error of the cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ab2d48972b5978e0bd94fe42ea037cdfc">prepend_boundary</a> (<a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bound)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend new one boundary to boundary vectors.  <a href="#ab2d48972b5978e0bd94fe42ea037cdfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#abe6827579a144172c348309894d30ecc">sort_boundaries</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort boundary occurreces in m_boundaries.  <a href="#abe6827579a144172c348309894d30ecc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ec8f20b9876c0b610d9db0a3721913"></a><!-- doxytag: member="MGCell::out" ref="a52ec8f20b9876c0b610d9db0a3721913" args="(std::ostream &amp;) const " -->
virtual std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a52ec8f20b9876c0b610d9db0a3721913">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a2d63b5e8dc4bf0e89142aaffb6946346">clone</a> (MGCellMap &amp;cmap) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a new <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a> pointer by newing the original <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a>.  <a href="#a2d63b5e8dc4bf0e89142aaffb6946346"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35df84c3d861367aa1a73b0b3c51e3ac"></a><!-- doxytag: member="MGCell::compute_box" ref="a35df84c3d861367aa1a73b0b3c51e3ac" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a35df84c3d861367aa1a73b0b3c51e3ac">compute_box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute box of the cell in m_box. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a193367353c59a0e82c298df70b361c6f"></a><!-- doxytag: member="MGCell::set_box_as_null" ref="a193367353c59a0e82c298df70b361c6f" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a193367353c59a0e82c298df70b361c6f">set_box_as_null</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set box as null(to set the box as initial) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabe02b23d3bf9eb0d92944b88eef4d12"></a><!-- doxytag: member="MGCell::copy_all_boundaries" ref="aabe02b23d3bf9eb0d92944b88eef4d12" args="(const MGCellBase &amp;cell)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#aabe02b23d3bf9eb0d92944b88eef4d12">copy_all_boundaries</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all boundaries into this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a412c7dbe92b31086243d3238fbebad21">copy_all_boundaries</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell, MGCellMap &amp;cmap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all boundaries of cell into this, and binders association of the boundaries in the cmap.  <a href="#a412c7dbe92b31086243d3238fbebad21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd8d7eb2f5a415b9c3300da9ddf15565"></a><!-- doxytag: member="MGCell::copy_box" ref="acd8d7eb2f5a415b9c3300da9ddf15565" args="(const MGCellBase &amp;cell2) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#acd8d7eb2f5a415b9c3300da9ddf15565">copy_box</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy m_box data of cell2 into this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0828ed232dbe6cdc8cb9a960a905b281"></a><!-- doxytag: member="MGCell::copy_perror" ref="a0828ed232dbe6cdc8cb9a960a905b281" args="(const MGCellBase &amp;cell2) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a0828ed232dbe6cdc8cb9a960a905b281">copy_perror</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy m_perror data of cell2 into this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#adac4c4171869d41af97e49f0f159130b">set_cell</a> (const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;cell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#adac4c4171869d41af97e49f0f159130b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac18a6d4eea5d3ed172150c7da27fcafc"></a><!-- doxytag: member="MGCell::whoami" ref="ac18a6d4eea5d3ed172150c7da27fcafc" args="() const " -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf62695930b6988161aefdf7eeb86e32"></a><!-- doxytag: member="MGCell::ReadMembers" ref="aaf62695930b6988161aefdf7eeb86e32" args="(MGIfstream &amp;buf)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#aaf62695930b6988161aefdf7eeb86e32">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed32dfb7760beb77b35c539bef7b2104"></a><!-- doxytag: member="MGCell::WriteMembers" ref="aed32dfb7760beb77b35c539bef7b2104" args="(MGOfstream &amp;buf) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#aed32dfb7760beb77b35c539bef7b2104">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#ad7efd265124ed5bd5ccee1f9c7c1ad78">m_box</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Box of this cell.  <a href="#ad7efd265124ed5bd5ccee1f9c7c1ad78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c8be5406593c9a76ae0af7b89d58ef4"></a><!-- doxytag: member="MGCell::m_boundaries" ref="a7c8be5406593c9a76ae0af7b89d58ef4" args="" -->
std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a7c8be5406593c9a76ae0af7b89d58ef4">m_boundaries</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector of boundaries who bound this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a5a374337c0ed88e146fd8ed9e8a059b8">m_perror</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error allowed for the parameter space of the cell.  <a href="#a5a374337c0ed88e146fd8ed9e8a059b8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a518243e565e3a5ab40585a6f7f4f28a9"></a><!-- doxytag: member="MGCell::MGComplex" ref="a518243e565e3a5ab40585a6f7f4f28a9" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a518243e565e3a5ab40585a6f7f4f28a9">MGComplex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cfdb21abd2b800d5d5aeeab221fbd2c"></a><!-- doxytag: member="MGCell::MGBoundary" ref="a7cfdb21abd2b800d5d5aeeab221fbd2c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cell.html#a7cfdb21abd2b800d5d5aeeab221fbd2c">MGBoundary</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a> is a general cell that has bound. </p>
<p>MGCell's additional data to CellNB are Boundary, box, and perror. There are two types of cells. One is parameter cell(pcell) and the other is binder cell(bcell). They are exclusive, that is, if a cell is a parameter cell, the cell cannot be binder cell and vice versa. Parameter cell is a constituent of a complex. Binder cell is a binder of parameter cells. Plural cells are connected through a binder. <a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a> is an abstrct class. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5e0310787831ec092d8d6c2e5bcefdf2"></a><!-- doxytag: member="MGCell::MGCell" ref="a5e0310787831ec092d8d6c2e5bcefdf2" args="(const MGCell &amp;cell)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCell::MGCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cell</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Result cell is not a member of any complex. Binders and boundaries of cell will not be copied. Copy of boudaries can be done by <a class="el" href="class_m_g_cell.html#aabe02b23d3bf9eb0d92944b88eef4d12" title="Copy all boundaries into this.">copy_all_boundaries()</a>. </p>

</div>
</div>
<a class="anchor" id="a28a133843fdb5728a0ad1834f6a2e34c"></a><!-- doxytag: member="MGCell::MGCell" ref="a28a133843fdb5728a0ad1834f6a2e34c" args="(const MGGeometry &amp;geo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCell::MGCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a> of whole geometry(no boundary), under parent. </p>
<p>Constructor of pcell. The second form that input MGGeometry* takes the ownership of the geo into the <a class="el" href="class_m_g_cell.html" title="MGCell is a general cell that has bound.">MGCell</a>, must not delete the object and the object must be newed one. </p>

</div>
</div>
<a class="anchor" id="ad6d34cdc2276801b1f6799063f0a47da"></a><!-- doxytag: member="MGCell::MGCell" ref="ad6d34cdc2276801b1f6799063f0a47da" args="(MGGeometry *geo, std::vector&lt; MGBoundary * &gt; &amp;boundaries, MGCell *binder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCell::MGCell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_geometry.html">MGGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>geo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td>
          <td class="paramname"> <em>binder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a parameter cell from all the necessary data, geo, vector of boundaries, and the binder. </p>
<p>The newly constructed parameter cell will be a partner member of the binder 'binder'. Constructor takes the ownership of goe and <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a> in boundaries. </p>

</div>
</div>
<a class="anchor" id="ae56cf0a63fb0122dbaf48434497246bd"></a><!-- doxytag: member="MGCell::MGCell" ref="ae56cf0a63fb0122dbaf48434497246bd" args="(const MGGeometry &amp;geo, const std::vector&lt; MGBoundary * &gt; &amp;boundaries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCell::MGCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_g_boundary.html">MGBoundary</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parameter Cell with boundaries. </p>
<p>Only pcells(parameter representation) in boundaries are copied. Binders(world coordinate representation) in boundaries are discarded. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2f6278e1b5cb91e55ffd11d190fa4909"></a><!-- doxytag: member="MGCell::append_boundary" ref="a2f6278e1b5cb91e55ffd11d190fa4909" args="(MGBoundary *bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGCell::append_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td>
          <td class="paramname"> <em>bound</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append new one boundary to boundary vectors. </p>
<p>Returned is the number of boudaries after appending. </p>

</div>
</div>
<a class="anchor" id="ad31e261f2d53b990a36a07933cb4f188"></a><!-- doxytag: member="MGCell::boundary_direction" ref="ad31e261f2d53b990a36a07933cb4f188" args="(size_t i, size_t j) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGCell::boundary_direction </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th boundary's j-th pcell direction (direction of boundary measured by this cell's coordinate along the boundary). </p>
<p>The direction is represented by the center of the boundary. </p>

</div>
</div>
<a class="anchor" id="a2d63b5e8dc4bf0e89142aaffb6946346"></a><!-- doxytag: member="MGCell::clone" ref="a2d63b5e8dc4bf0e89142aaffb6946346" args="(MGCellMap &amp;cmap) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_cell.html">MGCell</a>* MGCell::clone </td>
          <td>(</td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a new <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a> pointer by newing the original <a class="el" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists.">MGCellBase</a>. </p>
<p>This is a proprietry routine of <a class="el" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells.">MGComplex</a> copy. Copy all boundary data, (but does not copy own binder cell relation) and register boundary binder association of new and old into cmap. </p>

<p>Reimplemented from <a class="el" href="class_m_g_cell_n_b.html#a8071eedf119853d20f8fbe7ccb407f30">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a1b5ffbed1723670e566c5420c9663124"></a><!-- doxytag: member="MGCell::clone" ref="a1b5ffbed1723670e566c5420c9663124" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_cell.html">MGCell</a>* MGCell::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of the cell. </p>
<p><a class="el" href="class_m_g_cell.html#a1b5ffbed1723670e566c5420c9663124" title="Make a clone of the cell.">clone()</a>, <a class="el" href="class_m_g_cell.html#aa3c8948a3af77ced7e2158182e9b2cfb" title="Make a clone of the cell without boundaries.">clone_without_boundaries()</a> does not copy the binder cell relation. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a735842331fa8e53bdc26fee5d50df7ab">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="ab0c8dab0a35dedf181eb6622ca8e757b"></a><!-- doxytag: member="MGCell::clone_binder" ref="ab0c8dab0a35dedf181eb6622ca8e757b" args="(const MGCellBase &amp;c) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_cell.html">MGCell</a>* MGCell::clone_binder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of this(this is a binder), and set binder and parameter cell relation between the new binder and the parameter cell pcell. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#ac17dacc0a49fb6084ab04736f31d99b9">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="aa3c8948a3af77ced7e2158182e9b2cfb"></a><!-- doxytag: member="MGCell::clone_without_boundaries" ref="aa3c8948a3af77ced7e2158182e9b2cfb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_cell.html">MGCell</a>* MGCell::clone_without_boundaries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of the cell without boundaries. </p>
<p><a class="el" href="class_m_g_cell.html#aa3c8948a3af77ced7e2158182e9b2cfb" title="Make a clone of the cell without boundaries.">clone_without_boundaries()</a> does not copy the binder cell relation. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a7f2987e98eaa1221a993c5bd37b0836f">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="ad90ebdefd2282e8a49af54d605bef7b7"></a><!-- doxytag: member="MGCell::connect" ref="ad90ebdefd2282e8a49af54d605bef7b7" args="(size_t i1, size_t j1, MGCell *cell2, size_t i2, size_t j2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCell::connect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td>
          <td class="paramname"> <em>cell2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect i1-th boundary's j1-th pcell of this to i2-th boundary's j2-th pcell of cell2. </p>
<p>This connect can be applied to any manifold dimension's cell. </p>

</div>
</div>
<a class="anchor" id="a412c7dbe92b31086243d3238fbebad21"></a><!-- doxytag: member="MGCell::copy_all_boundaries" ref="a412c7dbe92b31086243d3238fbebad21" args="(const MGCellBase &amp;cell, MGCellMap &amp;cmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCell::copy_all_boundaries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all boundaries of cell into this, and binders association of the boundaries in the cmap. </p>
<p>Binder cells of cell will be registered in cmap. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a76c43ff40d3fd3ea3655b5396eaf89c1"></a><!-- doxytag: member="MGCell::draw3DVertex" ref="a76c43ff40d3fd3ea3655b5396eaf89c1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCell::draw3DVertex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D point(vertex) in world coordinates. </p>
<p>The object is converted to point(s) and is drawn. This is valid only for topology objects or <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a893bb5e4f0fcfe2bab43b413a9b57d53">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="ac29dee9aea2b0b38432f163faa4417d3"></a><!-- doxytag: member="MGCell::erase_boundary" ref="ac29dee9aea2b0b38432f163faa4417d3" args="(iterator i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCell::erase_boundary </td>
          <td>(</td>
          <td class="paramtype">iterator&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase i-th boundary. </p>
<p>erase_boundary remove from this cell's bounary and destruct the boundary. </p>

</div>
</div>
<a class="anchor" id="ac06eebac0ed8e1cf6c002045b162a338"></a><!-- doxytag: member="MGCell::free_boundary" ref="ac06eebac0ed8e1cf6c002045b162a338" args="(const MGBoundary *bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a>* MGCell::free_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td>
          <td class="paramname"> <em>bound</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free specified boundary(bound) from a member of parent cell's boundaries. </p>
<p>Return <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a> if freed normally. If bound was not a member of the boundaries, return 0. Only free, does not destruct the boundary. </p>

</div>
</div>
<a class="anchor" id="ad68606321567c22d2d908d3c4917ade3"></a><!-- doxytag: member="MGCell::make_binder" ref="ad68606321567c22d2d908d3c4917ade3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>* MGCell::make_binder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a binder cell of this parameter cell. </p>
<p>Returned is the binder pointer generated by new. The binder has no geometry, only has binder and parameter cell relationship. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a660e0dcb574bbd92a34075412ea8c9bb">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a1b1aca53a54cf1f562e363dc8a05c612"></a><!-- doxytag: member="MGCell::neighbours" ref="a1b1aca53a54cf1f562e363dc8a05c612" args="(size_t i, size_t j=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>*&gt; MGCell::neighbours </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return neighbours at the j-th boundary's i-th pcell. </p>
<p>The neighbours do not contain this cell except the case that this cell is connected to this cell itself(closed cell) at cell i of boundary j. </p>

</div>
</div>
<a class="anchor" id="a24370a5c8ff67fc14de44dfd69dd705d"></a><!-- doxytag: member="MGCell::neighbours" ref="a24370a5c8ff67fc14de44dfd69dd705d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>*&gt; MGCell::neighbours </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain all the neighbours. </p>
<p>The neighbours do not contain this cell except when this cell is connected to this cell itself(closed cell). </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a7b2d010eda4c20b53714e3341abde288">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a69d64ba582d97f5bbdf456c5f537096f"></a><!-- doxytag: member="MGCell::operator=" ref="a69d64ba582d97f5bbdf456c5f537096f" args="(const MGCell &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_cell.html">MGCell</a>&amp; MGCell::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>does not change binder and partner relation, does not change parent complex. </p>

</div>
</div>
<a class="anchor" id="ab2d48972b5978e0bd94fe42ea037cdfc"></a><!-- doxytag: member="MGCell::prepend_boundary" ref="ab2d48972b5978e0bd94fe42ea037cdfc" args="(MGBoundary *bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGCell::prepend_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td>
          <td class="paramname"> <em>bound</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepend new one boundary to boundary vectors. </p>
<p>Returned is the number of boudaries after prepending. </p>

</div>
</div>
<a class="anchor" id="adac4c4171869d41af97e49f0f159130b"></a><!-- doxytag: member="MGCell::set_cell" ref="adac4c4171869d41af97e49f0f159130b" args="(const MGCell &amp;cell)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cell.html">MGCell</a>&amp; MGCell::set_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cell</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>does not change binder and partner relation, does not change parent complex. </p>

</div>
</div>
<a class="anchor" id="abe6827579a144172c348309894d30ecc"></a><!-- doxytag: member="MGCell::sort_boundaries" ref="abe6827579a144172c348309894d30ecc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCell::sort_boundaries </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort boundary occurreces in m_boundaries. </p>
<p>Sorting is done according to operator&lt; of <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a>. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad7efd265124ed5bd5ccee1f9c7c1ad78"></a><!-- doxytag: member="MGCell::m_box" ref="ad7efd265124ed5bd5ccee1f9c7c1ad78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> <a class="el" href="class_m_g_cell.html#ad7efd265124ed5bd5ccee1f9c7c1ad78">MGCell::m_box</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Box of this cell. </p>
<p>=null box when 0D cell. Initially this is null, and will be computed by <a class="el" href="class_m_g_cell.html#a35df84c3d861367aa1a73b0b3c51e3ac" title="compute box of the cell in m_box.">compute_box()</a> when necessary. </p>

</div>
</div>
<a class="anchor" id="a5a374337c0ed88e146fd8ed9e8a059b8"></a><!-- doxytag: member="MGCell::m_perror" ref="a5a374337c0ed88e146fd8ed9e8a059b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_m_g_cell.html#a5a374337c0ed88e146fd8ed9e8a059b8">MGCell::m_perror</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error allowed for the parameter space of the cell. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Cell.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:18 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

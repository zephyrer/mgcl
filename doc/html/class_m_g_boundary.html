<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGBoundary Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>MGBoundary Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGBoundary" --><!-- doxytag: inherits="MGComplex" -->
<p><a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a> is a boundary of more than 1 manifold dimension.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Boundary.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGBoundary:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_boundary__inherit__graph.png" border="0" usemap="#_m_g_boundary_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_boundary_inherit__map" id="_m_g_boundary_inherit__map">
<area shape="rect" id="node13" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell." alt="" coords="5,469,75,499"/><area shape="rect" id="node15" href="class_m_g_shell.html" title="MGShell is a composition of MGFace&#39;s(trimmed surface)." alt="" coords="99,469,171,499"/><area shape="rect" id="node2" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="40,315,133,344"/><area shape="rect" id="node4" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="40,237,133,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="47,160,127,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="33,83,140,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="56,5,117,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGBoundary:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_boundary__coll__graph.png" border="0" usemap="#_m_g_boundary_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_boundary_coll__map" id="_m_g_boundary_coll__map">
<area shape="rect" id="node2" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="125,581,219,611"/><area shape="rect" id="node28" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="212,677,295,707"/><area shape="rect" id="node4" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="120,485,213,515"/><area shape="rect" id="node30" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="171,773,264,803"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="163,373,243,403"/><area shape="rect" id="node34" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="268,581,367,611"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,261,167,291"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="308,485,375,515"/><area shape="rect" id="node26" href="class_m_g_cell.html" title="MGCell is a general cell that has bound." alt="" coords="295,773,359,803"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="300,373,383,403"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="303,261,380,291"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_boundary-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b22b64c2acbd01716d785719b259f88"></a><!-- doxytag: member="MGBoundary::MGBoundary" ref="a9b22b64c2acbd01716d785719b259f88" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a9b22b64c2acbd01716d785719b259f88">MGBoundary</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451bfdd0eafa902fc1cc82092a4fc33d"></a><!-- doxytag: member="MGBoundary::MGBoundary" ref="a451bfdd0eafa902fc1cc82092a4fc33d" args="(MGCellNB *pcell)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a451bfdd0eafa902fc1cc82092a4fc33d">MGBoundary</a> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *pcell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of one parameter cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec105f132da313d97d91f1f5e2065b24"></a><!-- doxytag: member="MGBoundary::MGBoundary" ref="aec105f132da313d97d91f1f5e2065b24" args="(std::list&lt; MGCellNB * &gt; &amp;pcells)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#aec105f132da313d97d91f1f5e2065b24">MGBoundary</a> (std::list&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt; &amp;pcells)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from list of member pcells. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a060b30c5a5ab4c1b9a464ddb38b5a402">MGBoundary</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;boundary)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Boundary data pcells that constitue complex.  <a href="#a060b30c5a5ab4c1b9a464ddb38b5a402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#ac00d38c9f8914114c1b24c5d0c15a438">‾MGBoundary</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">original boundary.  <a href="#ac00d38c9f8914114c1b24c5d0c15a438"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#aecf7c8938979abf8e30193ab8f6a71ee">operator=</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#aecf7c8938979abf8e30193ab8f6a71ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a259579d53e6b78b3bdd460186255e42d"></a><!-- doxytag: member="MGBoundary::operator+=" ref="a259579d53e6b78b3bdd460186255e42d" args="(const MGVector &amp;v)" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a259579d53e6b78b3bdd460186255e42d">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af50ce7aa53081b9ec74860e22346e7a2"></a><!-- doxytag: member="MGBoundary::operator&#45;=" ref="af50ce7aa53081b9ec74860e22346e7a2" args="(const MGVector &amp;v)" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b8380834310da93dc7cac41441c2219"></a><!-- doxytag: member="MGBoundary::operator*=" ref="a4b8380834310da93dc7cac41441c2219" args="(double scale)" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab97e1a81f79dacc59c07cd93f2ae8556"></a><!-- doxytag: member="MGBoundary::operator*=" ref="ab97e1a81f79dacc59c07cd93f2ae8556" args="(const MGMatrix &amp;mat)" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af837702890fee0a8edcdd9a4014d387a"></a><!-- doxytag: member="MGBoundary::operator*=" ref="af837702890fee0a8edcdd9a4014d387a" args="(const MGTransf &amp;tr)" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9e54e769c91b7bb4b1cbb697a1093e8"></a><!-- doxytag: member="MGBoundary::active" ref="af9e54e769c91b7bb4b1cbb697a1093e8" args="() const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#af9e54e769c91b7bb4b1cbb697a1093e8">active</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is an active boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e4e3366adcffd5ba024fc7721b85d3"></a><!-- doxytag: member="MGBoundary::box" ref="af4e4e3366adcffd5ba024fc7721b85d3" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#af4e4e3366adcffd5ba024fc7721b85d3">box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the box of this boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#ad0c3d93096d2338e542ec119dc46aac8">clone</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;parent) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone.  <a href="#ad0c3d93096d2338e542ec119dc46aac8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a545ab978b74513d4bf83fba61de8028d">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new object by copying to newed area.  <a href="#a545ab978b74513d4bf83fba61de8028d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae875574006b65c3a5bc4f7cf03799762"></a><!-- doxytag: member="MGBoundary::clone_without_binders" ref="ae875574006b65c3a5bc4f7cf03799762" args="(MGCell &amp;parent) const =0" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#ae875574006b65c3a5bc4f7cf03799762">clone_without_binders</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;parent) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone that has not binders. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c10c895590da3ad14acea5717c3126c"></a><!-- doxytag: member="MGBoundary::clone_without_binders" ref="a4c10c895590da3ad14acea5717c3126c" args="() const =0" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>clone_without_binders</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73d1e73e7b1a4faa7bd9eba2834b6fe3"></a><!-- doxytag: member="MGBoundary::closed" ref="a73d1e73e7b1a4faa7bd9eba2834b6fe3" args="() const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a73d1e73e7b1a4faa7bd9eba2834b6fe3">closed</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is closed boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a867228f534c76fb65ba463ba79dbb5ac">direction_star</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the direction of star cell at the i-th pcell of this boundary.  <a href="#a867228f534c76fb65ba463ba79dbb5ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a268d78a459f9e65ddcaff3ba9473f503">empty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if PCells exist in this boundary.  <a href="#a268d78a459f9e65ddcaff3ba9473f503"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#adca09711737bbf3d418e2f386038819f">equal_direction</a> (size_t i, const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;bound2, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this boundary's star cell's direction is equal to bounda2's star cell's direction along this boundary's i and bound2's boundary j-th parameter cell.  <a href="#adca09711737bbf3d418e2f386038819f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9287f72fbcba754c8f5079669653f66"></a><!-- doxytag: member="MGBoundary::identify_type" ref="af9287f72fbcba754c8f5079669653f66" args="() const =0" -->
virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#af9287f72fbcba754c8f5079669653f66">identify_type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaa27b4f9daec87ef5a45975c55dde6e"></a><!-- doxytag: member="MGBoundary::manifold_dimension" ref="adaa27b4f9daec87ef5a45975c55dde6e" args="() const =0" -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#adaa27b4f9daec87ef5a45975c55dde6e">manifold_dimension</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a50aa2454407bfe1876cb15df444be653">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse the direction of the boundary.  <a href="#a50aa2454407bfe1876cb15df444be653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a5a367f41a49785616d35eefeb5288778">negate_as_boundary</a> (const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *parent=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the boundary according to the parent cell negation.  <a href="#a5a367f41a49785616d35eefeb5288778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec9e4712dab110e8ca44a2bac4a65834"></a><!-- doxytag: member="MGBoundary::number_of_pcells" ref="aec9e4712dab110e8ca44a2bac4a65834" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#aec9e4712dab110e8ca44a2bac4a65834">number_of_pcells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain how many parameter cells are included in the boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a457894a5feb4b98a02ed32ff40b0122e"></a><!-- doxytag: member="MGBoundary::out" ref="a457894a5feb4b98a02ed32ff40b0122e" args="(std::ostream &amp;) const " -->
virtual std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a457894a5feb4b98a02ed32ff40b0122e">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a570bb23afb63c682160abf54cbe46a80">set_binder</a> (size_t i, <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> &amp;binder) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set binder relation to i-th parameter cell.  <a href="#a570bb23afb63c682160abf54cbe46a80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a2220f033c405010c80fd9a134b8ce1df">set_parent</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;new_parent) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set parent cell.  <a href="#a2220f033c405010c80fd9a134b8ce1df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7547171f0c4538110cd689bbc2fbdab5"></a><!-- doxytag: member="MGBoundary::star" ref="a7547171f0c4538110cd689bbc2fbdab5" args="() const " -->
const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a7547171f0c4538110cd689bbc2fbdab5">star</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the star cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80b6073f2e9ad1dc96f936df0044b828"></a><!-- doxytag: member="MGBoundary::star" ref="a80b6073f2e9ad1dc96f936df0044b828" args="()" -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>star</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af041714836c7f54e091ac16743d23835"></a><!-- doxytag: member="MGBoundary::whoami" ref="af041714836c7f54e091ac16743d23835" args="() const " -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#ad1037d0727a03ed565769eb677047640">MGBoundary</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;boundary, MGCellMap &amp;cmap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#ad1037d0727a03ed565769eb677047640"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#aa6831d69243fa31cdb90c028b81dfab1">clone</a> (<a class="el" href="class_m_g_cell.html">MGCell</a> &amp;parent, MGCellMap &amp;cmap) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone.  <a href="#aa6831d69243fa31cdb90c028b81dfab1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b2cec8dd9fff935582099ce8d5b306e"></a><!-- doxytag: member="MGBoundary::clone" ref="a5b2cec8dd9fff935582099ce8d5b306e" args="(MGCellMap &amp;cmap) const =0" -->
virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>clone</b> (MGCellMap &amp;cmap) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#aed1f3400f3ce89fe6ce388dccbdec0ca">connect_bound</a> (size_t i, <a class="el" href="class_m_g_boundary.html">MGBoundary</a> *bound2, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect i-th pcell of this boundary to j-th pcell of boud2.  <a href="#aed1f3400f3ce89fe6ce388dccbdec0ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a82fed4d90fa65d6680136a62623bf7ea">copy_boundary</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;bnd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy boundary.  <a href="#a82fed4d90fa65d6680136a62623bf7ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#af623b25b87044ad351b15b6574d39273">copy_boundary_without_binders</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;bnd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy boundary data, but does not copy the binders.  <a href="#af623b25b87044ad351b15b6574d39273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a519561d2019ec7d3e0a9d3559214cd9a">disconnect</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect i-th pcell of this boundary from its partnership relation.  <a href="#a519561d2019ec7d3e0a9d3559214cd9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#af43137e189e9beac81d1f743f796226a">free_binders</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all binders of this boundary.  <a href="#af43137e189e9beac81d1f743f796226a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c1d5e248696836a1081a881ba0c719"></a><!-- doxytag: member="MGBoundary::ReadMembers" ref="ab7c1d5e248696836a1081a881ba0c719" args="(MGIfstream &amp;buf)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#ab7c1d5e248696836a1081a881ba0c719">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a5a7fb93fa118cf0cac6a47aa57a9085a">set_boundary</a> (const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When the leaf object of this and comp2 are not equal, this assignment does nothing.  <a href="#a5a7fb93fa118cf0cac6a47aa57a9085a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952a48df465ade77deba5550418897bb"></a><!-- doxytag: member="MGBoundary::WriteMembers" ref="a952a48df465ade77deba5550418897bb" args="(MGOfstream &amp;buf) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#a952a48df465ade77deba5550418897bb">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5cde16dbfb7b1acd8811baed83c4d67"></a><!-- doxytag: member="MGBoundary::m_parent_cell" ref="ae5cde16dbfb7b1acd8811baed83c4d67" args="" -->
<a class="el" href="class_m_g_cell.html">MGCell</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_boundary.html#ae5cde16dbfb7b1acd8811baed83c4d67">m_parent_cell</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cell that has this boundary as a boundary. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a> is a boundary of more than 1 manifold dimension. </p>
<p>That is, a boundary of a face, a volume, or other general manifold dimension's cells. Cells stored in parent class complex constitute this boundary. This boundary cell's geometry's space dimension is the same as the parent cell's manifold dimension, since boundary cell is parameter space world. For edges whose <a class="el" href="class_m_g_boundary.html#adaa27b4f9daec87ef5a45975c55dde6e" title="Get manifold dimension.">manifold_dimension()</a> is 1, this class is not used. Instead, Edges conatain the parameter cell <a class="el" href="class_m_g_p_vertex.html" title="MGPVertex is a parameter cell of the manifold dimension 0.">MGPVertex</a>. (<a class="el" href="class_m_g_p_vertex.html" title="MGPVertex is a parameter cell of the manifold dimension 0.">MGPVertex</a> is a parameter cell and also a boundary.) <a class="el" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension.">MGBoundary</a> is an abstract class. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a060b30c5a5ab4c1b9a464ddb38b5a402"></a><!-- doxytag: member="MGBoundary::MGBoundary" ref="a060b30c5a5ab4c1b9a464ddb38b5a402" args="(const MGBoundary &amp;boundary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBoundary::MGBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Boundary data pcells that constitue complex. </p>
<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="ad1037d0727a03ed565769eb677047640"></a><!-- doxytag: member="MGBoundary::MGBoundary" ref="ad1037d0727a03ed565769eb677047640" args="(const MGBoundary &amp;boundary, MGCellMap &amp;cmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBoundary::MGBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Binder cells of the pcells in boundary will be registered in cmap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boundary</em>&nbsp;</td><td>original boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmap</em>&nbsp;</td><td>cellmap to register binder association. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad0c3d93096d2338e542ec119dc46aac8"></a><!-- doxytag: member="MGBoundary::clone" ref="ad0c3d93096d2338e542ec119dc46aac8" args="(MGCell &amp;parent) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a>* MGBoundary::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone. </p>
<p>Returned is pointer of newed object, must be deleted. When parent is specified, clone's parent is set to the parent. </p>

<p>Implemented in <a class="el" href="class_m_g_loop.html#aca2915ed89d1bd52afaf0072f48c45af">MGLoop</a>, and <a class="el" href="class_m_g_shell.html#a041619f2a39404143335614dae5c1f68">MGShell</a>.</p>

</div>
</div>
<a class="anchor" id="a545ab978b74513d4bf83fba61de8028d"></a><!-- doxytag: member="MGBoundary::clone" ref="a545ab978b74513d4bf83fba61de8028d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a>* MGBoundary::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Reimplemented from <a class="el" href="class_m_g_complex.html#aa3f172d1cfa17d3acd5d7a477fe8a227">MGComplex</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_loop.html#a9675c0e77ade5b4ebd3f62fce826f90c">MGLoop</a>, and <a class="el" href="class_m_g_shell.html#afa2a29fd6b285fe2dbaf89a3f5b7d416">MGShell</a>.</p>

</div>
</div>
<a class="anchor" id="aa6831d69243fa31cdb90c028b81dfab1"></a><!-- doxytag: member="MGBoundary::clone" ref="aa6831d69243fa31cdb90c028b81dfab1" args="(MGCell &amp;parent, MGCellMap &amp;cmap) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a>* MGBoundary::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGCellMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone. </p>
<p>The forms that have cmap as an argumetnt is to register binder association. Binder cells of the pcells in this boundary will be registered in cmap. Returned is pointer of newed object, must be deleted. When parent is specified, clone's parent is set to the parent. </p>

<p>Implemented in <a class="el" href="class_m_g_loop.html#a681c66d11d6be25b2d9fc7bec3101c07">MGLoop</a>.</p>

</div>
</div>
<a class="anchor" id="aed1f3400f3ce89fe6ce388dccbdec0ca"></a><!-- doxytag: member="MGBoundary::connect_bound" ref="aed1f3400f3ce89fe6ce388dccbdec0ca" args="(size_t i, MGBoundary *bound2, size_t j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBoundary::connect_bound </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_boundary.html">MGBoundary</a> *&nbsp;</td>
          <td class="paramname"> <em>bound2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect i-th pcell of this boundary to j-th pcell of boud2. </p>
<p>Returned is the pointer of complex of the parent pcell of this boundary. The parent pcell of this must be a memeber of a complex. If both of this and bound2 are a member of a complex, they must be the same. </p>

</div>
</div>
<a class="anchor" id="a82fed4d90fa65d6680136a62623bf7ea"></a><!-- doxytag: member="MGBoundary::copy_boundary" ref="a82fed4d90fa65d6680136a62623bf7ea" args="(const MGBoundary &amp;bnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGBoundary::copy_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bnd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy boundary. </p>
<p>This boundary data is cleared and bnd's boundary is copied into this. </p>

<p>Reimplemented in <a class="el" href="class_m_g_loop.html#a1f27117f120c7e3410770e494f9ec885">MGLoop</a>.</p>

</div>
</div>
<a class="anchor" id="af623b25b87044ad351b15b6574d39273"></a><!-- doxytag: member="MGBoundary::copy_boundary_without_binders" ref="af623b25b87044ad351b15b6574d39273" args="(const MGBoundary &amp;bnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGBoundary::copy_boundary_without_binders </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bnd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy boundary data, but does not copy the binders. </p>
<p>This boundary data is cleared and bnd's boundary is copied into this. </p>

<p>Reimplemented in <a class="el" href="class_m_g_loop.html#aee3c12f2d079732c3da45dcc485b8eac">MGLoop</a>.</p>

</div>
</div>
<a class="anchor" id="a867228f534c76fb65ba463ba79dbb5ac"></a><!-- doxytag: member="MGBoundary::direction_star" ref="a867228f534c76fb65ba463ba79dbb5ac" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> MGBoundary::direction_star </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the direction of star cell at the i-th pcell of this boundary. </p>
<p>Star cell's direction, not boundary's direction. </p>

</div>
</div>
<a class="anchor" id="a519561d2019ec7d3e0a9d3559214cd9a"></a><!-- doxytag: member="MGBoundary::disconnect" ref="a519561d2019ec7d3e0a9d3559214cd9a" args="(size_t i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBoundary::disconnect </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect i-th pcell of this boundary from its partnership relation. </p>
<p>disconnect does not free membership of the parent cell from its parent complex. </p>

</div>
</div>
<a class="anchor" id="a268d78a459f9e65ddcaff3ba9473f503"></a><!-- doxytag: member="MGBoundary::empty" ref="a268d78a459f9e65ddcaff3ba9473f503" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGBoundary::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if PCells exist in this boundary. </p>
<p>If no pcells are included, <a class="el" href="class_m_g_boundary.html#a268d78a459f9e65ddcaff3ba9473f503" title="Test if PCells exist in this boundary.">empty()</a> returns true. </p>

</div>
</div>
<a class="anchor" id="adca09711737bbf3d418e2f386038819f"></a><!-- doxytag: member="MGBoundary::equal_direction" ref="adca09711737bbf3d418e2f386038819f" args="(size_t i, const MGBoundary &amp;bound2, size_t j) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGBoundary::equal_direction </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bound2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this boundary's star cell's direction is equal to bounda2's star cell's direction along this boundary's i and bound2's boundary j-th parameter cell. </p>
<p>Not testing boundary's direction, but star cell's direction. </p>

</div>
</div>
<a class="anchor" id="af43137e189e9beac81d1f743f796226a"></a><!-- doxytag: member="MGBoundary::free_binders" ref="af43137e189e9beac81d1f743f796226a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBoundary::free_binders </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all binders of this boundary. </p>
<p>That is, if num n of partners of a binder of a pcell of this boundary is one, free from the parent complex, and does not free from the pcell. If n is more than one, free from the pcell, and does not free from the parent complex. </p>

</div>
</div>
<a class="anchor" id="a50aa2454407bfe1876cb15df444be653"></a><!-- doxytag: member="MGBoundary::negate" ref="a50aa2454407bfe1876cb15df444be653" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGBoundary::negate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse the direction of the boundary. </p>
<p>(Coordinate transformation is not performed.) </p>

<p>Reimplemented in <a class="el" href="class_m_g_loop.html#a3cb3edc035c3c2c7e04b6675e7d40952">MGLoop</a>.</p>

</div>
</div>
<a class="anchor" id="a5a367f41a49785616d35eefeb5288778"></a><!-- doxytag: member="MGBoundary::negate_as_boundary" ref="a5a367f41a49785616d35eefeb5288778" args="(const MGCellNB *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGBoundary::negate_as_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate the boundary according to the parent cell negation. </p>
<p>That is, 1. Transform the coordinates of the bondary cell. (This transfromation depends on how the parent cell is transformed when <a class="el" href="class_m_g_boundary.html#a50aa2454407bfe1876cb15df444be653" title="Reverse the direction of the boundary.">negate()</a> is invoked. So, the member cells of this boundary are transformed by negate_transoform of the parent cell.) 2. Reverse the direction of the parameter cells(negate each cell). 3. Reverse the ordering of the parameter cells. </p>

<p>Reimplemented in <a class="el" href="class_m_g_loop.html#a9a86db2fa1dda6c240a1cea544f4ab97">MGLoop</a>.</p>

</div>
</div>
<a class="anchor" id="aecf7c8938979abf8e30193ab8f6a71ee"></a><!-- doxytag: member="MGBoundary::operator=" ref="aecf7c8938979abf8e30193ab8f6a71ee" args="(const MGBoundary &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_boundary.html">MGBoundary</a>&amp; MGBoundary::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and comp2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a570bb23afb63c682160abf54cbe46a80"></a><!-- doxytag: member="MGBoundary::set_binder" ref="a570bb23afb63c682160abf54cbe46a80" args="(size_t i, MGCellNB &amp;binder) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBoundary::set_binder </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>binder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set binder relation to i-th parameter cell. </p>
<p>The binder must be newed object and the owenership is transfered to boundary(precisely, to parameter cell that corresponds to the binder). </p>

</div>
</div>
<a class="anchor" id="a5a7fb93fa118cf0cac6a47aa57a9085a"></a><!-- doxytag: member="MGBoundary::set_boundary" ref="a5a7fb93fa118cf0cac6a47aa57a9085a" args="(const MGBoundary &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_boundary.html">MGBoundary</a>&amp; MGBoundary::set_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_boundary.html">MGBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When the leaf object of this and comp2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a2220f033c405010c80fd9a134b8ce1df"></a><!-- doxytag: member="MGBoundary::set_parent" ref="a2220f033c405010c80fd9a134b8ce1df" args="(MGCell &amp;new_parent) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cell.html">MGCell</a>* MGBoundary::set_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell.html">MGCell</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>new_parent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set parent cell. </p>
<p>Returned is the conventional parent cell attached to before execution of this set_parent. </p>

</div>
</div>
<a class="anchor" id="ac00d38c9f8914114c1b24c5d0c15a438"></a><!-- doxytag: member="MGBoundary::‾MGBoundary" ref="ac00d38c9f8914114c1b24c5d0c15a438" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual MGBoundary::‾<a class="el" href="class_m_g_boundary.html">MGBoundary</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>original boundary. </p>
<p>Virtual Destructor </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Boundary.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:18 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

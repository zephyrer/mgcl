<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGComplex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGComplex Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGComplex" --><!-- doxytag: inherits="MGTopology" -->
<p><a class="el" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells.">MGComplex</a> is a container of parameter cells and binder cells.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Complex.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGComplex:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_complex__inherit__graph.png" border="0" usemap="#_m_g_complex_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_complex_inherit__map" id="_m_g_complex_inherit__map">
<area shape="rect" id="node11" href="class_m_g_boundary.html" title="MGBoundary is a boundary of more than 1 manifold dimension." alt="" coords="37,392,136,421"/><area shape="rect" id="node2" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="40,237,133,267"/><area shape="rect" id="node4" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="47,160,127,189"/><area shape="rect" id="node6" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="33,83,140,112"/><area shape="rect" id="node8" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="56,5,117,35"/><area shape="rect" id="node13" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell." alt="" coords="5,469,75,499"/><area shape="rect" id="node15" href="class_m_g_shell.html" title="MGShell is a composition of MGFace&#39;s(trimmed surface)." alt="" coords="99,469,171,499"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGComplex:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_complex__coll__graph.png" border="0" usemap="#_m_g_complex_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_complex_coll__map" id="_m_g_complex_coll__map">
<area shape="rect" id="node2" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="155,485,248,515"/><area shape="rect" id="node4" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="161,373,241,403"/><area shape="rect" id="node6" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node12" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node8" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node10" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,261,167,291"/><area shape="rect" id="node15" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node18" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="272,485,339,515"/><area shape="rect" id="node20" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="265,373,348,403"/><area shape="rect" id="node22" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="268,261,345,291"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_complex-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a667b9d59ec50c259fcdae01b8a01b59b"></a><!-- doxytag: member="MGComplex::container_type" ref="a667b9d59ec50c259fcdae01b8a01b59b" args="" -->
typedef std::list&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac260eaad84e9accdb52c5361af35c9b1"></a><!-- doxytag: member="MGComplex::cellItr" ref="ac260eaad84e9accdb52c5361af35c9b1" args="" -->
typedef container_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>cellItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d902b2d2c2e91e0f5d7171d5ac6ef0a"></a><!-- doxytag: member="MGComplex::const_cellItr" ref="a3d902b2d2c2e91e0f5d7171d5ac6ef0a" args="" -->
typedef <br class="typebreak"/>
container_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_cellItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52490435309231fd6eaba4286a81ddd2"></a><!-- doxytag: member="MGComplex::pcellItr" ref="a52490435309231fd6eaba4286a81ddd2" args="" -->
typedef container_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>pcellItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ff779edadcb3046ea6723e34634607e"></a><!-- doxytag: member="MGComplex::const_pcellItr" ref="a1ff779edadcb3046ea6723e34634607e" args="" -->
typedef <br class="typebreak"/>
container_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pcellItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16ce49b532637cb34ebecef32722929a"></a><!-- doxytag: member="MGComplex::bcellItr" ref="a16ce49b532637cb34ebecef32722929a" args="" -->
typedef container_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>bcellItr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0871576f674d60d36d711f80539240b"></a><!-- doxytag: member="MGComplex::const_bcellItr" ref="ab0871576f674d60d36d711f80539240b" args="" -->
typedef <br class="typebreak"/>
container_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_bcellItr</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65c67b6ac6d59a50f9098a54bc5281e8"></a><!-- doxytag: member="MGComplex::MGComplex" ref="a65c67b6ac6d59a50f9098a54bc5281e8" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a65c67b6ac6d59a50f9098a54bc5281e8">MGComplex</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a93125cf9fcd99120f3d226de04fe5220">MGComplex</a> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;complex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a93125cf9fcd99120f3d226de04fe5220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#af9221864da63938ef0fca628342b96ef">MGComplex</a> (const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> &amp;cell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct of one cell.  <a href="#af9221864da63938ef0fca628342b96ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c43a01d3b20e32021aeb929b5ed228b"></a><!-- doxytag: member="MGComplex::MGComplex" ref="a9c43a01d3b20e32021aeb929b5ed228b" args="(MGCellNB *cell)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGComplex</b> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *cell)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a718614d8eea9ef749bb1794fe79b3591"></a><!-- doxytag: member="MGComplex::‾MGComplex" ref="a718614d8eea9ef749bb1794fe79b3591" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGComplex</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a68677e75e2739903c83c9dc8d15bd27e">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a68677e75e2739903c83c9dc8d15bd27e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fc77188501ca5772a7815ff81144541"></a><!-- doxytag: member="MGComplex::operator=" ref="a5fc77188501ca5772a7815ff81144541" args="(const MGComplex &amp;gel2)" -->
virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f0d5dda2284725a999702b5739f1fa"></a><!-- doxytag: member="MGComplex::operator+" ref="a88f0d5dda2284725a999702b5739f1fa" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a88f0d5dda2284725a999702b5739f1fa">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexに平行移動を行ないオブジェクトを生成する。 Translation of the Complex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaefbe1afb7cbfbfd255fab24cc541a90"></a><!-- doxytag: member="MGComplex::operator&#45;" ref="aaefbe1afb7cbfbfd255fab24cc541a90" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#aaefbe1afb7cbfbfd255fab24cc541a90">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexに逆方向の平行移動を行ないオブジェクトを生成する。 Translation of the Complex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a89d191471c5f833e0e3347c64ba38f41">operator*</a> (double s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double.  <a href="#a89d191471c5f833e0e3347c64ba38f41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#af24628df8b7060cffdbcfaa701d525d3">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換でComplexの変換を行い，Complexを作成する。 Transformation of the Complex by a matrix.  <a href="#af24628df8b7060cffdbcfaa701d525d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a704c3a3d43f10a739e9cab09c83a7c63">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換によってトランスフォームをおこないComplexを生成する。 Transformation of the Complex by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>.  <a href="#a704c3a3d43f10a739e9cab09c83a7c63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54341cf665a189816963437311d647a9"></a><!-- doxytag: member="MGComplex::operator+=" ref="a54341cf665a189816963437311d647a9" args="(const MGVector &amp;v)" -->
virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a54341cf665a189816963437311d647a9">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f4a0b9c9037073e9d68e6bc1468aff"></a><!-- doxytag: member="MGComplex::operator&#45;=" ref="a50f4a0b9c9037073e9d68e6bc1468aff" args="(const MGVector &amp;v)" -->
virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb5b21c97bcb0a3dd0255ded656ef68b"></a><!-- doxytag: member="MGComplex::operator*=" ref="adb5b21c97bcb0a3dd0255ded656ef68b" args="(double scale)" -->
virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac06d2ec096df6ba97479647eee330082"></a><!-- doxytag: member="MGComplex::operator*=" ref="ac06d2ec096df6ba97479647eee330082" args="(const MGMatrix &amp;mat)" -->
virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb326caae7c2fa24631fbdb3117c2f1"></a><!-- doxytag: member="MGComplex::operator*=" ref="a5fb326caae7c2fa24631fbdb3117c2f1" args="(const MGTransf &amp;tr)" -->
virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a7f84de6ec58b59548315a274174ea162">operator/</a> (double s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double.  <a href="#a7f84de6ec58b59548315a274174ea162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ec3aa09cdd04093a0d2130ffc1ec0d"></a><!-- doxytag: member="MGComplex::operator&lt;" ref="aa9ec3aa09cdd04093a0d2130ffc1ec0d" args="(const MGComplex &amp;gel2) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#aa9ec3aa09cdd04093a0d2130ffc1ec0d">operator&lt;</a> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f7efe5049242ba9d016851c7a260951"></a><!-- doxytag: member="MGComplex::operator&lt;" ref="a2f7efe5049242ba9d016851c7a260951" args="(const MGGel &amp;gel2) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9589491e863867106e2efcab9d10c982"></a><!-- doxytag: member="MGComplex::bcell_begin" ref="a9589491e863867106e2efcab9d10c982" args="() const " -->
const_bcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a9589491e863867106e2efcab9d10c982">bcell_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain first bcell iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f791f37d96b24fd7f5f55b2702e5d64"></a><!-- doxytag: member="MGComplex::bcell_begin" ref="a9f791f37d96b24fd7f5f55b2702e5d64" args="()" -->
bcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>bcell_begin</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e087d5e99a48754051bc35636f7e6ea"></a><!-- doxytag: member="MGComplex::bcell_end" ref="a8e087d5e99a48754051bc35636f7e6ea" args="() const " -->
const_bcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a8e087d5e99a48754051bc35636f7e6ea">bcell_end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain end bcell iterator(next of the last bcell). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb220e15c662f50849239c818f084e7"></a><!-- doxytag: member="MGComplex::bcell_end" ref="a6eb220e15c662f50849239c818f084e7" args="()" -->
bcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>bcell_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68d6fe11b8c0f9a4db44f17f365fbe22"></a><!-- doxytag: member="MGComplex::bcelli" ref="a68d6fe11b8c0f9a4db44f17f365fbe22" args="(size_t i) const " -->
const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a68d6fe11b8c0f9a4db44f17f365fbe22">bcelli</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-the pcell in the m_bcells sequence. <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a> version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19611b436060b53c03851e074e85811c"></a><!-- doxytag: member="MGComplex::bcelli" ref="a19611b436060b53c03851e074e85811c" args="(size_t i)" -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>bcelli</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a658e310e1a059d6faacd3f92ee3466a4"></a><!-- doxytag: member="MGComplex::bcellIterator" ref="a658e310e1a059d6faacd3f92ee3466a4" args="(size_t i) const " -->
const_bcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a658e310e1a059d6faacd3f92ee3466a4">bcellIterator</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-the pcell in the m_bcells sequence. <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a> version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe628c856f3041fedf6a85bd404741bc"></a><!-- doxytag: member="MGComplex::bcellIterator" ref="afe628c856f3041fedf6a85bd404741bc" args="(size_t i)" -->
bcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>bcellIterator</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17ec729c5ad07ef52a760f26d3330753"></a><!-- doxytag: member="MGComplex::bcell_exist" ref="a17ec729c5ad07ef52a760f26d3330753" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a17ec729c5ad07ef52a760f26d3330753">bcell_exist</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cehck if bcell exist. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0dd17462d6ed31498b54af30a0a263f"></a><!-- doxytag: member="MGComplex::binder" ref="af0dd17462d6ed31498b54af30a0a263f" args="(size_t i) const " -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#af0dd17462d6ed31498b54af30a0a263f">binder</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the binder of i-the pcell, may be null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a93e3dd3da243cb7c615cfa09fa6e56d0">binders</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain binders of all the pcells of the boundary.  <a href="#a93e3dd3da243cb7c615cfa09fa6e56d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cb9954f82b3a6c3609a060bf1f851cb"></a><!-- doxytag: member="MGComplex::box" ref="a5cb9954f82b3a6c3609a060bf1f851cb" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a5cb9954f82b3a6c3609a060bf1f851cb">box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the box of this complex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a456439fcbecf9da638d01deae57b00a3">center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute barycenter of all the vertex(binder cell of 0D manifold dimension).  <a href="#a456439fcbecf9da638d01deae57b00a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_complex.html">MGComplex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#aa3f172d1cfa17d3acd5d7a477fe8a227">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new object by copying to newed area.  <a href="#aa3f172d1cfa17d3acd5d7a477fe8a227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a4d63e44261a5983ea894958934fc4191">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#a4d63e44261a5983ea894958934fc4191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#ae2ab5101b12196484fde9ffda324b33a">drawWire_in_star</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in the topology's star cell world coordinates.  <a href="#ae2ab5101b12196484fde9ffda324b33a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a96db58f8f11eb168cf7d2c96bebb3f06">draw3DVertex</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D point(vertex) in world coordinates.  <a href="#a96db58f8f11eb168cf7d2c96bebb3f06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a24f9a84fffb017cf5eef618e6acfe14d">draw3DVertex_in_star</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D point(vertex) in star cell's world coordinates.  <a href="#a24f9a84fffb017cf5eef618e6acfe14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#aa80414982e4282ecc748b4c042a7a818">erase_first_pcell</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase first pcell element, including binder cells that will be free when the first pcell is erased.  <a href="#aa80414982e4282ecc748b4c042a7a818"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#aa0be044f74c5981a6b57561c1f3a1f14">erase_last_pcell</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">erase first pcell.  <a href="#aa0be044f74c5981a6b57561c1f3a1f14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a7b4579a9f59b1ffe3974dd0a2fc64d98">erase_pcell</a> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *pcell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">erase last pcell.  <a href="#a7b4579a9f59b1ffe3974dd0a2fc64d98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2887a9d9fc438ea0189e52866fe158f3"></a><!-- doxytag: member="MGComplex::first_pcell" ref="a2887a9d9fc438ea0189e52866fe158f3" args="() const " -->
const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a2887a9d9fc438ea0189e52866fe158f3">first_pcell</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get fisrt pcell pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b0eae477d767ac988364e31c8217bdf"></a><!-- doxytag: member="MGComplex::first_pcell" ref="a4b0eae477d767ac988364e31c8217bdf" args="()" -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>first_pcell</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acef278bd23975a15060d395281859302"></a><!-- doxytag: member="MGComplex::identify_type" ref="acef278bd23975a15060d395281859302" args="() const " -->
virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#acef278bd23975a15060d395281859302">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a752b2c1abc8324ffeb9c37ba06e0f824">includes</a> (const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *cell) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this complex includes the <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a> cell as a contituent.  <a href="#a752b2c1abc8324ffeb9c37ba06e0f824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05bffc00f8f56466038a260a007b8545"></a><!-- doxytag: member="MGComplex::last_pcell" ref="a05bffc00f8f56466038a260a007b8545" args="() const " -->
const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a05bffc00f8f56466038a260a007b8545">last_pcell</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last pcell pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905468ba6a459c25fb012ed61addda94"></a><!-- doxytag: member="MGComplex::last_pcell" ref="a905468ba6a459c25fb012ed61addda94" args="()" -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>last_pcell</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6132d91d2ebbbe8a090cdc20f781a25"></a><!-- doxytag: member="MGComplex::manifold_dimension" ref="ae6132d91d2ebbbe8a090cdc20f781a25" args="() const " -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#ae6132d91d2ebbbe8a090cdc20f781a25">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e8b4834fd1d4d2e317dd5b4a8565f1"></a><!-- doxytag: member="MGComplex::number_of_bcells" ref="a75e8b4834fd1d4d2e317dd5b4a8565f1" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a75e8b4834fd1d4d2e317dd5b4a8565f1">number_of_bcells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">count number of bcells of the complex <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ca37ddfc493de0ecf9ad7efe01b2efc"></a><!-- doxytag: member="MGComplex::number_of_pcells" ref="a8ca37ddfc493de0ecf9ad7efe01b2efc" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a8ca37ddfc493de0ecf9ad7efe01b2efc">number_of_pcells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">count number of pcells of the complex <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01c4b579f60869c90b1093cf94dc9e75"></a><!-- doxytag: member="MGComplex::out" ref="a01c4b579f60869c90b1093cf94dc9e75" args="(std::ostream &amp;) const " -->
virtual std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a01c4b579f60869c90b1093cf94dc9e75">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a976840702ddbb1a8285a8d9c2272ac1d"></a><!-- doxytag: member="MGComplex::pcell_begin" ref="a976840702ddbb1a8285a8d9c2272ac1d" args="() const " -->
const_pcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a976840702ddbb1a8285a8d9c2272ac1d">pcell_begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain first pcell iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb0d04d3f41d316cc64419d4c0c00852"></a><!-- doxytag: member="MGComplex::pcell_begin" ref="afb0d04d3f41d316cc64419d4c0c00852" args="()" -->
pcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>pcell_begin</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a711f823d9e8b6d3bd679b0eed9bf2b"></a><!-- doxytag: member="MGComplex::pcell_end" ref="a5a711f823d9e8b6d3bd679b0eed9bf2b" args="() const " -->
const_pcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a5a711f823d9e8b6d3bd679b0eed9bf2b">pcell_end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain end pcell iterator(next of the last pcell). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a202a89eadb803b08989cf39c49053c5b"></a><!-- doxytag: member="MGComplex::pcell_end" ref="a202a89eadb803b08989cf39c49053c5b" args="()" -->
pcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>pcell_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab820dfff952ebd6f53e006d1798b4762"></a><!-- doxytag: member="MGComplex::pcelli" ref="ab820dfff952ebd6f53e006d1798b4762" args="(size_t i) const " -->
const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#ab820dfff952ebd6f53e006d1798b4762">pcelli</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-the pcell. <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a> version. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bfd8eb557730cec0687c65d1b6e24ee"></a><!-- doxytag: member="MGComplex::pcelli" ref="a6bfd8eb557730cec0687c65d1b6e24ee" args="(size_t i)" -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pcelli</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96e18d35f493af6f2b85ff456aac7d01"></a><!-- doxytag: member="MGComplex::pcellIterator" ref="a96e18d35f493af6f2b85ff456aac7d01" args="(size_t i) const " -->
const_pcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a96e18d35f493af6f2b85ff456aac7d01">pcellIterator</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th pcell iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a87ab984b580b6a80871bad57ec4c3f"></a><!-- doxytag: member="MGComplex::pcellIterator" ref="a8a87ab984b580b6a80871bad57ec4c3f" args="(size_t i)" -->
pcellItr&nbsp;</td><td class="memItemRight" valign="bottom"><b>pcellIterator</b> (size_t i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6158be60dd6bf5d525909896459d1274"></a><!-- doxytag: member="MGComplex::pcell_exist" ref="a6158be60dd6bf5d525909896459d1274" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a6158be60dd6bf5d525909896459d1274">pcell_exist</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cehck if pcell exist. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a86cf010e9af94e2de01a44398ab10e30">pcells</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain pcells that constitute the boundary.  <a href="#a86cf010e9af94e2de01a44398ab10e30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78291d4c0b616fc463b49e8844ab2851"></a><!-- doxytag: member="MGComplex::pcells" ref="a78291d4c0b616fc463b49e8844ab2851" args="() const " -->
std::vector&lt; const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>pcells</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a7872f742bf4591dc6ccd67be200335df">pick_closest</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parameter value of the closest point from the straight to this object.  <a href="#a7872f742bf4591dc6ccd67be200335df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a88d7504a82ebe9f05fce913ef7984110">star</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get star cell pointer if this complex is a boundary of a cell.  <a href="#a88d7504a82ebe9f05fce913ef7984110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd3a8beabdc827bcdadc7cb4f03922df"></a><!-- doxytag: member="MGComplex::star" ref="acd3a8beabdc827bcdadc7cb4f03922df" args="()" -->
<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>star</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a6efc30740f7af21a3ca12a2729a42628">MGComplex</a> (std::list&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt; &amp;pcells)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fundamental constructor.  <a href="#a6efc30740f7af21a3ca12a2729a42628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8640f0e43dca47d154174688311ff4cb"></a><!-- doxytag: member="MGComplex::MGComplex" ref="a8640f0e43dca47d154174688311ff4cb" args="(const MGComplex &amp;complex, MGCellMap &amp;cmap)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a8640f0e43dca47d154174688311ff4cb">MGComplex</a> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;complex, MGCellMap &amp;cmap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binder cells of the pcells in complex will be registered in cmap. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a6f6a4f2fecac014a27db1f8d45b23c72">append_bcell</a> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *cell) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cellmap to register binder association.  <a href="#a6f6a4f2fecac014a27db1f8d45b23c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a4be69d1ce2d0f7ed34517994284fcb8d">add_cell</a> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *cell, bool pcell, cellItr loc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a Cell(binder or parameter) before the position loc.  <a href="#a4be69d1ce2d0f7ed34517994284fcb8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a74cca5e49cbf508cab7b16fddef29"></a><!-- doxytag: member="MGComplex::append_pcell" ref="a51a74cca5e49cbf508cab7b16fddef29" args="(MGCellNB *cell)" -->
cellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a51a74cca5e49cbf508cab7b16fddef29">append_pcell</a> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *cell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a PCell to the end of pcell sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f7044db59eb5e58898cc62f696c2ff1"></a><!-- doxytag: member="MGComplex::compute_box" ref="a4f7044db59eb5e58898cc62f696c2ff1" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a4f7044db59eb5e58898cc62f696c2ff1">compute_box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the box from the scratch. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a61fb7d82521125710207dae46ba577a2">copy_without_binders</a> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;comp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all pcells of comp into this, but does not copy binders of the pcells.  <a href="#a61fb7d82521125710207dae46ba577a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a7933b635822635ac530d18dcbce9c995">erase_all_elements</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all elements(PCells and BCells).  <a href="#a7933b635822635ac530d18dcbce9c995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad465b6740a557fedd16b628d309201f8"></a><!-- doxytag: member="MGComplex::prepend_pcell" ref="ad465b6740a557fedd16b628d309201f8" args="(MGCellNB *cell)" -->
cellItr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#ad465b6740a557fedd16b628d309201f8">prepend_pcell</a> (<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *cell)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend a PCell to the end of pcell sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f18c00202ab797f883a6880ca8108a4"></a><!-- doxytag: member="MGComplex::whoami" ref="a2f18c00202ab797f883a6880ca8108a4" args="() const " -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7534864b508fd471e1bddf334cf96d5f"></a><!-- doxytag: member="MGComplex::ReadMembers" ref="a7534864b508fd471e1bddf334cf96d5f" args="(MGIfstream &amp;buf)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a7534864b508fd471e1bddf334cf96d5f">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a913f2a513eb369ae39f44bd98017f45d">set_complex</a> (const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;comp2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assighment.  <a href="#a913f2a513eb369ae39f44bd98017f45d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30ba79b66279e132431d1a4ba78cef08"></a><!-- doxytag: member="MGComplex::WriteMembers" ref="a30ba79b66279e132431d1a4ba78cef08" args="(MGOfstream &amp;buf) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a30ba79b66279e132431d1a4ba78cef08">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a1fe5b3c2df3d39db626d77c3592ff24d">m_box</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Box of the complex.  <a href="#a1fe5b3c2df3d39db626d77c3592ff24d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee7c13b63bfe4299f7c7687e2cbe97b"></a><!-- doxytag: member="MGComplex::MGCellBase" ref="a8ee7c13b63bfe4299f7c7687e2cbe97b" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a8ee7c13b63bfe4299f7c7687e2cbe97b">MGCellBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4770bd0d0b30e0526d5c45f284a7ba8f"></a><!-- doxytag: member="MGComplex::MGCellNB" ref="a4770bd0d0b30e0526d5c45f284a7ba8f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a4770bd0d0b30e0526d5c45f284a7ba8f">MGCellNB</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86b87d33b3c5fe20f8a3d18a6182de07"></a><!-- doxytag: member="MGComplex::MGCell" ref="a86b87d33b3c5fe20f8a3d18a6182de07" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#a86b87d33b3c5fe20f8a3d18a6182de07">MGCell</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af72d9909f1d3964ebe7e7a084227a5d0"></a><!-- doxytag: member="MGComplex::MGEdge" ref="af72d9909f1d3964ebe7e7a084227a5d0" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#af72d9909f1d3964ebe7e7a084227a5d0">MGEdge</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_complex.html">MGComplex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_complex.html#abd1cdb348153c52e9bf5a24cfceb60df">operator*</a> (double s, const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;complex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double.  <a href="#abd1cdb348153c52e9bf5a24cfceb60df"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells.">MGComplex</a> is a container of parameter cells and binder cells. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a93125cf9fcd99120f3d226de04fe5220"></a><!-- doxytag: member="MGComplex::MGComplex" ref="a93125cf9fcd99120f3d226de04fe5220" args="(const MGComplex &amp;complex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGComplex::MGComplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>complex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copy as a boundary complex of parent. When parent is not specified, this is ordinary world complex. Not a boundary complex. </p>

</div>
</div>
<a class="anchor" id="af9221864da63938ef0fca628342b96ef"></a><!-- doxytag: member="MGComplex::MGComplex" ref="af9221864da63938ef0fca628342b96ef" args="(const MGCellNB &amp;cell)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGComplex::MGComplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cell</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct of one cell. </p>
<p>The second form takes the ownership of the cell, must be newed object. </p>

</div>
</div>
<a class="anchor" id="a6efc30740f7af21a3ca12a2729a42628"></a><!-- doxytag: member="MGComplex::MGComplex" ref="a6efc30740f7af21a3ca12a2729a42628" args="(std::list&lt; MGCellNB * &gt; &amp;pcells)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGComplex::MGComplex </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pcells</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fundamental constructor. </p>
<p>Construct from a list of pcells. This constructor takes the ownership of all pcells in pcells. Fundamental constructor of <a class="el" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells.">MGComplex</a> does not take box as input since this constructor has to do binder append treatment that is attached to pcells. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4be69d1ce2d0f7ed34517994284fcb8d"></a><!-- doxytag: member="MGComplex::add_cell" ref="a4be69d1ce2d0f7ed34517994284fcb8d" args="(MGCellNB *cell, bool pcell, cellItr loc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cellItr MGComplex::add_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pcell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cellItr&nbsp;</td>
          <td class="paramname"> <em>loc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a Cell(binder or parameter) before the position loc. </p>
<p>loc is the iterator of m_pcells or m_bcells according to pcell. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cell</em>&nbsp;</td><td>Cell to insert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcell</em>&nbsp;</td><td>indicates if input cell is parameter or binder cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loc</em>&nbsp;</td><td>Iterator that indicates insert position. Insert cell befoer the iterator loc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f6a4f2fecac014a27db1f8d45b23c72"></a><!-- doxytag: member="MGComplex::append_bcell" ref="a6f6a4f2fecac014a27db1f8d45b23c72" args="(MGCellNB *cell) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cellItr MGComplex::append_bcell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>cell</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cellmap to register binder association. </p>
<p>Append a binder to the end of bcell sequence. </p>

</div>
</div>
<a class="anchor" id="a93e3dd3da243cb7c615cfa09fa6e56d0"></a><!-- doxytag: member="MGComplex::binders" ref="a93e3dd3da243cb7c615cfa09fa6e56d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>*&gt; MGComplex::binders </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain binders of all the pcells of the boundary. </p>
<p>i-th binder of the fucntion's returned value is the binder of i-th pcell of the boundary, and may be null. </p>

</div>
</div>
<a class="anchor" id="a456439fcbecf9da638d01deae57b00a3"></a><!-- doxytag: member="MGComplex::center" ref="a456439fcbecf9da638d01deae57b00a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGComplex::center </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute barycenter of all the vertex(binder cell of 0D manifold dimension). </p>

</div>
</div>
<a class="anchor" id="aa3f172d1cfa17d3acd5d7a477fe8a227"></a><!-- doxytag: member="MGComplex::clone" ref="aa3f172d1cfa17d3acd5d7a477fe8a227" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_complex.html">MGComplex</a>* MGComplex::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_object.html#a2674ad0e501474d262335fb5b741dca4">MGObject</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_boundary.html#a545ab978b74513d4bf83fba61de8028d">MGBoundary</a>, <a class="el" href="class_m_g_loop.html#a9675c0e77ade5b4ebd3f62fce826f90c">MGLoop</a>, and <a class="el" href="class_m_g_shell.html#afa2a29fd6b285fe2dbaf89a3f5b7d416">MGShell</a>.</p>

</div>
</div>
<a class="anchor" id="a61fb7d82521125710207dae46ba577a2"></a><!-- doxytag: member="MGComplex::copy_without_binders" ref="a61fb7d82521125710207dae46ba577a2" args="(const MGComplex &amp;comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGComplex::copy_without_binders </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all pcells of comp into this, but does not copy binders of the pcells. </p>

</div>
</div>
<a class="anchor" id="a96db58f8f11eb168cf7d2c96bebb3f06"></a><!-- doxytag: member="MGComplex::draw3DVertex" ref="a96db58f8f11eb168cf7d2c96bebb3f06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGComplex::draw3DVertex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D point(vertex) in world coordinates. </p>
<p>The object is converted to point(s) and is drawn. This is valid only for topology objects or <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>. </p>

<p>Implements <a class="el" href="class_m_g_object.html#a8be57a080a4410ac2981752b157bdff3">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="a24f9a84fffb017cf5eef618e6acfe14d"></a><!-- doxytag: member="MGComplex::draw3DVertex_in_star" ref="a24f9a84fffb017cf5eef618e6acfe14d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGComplex::draw3DVertex_in_star </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D point(vertex) in star cell's world coordinates. </p>
<p>The object is converted to point(s) and is drawn. </p>

</div>
</div>
<a class="anchor" id="a4d63e44261a5983ea894958934fc4191"></a><!-- doxytag: member="MGComplex::drawWire" ref="a4d63e44261a5983ea894958934fc4191" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGComplex::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_object.html#ad422cfd57a3a6daedd7762001cb04a8f">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="ae2ab5101b12196484fde9ffda324b33a"></a><!-- doxytag: member="MGComplex::drawWire_in_star" ref="ae2ab5101b12196484fde9ffda324b33a" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGComplex::drawWire_in_star </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in the topology's star cell world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7933b635822635ac530d18dcbce9c995"></a><!-- doxytag: member="MGComplex::erase_all_elements" ref="a7933b635822635ac530d18dcbce9c995" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGComplex::erase_all_elements </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all elements(PCells and BCells). </p>
<p>erase_all_elements does free and destruct all the elements. erase_all_elements does not maintain m_box. </p>

</div>
</div>
<a class="anchor" id="aa80414982e4282ecc748b4c042a7a818"></a><!-- doxytag: member="MGComplex::erase_first_pcell" ref="aa80414982e4282ecc748b4c042a7a818" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGComplex::erase_first_pcell </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase first pcell element, including binder cells that will be free when the first pcell is erased. </p>

</div>
</div>
<a class="anchor" id="aa0be044f74c5981a6b57561c1f3a1f14"></a><!-- doxytag: member="MGComplex::erase_last_pcell" ref="aa0be044f74c5981a6b57561c1f3a1f14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGComplex::erase_last_pcell </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erase first pcell. </p>
<p>Erase last pcell element, including binder cells that will be free when the last pcell is erased. </p>

</div>
</div>
<a class="anchor" id="a7b4579a9f59b1ffe3974dd0a2fc64d98"></a><!-- doxytag: member="MGComplex::erase_pcell" ref="a7b4579a9f59b1ffe3974dd0a2fc64d98" args="(MGCellNB *pcell)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGComplex::erase_pcell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>pcell</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erase last pcell. </p>
<p>Erase the pcell element, including binder cells that will be free when the last pcell is erased. </p>

</div>
</div>
<a class="anchor" id="a752b2c1abc8324ffeb9c37ba06e0f824"></a><!-- doxytag: member="MGComplex::includes" ref="a752b2c1abc8324ffeb9c37ba06e0f824" args="(const MGCellNB *cell) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGComplex::includes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>cell</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this complex includes the <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a> cell as a contituent. </p>
<p>Returns true if cell is included in this complex. </p>

</div>
</div>
<a class="anchor" id="a89d191471c5f833e0e3347c64ba38f41"></a><!-- doxytag: member="MGComplex::operator*" ref="a89d191471c5f833e0e3347c64ba38f41" args="(double s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_complex.html">MGComplex</a> MGComplex::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double. </p>

</div>
</div>
<a class="anchor" id="a704c3a3d43f10a739e9cab09c83a7c63"></a><!-- doxytag: member="MGComplex::operator*" ref="a704c3a3d43f10a739e9cab09c83a7c63" args="(const MGTransf &amp;tr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_complex.html">MGComplex</a> MGComplex::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換によってトランスフォームをおこないComplexを生成する。 Transformation of the Complex by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>. </p>

</div>
</div>
<a class="anchor" id="af24628df8b7060cffdbcfaa701d525d3"></a><!-- doxytag: member="MGComplex::operator*" ref="af24628df8b7060cffdbcfaa701d525d3" args="(const MGMatrix &amp;mat) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_complex.html">MGComplex</a> MGComplex::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換でComplexの変換を行い，Complexを作成する。 Transformation of the Complex by a matrix. </p>

</div>
</div>
<a class="anchor" id="a7f84de6ec58b59548315a274174ea162"></a><!-- doxytag: member="MGComplex::operator/" ref="a7f84de6ec58b59548315a274174ea162" args="(double s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_complex.html">MGComplex</a> MGComplex::operator/ </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double. </p>

</div>
</div>
<a class="anchor" id="a68677e75e2739903c83c9dc8d15bd27e"></a><!-- doxytag: member="MGComplex::operator=" ref="a68677e75e2739903c83c9dc8d15bd27e" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_complex.html">MGComplex</a>&amp; MGComplex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and topo2 are not equal, this assignment does nothing. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_loop.html#a843f58910e6f890d5f415b3322cf69f5">MGLoop</a>, and <a class="el" href="class_m_g_shell.html#a0e273568faef8b3b374b5b6c44355101">MGShell</a>.</p>

</div>
</div>
<a class="anchor" id="a86cf010e9af94e2de01a44398ab10e30"></a><!-- doxytag: member="MGComplex::pcells" ref="a86cf010e9af94e2de01a44398ab10e30" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>*&gt; MGComplex::pcells </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain pcells that constitute the boundary. </p>
<p>Let pcellvec[.] be pcells' return value and bindervec[.] be binders' return value. Then pcellvec[i] corresponds to bindervec[i]. bindervec[i] is binder cell of i-th pcell element of the boundary. </p>

</div>
</div>
<a class="anchor" id="a7872f742bf4591dc6ccd67be200335df"></a><!-- doxytag: member="MGComplex::pick_closest" ref="a7872f742bf4591dc6ccd67be200335df" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGComplex::pick_closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parameter value of the closest point from the straight to this object. </p>
<p>sl is the eye projection line whose direction is from yon to hither, and if sl had multiple intersection points, The closest point to the eye will be selected. </p>

<p>Reimplemented from <a class="el" href="class_m_g_object.html#afad70053cb311ff1a2a7ab86b9a4e1a7">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="a913f2a513eb369ae39f44bd98017f45d"></a><!-- doxytag: member="MGComplex::set_complex" ref="a913f2a513eb369ae39f44bd98017f45d" args="(const MGComplex &amp;comp2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_complex.html">MGComplex</a>&amp; MGComplex::set_complex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comp2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assighment. </p>
<p>When the leaf object of this and topo2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a88d7504a82ebe9f05fce913ef7984110"></a><!-- doxytag: member="MGComplex::star" ref="a88d7504a82ebe9f05fce913ef7984110" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>* MGComplex::star </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get star cell pointer if this complex is a boundary of a cell. </p>
<p>Else, null will be returned. </p>

<p>Reimplemented in <a class="el" href="class_m_g_boundary.html#a7547171f0c4538110cd689bbc2fbdab5">MGBoundary</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="abd1cdb348153c52e9bf5a24cfceb60df"></a><!-- doxytag: member="MGComplex::operator*" ref="abd1cdb348153c52e9bf5a24cfceb60df" args="(double s, const MGComplex &amp;complex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_complex.html">MGComplex</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_complex.html">MGComplex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>complex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a1fe5b3c2df3d39db626d77c3592ff24d"></a><!-- doxytag: member="MGComplex::m_box" ref="a1fe5b3c2df3d39db626d77c3592ff24d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> <a class="el" href="class_m_g_complex.html#a1fe5b3c2df3d39db626d77c3592ff24d">MGComplex::m_box</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Box of the complex. </p>
<p>Initially this is null, and will be computed if necessary. Currently Box is computed only from pcells, not correct box. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Complex.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:19 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGSurface Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGSurface" --><!-- doxytag: inherits="MGGeometry,MGFSurface" -->
<p><a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> is an abstract class of 3D surface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Surface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_surface__inherit__graph.png" border="0" usemap="#_m_g_surface_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_surface_inherit__map" id="_m_g_surface_inherit__map">
<area shape="rect" id="node13" href="class_m_g_b_sum_surf.html" title="Defines Boolean sum surface." alt="" coords="5,392,107,421"/><area shape="rect" id="node15" href="class_m_g_cylinder.html" title="MGCylinder is a Cylinder in 3D space." alt="" coords="131,392,221,421"/><area shape="rect" id="node17" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space." alt="" coords="245,392,320,421"/><area shape="rect" id="node19" href="class_m_g_r_s_b_rep.html" title="Defines Surface B&#45;Representation of rational form." alt="" coords="344,392,437,421"/><area shape="rect" id="node21" href="class_m_g_s_b_rep.html" title="Defines Surface B&#45;Representation, that is , B&#45;Spline surface." alt="" coords="461,392,544,421"/><area shape="rect" id="node23" href="class_m_g_sphere.html" title="MGSphere is a Sphere in 3D space." alt="" coords="568,392,651,421"/><area shape="rect" id="node2" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="227,237,325,267"/><area shape="rect" id="node4" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="236,160,316,189"/><area shape="rect" id="node6" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="223,83,329,112"/><area shape="rect" id="node8" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="245,5,307,35"/><area shape="rect" id="node10" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="349,237,443,267"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_surface__coll__graph.png" border="0" usemap="#_m_g_surface_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_surface_coll__map" id="_m_g_surface_coll__map">
<area shape="rect" id="node2" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="192,501,291,531"/><area shape="rect" id="node4" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node6" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node12" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node8" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node10" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node15" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node18" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node20" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node22" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/><area shape="rect" id="node24" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="315,501,408,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_surface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7499a48fa31e1a7b8ccffee9d2a23a5"></a><!-- doxytag: member="MGSurface::MGSurface" ref="ab7499a48fa31e1a7b8ccffee9d2a23a5" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab7499a48fa31e1a7b8ccffee9d2a23a5">MGSurface</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void Constructor. 初期化なしでオブジェクトを作成する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a46cef9293e898278d8e405da3fd5f"></a><!-- doxytag: member="MGSurface::MGSurface" ref="ab8a46cef9293e898278d8e405da3fd5f" args="(const MGSurface &amp;srf)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab8a46cef9293e898278d8e405da3fd5f">MGSurface</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af083e85011758470457521a8d445beb7"></a><!-- doxytag: member="MGSurface::‾MGSurface" ref="af083e85011758470457521a8d445beb7" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGSurface</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a76c986bf4d62c1dd70014ea0cc90c6e3">operator=</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a76c986bf4d62c1dd70014ea0cc90c6e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a501dcf91207e2d51215d480a394bed23"></a><!-- doxytag: member="MGSurface::operator+=" ref="a501dcf91207e2d51215d480a394bed23" args="(const MGVector &amp;v)=0" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a501dcf91207e2d51215d480a394bed23">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a946107e349493222bd484230e18b9503"></a><!-- doxytag: member="MGSurface::operator&#45;=" ref="a946107e349493222bd484230e18b9503" args="(const MGVector &amp;v)=0" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac477272aed2dbfe93f084ef2be430994"></a><!-- doxytag: member="MGSurface::operator*=" ref="ac477272aed2dbfe93f084ef2be430994" args="(double scale)=0" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ec820b088a398968292638e501e3868"></a><!-- doxytag: member="MGSurface::operator*=" ref="a3ec820b088a398968292638e501e3868" args="(const MGMatrix &amp;mat)=0" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7628abab1b1e56600c2fa52f5dbf9451"></a><!-- doxytag: member="MGSurface::operator*=" ref="a7628abab1b1e56600c2fa52f5dbf9451" args="(const MGTransf &amp;tr)=0" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acedcfdecfdcfa3890f882a04ecab1ca8"></a><!-- doxytag: member="MGSurface::operator==" ref="acedcfdecfdcfa3890f882a04ecab1ca8" args="(const MGGel &amp;gel2) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#acedcfdecfdcfa3890f882a04ecab1ca8">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38e91566e2935f401fa38393ee9f03b"></a><!-- doxytag: member="MGSurface::operator&lt;" ref="aa38e91566e2935f401fa38393ee9f03b" args="(const MGGel &amp;gel2) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a0df52ab736aa74ae2da517bd0484be03">arrow</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects.">MGAppearance</a> pointer of this object.  <a href="#a0df52ab736aa74ae2da517bd0484be03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d415789629f5216fad1fa852cebf237"></a><!-- doxytag: member="MGSurface::arrow" ref="a3d415789629f5216fad1fa852cebf237" args="(const MGPosition &amp;uv, MGPosition data[10]) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>arrow</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a9b56d297311a97669543ccdc0f2977f9">arrow</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;box, double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> data[10]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate arrow data, given box.  <a href="#a9b56d297311a97669543ccdc0f2977f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd85eec612a4a725bdf9d2013b46b6ed"></a><!-- doxytag: member="MGSurface::bdim_u" ref="abd85eec612a4a725bdf9d2013b46b6ed" args="() const " -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bdim_u</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f91b61d1e9aef9655628f3fbcbb942e"></a><!-- doxytag: member="MGSurface::bdim_v" ref="a1f91b61d1e9aef9655628f3fbcbb942e" args="() const " -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1f91b61d1e9aef9655628f3fbcbb942e">bdim_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension of u. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a9182844563218c392ef526d29e5bfb7e">box_limitted</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension of v.  <a href="#a9182844563218c392ef526d29e5bfb7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bbb9da67cf70b8c7422159d6c37606b"></a><!-- doxytag: member="MGSurface::box_param" ref="a8bbb9da67cf70b8c7422159d6c37606b" args="() const " -->
<a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8bbb9da67cf70b8c7422159d6c37606b">box_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return box of the parameter space of the surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ad0b4d8c8eb52d145ba1128936d2a0e1e">box_param2</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return box of the parameter space of the FSurface.  <a href="#ad0b4d8c8eb52d145ba1128936d2a0e1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008d749d0698e5d4b46aa086888604df"></a><!-- doxytag: member="MGSurface::center" ref="a008d749d0698e5d4b46aa086888604df" args="() const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a008d749d0698e5d4b46aa086888604df">center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain ceter coordinate of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1825e4f390e6cee6461a0dacd36b03ee"></a><!-- doxytag: member="MGSurface::center_param" ref="a1825e4f390e6cee6461a0dacd36b03ee" args="() const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1825e4f390e6cee6461a0dacd36b03ee">center_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain ceter parameter value of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab37b86c29caed93258a98d7e70459d4e">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#ab37b86c29caed93258a98d7e70459d4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1d4365d58c465f916b2fb038ef896b2d">change_range</a> (int is_u, double t1, double t2)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a1d4365d58c465f916b2fb038ef896b2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#adfdb3b6a71739d4003fa3ec2d840a034">coef_sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain coefficient's space dimension.  <a href="#adfdb3b6a71739d4003fa3ec2d840a034"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6afd503925efe4e75890ec9c7c5c909"></a><!-- doxytag: member="MGSurface::clone_fsurface" ref="ae6afd503925efe4e75890ec9c7c5c909" args="() const " -->
virtual <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ae6afd503925efe4e75890ec9c7c5c909">clone_fsurface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the clone of this <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a4a623309eb1cc5105400dda4aa003efe">clone_as_face</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the clone of this as a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>.  <a href="#a4a623309eb1cc5105400dda4aa003efe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a968d690be2c0009a282ac74085b95422">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value (u,v)of this surface from a point.  <a href="#a968d690be2c0009a282ac74085b95422"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a79b233ce393381acf1017555e203971c">closest_on_perimeter</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point on all the perimeters of the surface.  <a href="#a79b233ce393381acf1017555e203971c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb7a66b9599124681da7a2a36ced2088"></a><!-- doxytag: member="MGSurface::closest_on_perimeter" ref="afb7a66b9599124681da7a2a36ced2088" args="(const MGStraight &amp;sl) const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>closest_on_perimeter</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a389583b74836a7496f7ead774fe1d6f5">closest_on_boundary</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute closest point from a line to the boundary of the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>.  <a href="#a389583b74836a7496f7ead774fe1d6f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a55ce6580673b46480f6ae5a8d2117c17">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#a55ce6580673b46480f6ae5a8d2117c17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a0cf87d2f42a919c9f5bc44cc406ea0fd">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#a0cf87d2f42a919c9f5bc44cc406ea0fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#afbab88475e9baabe1684775ffbff30dc">curvatures</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double value[4], <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute surface curvatures: value[0]=K:Gaussian curvature=k1*k2, value[1]=H:Mean curvature=(k1+k2)/2, value[2]=k1:minimum curvature, and value[3]=k2=maximum curvature.  <a href="#afbab88475e9baabe1684775ffbff30dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d57ff8aa887f5818540e5070e634bc1"></a><!-- doxytag: member="MGSurface::curvatures" ref="a4d57ff8aa887f5818540e5070e634bc1" args="(double u, double v, double value[4], MGUnit_vector &amp;N) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>curvatures</b> (double u, double v, double value[4], <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecd70fbdd3a3e91de49b5c8515c195db"></a><!-- doxytag: member="MGSurface::direction" ref="aecd70fbdd3a3e91de49b5c8515c195db" args="(const MGPosition &amp;param) const " -->
<a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aecd70fbdd3a3e91de49b5c8515c195db">direction</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;param) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute direction unit vector of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ad43e101de71052301de2cc8c7e4405ef">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#ad43e101de71052301de2cc8c7e4405ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af76280bbd8b55c5d5d1da95c6f5accd3">copy_surface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area.  <a href="#af76280bbd8b55c5d5d1da95c6f5accd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c4e970b60d81ea1b0de587c33241ef"></a><!-- doxytag: member="MGSurface::display_arrows" ref="a51c4e970b60d81ea1b0de587c33241ef" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_arrows</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a27fdd1ff58f14d6ee6691f711d3bd039">divide_multi_knot</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt; &amp;srfl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uまたはv方向に折れ(マルチノット)があるとき面を分割する 戻り値は、分割数を返却する  <a href="#a27fdd1ff58f14d6ee6691f711d3bd039"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a2d663b20dc40dbf65b2a27b8226e4468">equal_direction</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;param_curve, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;world_curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute if <a class="el" href="class_m_g_surf_curve.html" title="MGSurfCurve is a curve defined by a surface and its parameter space line represented...">MGSurfCurve</a> scurve(*this, param_curve) has the same direction to world_curve, assuming that scurve and world_curve are the same curve.  <a href="#a2d663b20dc40dbf65b2a27b8226e4468"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#ada7939e987d1f90d7c765b63b07b8533"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a9d9355b68189922fd3e326fc8a91d1e7">eval_spoint</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utau, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtau, <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;spoint) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate all the points (ui, vj) into spoint(i,j,.  <a href="#a9d9355b68189922fd3e326fc8a91d1e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8153b4db02d3056377d79f43254d11e5">eval_all</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#a8153b4db02d3056377d79f43254d11e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8ce3c2446526c5961f70b998c37e4b30">eval_all</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#a8ce3c2446526c5961f70b998c37e4b30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aa8e61cdada1be0cd679b49c3324f5ddd">eval_gap</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, int iperi, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">evaluate gap between this surface's perimeter iperi and the given curve curve.  <a href="#aa8e61cdada1be0cd679b49c3324f5ddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a639a294d997ce03d7c4d3881d02015f2">eval_gap</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> *curve[4], <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">evaluate gap between this surface's perimeters and the given curve curve.  <a href="#a639a294d997ce03d7c4d3881d02015f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a360cae304c680229d60d725f92fb3701">evaluate</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;t, const size_t *nderiv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate n'th derivative data. n=0 means positional data evaluation.  <a href="#a360cae304c680229d60d725f92fb3701"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae86003b1b05b6a7c0ec087a90f994164"></a><!-- doxytag: member="MGSurface::exchange_uv" ref="ae86003b1b05b6a7c0ec087a90f994164" args="()=0" -->
virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ae86003b1b05b6a7c0ec087a90f994164">exchange_uv</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange parameter u and v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab52fd64da1afa26965f381962edf0f75">extend</a> (int perimeter, double param, double length, double dk=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original Surface by extrapolating the specified perimeter.  <a href="#ab52fd64da1afa26965f381962edf0f75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a6cde8bf99bc3151077ddcfa1233cb"></a><!-- doxytag: member="MGSurface::fsurface" ref="af4a6cde8bf99bc3151077ddcfa1233cb" args="() const " -->
const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af4a6cde8bf99bc3151077ddcfa1233cb">fsurface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a> pointer if this is <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> or <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59158eb90a1b23530f46fd3d237b67ff"></a><!-- doxytag: member="MGSurface::fsurface" ref="a59158eb90a1b23530f46fd3d237b67ff" args="()" -->
<a class="el" href="class_m_g_f_surface.html">MGFSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fsurface</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a41b9e5c2304da978143e5a511e9adf4b">fundamentals</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double Q[6], <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;UN) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute 1st and 2nd fundamental quantities of the surface.  <a href="#a41b9e5c2304da978143e5a511e9adf4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab60e61180fcca5f540b2acabe518d316">fundamentals</a> (double u, double v, double Q[6], <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a4adb7c525fcc20d70c1fdbd171b5df33">get_approximate_plane</a> (double u0, double u1, double v0, double v1, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, double *width=0, double *height=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the approximate plane in the parameter range from (u0, v0) to (u1,v1) The plane's origin is center point of the plane when the surface is mapped onto the plane.  <a href="#a4adb7c525fcc20d70c1fdbd171b5df33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad46d4d518414c33a33c8c3d81cf84bf2"></a><!-- doxytag: member="MGSurface::get_face_pointer" ref="ad46d4d518414c33a33c8c3d81cf84bf2" args="()" -->
<a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ad46d4d518414c33a33c8c3d81cf84bf2">get_face_pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get face pointer if this is <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, else null will be returned. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb5cbfe5daca198fd000b573d28e8529"></a><!-- doxytag: member="MGSurface::get_face_pointer" ref="acb5cbfe5daca198fd000b573d28e8529" args="() const " -->
const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_face_pointer</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a93c9df7b6765434539d85dc059619311">getPerimeterCommon</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, std::vector&lt; double &gt; pspan[2], int peri_num[2]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute common curve part of this surface's perimeter and the crv.  <a href="#a93c9df7b6765434539d85dc059619311"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8c24da8133fbbef6f02284939d1caaa5">get_surface_pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get surface pointer.  <a href="#a8c24da8133fbbef6f02284939d1caaa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6330c3b66fef19ec1aa0b64e2a14766b"></a><!-- doxytag: member="MGSurface::get_surface_pointer" ref="a6330c3b66fef19ec1aa0b64e2a14766b" args="() const " -->
const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_surface_pointer</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a832e534adf43ad01904baa15e3eff6"></a><!-- doxytag: member="MGSurface::get_number_of_boundaries" ref="a5a832e534adf43ad01904baa15e3eff6" args="() const " -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a5a832e534adf43ad01904baa15e3eff6">get_number_of_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of inner boundaries as the output of the function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ac0eb77f69a81d6ed8106faa92e42a7c5">get_parameterCurve</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;wcrv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given world curve wcrv on this face, get the parameter space representation pcrv.  <a href="#ac0eb77f69a81d6ed8106faa92e42a7c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a6f773b2759f1b0c66b20ed8888aae990">on_a_perimeter</a> (double &amp;u, double &amp;v, size_t &amp;perim_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is parameter value on a perimeter of the surface.  <a href="#a6f773b2759f1b0c66b20ed8888aae990"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a5c6a8ed9b6d90b4481baa3c553aaf272">on_a_perimeter2</a> (int is_u, double &amp;x, size_t &amp;perim_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input x is parameter value on a perimeter of the surface.  <a href="#a5c6a8ed9b6d90b4481baa3c553aaf272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a75f016363f801103239789e75fd34972">has_commonFS</a> (const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;obj2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this and 2nd object has common area about their <a class="el" href="class_m_g_geometry.html#a28feceac1ef6e868090b24832c0710b4" title="Return minimum box that includes whole of the geometry.">box()</a>, taking error into account.  <a href="#a75f016363f801103239789e75fd34972"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a55206c783635934aa4bcd2f3231a2a1a">shade</a> (double span_length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shade the object in world coordinates.  <a href="#a55206c783635934aa4bcd2f3231a2a1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ac24e9631f2fb3c3940ac0ff552e723e9">test_and_get_approximate_plane</a> (double u0, double u1, double v0, double v1, double surface_tol, double angle, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, double &amp;width, double &amp;height) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the approximate plane in the parameter range from (u0, v0) to (u1,v1) when the surface is within surface_tol and angle from the plane.  <a href="#ac24e9631f2fb3c3940ac0ff552e723e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5cb46309b44af0efdabfc08550db9c9"></a><!-- doxytag: member="MGSurface::identify_type" ref="ad5cb46309b44af0efdabfc08550db9c9" args="() const =0" -->
virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ad5cb46309b44af0efdabfc08550db9c9">identify_type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39e2319c9333621b8765642109c901ad"></a><!-- doxytag: member="MGSurface::in_range" ref="a39e2319c9333621b8765642109c901ad" args="(double u, double v) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a39e2319c9333621b8765642109c901ad">in_range</a> (double u, double v) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is in the range of the FSurface parameter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d240c3421fbfe8f003b878f29832030"></a><!-- doxytag: member="MGSurface::in_range" ref="a6d240c3421fbfe8f003b878f29832030" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a2f5d3960fca3e1e69e67314087a4ea24">in_range_with_on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if (u,v) is inside the face.  <a href="#a2f5d3960fca3e1e69e67314087a4ea24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1da72edf6bf5bea0bb56864266258ce0">inner_boundary</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface.  <a href="#a1da72edf6bf5bea0bb56864266258ce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a866b006d84096d32762b7dec7611d67f">inner_boundary_param</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface.  <a href="#a866b006d84096d32762b7dec7611d67f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a066b0c4f04d3600684677e9fad4dc500">intersect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default surface-curve intersection function.  <a href="#a066b0c4f04d3600684677e9fad4dc500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd4fe8290f11633bf1ea62d63a4bc7bb"></a><!-- doxytag: member="MGSurface::intersect" ref="acd4fe8290f11633bf1ea62d63a4bc7bb" args="(const MGEllipse &amp;el) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#acd4fe8290f11633bf1ea62d63a4bc7bb">intersect</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;el) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default surface-curve intersection function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aede24171ee30feb42c62cf397a615465">intersection</a> (const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;obj2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersections of two objects.  <a href="#aede24171ee30feb42c62cf397a615465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c2da8e3cbeb62d422d6c262b7599023"></a><!-- doxytag: member="MGSurface::intersection" ref="a4c2da8e3cbeb62d422d6c262b7599023" args="(const MGCurve &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabcbdb6dd86332555a1c1947e2328604"></a><!-- doxytag: member="MGSurface::intersection" ref="aabcbdb6dd86332555a1c1947e2328604" args="(const MGFSurface &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18383a054c58a6effc5116be5fb0d720"></a><!-- doxytag: member="MGSurface::intersection" ref="a18383a054c58a6effc5116be5fb0d720" args="(const MGSurface &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5420456c3f38c1444135596e352cc829"></a><!-- doxytag: member="MGSurface::intersection" ref="a5420456c3f38c1444135596e352cc829" args="(const MGFace &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab332d83ecdf10b3a0e9c253fbdb906e0"></a><!-- doxytag: member="MGSurface::intersection" ref="ab332d83ecdf10b3a0e9c253fbdb906e0" args="(const MGShell &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a3d84645dc04d80bb2ff1df214f3a3b9b">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Surface の交線を求める。 Surface and Surface intersection.  <a href="#a3d84645dc04d80bb2ff1df214f3a3b9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291c771e87088c632dd7b21884c627e3"></a><!-- doxytag: member="MGSurface::isect" ref="a291c771e87088c632dd7b21884c627e3" args="(const MGPlane &amp;srf2) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e8dddd9e81e7d864520eaae7bf341c9"></a><!-- doxytag: member="MGSurface::isect" ref="a5e8dddd9e81e7d864520eaae7bf341c9" args="(const MGSphere &amp;srf2) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;srf2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bdb2f44bdd9d2122fe4f423589b91b0"></a><!-- doxytag: member="MGSurface::isect" ref="a0bdb2f44bdd9d2122fe4f423589b91b0" args="(const MGCylinder &amp;srf2) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;srf2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a315b7abc24f64c42257c7ae09da466e7"></a><!-- doxytag: member="MGSurface::isect" ref="a315b7abc24f64c42257c7ae09da466e7" args="(const MGSBRep &amp;srf2) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;srf2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f9c33ab60fe0605374eb489299028e0"></a><!-- doxytag: member="MGSurface::isect" ref="a0f9c33ab60fe0605374eb489299028e0" args="(const MGRSBRep &amp;srf2) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;srf2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81d93d48392df5831861362302591f7c"></a><!-- doxytag: member="MGSurface::isect" ref="a81d93d48392df5831861362302591f7c" args="(const MGBSumSurf &amp;srf2) const =0" -->
virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;srf2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f8765256601481a6bb63a81d3c8e85"></a><!-- doxytag: member="MGSurface::isect" ref="a38f8765256601481a6bb63a81d3c8e85" args="(const MGFace &amp;f) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;f) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a502c2405a78016f5724eae8a6dcb15d7"></a><!-- doxytag: member="MGSurface::isect" ref="a502c2405a78016f5724eae8a6dcb15d7" args="(const MGFSurface &amp;fsurf) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;fsurf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40d9a7d56731aab8221c0b19686fca72"></a><!-- doxytag: member="MGSurface::isect" ref="a40d9a7d56731aab8221c0b19686fca72" args="(const MGShell &amp;shl) const " -->
<a class="el" href="class_m_g_h_hisect__vector.html">MGHHisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a40d9a7d56731aab8221c0b19686fca72">isect</a> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;shl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a97fecbc27841cd336e1b26d2e64c2bf0">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Curve の交点を求める。 Curve and Surface intersection.  <a href="#a97fecbc27841cd336e1b26d2e64c2bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a335ba5373321e236da3ff3ae24ed451a">isect_order</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return order of intersection line order of <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>.  <a href="#a335ba5373321e236da3ff3ae24ed451a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1693f122c84dfb66888e0189767550d8">isect_startH</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_startIn, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;sf2, <a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;ssi, MGPosition_list::iterator &amp;uvuv_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_startH compute one intersection line of two surfaces, this and sf2, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2).  <a href="#a1693f122c84dfb66888e0189767550d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a84499b9e91ee9d02e1cf2c8c911805c2">isect_boundary</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuvs, size_t id1=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of this face's boundary(outer and inners) with face2.  <a href="#a84499b9e91ee9d02e1cf2c8c911805c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a01bca74c9479d189a5b49c331414a77e">isect_incurves</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, size_t iid, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, size_t id1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points between the boundary of iid-th inner boundary of this face and face2 to compute intersections of face with face2.  <a href="#a01bca74c9479d189a5b49c331414a77e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af7ed14b2843adc1468aaca7328f71a0b">isect_outcurves</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;face2, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, size_t id1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of outer boundary curves of this face with face2 to compute intersections.  <a href="#af7ed14b2843adc1468aaca7328f71a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdacdadc955741a3d1a52a78315a58f0"></a><!-- doxytag: member="MGSurface::knot_u" ref="afdacdadc955741a3d1a52a78315a58f0" args="(size_t i) const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#afdacdadc955741a3d1a52a78315a58f0">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0fd46f1a7050a81175014916935c317"></a><!-- doxytag: member="MGSurface::knot_v" ref="aa0fd46f1a7050a81175014916935c317" args="(size_t i) const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aa0fd46f1a7050a81175014916935c317">knot_v</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d3e1c90bf96811d94debfe924414cb0"></a><!-- doxytag: member="MGSurface::knot_vector_u" ref="a9d3e1c90bf96811d94debfe924414cb0" args="() const =0" -->
virtual const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a9d3e1c90bf96811d94debfe924414cb0">knot_vector_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21115aadc911f1b05dfd53bd86a37df"></a><!-- doxytag: member="MGSurface::knot_vector_u" ref="ac21115aadc911f1b05dfd53bd86a37df" args="()=0" -->
virtual <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a646a6937dcbfee97cff8badde6becfca"></a><!-- doxytag: member="MGSurface::knot_vector_v" ref="a646a6937dcbfee97cff8badde6becfca" args="() const =0" -->
virtual const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a646a6937dcbfee97cff8badde6becfca">knot_vector_v</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addb4b6f21142a41d7e7b5e1a3b778a51"></a><!-- doxytag: member="MGSurface::knot_vector_v" ref="addb4b6f21142a41d7e7b5e1a3b778a51" args="()=0" -->
virtual <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ae1325fe2f42237e3348d410e5de8c700">less_than</a> (size_t i, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two parameter values.  <a href="#ae1325fe2f42237e3348d410e5de8c700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a5c88f614bd2981dd988ba77a06005244">make_face</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> object.  <a href="#a5c88f614bd2981dd988ba77a06005244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ad98eb8a83bc79f4b4883953ea3545c0e">make_display_list_to_hilight</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a display list without color of this gel.  <a href="#ad98eb8a83bc79f4b4883953ea3545c0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d696843de6236a430ea8c2fc74626bc"></a><!-- doxytag: member="MGSurface::manifold_dimension" ref="a2d696843de6236a430ea8c2fc74626bc" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a2d696843de6236a430ea8c2fc74626bc">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a6bf59d4cc4acf012450b3fdc5bb742ae">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">面の方向を反転する。 Negate direction of surface.  <a href="#a6bf59d4cc4acf012450b3fdc5bb742ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a185448fbcec5764d2823db4c0064c6c5"></a><!-- doxytag: member="MGSurface::negateFS" ref="a185448fbcec5764d2823db4c0064c6c5" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a185448fbcec5764d2823db4c0064c6c5">negateFS</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the FSurface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a5f1ebb47122de32a0f5702f160a51d2a">negate</a> (int is_u)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate direction of surface.  <a href="#a5f1ebb47122de32a0f5702f160a51d2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a721d66f4cf446ecd1e987227aea5c998">negate_transform</a> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;boundary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform the coordinates of boundary of this geometry so that new coordinate of boundary is the same coordinate as the new one of this geometry after <a class="el" href="class_m_g_surface.html#a6bf59d4cc4acf012450b3fdc5bb742ae" title="面の方向を反転する。 Negate direction of surface.">negate()</a> of this geometry is done.  <a href="#a721d66f4cf446ecd1e987227aea5c998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdde39674b6819ed509b6f1e8a3675df"></a><!-- doxytag: member="MGSurface::normal" ref="acdde39674b6819ed509b6f1e8a3675df" args="(double u, double v) const " -->
virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#acdde39674b6819ed509b6f1e8a3675df">normal</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a873a07c74cc0ed6dfba62adf43237d92"></a><!-- doxytag: member="MGSurface::normal" ref="a873a07c74cc0ed6dfba62adf43237d92" args="(const MGPosition &amp;uv) const " -->
virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a873a07c74cc0ed6dfba62adf43237d92">normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8757344a70852bfea6e96bce5d537faf"></a><!-- doxytag: member="MGSurface::object_pointer" ref="a8757344a70852bfea6e96bce5d537faf" args="() const " -->
virtual const <a class="el" href="class_m_g_object.html">MGObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8757344a70852bfea6e96bce5d537faf">object_pointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the object point of this <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9c2073bc3411214ec2f1d25d9542d2d"></a><!-- doxytag: member="MGSurface::object_pointer" ref="ae9c2073bc3411214ec2f1d25d9542d2d" args="()" -->
virtual <a class="el" href="class_m_g_object.html">MGObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>object_pointer</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ade5530f3866464eda2faf064edc3aa31">offset</a> (double ofs_value, int &amp;error) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">一定オフセット関数 オフセット方向は、ノーマル方向を正とする。曲率半径より大きいオフセットは行わない。 戻り値は、オフセット曲面リストが返却される。エラーのとき長さ0の曲面リストが返る。 トレランスはline_zero()を使用している。 Surface offset.  <a href="#ade5530f3866464eda2faf064edc3aa31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a12a83c8c316f114b5eac5bb9fdac12bf">offset_fs</a> (double distance, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;vecOfsFSurface) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset.  <a href="#a12a83c8c316f114b5eac5bb9fdac12bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ae2dab410e24064b16318be2f56d2246c">offset_c1</a> (double ofs_value, int &amp;error) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。曲率半径より大きいオフセットは行わない。 戻り値は、オフセットした曲面のオートポインタが返却される。エラーのときヌルが返る。 トレランスはline_zero()を使用している。 C1 continuous Surface offset.  <a href="#ae2dab410e24064b16318be2f56d2246c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a409507f5dcc86cab92e3448529a94196">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた誤差内で点が面上にあるかどうかテストする。 Test if point P is ont the surface or not.  <a href="#a409507f5dcc86cab92e3448529a94196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a2b61d4bf8d30ee128a81c96ac4e9beb9">on_the_perimeter</a> (size_t perim_num, double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is on the perimeter perim_num.  <a href="#a2b61d4bf8d30ee128a81c96ac4e9beb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ac94c4040b915518414e83fdfe65a8515">on_perimeter</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;uvcurve, size_t &amp;perim_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test the uvcurve is on a perimeter.  <a href="#ac94c4040b915518414e83fdfe65a8515"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad8d526e4ef677abad131d35a18031e"></a><!-- doxytag: member="MGSurface::order_u" ref="a3ad8d526e4ef677abad131d35a18031e" args="() const " -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a3ad8d526e4ef677abad131d35a18031e">order_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order of u. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c1bd04d687e8816e82551876948564f"></a><!-- doxytag: member="MGSurface::order_v" ref="a3c1bd04d687e8816e82551876948564f" args="() const " -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a3c1bd04d687e8816e82551876948564f">order_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order of v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a484f8cc1c250c5b52fb960b1fda5bb54"></a><!-- doxytag: member="MGSurface::out" ref="a484f8cc1c250c5b52fb960b1fda5bb54" args="(std::ostream &amp;ostrm) const " -->
virtual std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a484f8cc1c250c5b52fb960b1fda5bb54">out</a> (std::ostream &amp;ostrm) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f1fc922dcff017f633c4ceae356b472"></a><!-- doxytag: member="MGSurface::outFS" ref="a8f1fc922dcff017f633c4ceae356b472" args="(std::ostream &amp;ostrm) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8f1fc922dcff017f633c4ceae356b472">outFS</a> (std::ostream &amp;ostrm) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af348d7e9562dce2b9d435e4960ff1ac5">outer_boundary</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain outer_boundary curves(world coordinates representation) of the FSurface.  <a href="#af348d7e9562dce2b9d435e4960ff1ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a58d900e6d0b1f91aa0e9ce7857bd07b8">outer_boundary_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain boundary curves(parameter space representation) of the FSurface.  <a href="#a58d900e6d0b1f91aa0e9ce7857bd07b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a423bee27e6e375739359ff13ca2c73c2">param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身の上の指定点を表すパラメータ値を返す。 Return surface parameter value of a point on the surface.  <a href="#a423bee27e6e375739359ff13ca2c73c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#adc9bc5efbc9fdf96b92770aaeed602ca">param_of_pcurve</a> (double tw, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;wcurve, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;pcurve, const double *guess=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let wcurve be a world curve rep that lies on this surface, and pcurve is parameter (u,v) expression of wcurve.  <a href="#adc9bc5efbc9fdf96b92770aaeed602ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a990784f37f8d568aab8d0bc1a0d08e5b">parameter</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter value of given point.  <a href="#a990784f37f8d568aab8d0bc1a0d08e5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a470c01ec42c6e71b6c34601cc558ec96">parameter_curve</a> (int is_u, double x) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter curve.  <a href="#a470c01ec42c6e71b6c34601cc558ec96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a47ed9e72cb270f3edfe14d28df1a8e28">parameter_curves</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter curves.  <a href="#a47ed9e72cb270f3edfe14d28df1a8e28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c3e00eb70f71386cbf3bd0934e62cd"></a><!-- doxytag: member="MGSurface::param_error" ref="af9c3e00eb70f71386cbf3bd0934e62cd" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af9c3e00eb70f71386cbf3bd0934e62cd">param_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter space error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fa9705d665fe87e4584f7559c1b177e"></a><!-- doxytag: member="MGSurface::param_error_u" ref="a3fa9705d665fe87e4584f7559c1b177e" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_error_u</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6bc20bfd8cd1c4502f80ebf8b46ff1f"></a><!-- doxytag: member="MGSurface::param_error_v" ref="af6bc20bfd8cd1c4502f80ebf8b46ff1f" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_error_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8008063c4bd5800dcba5ccb926a9941"></a><!-- doxytag: member="MGSurface::param_e_u" ref="ae8008063c4bd5800dcba5ccb926a9941" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ae8008063c4bd5800dcba5ccb926a9941">param_e_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5322da17789e6384ccc1ad2de94ccea"></a><!-- doxytag: member="MGSurface::param_e_v" ref="ad5322da17789e6384ccc1ad2de94ccea" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a92d73f3618144b4cf2fbefe4030a5ea7">param_mid</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter value of the middle point of the surface.  <a href="#a92d73f3618144b4cf2fbefe4030a5ea7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">param_range</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range.  <a href="#a1f667e5368e55f075f7dcf4cd052a4dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdd1f536e2e572017dd22a76b6db2ea7"></a><!-- doxytag: member="MGSurface::parameter_range" ref="abdd1f536e2e572017dd22a76b6db2ea7" args="() const " -->
<a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#abdd1f536e2e572017dd22a76b6db2ea7">parameter_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter range of the geometry(パラメータ範囲を返す). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab685287c057802933f1759b30c22cf32"></a><!-- doxytag: member="MGSurface::param_s_u" ref="ab685287c057802933f1759b30c22cf32" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab685287c057802933f1759b30c22cf32">param_s_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea409eb652edb29595d5ec876a6bc8f6"></a><!-- doxytag: member="MGSurface::param_s_v" ref="aea409eb652edb29595d5ec876a6bc8f6" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a96162a006f79046e1504b6731c599049">param_span</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute square of parameter span length from (u.min, v.min) to (u.max, v.max).  <a href="#a96162a006f79046e1504b6731c599049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a7a924b141ca6ea037545953c5e00d682">part</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;bx, int multiple=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of the surface limitted by the parameter range bx.  <a href="#a7a924b141ca6ea037545953c5e00d682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a57c8bffdb617cf4ff7c654e2b080200c">perimeter_curve</a> (size_t i) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve perimeter i of this surface.  <a href="#a57c8bffdb617cf4ff7c654e2b080200c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc5963351892255db41d325c8348155b"></a><!-- doxytag: member="MGSurface::perimeter_num" ref="acc5963351892255db41d325c8348155b" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#acc5963351892255db41d325c8348155b">perimeter_num</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many perimeters this surface has. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83e100c532a4bb82f22ec00066993e02"></a><!-- doxytag: member="MGSurface::perimeter_uv" ref="a83e100c532a4bb82f22ec00066993e02" args="(unsigned i, double t) const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a83e100c532a4bb82f22ec00066993e02">perimeter_uv</a> (unsigned i, double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct perimeter i's (u,v) parameter position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af4e0ecf2e16bc611a9ad8a6032c5516b">perp_guess</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv0, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a perpendicular point from a point P, given guess parameter value uvguess.  <a href="#af4e0ecf2e16bc611a9ad8a6032c5516b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a20678e5bff86bc76a04add72aa002eac">perp_guess</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the foot of the perpendicular straight line from P.  <a href="#a20678e5bff86bc76a04add72aa002eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aa2e3a648ac566d105a6802238d022a6e">perp_guess</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv0, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, double t0, double t1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;tuvg, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;tuv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perpendicular points of a curve and a surface, given guess starting paramter values.  <a href="#aa2e3a648ac566d105a6802238d022a6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a47c0a87ffbd5e473cdeda87ad9127cbf">perp_guess</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv0, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv1, const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;crv, double t0, double t1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;tuvg, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;tuv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a824d86bf1baa1ed5ee16cdf839c04f71">perp_guess</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvguess, double tguess, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perpendicular points of a curve and the FSurface, given guess starting paramter values.  <a href="#a824d86bf1baa1ed5ee16cdf839c04f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ac94884f1674a06f476c417511a93eb2a">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, const <a class="el" href="class_m_g_position.html">MGPosition</a> *uvguess=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与点にもっとも近い、与点から面に垂直な面上の点を求める。 Return the foot of the perpendicular straight line from P that is nearest to point uvguess.  <a href="#ac94884f1674a06f476c417511a93eb2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aed36001c59550de9c2054564844c638f">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all foots of perpendicular straight lines from P.  <a href="#aed36001c59550de9c2054564844c638f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a677cc63d5ec6d7fe4fa95013ed4b50d4">pick_closest</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parameter value of the closest point from the straight to this object.  <a href="#a677cc63d5ec6d7fe4fa95013ed4b50d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8966c7e15642175de66afee13234dfc5">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力パラメータをパラメータ範囲でまるめて返却する。 Round the input parameter value uv into the parameter range of the surface.  <a href="#a8966c7e15642175de66afee13234dfc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a168a7c2b0732dc2d6e4f534371e4b12b">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数(B表現曲線のみ) トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal redundant knots within the tolerance line_zero().  <a href="#a168a7c2b0732dc2d6e4f534371e4b12b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a5588c90dbae532152f8dd4356e927f6d">rotate_self</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec, double angle, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;origin=mgORIGIN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定点をとおり指定方向ベクトルを持つ直線の回りを指定角度の 回転を行ない自身の面とする。 Rotate the surface around the straight line whose direction is vec and that passes through origin.  <a href="#a5588c90dbae532152f8dd4356e927f6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1a4ba9bdcaf225a541eeb1b2fa7ec7"></a><!-- doxytag: member="MGSurface::sdim" ref="aeb1a4ba9bdcaf225a541eeb1b2fa7ec7" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aeb1a4ba9bdcaf225a541eeb1b2fa7ec7">sdim</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the surface type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a7bb84fd8e6434c9eabccd05675ddf2b5">shrink_to_knot</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbx, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shrink this surface to the part limitted by the parameter range of uvbx.  <a href="#a7bb84fd8e6434c9eabccd05675ddf2b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aa42207d63b66cb594cf5329597657eec">split</a> (double param, bool is_u, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;surfaces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">split this fsurface at the parameter param.  <a href="#aa42207d63b66cb594cf5329597657eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a87c0d6fd656d16ace82bc5232be1ac5b">surf</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> pointer if this is a <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>.  <a href="#a87c0d6fd656d16ace82bc5232be1ac5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84c9e2fb6fa3da09a04ff46ec80f1ef"></a><!-- doxytag: member="MGSurface::surf" ref="aa84c9e2fb6fa3da09a04ff46ec80f1ef" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>surf</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a83ad0b3f99b05d775a1d4d7352baf9d0">type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">面のTypeを返却する。 Return the surface type.  <a href="#a83ad0b3f99b05d775a1d4d7352baf9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12b46e348c0ca58f6dfc40d298bc4657"></a><!-- doxytag: member="MGSurface::unit_normal" ref="a12b46e348c0ca58f6dfc40d298bc4657" args="(const MGPosition &amp;uv) const " -->
<a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a12b46e348c0ca58f6dfc40d298bc4657">unit_normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute unit normal vector at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b2d4f528e302f720cc69fc1f666857"></a><!-- doxytag: member="MGSurface::unit_normal" ref="a29b2d4f528e302f720cc69fc1f666857" args="(double u, double v) const " -->
<a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a29b2d4f528e302f720cc69fc1f666857">unit_normal</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute unit normal vector at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7be3e82bbb41d9aef0a1e7b8a3c41e8a"></a><!-- doxytag: member="MGSurface::whoami" ref="a7be3e82bbb41d9aef0a1e7b8a3c41e8a" args="() const " -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a6cce2a79bd519568b05467e302274bba">flat</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox, double tol, int &amp;direction, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the surface is flat or not within the parameter value rectangle of uvbox.  <a href="#a6cce2a79bd519568b05467e302274bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a011c5875959170054589915433325e76">intersect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default intersection program of <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>.  <a href="#a011c5875959170054589915433325e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a820dc314dd99023e861eb13a056e0d12"></a><!-- doxytag: member="MGSurface::intersectPl" ref="a820dc314dd99023e861eb13a056e0d12" args="(const MGPlane &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a820dc314dd99023e861eb13a056e0d12">intersectPl</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default intersection program of <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> with a plane. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aab041e3e90c98489a7dda3b9e42dd98a">intersectInner</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;sf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection points of an inner parameter line of this surface and sf2.  <a href="#aab041e3e90c98489a7dda3b9e42dd98a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#adeee48dc794aa404bce3dc81b9679cfb">intersect_dnum_u</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess.  <a href="#adeee48dc794aa404bce3dc81b9679cfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e2012ed2f035496f327fb088598c4a"></a><!-- doxytag: member="MGSurface::intersect_dnum_v" ref="a94e2012ed2f035496f327fb088598c4a" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersect_dnum_v</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a7c5f81bf50ebafb185d53341e9b9aa4e">isect_area_length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_surface.html#a7c5f81bf50ebafb185d53341e9b9aa4e" title="isect_area_length() returns initial area length for the intersection line.">isect_area_length()</a> returns initial area length for the intersection line.  <a href="#a7c5f81bf50ebafb185d53341e9b9aa4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a7eb99b357d5acfa389b24e902f58f77f">isect_direction</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, size_t m1, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuvS, double &amp;du, double &amp;dv, double acuRatio=1.) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_surface.html#a7eb99b357d5acfa389b24e902f58f77f" title="isect_direction() is used by isect_startPt() to define which constant parameter line...">isect_direction()</a> is used by <a class="el" href="class_m_g_f_surface.html#a2951bc0d2d4705be6d570bccd60f9ab0" title="isect_startPt compute an array of parameter value pairs of this surf and sf2 for...">isect_startPt()</a> to define which constant parameter line should be used to compute intersection, and what incremental value be used for the parameter.  <a href="#a7eb99b357d5acfa389b24e902f58f77f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a68d207fd08c45db618304b0ee367b668">isect_div_id_max</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_div_id_max is maximum id of array of sect_div defined in isect_dt_coef.  <a href="#a68d207fd08c45db618304b0ee367b668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a73bb5133b684226cb8bca310cfdf152e">isect_incr_pline</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int kdt, double du, double dv, double &amp;u, double &amp;v, size_t incr=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect1_incr_pline" is a dedicated function of isect_start_incr, will get shortest parameter line necessary to compute intersection.  <a href="#a73bb5133b684226cb8bca310cfdf152e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a577846dde31c5f63f0bc8854e0fe0b10">isect_inner_dt</a> (size_t n, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvnow, double &amp;du, double &amp;dv, int &amp;kdt, double acuRatio=1.) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"isect_inner_dt" is a dedicated function of isect_startPt, comutes adequate incremental parameter value(du,dv) and parameter line kind kdt(u=const or v=const).  <a href="#a577846dde31c5f63f0bc8854e0fe0b10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f3cd378aa9405398b428b6937ea6f7"></a><!-- doxytag: member="MGSurface::isect_withC1LB" ref="ac3f3cd378aa9405398b428b6937ea6f7" args="(const MGLBRep &amp;lb) const " -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ac3f3cd378aa9405398b428b6937ea6f7">isect_withC1LB</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lb) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersections with <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> lb that does not have C0 continuity in it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a042285403895f20e8e779d4562dfe139"></a><!-- doxytag: member="MGSurface::isect_with_noCompoSC" ref="a042285403895f20e8e779d4562dfe139" args="(const MGSurfCurve &amp;scrv) const " -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a042285403895f20e8e779d4562dfe139">isect_with_noCompoSC</a> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;scrv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect with SurfCurve whose m_curve is not a <a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a> of <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aa0bd5720dfdbf979fa89054b785014ce">isectSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox=mgNULL_BOX) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Surface and a straight line.  <a href="#aa0bd5720dfdbf979fa89054b785014ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af0d34261ef8ffb620434a072539b9aad">surf1D</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain 1D surface rep.  <a href="#af0d34261ef8ffb620434a072539b9aad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabe8c9066ad3530f2731485910094c81"></a><!-- doxytag: member="MGSurface::ReadMembers" ref="aabe8c9066ad3530f2731485910094c81" args="(MGIfstream &amp;buf)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#aabe8c9066ad3530f2731485910094c81">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 戻り値boolは正常に読み出しが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48aa73a5d5a598a8bca9281cce6beae8"></a><!-- doxytag: member="MGSurface::WriteMembers" ref="a48aa73a5d5a598a8bca9281cce6beae8" args="(MGOfstream &amp;buf) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a48aa73a5d5a598a8bca9281cce6beae8">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 戻り値boolは正常に書き込みが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a57185a8c75407c288944d596184e9"></a><!-- doxytag: member="MGSurface::MGStraight" ref="ae2a57185a8c75407c288944d596184e9" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ae2a57185a8c75407c288944d596184e9">MGStraight</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23669e08ae9e6c150b0deb0d002fa39a"></a><!-- doxytag: member="MGSurface::MGLBRep" ref="a23669e08ae9e6c150b0deb0d002fa39a" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a23669e08ae9e6c150b0deb0d002fa39a">MGLBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663f1f5614262622b7e5ca59affbc1e0"></a><!-- doxytag: member="MGSurface::MGSurfCurve" ref="a663f1f5614262622b7e5ca59affbc1e0" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a663f1f5614262622b7e5ca59affbc1e0">MGSurfCurve</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af11460e1f16d901b0f4ceeeee4b37047"></a><!-- doxytag: member="MGSurface::MGSBRep" ref="af11460e1f16d901b0f4ceeeee4b37047" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af11460e1f16d901b0f4ceeeee4b37047">MGSBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e308328b17d188ba1542177a9d8e00"></a><!-- doxytag: member="MGSurface::MGPlane" ref="af6e308328b17d188ba1542177a9d8e00" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#af6e308328b17d188ba1542177a9d8e00">MGPlane</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab076a779a8188015756fc0be78ffd06e"></a><!-- doxytag: member="MGSurface::MGCylinder" ref="ab076a779a8188015756fc0be78ffd06e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#ab076a779a8188015756fc0be78ffd06e">MGCylinder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a443b939759230521058b7612c5bf583e"></a><!-- doxytag: member="MGSurface::MGFSurface" ref="a443b939759230521058b7612c5bf583e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a443b939759230521058b7612c5bf583e">MGFSurface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6e5cc99c9f14d029d61a74031ded4e"></a><!-- doxytag: member="MGSurface::MGFace" ref="a1f6e5cc99c9f14d029d61a74031ded4e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a1f6e5cc99c9f14d029d61a74031ded4e">MGFace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a690302e74a6ef57b1dd54fb56dbe70ec"></a><!-- doxytag: member="MGSurface::MGBSumSurf" ref="a690302e74a6ef57b1dd54fb56dbe70ec" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a690302e74a6ef57b1dd54fb56dbe70ec">MGBSumSurf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ad13ce0003a43cd11981c2d127c0b92"></a><!-- doxytag: member="MGSurface::mgTLRects" ref="a8ad13ce0003a43cd11981c2d127c0b92" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8ad13ce0003a43cd11981c2d127c0b92">mgTLRects</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a90fec61e4e1f3f47d5455885282f137a">test_to_get_approximate_plane</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> Pn[9], const <a class="el" href="class_m_g_vector.html">MGVector</a> Nn[9], const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N, double surface_tol, double angle, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, double &amp;width, double &amp;height)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a365297ecdb62e0f4803a72d140babec2">isect_start_tan</a> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf1, const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;sf2, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lineb, <a class="el" href="class_m_g_vector.html">MGVector</a> *Tse[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the intersection line lineb's start and end tangent vectors are accurate enough.  <a href="#a365297ecdb62e0f4803a72d140babec2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_surface.html#a8515101478c20c294195fd74724e2b78">isect_start_adjustSE</a> (int ngtan, <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;point, <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lineb, <a class="el" href="class_m_g_vector.html">MGVector</a> *tan[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update lineb so as to have the tangent tan for start or end according to ngtan.  <a href="#a8515101478c20c294195fd74724e2b78"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> is an abstract class of 3D surface. </p>
<p>Surface is represented using two parameter u and v:f(u,v). </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0df52ab736aa74ae2da517bd0484be03"></a><!-- doxytag: member="MGSurface::arrow" ref="a0df52ab736aa74ae2da517bd0484be03" args="(double u, double v, MGPosition data[10]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::arrow </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>[10]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the <a class="el" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects.">MGAppearance</a> pointer of this object. </p>
<p>If not defined, null will be returned. See <a class="el" href="class_m_g_object.html#a68f2d3f2baf1eb653a174fc09bef16a8" title="make this group has appearance and get the MGAppearance pointer.">ensure_appearance()</a>. MGAppearance* <a class="el" href="class_m_g_object.html#a75663d3ba117da3bed1d62f1e938282e" title="Get the MGAppearance pointer of this object.">appearance()</a>{return <a class="el" href="class_m_g_object.html#a75663d3ba117da3bed1d62f1e938282e" title="Get the MGAppearance pointer of this object.">MGObject::appearance()</a>;}; const MGAppearance* appearance()const{return <a class="el" href="class_m_g_object.html#a75663d3ba117da3bed1d62f1e938282e" title="Get the MGAppearance pointer of this object.">MGObject::appearance()</a>;}; Generate arrow data of the tangent along u and v and the normal at the parameter value (u,v) of the surface. data[0] is the origin of the u-tangent arrow, data[1] is the top of the u-tangent arrow, data[2], [3] are two bottoms of u-tangent arrowhead. data[0], [4], [5], [6] are the points of v-tangent arrow. data[0], [7], [8], [9] are the points of v-tangent arrow. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a17e4c4cfd0c528657426629f3dc8fc24">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9b56d297311a97669543ccdc0f2977f9"></a><!-- doxytag: member="MGSurface::arrow" ref="a9b56d297311a97669543ccdc0f2977f9" args="(const MGBox &amp;box, double u, double v, MGPosition data[10]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::arrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>[10]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate arrow data, given box. </p>
<p>The length of the arrows are defined from box.len() </p>

</div>
</div>
<a class="anchor" id="a9182844563218c392ef526d29e5bfb7e"></a><!-- doxytag: member="MGSurface::box_limitted" ref="a9182844563218c392ef526d29e5bfb7e" args="(const MGBox &amp;uvrange) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_box.html">MGBox</a> MGSurface::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns B-Rep Dimension of v. </p>
<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Return minimum box that includes limitted surface by uvrange. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvrange</em>&nbsp;</td><td>Parameter Range of the curve. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#aebf8ba7cb5f0b1a49e0865e7ccac3751">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a5e77dceb2626130499376407219b4e52">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a5595ea90c345ce3009b7d0be473d14d9">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#ad9b96b65fb806fd86cbeaf69743c0cbd">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a26c91e103bee0635b22ff18eda1132fe">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a6f1d65f6e9c72c2dc48dc7b5657c9c97">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b4d8c8eb52d145ba1128936d2a0e1e"></a><!-- doxytag: member="MGSurface::box_param2" ref="ad0b4d8c8eb52d145ba1128936d2a0e1e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_box.html">MGBox</a> MGSurface::box_param2 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return box of the parameter space of the FSurface. </p>
<p>After trimmed one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a027f707b72095b5a4038dc5410e50ce2">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab37b86c29caed93258a98d7e70459d4e"></a><!-- doxytag: member="MGSurface::change_dimension" ref="ab37b86c29caed93258a98d7e70459d4e" args="(size_t sdim, size_t start1=0, size_t start2=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGSurface::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a7d4b453238236b466f2b11a409c76a24">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a917a1dd67813d56274904d95980e084b">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#aaeb166ed17532baea4386dceba1051cb">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a23a5d4c1c4d767c962618d645bb33ec9">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a48f250dd11dac3e4d15120659bbdc784">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a252840bfe0588dbc050d7e48789434a8">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a1d4365d58c465f916b2fb038ef896b2d"></a><!-- doxytag: member="MGSurface::change_range" ref="a1d4365d58c465f916b2fb038ef896b2d" args="(int is_u, double t1, double t2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGSurface::change_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, (t1,t2) are u-value. if not, v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#ab305a1b0de094833df9c1068ed51ee6a">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#abadaa0513dbecebf7f5c58c094394be8">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a7312b8fb5aa59fdfa6ab2812bdb7769b">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a00f76b01674e6b7daf29dab5542613fe">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#ac7f399399a134367ee989fe1c4a3a791">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#aabb3dd8e981aac5715acb3c4a89c3972">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a55ce6580673b46480f6ae5a8d2117c17"></a><!-- doxytag: member="MGSurface::clone" ref="a55ce6580673b46480f6ae5a8d2117c17" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGSurface::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a3c334d9ed61dbdfd11826216539cfaaa">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a6cc82d0d57aa40f004bf559b0b665104">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a7729fdc314d7712e734c83fef8d3771a">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#ad46f96a1b5ea7e4284e2f025dcf5aeda">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#ad9f88bcf91d300945c3a2dc1e6c08d1f">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a2b71fbb3471168b4e56862ce4fc05c6a">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a4a623309eb1cc5105400dda4aa003efe"></a><!-- doxytag: member="MGSurface::clone_as_face" ref="a4a623309eb1cc5105400dda4aa003efe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGSurface::clone_as_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the clone of this as a <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. </p>
<p>If this is <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, it is converted to <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a4a39743914b8e15d32c27740aa6d8c79">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a968d690be2c0009a282ac74085b95422"></a><!-- doxytag: member="MGSurface::closest" ref="a968d690be2c0009a282ac74085b95422" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value (u,v)of this surface from a point. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a44385215d7089b9f2ad42792aad0d3f7">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a8cfc205e727c9d77cb3c393a4bdf925d">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a4a947f099c9866e3d76fd6e80fd0296b">MGPlane</a>, and <a class="el" href="class_m_g_sphere.html#afa2bf9455d696da90d888dd7449fcfe4">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a389583b74836a7496f7ead774fe1d6f5"></a><!-- doxytag: member="MGSurface::closest_on_boundary" ref="a389583b74836a7496f7ead774fe1d6f5" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::closest_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute closest point from a line to the boundary of the <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. </p>
<p>Returned is the parameter value of the FSurface that is closest to point. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a7f41b0c00f61627312776bfe06366bdb">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a79b233ce393381acf1017555e203971c"></a><!-- doxytag: member="MGSurface::closest_on_perimeter" ref="a79b233ce393381acf1017555e203971c" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::closest_on_perimeter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point on all the perimeters of the surface. </p>
<p>The point is returned as the parameter value (u,v) of this surface. </p>

<p>Reimplemented in <a class="el" href="class_m_g_sphere.html#a758a0d5caeead60599bdcedd20a408cf">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="adfdb3b6a71739d4003fa3ec2d840a034"></a><!-- doxytag: member="MGSurface::coef_sdim" ref="adfdb3b6a71739d4003fa3ec2d840a034" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::coef_sdim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain coefficient's space dimension. </p>
<p>This function is used in isect_start etc. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a0bdea946f6f1707b23aac826aa7aee91">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf87d2f42a919c9f5bc44cc406ea0fd"></a><!-- doxytag: member="MGSurface::copy_change_dimension" ref="a0cf87d2f42a919c9f5bc44cc406ea0fd" args="(size_t sdim, size_t start1=0, size_t start2=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGSurface::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a3a5a640c089ed7d3220171839ac84f41">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#ae9a4a39c77ce36e80743cdc3ebb456f7">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a873b6bfe59240fa8b47b0a2b49ceca64">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#af6b3c3235fabba9e03cce44f2a956b58">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#abb5372526064576308dcf992540bbfdb">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#ae96e9b634d0de211a1a7355d35ab719c">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="af76280bbd8b55c5d5d1da95c6f5accd3"></a><!-- doxytag: member="MGSurface::copy_surface" ref="af76280bbd8b55c5d5d1da95c6f5accd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGSurface::copy_surface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

</div>
</div>
<a class="anchor" id="afbab88475e9baabe1684775ffbff30dc"></a><!-- doxytag: member="MGSurface::curvatures" ref="afbab88475e9baabe1684775ffbff30dc" args="(const MGPosition &amp;uv, double value[4], MGUnit_vector &amp;N) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::curvatures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute surface curvatures: value[0]=K:Gaussian curvature=k1*k2, value[1]=H:Mean curvature=(k1+k2)/2, value[2]=k1:minimum curvature, and value[3]=k2=maximum curvature. </p>
<p>N is the unit normal vector at position (u,v). </p>

</div>
</div>
<a class="anchor" id="a27fdd1ff58f14d6ee6691f711d3bd039"></a><!-- doxytag: member="MGSurface::divide_multi_knot" ref="a27fdd1ff58f14d6ee6691f711d3bd039" args="(MGPvector&lt; MGSurface &gt; &amp;srfl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGSurface::divide_multi_knot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srfl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>uまたはv方向に折れ(マルチノット)があるとき面を分割する 戻り値は、分割数を返却する </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srfl</em>&nbsp;</td><td>分割した曲面リスト </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_r_s_b_rep.html#ab1e9d580381ad44cc19ff8713494063c">MGRSBRep</a>, and <a class="el" href="class_m_g_s_b_rep.html#a8f34a9e4dcccaed411c7d90c106e4b82">MGSBRep</a>.</p>

</div>
</div>
<a class="anchor" id="ad43e101de71052301de2cc8c7e4405ef"></a><!-- doxytag: member="MGSurface::drawWire" ref="ad43e101de71052301de2cc8c7e4405ef" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#ab17eaa929a4de9e645dc2fd0347c9390">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a2d663b20dc40dbf65b2a27b8226e4468"></a><!-- doxytag: member="MGSurface::equal_direction" ref="a2d663b20dc40dbf65b2a27b8226e4468" args="(const MGCurve &amp;param_curve, const MGCurve &amp;world_curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSurface::equal_direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>param_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>world_curve</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute if <a class="el" href="class_m_g_surf_curve.html" title="MGSurfCurve is a curve defined by a surface and its parameter space line represented...">MGSurfCurve</a> scurve(*this, param_curve) has the same direction to world_curve, assuming that scurve and world_curve are the same curve. </p>
<p>Function's return value is: 1: same direction, -1:oppositie direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param_curve</em>&nbsp;</td><td>(u,v) parameter representation curve of this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>world_curve</em>&nbsp;</td><td>world representation curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada7939e987d1f90d7c765b63b07b8533"></a><!-- doxytag: member="MGSurface::eval" ref="ada7939e987d1f90d7c765b63b07b8533" args="(double u, double v, size_t ndu=0, size_t ndv=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_vector.html">MGVector</a> MGSurface::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a827522c3a515722c10a945c4eb25b8f0">MGFSurface</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#aa88d8ee7066981625215a47e77948417">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a151bc0f63249fe878740eb16e5d7c457">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a349a162d7e65af4e52a6d049b069f665">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a01bf003a29ccd6bdc004ca3028506f96">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a16d04d8d8da3f8068ee958c93a0f02a9">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a38667e0405d3b3d7cb50a2ddd8055779">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="aafe04bb26aae4194f9c477ccdf900e27"></a><!-- doxytag: member="MGSurface::eval" ref="aafe04bb26aae4194f9c477ccdf900e27" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGSurface::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>FSurface parameter value(u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a0a681a39c5dc1107447b3399b110fdea">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_b_sum_surf.html#a4e011c4af6d79a793fbf9f652f59d4c1">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a6288008dc36129da70f17870a05a5902">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a1b246aa1ff1ae915cf8fc068dac5ab74">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a6ad9b9fbb8558192e37e71308ff691bd">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a4a84a30a177df8c06d2e692968f43323">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a1b5a6e9f2820a9db9da6a13dd113ab7f">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a8153b4db02d3056377d79f43254d11e5"></a><!-- doxytag: member="MGSurface::eval_all" ref="a8153b4db02d3056377d79f43254d11e5" args="(double u, double v, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data, 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a30f4773f6bc7ecc496527b3dbcbecd32">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#ab70c9f241d5ba4cf9478c14badf441ca">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a28e1cae47b5ca6f0af8abbb211c70f3e">MGRSBRep</a>, and <a class="el" href="class_m_g_s_b_rep.html#aeb2412bdf35040de594328cb89af4e36">MGSBRep</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce3c2446526c5961f70b998c37e4b30"></a><!-- doxytag: member="MGSurface::eval_all" ref="a8ce3c2446526c5961f70b998c37e4b30" args="(const MGPosition &amp;uv, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::eval_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data, 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a9fa0d2966629c8a0532fde91477ffbb6">MGCylinder</a>.</p>

</div>
</div>
<a class="anchor" id="aa8e61cdada1be0cd679b49c3324f5ddd"></a><!-- doxytag: member="MGSurface::eval_gap" ref="aa8e61cdada1be0cd679b49c3324f5ddd" args="(const MGCurve &amp;curve, int iperi, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGSurface::eval_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iperi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>evaluate gap between this surface's perimeter iperi and the given curve curve. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>(I/ ) curve to evaluate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iperi</em>&nbsp;</td><td>(I/ ) 0: vmin, 1: umax, 2: vmax, and 3: umin. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>( /O) the parameter of this that had the largest gap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a639a294d997ce03d7c4d3881d02015f2"></a><!-- doxytag: member="MGSurface::eval_gap" ref="a639a294d997ce03d7c4d3881d02015f2" args="(const MGCurve *curve[4], MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGSurface::eval_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>curve</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>evaluate gap between this surface's perimeters and the given curve curve. </p>
<p>evaluation is performed for the perimeter i and curve[i] for 0&lt;=i&lt;=4. function's return value is the maximum gap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>(I/ ) curves to evaluate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>( /O) the parameter of this that had the largest gap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d9355b68189922fd3e326fc8a91d1e7"></a><!-- doxytag: member="MGSurface::eval_spoint" ref="a9d9355b68189922fd3e326fc8a91d1e7" args="(const MGNDDArray &amp;utau, const MGNDDArray &amp;vtau, MGSPointSeq &amp;spoint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::eval_spoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate all the points (ui, vj) into spoint(i,j,. </p>
<p>), where ui=utau(i) for 0&lt;=i&lt;utau.length() and vj=vtau(j) for 0&lt;=j&lt;vtau.length(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>utau</em>&nbsp;</td><td>u方向のデータポイント </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtau</em>&nbsp;</td><td>v方向のデータポイント </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spoint</em>&nbsp;</td><td>evaluated data will be output to spoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a360cae304c680229d60d725f92fb3701"></a><!-- doxytag: member="MGSurface::evaluate" ref="a360cae304c680229d60d725f92fb3701" args="(const MGPosition &amp;t, const size_t *nderiv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGSurface::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&nbsp;</td>
          <td class="paramname"> <em>nderiv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate n'th derivative data. n=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value, t's space dimension is geometry's manifold dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of derivative of i-th parameter in nderiv[i], When nderiv=null, nderiv[i]=0 is assumed for all i. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab52fd64da1afa26965f381962edf0f75"></a><!-- doxytag: member="MGSurface::extend" ref="ab52fd64da1afa26965f381962edf0f75" args="(int perimeter, double param, double length, double dk=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGSurface::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>perimeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original Surface by extrapolating the specified perimeter. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. The extrapolation is done so that extrapolating length is "length" at the position of the parameter value "param" of the perimeter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perimeter</em>&nbsp;</td><td>perimeter number of the Surface. =0:v=min, =1:u=max, =2:v=max, =3:u=min. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of above perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend at the parameter param of the perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at extrapolation start point. When dk=0, curvature keeps same, i.e. dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#add30aac7fbdc06eedbb880369c861168">MGCylinder</a>, <a class="el" href="class_m_g_r_s_b_rep.html#ad2cac4895eceb7725f54115cb5fa6aad">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a01ce7a44e3db215c5ae1522b094b864a">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#ab8145245e1ba16d48dcc611f9bebd8c7">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a6cce2a79bd519568b05467e302274bba"></a><!-- doxytag: member="MGSurface::flat" ref="a6cce2a79bd519568b05467e302274bba" args="(const MGBox &amp;uvbox, double tol, int &amp;direction, MGPosition &amp;P, MGUnit_vector &amp;N) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::flat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the surface is flat or not within the parameter value rectangle of uvbox. </p>
<p>Function's return value is: true: if the surface is flat false: if the surface is not falt. When this is not falt, the direction that indicates which direction the surface should be divided will be output. the flatness is tested only approximately. This is for exclusive use of planar(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>Tolerance allowed to regart flat (Allowed distance from a plane). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>1: u-direction is more non flat. 0: v-direction is more non flat. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Position of the flat plane will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Normal of the flat plane will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#ace4057429c8d64c9679e06367b018550">MGCylinder</a>, and <a class="el" href="class_m_g_plane.html#a52a1a74215b08614718cf316a5ff3d2d">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a41b9e5c2304da978143e5a511e9adf4b"></a><!-- doxytag: member="MGSurface::fundamentals" ref="a41b9e5c2304da978143e5a511e9adf4b" args="(const MGPosition &amp;uv, double Q[6], MGUnit_vector &amp;UN) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::fundamentals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>Q</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>UN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute 1st and 2nd fundamental quantities of the surface. </p>
<p>In Q, 1st and 2nd fundamental quantities are returned as: Q[0]=E=fufu, Q[1]=F=fufv, Q[2]=G=fvfv, Q[3]=L=fuuUN, Q[4]=M=fuvUN=fvuUN, Q[5]=N=fvvUN. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Surface parameter value (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UN</em>&nbsp;</td><td>Normal vector at uv will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab60e61180fcca5f540b2acabe518d316"></a><!-- doxytag: member="MGSurface::fundamentals" ref="ab60e61180fcca5f540b2acabe518d316" args="(double u, double v, double Q[6], MGUnit_vector &amp;N) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::fundamentals </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>Q</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter value (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Normal vector at uv will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4adb7c525fcc20d70c1fdbd171b5df33"></a><!-- doxytag: member="MGSurface::get_approximate_plane" ref="a4adb7c525fcc20d70c1fdbd171b5df33" args="(double u0, double u1, double v0, double v1, MGPlane &amp;plane, double *width=0, double *height=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::get_approximate_plane </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>height</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the approximate plane in the parameter range from (u0, v0) to (u1,v1) The plane's origin is center point of the plane when the surface is mapped onto the plane. </p>
<p>The uderiv of the plane is the direction from the point(u0, v0) to (u1,v0). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u1</em>&nbsp;</td><td>u range from u0 to u1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>v range from v0 to v1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>The plane will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width and the height of the plane that include all the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>for the surface point to map onto the plane will be output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0eb77f69a81d6ed8106faa92e42a7c5"></a><!-- doxytag: member="MGSurface::get_parameterCurve" ref="ac0eb77f69a81d6ed8106faa92e42a7c5" args="(const MGCurve &amp;wcrv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSurface::get_parameterCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wcrv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given world curve wcrv on this face, get the parameter space representation pcrv. </p>
<p>Function's return value is pcrv, which is newed one. Must be deleted. </p>

</div>
</div>
<a class="anchor" id="a8c24da8133fbbef6f02284939d1caaa5"></a><!-- doxytag: member="MGSurface::get_surface_pointer" ref="a8c24da8133fbbef6f02284939d1caaa5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGSurface::get_surface_pointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get surface pointer. </p>
<p>Null will never be returned if this is valid <a class="el" href="class_m_g_f_surface.html" title="Define MGFSurface Class.">MGFSurface</a>. That is, if this is <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, base surface will be returned. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#ad9f377eb6f6e2d22e5b1e4ba93ef866a">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a93c9df7b6765434539d85dc059619311"></a><!-- doxytag: member="MGSurface::getPerimeterCommon" ref="a93c9df7b6765434539d85dc059619311" args="(const MGCurve &amp;crv, std::vector&lt; double &gt; pspan[2], int peri_num[2]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSurface::getPerimeterCommon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>pspan</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>peri_num</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute common curve part of this surface's perimeter and the crv. </p>
<p>Function's returned value is the number of common part curve part, which is 2 at most. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>crv must be a cotinuous one curve, must not be <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pspan</em>&nbsp;</td><td>parameter range of crv and perimeters will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peri_num</em>&nbsp;</td><td>perimeter number of pspan[i] will be output in peri_num[i], (pspan[i], peri_num[i]) is one pair. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75f016363f801103239789e75fd34972"></a><!-- doxytag: member="MGSurface::has_commonFS" ref="a75f016363f801103239789e75fd34972" args="(const MGObject &amp;obj2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::has_commonFS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this and 2nd object has common area about their <a class="el" href="class_m_g_geometry.html#a28feceac1ef6e868090b24832c0710b4" title="Return minimum box that includes whole of the geometry.">box()</a>, taking error into account. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a49a378f0e540171dd62b4c62b60b30f2">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a2f5d3960fca3e1e69e67314087a4ea24"></a><!-- doxytag: member="MGSurface::in_range_with_on" ref="a2f5d3960fca3e1e69e67314087a4ea24" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSurface::in_range_with_on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if (u,v) is inside the face. </p>
<p>Function's return value is: 0:outside the face. 1:unknown. 2:inside the face, not on a boundary. &lt;0:(u,v) is on an inner boundary, and abs(return code) is the loop id. 4:(u,v) is on the outer boundary. &gt;=10: (u,v) is on a perimeter, (10+perimeter number) will be returned. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1da72edf6bf5bea0bb56864266258ce0"></a><!-- doxytag: member="MGSurface::inner_boundary" ref="a1da72edf6bf5bea0bb56864266258ce0" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGSurface::inner_boundary </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface. </p>
<p>Let the output of inner_boundary(i) be wcurves and of inner_boundary_param(i) be pcurves, then wcurves[j] corresponds to pcurves[j] one to one. Number of inner_boundary can be obtained by the function number_of_inner_boundary(). </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a959f466f07e68676b3ca976ae4a02ff4">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a866b006d84096d32762b7dec7611d67f"></a><!-- doxytag: member="MGSurface::inner_boundary_param" ref="a866b006d84096d32762b7dec7611d67f" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGSurface::inner_boundary_param </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain i-th inner_boundary curves(world coordinates representation) of the FSurface. </p>
<p>Let the output of inner_boundary(i) be wcurves and of inner_boundary_param(i) be pcurves, then wcurves[j] corresponds to pcurves[j] one to one. Number of inner_boundary can be obtained by the function number_of_inner_boundary(). </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a58c5b3bbb657bbfe80bbb5fd65a11da3">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a066b0c4f04d3600684677e9fad4dc500"></a><!-- doxytag: member="MGSurface::intersect" ref="a066b0c4f04d3600684677e9fad4dc500" args="(const MGCurve &amp;curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGSurface::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default surface-curve intersection function. </p>
<p>Restriction for this surface and curve: 1. this surface and curve must not have C0 continuity in it. 2. param_s() and param_e() of this surface and curve must return real start and end parameter values. That is, must be finite. </p>

</div>
</div>
<a class="anchor" id="a011c5875959170054589915433325e76"></a><!-- doxytag: member="MGSurface::intersect" ref="a011c5875959170054589915433325e76" args="(const MGSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGSurface::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default intersection program of <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>. </p>
<p>It is assumed that both this and srf2 are not a plane. </p>

</div>
</div>
<a class="anchor" id="adeee48dc794aa404bce3dc81b9679cfb"></a><!-- doxytag: member="MGSurface::intersect_dnum_u" ref="adeee48dc794aa404bce3dc81b9679cfb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::intersect_dnum_u </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess. </p>

<p>Implemented in <a class="el" href="class_m_g_cylinder.html#a397f3a462ee330902fa56a2c6d13b0d8">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#abb208080371da1602dab7534e32cb1e2">MGPlane</a>, and <a class="el" href="class_m_g_sphere.html#a8e877be2279d845cae44c398bdad798d">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="aab041e3e90c98489a7dda3b9e42dd98a"></a><!-- doxytag: member="MGSurface::intersectInner" ref="aab041e3e90c98489a7dda3b9e42dd98a" args="(const MGSurface &amp;sf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGSurface::intersectInner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of an inner parameter line of this surface and sf2. </p>
<p>The intersection point is used to compute surface to surface intersection lines. Function's return value is at most one intersection point un uvuv_list. One member of uvuv_list is (u1,v1,u2,v2), where (u1,v1) is a parameter of this surface and (u2,v2) is a parameter of surf. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>The second surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aede24171ee30feb42c62cf397a615465"></a><!-- doxytag: member="MGSurface::intersection" ref="aede24171ee30feb42c62cf397a615465" args="(const MGObject &amp;obj2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_gisects.html">MGisects</a> MGSurface::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersections of two objects. </p>
<p>Intersections are obtained from two objects, which are known using the <a class="el" href="class_m_gisects.html#af38c1dac073591a6405efb080957f094" title="Get the 1st object pointer of the i-th intersection.">MGisects::object1()</a> and object2(). NOTE**** When two objects' manifold dimension are the same, object1 is this object at the invocation of <a class="el" href="class_m_g_object.html#ad20afa7e5b85f49d80e53a2a9377438b" title="Compute the intersections of two objects.">MGObject::intersection()</a>, and object2 is the argument object. However, their manifold dimension are not the same, object1 is always the lower dimension's object and object2 is the higer dimension's object. </p>

</div>
</div>
<a class="anchor" id="a3d84645dc04d80bb2ff1df214f3a3b9b"></a><!-- doxytag: member="MGSurface::isect" ref="a3d84645dc04d80bb2ff1df214f3a3b9b" args="(const MGSurface &amp;srf2) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGSurface::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Surface の交線を求める。 Surface and Surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html">MGFSurface</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a32f0f9c8efe9b06e81be2536ae889c59">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a233473e7e409c76ab8b3547363d4c3a6">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#aa90e899199c61534667d233a977c4da3">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a581c8af06058ceebb4dee58f53af2193">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a073cb00a4408a1a0708bea855a73786a">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#adee115831d2ad538d8b15cc244e5db9a">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a97fecbc27841cd336e1b26d2e64c2bf0"></a><!-- doxytag: member="MGSurface::isect" ref="a97fecbc27841cd336e1b26d2e64c2bf0" args="(const MGCurve &amp;curve) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGSurface::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Curve の交点を求める。 Curve and Surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html">MGFSurface</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a17b360e86d0a5ca2a42cee3412263cbc">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a3edf03eba31701f680b557bdc68726a1">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a9b70cedfd398991ce61f109e37243e74">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a5ba47ec07226f8cbe09d48319398e785">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#af04359e1ff3f7abbf22e6721133c5a0e">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a86c0fe6443a1ca1b22c39f20e6700c63">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5f81bf50ebafb185d53341e9b9aa4e"></a><!-- doxytag: member="MGSurface::isect_area_length" ref="a7c5f81bf50ebafb185d53341e9b9aa4e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::isect_area_length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_m_g_surface.html#a7c5f81bf50ebafb185d53341e9b9aa4e" title="isect_area_length() returns initial area length for the intersection line.">isect_area_length()</a> returns initial area length for the intersection line. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a21533abf8615e4c29f3f73058176f067">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a84499b9e91ee9d02e1cf2c8c911805c2"></a><!-- doxytag: member="MGSurface::isect_boundary" ref="a84499b9e91ee9d02e1cf2c8c911805c2" args="(const MGFSurface &amp;face2, MGPosition_list &amp;uvuvs, size_t id1=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::isect_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of this face's boundary(outer and inners) with face2. </p>
<p>If intersection points are found and the boundary is a loop, the point's edge pointer(of this) will be stored in a member uvuv of uvuvs. uvuv[7] is the edge pointer. If the boundary is not a loop(that is, a perimeter of Surfaces), uvuv.sdim()==7 and an edge pointer is not returned. When uvuv.sdim()==8, the edge pointer of uvuv[7] is accessed through union mgEdgeP. uvuvs[i] is i-th intersection points. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuvs</em>&nbsp;</td><td>id1 and id2 are the ids of uvuv where this face's and f2's parameters are to be stored in a member of uvuvs. This face's (u,v) is stored in uvuv(id1) and (id1+1). f2's (u,v) is stored in uvuv(id2) and (id2+1). id2=0 if id1=2, and id2=2 if id1=0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a0936671424c065e29984938cd240d00c">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7eb99b357d5acfa389b24e902f58f77f"></a><!-- doxytag: member="MGSurface::isect_direction" ref="a7eb99b357d5acfa389b24e902f58f77f" args="(const MGFSurface &amp;sf2, size_t m1, MGPosition &amp;uvuvS, double &amp;du, double &amp;dv, double acuRatio=1.) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGSurface::isect_direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuvS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em> = <code>1.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_m_g_surface.html#a7eb99b357d5acfa389b24e902f58f77f" title="isect_direction() is used by isect_startPt() to define which constant parameter line...">isect_direction()</a> is used by <a class="el" href="class_m_g_f_surface.html#a2951bc0d2d4705be6d570bccd60f9ab0" title="isect_startPt compute an array of parameter value pairs of this surf and sf2 for...">isect_startPt()</a> to define which constant parameter line should be used to compute intersection, and what incremental value be used for the parameter. </p>
<p>Function's return value is direction to get next intersection(with dt). When =1: u=const direction, =0: v=const, =-1: cannot get intersection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>Second surface for the intersection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m1</em>&nbsp;</td><td>id of uvuvS that indicates this surface's parameter position in uvuvS. (uvuvS(m1), uvuvS(m1+1))=(u,v) of this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuvS</em>&nbsp;</td><td>start parameter (u,v) pair of this surface and sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>du</em>&nbsp;</td><td>Incremental value of the parameter kind of kdt will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Right dt will be output according to the function's output =0,1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>acuracy ratio. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#a147d5f67a2945555c5dfa346c713455f">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a68d207fd08c45db618304b0ee367b668"></a><!-- doxytag: member="MGSurface::isect_div_id_max" ref="a68d207fd08c45db618304b0ee367b668" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGSurface::isect_div_id_max </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_div_id_max is maximum id of array of sect_div defined in isect_dt_coef. </p>
<p>That is, isect_div_id_max+1 is the length of the array sect_div. </p>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#afe84f4e95712bb9b395e18e71f525ae8">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a73bb5133b684226cb8bca310cfdf152e"></a><!-- doxytag: member="MGSurface::isect_incr_pline" ref="a73bb5133b684226cb8bca310cfdf152e" args="(const MGPosition &amp;uv, int kdt, double du, double dv, double &amp;u, double &amp;v, size_t incr=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSurface::isect_incr_pline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>incr</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect1_incr_pline" is a dedicated function of isect_start_incr, will get shortest parameter line necessary to compute intersection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>last intersection point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdt</em>&nbsp;</td><td>Input if u=const v-parameter line or not, true:u=const, false:v=const. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>Incremental parameter length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>next u value will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>next v value will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>Incremental valuse of B-coef's id. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#ac230405620009b9c2ca54fba019b56a6">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a01bca74c9479d189a5b49c331414a77e"></a><!-- doxytag: member="MGSurface::isect_incurves" ref="a01bca74c9479d189a5b49c331414a77e" args="(const MGFSurface &amp;face2, size_t iid, MGPosition_list &amp;uvuv_list, size_t id1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::isect_incurves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points between the boundary of iid-th inner boundary of this face and face2 to compute intersections of face with face2. </p>
<p>Function's return value is the number of ip's obtained before appending into uvuv_list, may not be equal to the enlarged size of uvuv_list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iid</em>&nbsp;</td><td>Inner loop id of this face(from 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>intersection points will be appended, One member in the list is of sdim 8, (4,5,6) is the direction vector, and (7) is Edge pointer of the point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id1</em>&nbsp;</td><td>id of uvuv(a member of uvuv_list), uvuv(id1) for this face parameter uvuv(id2) for face2 parameter, id2=0 if id1=2, and id2=2 if id1=0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#ab492a3900dd067dab5668f0b7c0470c0">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a577846dde31c5f63f0bc8854e0fe0b10"></a><!-- doxytag: member="MGSurface::isect_inner_dt" ref="a577846dde31c5f63f0bc8854e0fe0b10" args="(size_t n, const MGPosition &amp;uvnow, double &amp;du, double &amp;dv, int &amp;kdt, double acuRatio=1.) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::isect_inner_dt </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvnow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>kdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acuRatio</em> = <code>1.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"isect_inner_dt" is a dedicated function of isect_startPt, comutes adequate incremental parameter value(du,dv) and parameter line kind kdt(u=const or v=const). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>num of i.p. obtained so far(not include uvnow). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvnow</em>&nbsp;</td><td>intersection point obtained last(of this). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>incremental length from previous to uvnow is input. New du or dv will be output according to kdt's return value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdt</em>&nbsp;</td><td>Parameter kind used so far is input, will be output as: =1:parameter line kind(u=const), =0: v=const, =-1:should halt computation since incremental value is zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>acuRatio</em>&nbsp;</td><td>Accurate ratio. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#a7d2432ce1d438c0f245b92e05d1383ad">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a335ba5373321e236da3ff3ae24ed451a"></a><!-- doxytag: member="MGSurface::isect_order" ref="a335ba5373321e236da3ff3ae24ed451a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::isect_order </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return order of intersection line order of <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. </p>
<p>The default is 4. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a77b3fde6fd1b884671d3319a892038b2">MGBSumSurf</a>.</p>

</div>
</div>
<a class="anchor" id="af7ed14b2843adc1468aaca7328f71a0b"></a><!-- doxytag: member="MGSurface::isect_outcurves" ref="af7ed14b2843adc1468aaca7328f71a0b" args="(const MGFSurface &amp;face2, MGPosition_list &amp;uvuv_list, size_t id1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGSurface::isect_outcurves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection points of outer boundary curves of this face with face2 to compute intersections. </p>
<p>Function's return value is the number of ip's obtained(appended) into uvuv_list, may not be equal to the enlarged size of uvuv_list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>intersection points will be appended, One member in the list is of sdim 7, and the last three elements are the ip direction vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id1</em>&nbsp;</td><td>id of uvuv(a member of uvuv_list), uvuv(id1) for this face parameter uvuv(id2) for srf or face2 parameter. id2=0 if id1=2, and id2=2 if id1=0. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a3d7bbd977a593d3987bd38b9bcadb201">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1693f122c84dfb66888e0189767550d8"></a><!-- doxytag: member="MGSurface::isect_startH" ref="a1693f122c84dfb66888e0189767550d8" args="(const MGPosition &amp;uvuv_startIn, MGPosition_list &amp;uvuv_list, const MGSurface &amp;sf2, MGSSisect &amp;ssi, MGPosition_list::iterator &amp;uvuv_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSurface::isect_startH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ssi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGPosition_list::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_startH compute one intersection line of two surfaces, this and sf2, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2). </p>
<p>isect_startH halts the computation when intersection reached to a boundary of this or sf2, or reached to one of the points in uvuv_list. The function's return value is: =0: Intersection was not obtained. !=0: Intersection was obtained as follows: =1: End point is a point on a perimeter of one of the surfaces. =3: End point is one of boundary points in uvuv_list. =4: End point is the starting point. =7: isect_start halted the computation since intersection was lost during the computation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_startIn</em>&nbsp;</td><td>Starting point of the intersection line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>isect_start will halt when ip reached one of the point in uvuv_list. isect_start does not change uvuv_list(actually uvuv_list is const). uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>2nd surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssi</em>&nbsp;</td><td>Surface-surface intersection line will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_id</em>&nbsp;</td><td>When the end point of ip was one of the points of uvuv_list, that is, when the function's return value was 3, uvuv_list's iterator of the point will be returned, When the end point was not a point of uvuv_list, end() of uvuv_list will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0bd5720dfdbf979fa89054b785014ce"></a><!-- doxytag: member="MGSurface::isectSl" ref="aa0bd5720dfdbf979fa89054b785014ce" args="(const MGStraight &amp;sl, const MGBox &amp;uvbox=mgNULL_BOX) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGSurface::isectSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em> = <code>mgNULL_BOX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Surface and a straight line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>indicates if this surface is restrictied to the parameter range of uvbox. If uvbox.is_null(), no restriction. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a8ce7bdd2f254cd4d835f182aa55825da">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#adfac271e291026f76b585fdd496c0153">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#ae943ed583a8321c45864651089a97723">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a9c2124c50a7825444f437ac785221857">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#adb94c05a8a193bcd6285ca3ff0321a73">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="ae1325fe2f42237e3348d410e5de8c700"></a><!-- doxytag: member="MGSurface::less_than" ref="ae1325fe2f42237e3348d410e5de8c700" args="(size_t i, const MGPosition &amp;uv1, const MGPosition &amp;uv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::less_than </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two parameter values. </p>
<p>If uv1 is less than uv2, return true. Comparison is done after projected to i-th perimeter of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>perimeter number. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_b_sum_surf.html#a5ed5101a53f45739e670f87c6019d407">MGBSumSurf</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a094d8848d132d9c3004508982d933e0d">MGRSBRep</a>, and <a class="el" href="class_m_g_s_b_rep.html#a8ebd913bf938f6c5af66874066f38339">MGSBRep</a>.</p>

</div>
</div>
<a class="anchor" id="ad98eb8a83bc79f4b4883953ea3545c0e"></a><!-- doxytag: member="MGSurface::make_display_list_to_hilight" ref="ad98eb8a83bc79f4b4883953ea3545c0e" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t MGSurface::make_display_list_to_hilight </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a display list without color of this gel. </p>
<p>Return is the display list name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>span length to approximate by polyline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a21a3c06b62d7fe006910e06ccadcde44">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a5c88f614bd2981dd988ba77a06005244"></a><!-- doxytag: member="MGSurface::make_face" ref="a5c88f614bd2981dd988ba77a06005244" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_face.html">MGFace</a>* MGSurface::make_face </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> object. </p>
<p>If this is a <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, construct a newed <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> using this newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, and returns the MGFace*. THIS MUST BE A NEWED OBJECT*********** </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a521de8eaa8905bf5e14c6af77af56d0a">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6bf59d4cc4acf012450b3fdc5bb742ae"></a><!-- doxytag: member="MGSurface::negate" ref="a6bf59d4cc4acf012450b3fdc5bb742ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::negate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>面の方向を反転する。 Negate direction of surface. </p>
<p>Change direction of the surface. </p>

</div>
</div>
<a class="anchor" id="a5f1ebb47122de32a0f5702f160a51d2a"></a><!-- doxytag: member="MGSurface::negate" ref="a5f1ebb47122de32a0f5702f160a51d2a" args="(int is_u)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::negate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate direction of surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Negate along u-direction if is_u is ture, else along v-direction. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a00298d97065e253e03030a7459a2e5ef">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#ad5b5d393e7163edbd896e30a8fc4468c">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a29eb89702cc18bdd6dff7f1e27f2201b">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a049b5b0cf90939ad6877a97c33d6f043">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#ab4c0fe6bd2ca1ffac3f3241b7a4eeef9">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#af68a83dfc72a9ae220528eeafe75472d">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a721d66f4cf446ecd1e987227aea5c998"></a><!-- doxytag: member="MGSurface::negate_transform" ref="a721d66f4cf446ecd1e987227aea5c998" args="(MGGeometry &amp;boundary) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSurface::negate_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the coordinates of boundary of this geometry so that new coordinate of boundary is the same coordinate as the new one of this geometry after <a class="el" href="class_m_g_surface.html#a6bf59d4cc4acf012450b3fdc5bb742ae" title="面の方向を反転する。 Negate direction of surface.">negate()</a> of this geometry is done. </p>
<p>That is, boundary coordinates are of parameter world of this geometry. </p>

</div>
</div>
<a class="anchor" id="ade5530f3866464eda2faf064edc3aa31"></a><!-- doxytag: member="MGSurface::offset" ref="ade5530f3866464eda2faf064edc3aa31" args="(double ofs_value, int &amp;error) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGSurface::offset </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>一定オフセット関数 オフセット方向は、ノーマル方向を正とする。曲率半径より大きいオフセットは行わない。 戻り値は、オフセット曲面リストが返却される。エラーのとき長さ0の曲面リストが返る。 トレランスはline_zero()を使用している。 Surface offset. </p>
<p>positive offset value means offset normal direction.line_zero() is used. the radius of curvature is larger than offset value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード 0:成功 -2:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2dab410e24064b16318be2f56d2246c"></a><!-- doxytag: member="MGSurface::offset_c1" ref="ae2dab410e24064b16318be2f56d2246c" args="(double ofs_value, int &amp;error) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGSurface::offset_c1 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。曲率半径より大きいオフセットは行わない。 戻り値は、オフセットした曲面のオートポインタが返却される。エラーのときヌルが返る。 トレランスはline_zero()を使用している。 C1 continuous Surface offset. </p>
<p>positive offset value means offset normal direction. the radius of curvature is larger than offset value.line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード 0:成功 -1:面におれがある -2:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#ab8001901de0d336274a825f1ec0505e2">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#ad8634bd9e251baf5fa41260c57af151e">MGPlane</a>, and <a class="el" href="class_m_g_sphere.html#af86134bda185afd3da8e1c9be506b2d1">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a12a83c8c316f114b5eac5bb9fdac12bf"></a><!-- doxytag: member="MGSurface::offset_fs" ref="a12a83c8c316f114b5eac5bb9fdac12bf" args="(double distance, MGPvector&lt; MGFSurface &gt; &amp;vecOfsFSurface) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSurface::offset_fs </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vecOfsFSurface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset. </p>
<p>distance is plus value if the direction is toward normal vector of the FSurface. Minus if against the normal vector. エラーコード 0:成功 -1:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a18926f742ba0ae8b3a41a263d8897628">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a409507f5dcc86cab92e3448529a94196"></a><!-- doxytag: member="MGSurface::on" ref="a409507f5dcc86cab92e3448529a94196" args="(const MGPosition &amp;P, MGPosition &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた誤差内で点が面上にあるかどうかテストする。 Test if point P is ont the surface or not. </p>
<p>Even if P is not on the surface, return parameter of the nearest point of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>A point. 指定点 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#afb6217a5d69beda117240ae8867ecea8">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a3b9680f36113090ae96029b2714f1bec">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a5e57c1ce7722e2d66cfe07bfae5fe662">MGPlane</a>, and <a class="el" href="class_m_g_sphere.html#a90a678f3eab870fd5d9ce67da2ce48d7">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a6f773b2759f1b0c66b20ed8888aae990"></a><!-- doxytag: member="MGSurface::on_a_perimeter" ref="a6f773b2759f1b0c66b20ed8888aae990" args="(double &amp;u, double &amp;v, size_t &amp;perim_num) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::on_a_perimeter </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is parameter value on a perimeter of the surface. </p>
<p>If u or v is on a perimeter, (u,v) will be updated to the perimeter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returns true,the perimete number will be output, If function returns false, the nearest perimeter number will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a73978585a34a380507af9e44113a2287">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a04414ee9c8cf9e6d48952922c0fae42f">MGCylinder</a>, and <a class="el" href="class_m_g_plane.html#a626af4d4de5e4c8fca9d020c48458e6d">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a5c6a8ed9b6d90b4481baa3c553aaf272"></a><!-- doxytag: member="MGSurface::on_a_perimeter2" ref="a5c6a8ed9b6d90b4481baa3c553aaf272" args="(int is_u, double &amp;x, size_t &amp;perim_num) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGSurface::on_a_perimeter2 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input x is parameter value on a perimeter of the surface. </p>
<p>If x is on a perimeter, x will be updated to the perimeter value. Function's return value is true if on a perimeter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>specify if x is u or v value, is_u!=0(true) means u value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Surface parameter (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returns true,the perimete number will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac94c4040b915518414e83fdfe65a8515"></a><!-- doxytag: member="MGSurface::on_perimeter" ref="ac94c4040b915518414e83fdfe65a8515" args="(const MGCurve &amp;uvcurve, size_t &amp;perim_num) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::on_perimeter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the uvcurve is on a perimeter. </p>
<p>If on a perimeter, true will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvcurve</em>&nbsp;</td><td>curve of surface parameter (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returned true, the perimete number will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b61d4bf8d30ee128a81c96ac4e9beb9"></a><!-- doxytag: member="MGSurface::on_the_perimeter" ref="a2b61d4bf8d30ee128a81c96ac4e9beb9" args="(size_t perim_num, double u, double v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::on_the_perimeter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>perim_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is on the perimeter perim_num. </p>
<p>If u or v is on a perimeter, true will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>a perimete number is input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a9a7b1bc1ab5972f2c58777dfca7f3467">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a76c986bf4d62c1dd70014ea0cc90c6e3"></a><!-- doxytag: member="MGSurface::operator=" ref="a76c986bf4d62c1dd70014ea0cc90c6e3" args="(const MGSurface &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGSurface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and obj2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="af348d7e9562dce2b9d435e4960ff1ac5"></a><!-- doxytag: member="MGSurface::outer_boundary" ref="af348d7e9562dce2b9d435e4960ff1ac5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGSurface::outer_boundary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain outer_boundary curves(world coordinates representation) of the FSurface. </p>
<p>Let the output of <a class="el" href="class_m_g_surface.html#af348d7e9562dce2b9d435e4960ff1ac5" title="Obtain outer_boundary curves(world coordinates representation) of the FSurface.">outer_boundary()</a> be wcurves and of <a class="el" href="class_m_g_surface.html#a58d900e6d0b1f91aa0e9ce7857bd07b8" title="Obtain boundary curves(parameter space representation) of the FSurface.">outer_boundary_param()</a> be pcurves, then wcurves[i] corresponds to pcurves[i] one to one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a8fc539b6e3ce0d7328aedd7c42c201ee">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a58d900e6d0b1f91aa0e9ce7857bd07b8"></a><!-- doxytag: member="MGSurface::outer_boundary_param" ref="a58d900e6d0b1f91aa0e9ce7857bd07b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGSurface::outer_boundary_param </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain boundary curves(parameter space representation) of the FSurface. </p>
<p>Let the output of boundary() be wcurves and of boundary_parameter() be pcurves, then wcurves[i] corresponds to pcurves[i] one to one. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a424bdd8b98a5c4eec9239da4dc689004">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a423bee27e6e375739359ff13ca2c73c2"></a><!-- doxytag: member="MGSurface::param" ref="a423bee27e6e375739359ff13ca2c73c2" args="(const MGPosition &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身の上の指定点を表すパラメータ値を返す。 Return surface parameter value of a point on the surface. </p>
<p>If input point is not on the surface, return the nearest point on the surface. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a25e4519221c8e8c34d5f9110d8a95439">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#afde3cc0a9d49c580798e3cb8be0ef8bf">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a92d73f3618144b4cf2fbefe4030a5ea7"></a><!-- doxytag: member="MGSurface::param_mid" ref="a92d73f3618144b4cf2fbefe4030a5ea7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::param_mid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return parameter value of the middle point of the surface. </p>
<p>The middle point is defined as the parameter (u,v) where u=(<a class="el" href="class_m_g_surface.html#ab685287c057802933f1759b30c22cf32" title="Return starting parameter value.">param_s_u()</a>+param_e_u())/2, and v likewise. </p>

</div>
</div>
<a class="anchor" id="adc9bc5efbc9fdf96b92770aaeed602ca"></a><!-- doxytag: member="MGSurface::param_of_pcurve" ref="adc9bc5efbc9fdf96b92770aaeed602ca" args="(double tw, const MGCurve &amp;wcurve, const MGCurve &amp;pcurve, const double *guess=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGSurface::param_of_pcurve </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>guess</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Let wcurve be a world curve rep that lies on this surface, and pcurve is parameter (u,v) expression of wcurve. </p>
<p>That is, wcurve==MGSurfCurve pline(*this,pcurve). Then, <a class="el" href="class_m_g_surface.html#adc9bc5efbc9fdf96b92770aaeed602ca" title="Let wcurve be a world curve rep that lies on this surface, and pcurve is parameter...">param_of_pcurve()</a> will obtain the parameter tp of pcurve that represent the same point as wcurve.eval(tw). Let S() is this surface, fp() is pcurve, and fw() is wcurve. Then S(fp(tp))=fw(tb). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tw</em>&nbsp;</td><td>point parameter of wcurve to get the pcurve parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wcurve</em>&nbsp;</td><td>world curve that lies on this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcurve</em>&nbsp;</td><td>This surface's parameter rep of wcurve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>guess</em>&nbsp;</td><td>guess parameter value to compute tp. When guess=null, param_of_pcurve will define the guess parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f667e5368e55f075f7dcf4cd052a4dc"></a><!-- doxytag: member="MGSurface::param_range" ref="a1f667e5368e55f075f7dcf4cd052a4dc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_box.html">MGBox</a> MGSurface::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a97b26afbbe3a66b95e3c7ef85e0af8b2">MGFSurface</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a59e3f02d6c5da744e739180674befdf3">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a94e4819a42abd37f1caa2fd0962476df">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#ad01034704a0cdb64e7bb3e1530389b33">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a16e184aac814e3be6f0c2b08d53d3e3d">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a6ab8517d3fb63eddcc8b1a8bb1545174">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#aff650f278660186bc2ba84bc9c1fd845">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a96162a006f79046e1504b6731c599049"></a><!-- doxytag: member="MGSurface::param_span" ref="a96162a006f79046e1504b6731c599049" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGSurface::param_span </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute square of parameter span length from (u.min, v.min) to (u.max, v.max). </p>

</div>
</div>
<a class="anchor" id="a990784f37f8d568aab8d0bc1a0d08e5b"></a><!-- doxytag: member="MGSurface::parameter" ref="a990784f37f8d568aab8d0bc1a0d08e5b" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::parameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter value of given point. </p>
<p>Same as param. 自身の上の指定点を表すパラメータ値を返す。 If input point is not on the geometry, return the nearest point on the geometry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a470c01ec42c6e71b6c34601cc558ec96"></a><!-- doxytag: member="MGSurface::parameter_curve" ref="a470c01ec42c6e71b6c34601cc558ec96" args="(int is_u, double x) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSurface::parameter_curve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter curve. </p>
<p>Returned is newed area pointer, and must be freed by delete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a99458b52d878d6b5991cae7332dc706b">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#ab9a3647d2c9fef4f562a6983021f7e91">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a28554194a15e2c6d712bfcaf5ed43a55">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#ac8dc0427d76fb4ca91b2ca01ac0d1796">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#ae481076c37271c9835c1d138bda2d99a">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a8d150f3f3d1d375c9f74d573eacd0df3">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a47ed9e72cb270f3edfe14d28df1a8e28"></a><!-- doxytag: member="MGSurface::parameter_curves" ref="a47ed9e72cb270f3edfe14d28df1a8e28" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGSurface::parameter_curves </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter curves. </p>
<p>In the case of surFSurface, parameter curve is only one. However, in the case of FSurface, number of parameter curves are more than one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>True(!=0) if x is u-value.(i.e. obtain u=const line) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>parameter value. u or v-value accordint to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a250b40652b5c0400bd5d5f4f350b85a0">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7a924b141ca6ea037545953c5e00d682"></a><!-- doxytag: member="MGSurface::part" ref="a7a924b141ca6ea037545953c5e00d682" args="(const MGBox &amp;bx, int multiple=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGSurface::part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of the surface limitted by the parameter range bx. </p>
<p>bx(0) is the parameter (us,vs) and bx(1) is (ue,ve). That is u range is from us to ue , and so on. Retured is newed object, must be deleted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#ab436b28f898b1e61b7fb4f337c7fa33b">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a9482d2f0f4a0e94c09db142411f597fd">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a822b1bbcfcbc9deaabd4b74d09f71f4f">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a8f016a068895c9d063444428fc919f5a">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a178ba8ec9ffc350fd488f3b4ed4301d8">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a8f095afc52d22271aa37d10d96a664ec">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a57c8bffdb617cf4ff7c654e2b080200c"></a><!-- doxytag: member="MGSurface::perimeter_curve" ref="a57c8bffdb617cf4ff7c654e2b080200c" args="(size_t i) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSurface::perimeter_curve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve perimeter i of this surface. </p>
<p>i must be &lt; <a class="el" href="class_m_g_surface.html#acc5963351892255db41d325c8348155b" title="Return how many perimeters this surface has.">perimeter_num()</a>. When <a class="el" href="class_m_g_surface.html#acc5963351892255db41d325c8348155b" title="Return how many perimeters this surface has.">perimeter_num()</a>==0, this function is undefined. Retured is newed object, must be deleted. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a0fca0e56a2be39681eedc753042c667a">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#ad2c8465ddc2a6643409df28908cdbde9">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a2a495af4be0561cbd09e45aff78641cb">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a1dbb8c28adef0d3d17f98b1715392eeb">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a2fa92e4b8f76fb299d682d28b686713e">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a11d32da214e2c26d03cf9c654828fce0">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="af4e0ecf2e16bc611a9ad8a6032c5516b"></a><!-- doxytag: member="MGSurface::perp_guess" ref="af4e0ecf2e16bc611a9ad8a6032c5516b" args="(const MGPosition &amp;uv0, const MGPosition &amp;uv1, const MGPosition &amp;P, const MGPosition &amp;uvguess, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a perpendicular point from a point P, given guess parameter value uvguess. </p>
<p>Function's return value is: true if uv is obtained, false if uv is not obtained. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv1</em>&nbsp;</td><td>parameter range of this surface, When uv0(0)&gt;=uv1(0) or uv0(1)&gt;=uv1(1), no limit for this parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a824d86bf1baa1ed5ee16cdf839c04f71"></a><!-- doxytag: member="MGSurface::perp_guess" ref="a824d86bf1baa1ed5ee16cdf839c04f71" args="(const MGCurve &amp;curve, const MGPosition &amp;uvguess, double tguess, MGPosition &amp;uv, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perpendicular points of a curve and the FSurface, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>Guess parameter value of the FSurface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tguess</em>&nbsp;</td><td>Guess parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>perpendicular point's parameter values of the shell will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a8d747b59a0f1209147a7e3f5e1ffbdad">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aa2e3a648ac566d105a6802238d022a6e"></a><!-- doxytag: member="MGSurface::perp_guess" ref="aa2e3a648ac566d105a6802238d022a6e" args="(const MGPosition &amp;uv0, const MGPosition &amp;uv1, const MGCurve &amp;curve, double t0, double t1, const MGPosition &amp;tuvg, MGPosition &amp;tuv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tuvg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tuv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perpendicular points of a curve and a surface, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv1</em>&nbsp;</td><td>parameter range of this surface. When uv0(0)&gt;=uv1(0) or uv0(1)&gt;=uv1(1), no limit for this parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curve</em>&nbsp;</td><td>curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of curve. When t0&gt;=t1, no limit for curve2 parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuvg</em>&nbsp;</td><td>Guess parameter value of curve and this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuv</em>&nbsp;</td><td>perpendicular points' parameter values will be output. tuv(0): curve's parameter, (tuv(1),tuv(2)):this surface's parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47c0a87ffbd5e473cdeda87ad9127cbf"></a><!-- doxytag: member="MGSurface::perp_guess" ref="a47c0a87ffbd5e473cdeda87ad9127cbf" args="(const MGPosition &amp;uv0, const MGPosition &amp;uv1, const MGCompositeCurve &amp;crv, double t0, double t1, const MGPosition &amp;tuvg, MGPosition &amp;tuv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tuvg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tuv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv1</em>&nbsp;</td><td>parameter range of this surface, When uv0(0)&gt;=uv1(0) or uv0(1)&gt;=uv1(1), no limit for this parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td><a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of curve, When t0&gt;=t1, no limit for curve2 parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuvg</em>&nbsp;</td><td>Guess parameter value of curve and this surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuv</em>&nbsp;</td><td>perpendicular points' parameter values will be output, tuv(0): curve's parameter, (tuv(1),tuv(2)):this surface's parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20678e5bff86bc76a04add72aa002eac"></a><!-- doxytag: member="MGSurface::perp_guess" ref="a20678e5bff86bc76a04add72aa002eac" args="(const MGPosition &amp;P, const MGPosition &amp;uvguess, MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGSurface::perp_guess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the foot of the perpendicular straight line from P. </p>
<p>Computation is done from the guess parameter value. Function's return value is whether point is obtained(true) or not(false). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of the shell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a388cb2b317aff6476993f3a19d6601c1">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ac94884f1674a06f476c417511a93eb2a"></a><!-- doxytag: member="MGSurface::perp_point" ref="ac94884f1674a06f476c417511a93eb2a" args="(const MGPosition &amp;P, MGPosition &amp;uv, const MGPosition *uvguess=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGSurface::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td>
          <td class="paramname"> <em>uvguess</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与点にもっとも近い、与点から面に垂直な面上の点を求める。 Return the foot of the perpendicular straight line from P that is nearest to point uvguess. </p>
<p>Function's return value is whether point is obtained(1) or not(0) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>指定点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the plane will be output パラメータ値 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess parameter value of the surface </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a487baf864df83faad23c2326b591a1ed">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#af2afc495f138ff58e03088e847236d5f">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a14e8bdacc9586ab1981f1d0ca1abb632">MGPlane</a>, and <a class="el" href="class_m_g_sphere.html#ae27787efac00f3e2b7d3de1ceaa55f63">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="aed36001c59550de9c2054564844c638f"></a><!-- doxytag: member="MGSurface::perps" ref="aed36001c59550de9c2054564844c638f" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGSurface::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return all foots of perpendicular straight lines from P. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point of a space(指定点) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a82802a49466e8a9a60c15d20103490bb">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a38776f8959055ad54283c6be587bc1e5">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a12dddf55a74e756d3d0de147e930e694">MGPlane</a>, and <a class="el" href="class_m_g_sphere.html#a67aec64f8ad44dc182da791208bd7534">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a677cc63d5ec6d7fe4fa95013ed4b50d4"></a><!-- doxytag: member="MGSurface::pick_closest" ref="a677cc63d5ec6d7fe4fa95013ed4b50d4" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::pick_closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parameter value of the closest point from the straight to this object. </p>
<p>sl is the eye projection line whose direction is from yon to hither, and if sl had multiple intersection points, The closest point to the eye will be selected. </p>

</div>
</div>
<a class="anchor" id="a8966c7e15642175de66afee13234dfc5"></a><!-- doxytag: member="MGSurface::range" ref="a8966c7e15642175de66afee13234dfc5" args="(const MGPosition &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGSurface::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力パラメータをパラメータ範囲でまるめて返却する。 Round the input parameter value uv into the parameter range of the surface. </p>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a13fb86a7db29413a40795bdb2522bb38">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_cylinder.html#a2e0654da4bfe2b9d45ae86c1c4a8a842">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#aefe8f7187ede379cb7528bef93a111a0">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a545928d1e952ea264a6ef83f9a43359e">MGRSBRep</a>, and <a class="el" href="class_m_g_sphere.html#ac531ee66ce206379acf8754492413d66">MGSphere</a>.</p>

</div>
</div>
<a class="anchor" id="a168a7c2b0732dc2d6e4f534371e4b12b"></a><!-- doxytag: member="MGSurface::remove_knot" ref="a168a7c2b0732dc2d6e4f534371e4b12b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数(B表現曲線のみ) トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal redundant knots within the tolerance line_zero(). </p>

<p>Reimplemented in <a class="el" href="class_m_g_r_s_b_rep.html#a8a18a4494af9d5965668233bbf9de922">MGRSBRep</a>, and <a class="el" href="class_m_g_s_b_rep.html#abde55a27be0c01339e3c0dd3738d260c">MGSBRep</a>.</p>

</div>
</div>
<a class="anchor" id="a5588c90dbae532152f8dd4356e927f6d"></a><!-- doxytag: member="MGSurface::rotate_self" ref="a5588c90dbae532152f8dd4356e927f6d" args="(const MGVector &amp;vec, double angle, const MGPosition &amp;origin=mgORIGIN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGSurface::rotate_self </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em> = <code>mgORIGIN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定点をとおり指定方向ベクトルを持つ直線の回りを指定角度の 回転を行ない自身の面とする。 Rotate the surface around the straight line whose direction is vec and that passes through origin. </p>

</div>
</div>
<a class="anchor" id="a55206c783635934aa4bcd2f3231a2a1a"></a><!-- doxytag: member="MGSurface::shade" ref="a55206c783635934aa4bcd2f3231a2a1a" args="(double span_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::shade </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shade the object in world coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a21c6e4cd6c4ce3efd2d1dfe98f043a04">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a7bb84fd8e6434c9eabccd05675ddf2b5"></a><!-- doxytag: member="MGSurface::shrink_to_knot" ref="a7bb84fd8e6434c9eabccd05675ddf2b5" args="(const MGBox &amp;uvbx, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::shrink_to_knot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrink this surface to the part limitted by the parameter range of uvbx. </p>
<p>New parameter range uvbx2 is so determined that uvbx2 is the smallest box tha includes uvbx, and all of the u or v values of uvbx2 is one of the values of u or v knots of the surface knotvector. uvbx(0) is the parameter (us,ue) and uvbx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_b_sum_surf.html#a8c48342bfed4bdba73e389b42ac25e4c">MGBSumSurf</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a47a54710c09c12e586688107f1a5baa0">MGRSBRep</a>, and <a class="el" href="class_m_g_s_b_rep.html#a3a4d045515d9884c96c7c8e0d2e38920">MGSBRep</a>.</p>

</div>
</div>
<a class="anchor" id="aa42207d63b66cb594cf5329597657eec"></a><!-- doxytag: member="MGSurface::split" ref="aa42207d63b66cb594cf5329597657eec" args="(double param, bool is_u, MGPvector&lt; MGFSurface &gt; &amp;surfaces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGSurface::split </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>surfaces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>split this fsurface at the parameter param. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of this fsurface. if is_u is true, param is u-value, else v-value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>indicates if param is u or v of the surface parameter (u,v). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>surfaces</em>&nbsp;</td><td>splitted surfaces will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_f_surface.html#a7566ec759dec2037106a0a0b53a0a922">MGFSurface</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_plane.html#a10de314e84981bdcc18a049b917e9d73">MGPlane</a>.</p>

</div>
</div>
<a class="anchor" id="a87c0d6fd656d16ace82bc5232be1ac5b"></a><!-- doxytag: member="MGSurface::surf" ref="a87c0d6fd656d16ace82bc5232be1ac5b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGSurface::surf </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a> pointer if this is a <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>. </p>
<p>Else returns null. </p>

</div>
</div>
<a class="anchor" id="af0d34261ef8ffb620434a072539b9aad"></a><!-- doxytag: member="MGSurface::surf1D" ref="af0d34261ef8ffb620434a072539b9aad" args="(const MGPlane &amp;pl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>* MGSurface::surf1D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain 1D surface rep. </p>
<p>of this surf which can be used for isect(const MGPlane&amp; pl). This surf1D is used in isect for the argument of isect_startPlane, which will use surf1D to compute isect(pl). surf1D=0.(intersection with x=0. plane) is the intersection lines. </p>

</div>
</div>
<a class="anchor" id="ac24e9631f2fb3c3940ac0ff552e723e9"></a><!-- doxytag: member="MGSurface::test_and_get_approximate_plane" ref="ac24e9631f2fb3c3940ac0ff552e723e9" args="(double u0, double u1, double v0, double v1, double surface_tol, double angle, MGPlane &amp;plane, double &amp;width, double &amp;height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGSurface::test_and_get_approximate_plane </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>surface_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the approximate plane in the parameter range from (u0, v0) to (u1,v1) when the surface is within surface_tol and angle from the plane. </p>
<p>The plane's origin is center point of the plane when the surface is mapped onto the plane. the uderiv is the direction from the point(u0, v0) to (u1,v0). Function's return value is true when the surface is within the tolerance surface_tol, and the surface normals are within angle from the plane's normal plane, width, and height are valid only when function's return value is true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u1</em>&nbsp;</td><td>u range from u0 to u1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>v range from v0 to v1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>surface_tol</em>&nbsp;</td><td>tolerance allowed for the deviation from the plane to the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>angle allowed for the normal of the plane and the normals of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>The plane will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width and the height of the plane that include all the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>for the surface point to map onto the plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83ad0b3f99b05d775a1d4d7352baf9d0"></a><!-- doxytag: member="MGSurface::type" ref="a83ad0b3f99b05d775a1d4d7352baf9d0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a> MGSurface::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>面のTypeを返却する。 Return the surface type. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_surf.html#a4837a3c9da2ba4a1c0113a07fa478d4a">MGBSumSurf</a>, <a class="el" href="class_m_g_cylinder.html#a23195f906d946b4a68a8b46aff07f092">MGCylinder</a>, <a class="el" href="class_m_g_plane.html#a340c1e5493ce45c2c33dded8fcfa0798">MGPlane</a>, <a class="el" href="class_m_g_r_s_b_rep.html#a8d5a8c2c6fae8edd18644569ae9462a7">MGRSBRep</a>, <a class="el" href="class_m_g_s_b_rep.html#a8e958688c5c4c90faf0f7316c2968568">MGSBRep</a>, and <a class="el" href="class_m_g_sphere.html#a260c9261c71928f41c796782296a6684">MGSphere</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a8515101478c20c294195fd74724e2b78"></a><!-- doxytag: member="MGSurface::isect_start_adjustSE" ref="a8515101478c20c294195fd74724e2b78" args="(int ngtan, MGNDDArray &amp;tau, MGBPointSeq &amp;point, MGLBRep &amp;lineb, MGVector *tan[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isect_start_adjustSE </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ngtan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lineb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> *&nbsp;</td>
          <td class="paramname"> <em>tan</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update lineb so as to have the tangent tan for start or end according to ngtan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ngtan</em>&nbsp;</td><td>Return value of isect_start_tan, indicates which end be adjusted. =1: start tangent, =2:end tangent, =3:both tangent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>data point abcissa. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>data point ordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lineb</em>&nbsp;</td><td>line b-rep obtained so far. tangent adjusted new B-rep will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tan</em>&nbsp;</td><td>accurate tangent data obtained by isect_start_tan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a365297ecdb62e0f4803a72d140babec2"></a><!-- doxytag: member="MGSurface::isect_start_tan" ref="a365297ecdb62e0f4803a72d140babec2" args="(const MGFSurface &amp;sf1, const MGFSurface &amp;sf2, const MGLBRep &amp;lineb, MGVector *Tse[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isect_start_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lineb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> *&nbsp;</td>
          <td class="paramname"> <em>Tse</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the intersection line lineb's start and end tangent vectors are accurate enough. </p>
<p>If they do not have enough accuracy, isect_start_tan returns which end did not have the accuracy. 1:start, 2:end, 3:start and end. If both ends had enough accuracy, returns 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tse</em>&nbsp;</td><td>If an end had not the accuracy, accurate tangent will be output. Tse[0]:start, Tse[1]:end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90fec61e4e1f3f47d5455885282f137a"></a><!-- doxytag: member="MGSurface::test_to_get_approximate_plane" ref="a90fec61e4e1f3f47d5455885282f137a" args="(const MGPosition Pn[9], const MGVector Nn[9], const MGPosition &amp;center, const MGUnit_vector &amp;N, double surface_tol, double angle, MGPlane &amp;plane, double &amp;width, double &amp;height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool test_to_get_approximate_plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>Pn</em>[9], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td>
          <td class="paramname"> <em>Nn</em>[9], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>surface_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface_tol</em>&nbsp;</td><td>tolerance allowed for the deviation from the plane to the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>angle allowed for the normal of the plane and the normals of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>The plane will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width and the height of the plane that include all the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>for the surface point to map onto the plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Surface.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:29 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

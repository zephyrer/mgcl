<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGBPointSeq Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGBPointSeq Class Reference<br/>
<small>
[<a class="el" href="group___b_a_s_e.html">Base Class</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGBPointSeq" -->
<p>Defines BPoint seq of a space dimension and of a capacity.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;BPointSeq.h&gt;</code></p>

<p><a href="class_m_g_b_point_seq-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ad5f4c114be3f95d36083a12544a3fda1">MGBPointSeq</a> (size_t capacity=0, size_t dim=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dimensioning of <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> is MGBPointSeq(capacity,dim).  <a href="#ad5f4c114be3f95d36083a12544a3fda1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a12e852a2f3d2a99979f44173fbdad27c">MGBPointSeq</a> (size_t dim, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;old_brep, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> by copying original <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a>, Can change the order of coordinates.  <a href="#a12e852a2f3d2a99979f44173fbdad27c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#afe9ebf714c5fc51af025fcfba376631e">MGBPointSeq</a> (bool along_u, size_t m, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;sp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct by extracting one line data of sp along u or v direction.  <a href="#afe9ebf714c5fc51af025fcfba376631e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ad430a3ac42fb48d8fc23ba55f04ea230">MGBPointSeq</a> (size_t start_id, size_t num, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bp_old)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct by extracting sub interval of bp_old.  <a href="#ad430a3ac42fb48d8fc23ba55f04ea230"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe6ae9931d834def8fba59adffe3083"></a><!-- doxytag: member="MGBPointSeq::MGBPointSeq" ref="a8fe6ae9931d834def8fba59adffe3083" args="(const std::vector&lt; MGPosition &gt; &amp;poses)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a8fe6ae9931d834def8fba59adffe3083">MGBPointSeq</a> (const std::vector&lt; <a class="el" href="class_m_g_position.html">MGPosition</a> &gt; &amp;poses)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77d53f572a37baedfd88dc65d9b6a74"></a><!-- doxytag: member="MGBPointSeq::MGBPointSeq" ref="ad77d53f572a37baedfd88dc65d9b6a74" args="(const MGBPointSeq &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ad77d53f572a37baedfd88dc65d9b6a74">MGBPointSeq</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac828bf53eafc82b85423f181b42a288d"></a><!-- doxytag: member="MGBPointSeq::‾MGBPointSeq" ref="ac828bf53eafc82b85423f181b42a288d" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGBPointSeq</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a311c68aa637cd3b20767a175cdf4d"></a><!-- doxytag: member="MGBPointSeq::operator=" ref="a44a311c68aa637cd3b20767a175cdf4d" args="(const MGBPointSeq &amp;)" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a44a311c68aa637cd3b20767a175cdf4d">operator=</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc7de75ba6fb74ad6cb665685bd1e4d7"></a><!-- doxytag: member="MGBPointSeq::operator()" ref="afc7de75ba6fb74ad6cb665685bd1e4d7" args="(size_t i, size_t j)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#afc7de75ba6fb74ad6cb665685bd1e4d7">operator()</a> (size_t i, size_t j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element(LHS version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39ad3c52108b9091a647126b78d82bab"></a><!-- doxytag: member="MGBPointSeq::operator()" ref="a39ad3c52108b9091a647126b78d82bab" args="(size_t i, size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a39ad3c52108b9091a647126b78d82bab">operator()</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element(RHS version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a452a443c9e751377052e821189448f12"></a><!-- doxytag: member="MGBPointSeq::operator()" ref="a452a443c9e751377052e821189448f12" args="(size_t i) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a452a443c9e751377052e821189448f12">operator()</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract (i,j) coordinate values for 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a> as a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a732bb171afc0b769f71710d39991ce67">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線の平行移動を行いオブジェクトを生成する。 Generates an object by translation.  <a href="#a732bb171afc0b769f71710d39991ce67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a40f34b593305365024f8d80e39d7f9c9">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与ベクトルだけ曲線を平行移動して自身とする。 Updates an object by translation.  <a href="#a40f34b593305365024f8d80e39d7f9c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ac137d542ccc9807d6eaa643f0904339d">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線の逆方向に平行移動を行いオブジェクトを生成する。 Generates an object by translation.  <a href="#ac137d542ccc9807d6eaa643f0904339d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ad57b2085a7b11b1e67f96b7c375fb8bb">operator-=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与ベクトルだけ曲線をマイナス方向に平行移動して自身とする。 Updates the object by translation.  <a href="#ad57b2085a7b11b1e67f96b7c375fb8bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab95ed12d225a00653519d66b93395938"></a><!-- doxytag: member="MGBPointSeq::operator+" ref="ab95ed12d225a00653519d66b93395938" args="(const MGBPointSeq &amp;bp2) const " -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ab95ed12d225a00653519d66b93395938">operator+</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bp2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add operation of two BPointSeq. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859890f45c9db707cac90b32a157546a"></a><!-- doxytag: member="MGBPointSeq::operator+=" ref="a859890f45c9db707cac90b32a157546a" args="(const MGBPointSeq &amp;bp2)" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a859890f45c9db707cac90b32a157546a">operator+=</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bp2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add operation of two BPointSeq. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fca3a4b2d8d12efeade4aa72da31a10"></a><!-- doxytag: member="MGBPointSeq::operator&#45;" ref="a2fca3a4b2d8d12efeade4aa72da31a10" args="(const MGBPointSeq &amp;bp2) const " -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a2fca3a4b2d8d12efeade4aa72da31a10">operator-</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bp2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract operation of two BPointSeq. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aad969cfc286dce65aa796302c2241d"></a><!-- doxytag: member="MGBPointSeq::operator&#45;=" ref="a4aad969cfc286dce65aa796302c2241d" args="(const MGBPointSeq &amp;bp2)" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a4aad969cfc286dce65aa796302c2241d">operator-=</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;bp2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract operation of two BPointSeq. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#afd0e7c3df2ab84cc3ef56744f63b49f2">operator*</a> (double scale) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケールで曲線の変換を行いオブジェクトを生成する。 Generates an object by multiplying scale to the original.  <a href="#afd0e7c3df2ab84cc3ef56744f63b49f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aada4d19840a7267e2f6a84d4bae03789">operator*=</a> (double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケールで曲線の変換を行い自身の曲線とする。 Updates the object by multiplying scale.  <a href="#aada4d19840a7267e2f6a84d4bae03789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aba4a3e2c66ba765223fb38cfb75bcbeb">operator/</a> (double scale) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケールで曲線の変換を行いオブジェクトを生成する。 Generates an object by multiplying scale to the original.  <a href="#aba4a3e2c66ba765223fb38cfb75bcbeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a560d6015114c2619da983941a546235c">operator/=</a> (double scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケールで曲線の変換を行い自身の曲線とする。 Updates the object by multiplying scale.  <a href="#a560d6015114c2619da983941a546235c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#af939fcad302a0bfe7862a9fce8b77d7c">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲線の変換を行いオブジェクトを生成する。 Generates an object by multiplying matrix to the original.  <a href="#af939fcad302a0bfe7862a9fce8b77d7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aeffcf1ff59f4ce6b414e0423ad60b4f2">operator*=</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲線の変換を行い自身の曲線とする。 Updates the object by multiplying matrix.  <a href="#aeffcf1ff59f4ce6b414e0423ad60b4f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a37f561fe10f75a6fb197d0857963ee70">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲線のトランスフォームを行いオブジェクトを生成する。 Generates an object by multiplying transformation to the original.  <a href="#a37f561fe10f75a6fb197d0857963ee70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a91264040f4277044279cf8a46f88755e">operator*=</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲線のトランスフォームを行い自身とする。 Updates the object by multiplying transformation.  <a href="#a91264040f4277044279cf8a46f88755e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a9a60424c8f58eaf47a2951c0149b6c69">operator==</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two BPointSeq if they are equal.  <a href="#a9a60424c8f58eaf47a2951c0149b6c69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a1846868f6c4ccbc82ba7ea4dd9015c37">operator!=</a> (const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;brep) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two BPointSeq if they are equal.  <a href="#a1846868f6c4ccbc82ba7ea4dd9015c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ab2307222798b99cc182129b9c0986ec9">average_plane</a> (<a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;line, double &amp;deviation) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute an average plane of the point sequence.  <a href="#ab2307222798b99cc182129b9c0986ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23971fca4614fad60e929b84e48ed45e"></a><!-- doxytag: member="MGBPointSeq::box" ref="a23971fca4614fad60e929b84e48ed45e" args="() const " -->
<a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a23971fca4614fad60e929b84e48ed45e">box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute minimum box sorrounding the all the points. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a0cb2f76ed2d0e851c465d85e1a962cec">coordinate_exchange</a> (size_t j1, size_t j2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange ordering of the coordinates.  <a href="#a0cb2f76ed2d0e851c465d85e1a962cec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a012c3074fc1085da1c3e12d43a3904f4"></a><!-- doxytag: member="MGBPointSeq::data" ref="a012c3074fc1085da1c3e12d43a3904f4" args="(size_t i=0, size_t j=0)" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a012c3074fc1085da1c3e12d43a3904f4">data</a> (size_t i=0, size_t j=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the data area. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf9476f468246f9077a7b293b623f4b3"></a><!-- doxytag: member="MGBPointSeq::data" ref="aaf9476f468246f9077a7b293b623f4b3" args="(size_t i=0, size_t j=0) const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aaf9476f468246f9077a7b293b623f4b3">data</a> (size_t i=0, size_t j=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the area. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aa88009851b010eead36567faf4f2f171">insert_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vctr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert vector data to this(i,j) 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>.  <a href="#aa88009851b010eead36567faf4f2f171"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a28413f9cea3fa3976a3ca86a7e6785e3">insert_at</a> (size_t i, const double *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert array data[j] to this(i,j) 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>.  <a href="#a28413f9cea3fa3976a3ca86a7e6785e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a147b3672103bb929211ab349ba172dc9"></a><!-- doxytag: member="MGBPointSeq::is_null" ref="a147b3672103bb929211ab349ba172dc9" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a147b3672103bb929211ab349ba172dc9">is_null</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23607886b78cf7dadadbcc42a62a8ba8"></a><!-- doxytag: member="MGBPointSeq::length" ref="a23607886b78cf7dadadbcc42a62a8ba8" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a23607886b78cf7dadadbcc42a62a8ba8">length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the actual size of Bpoint seq. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#abb5a62862ab9b962b81d42e9559959b9">non_homogeneous</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute non_homogeneous coordonate data without w coordinate element, assumed that this is homogeneous coordinate data, i.e., maximum space dimension element is w(weight) coordinate.  <a href="#abb5a62862ab9b962b81d42e9559959b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a64278ec0c53d5925116501303819de91">planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;line, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;center) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if coefficients are planar.  <a href="#a64278ec0c53d5925116501303819de91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aeab6b41eb5ab55040eb93d9bb22d581a">point</a> (size_t i, size_t j, size_t sd, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve sub data of i-th point of the BPointSeq.  <a href="#aeab6b41eb5ab55040eb93d9bb22d581a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b229c4b1e44df09c0b516d9bc040274"></a><!-- doxytag: member="MGBPointSeq::ref" ref="a2b229c4b1e44df09c0b516d9bc040274" args="(size_t i, size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a2b229c4b1e44df09c0b516d9bc040274">ref</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return (i,j)-th element data, return 0.0 when j&gt;=sdim(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ab6b9e7dfac101794d8ba06838226ba85">reshape</a> (size_t capacity, size_t start=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change capacity.  <a href="#ab6b9e7dfac101794d8ba06838226ba85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#aa308a6fc1c154dfeefbce5eff70c7ed4">resize</a> (size_t sz, size_t dim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the array.  <a href="#aa308a6fc1c154dfeefbce5eff70c7ed4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac820de22609c82741b3f55c98fdd22d2"></a><!-- doxytag: member="MGBPointSeq::sdim" ref="ac820de22609c82741b3f55c98fdd22d2" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06d5250701edc1e2de7eae568195d041"></a><!-- doxytag: member="MGBPointSeq::set_length" ref="a06d5250701edc1e2de7eae568195d041" args="(size_t length)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a06d5250701edc1e2de7eae568195d041">set_length</a> (size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the length of effective data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f39e56462a093a2e5712246524430e0"></a><!-- doxytag: member="MGBPointSeq::set_null" ref="a0f39e56462a093a2e5712246524430e0" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a0f39e56462a093a2e5712246524430e0">set_null</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this BPointSeq as a null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731bddd9824f56eed4c9297f5cd61ad7"></a><!-- doxytag: member="MGBPointSeq::capacity" ref="a731bddd9824f56eed4c9297f5cd61ad7" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a731bddd9824f56eed4c9297f5cd61ad7">capacity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the capacity. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#afdfbd883418853ce86e3a5fa96139b3a">store_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vctr, size_t to=0, size_t from=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store vector data vector(from+j) to this(i,to+j) for 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>.  <a href="#afdfbd883418853ce86e3a5fa96139b3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a04fd2903d48feda7463ec157d98ed2d6">store_at</a> (size_t i, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vctr, size_t to, size_t from, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store vector data vector(from+j) to this(i,to+j) for 0&lt;=j&lt;len.  <a href="#a04fd2903d48feda7463ec157d98ed2d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a312dd0a046687778dbe867a4db09aed5">store_at</a> (size_t i, const double *data, size_t to=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store data[j] to this(i,to+j) for 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>.  <a href="#a312dd0a046687778dbe867a4db09aed5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#afdb61b68fe109705495b2a856bb0d370">homogeneous_transform</a> (double)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of own for rational(MGRLBRep) Control Polygon.  <a href="#afdb61b68fe109705495b2a856bb0d370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40560387479938bcecdb9b536e1e1e96"></a><!-- doxytag: member="MGBPointSeq::homogeneous_transform" ref="a40560387479938bcecdb9b536e1e1e96" args="(const MGVector &amp;)" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a40560387479938bcecdb9b536e1e1e96">homogeneous_transform</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add the vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa232d9bcbcd8004e55792fc9594e3e3"></a><!-- doxytag: member="MGBPointSeq::homogeneous_transform" ref="afa232d9bcbcd8004e55792fc9594e3e3" args="(const MGMatrix &amp;)" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#afa232d9bcbcd8004e55792fc9594e3e3">homogeneous_transform</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the matrix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae09869bfe894440cc586848bfa77ba62"></a><!-- doxytag: member="MGBPointSeq::homogeneous_transform" ref="ae09869bfe894440cc586848bfa77ba62" args="(const MGTransf &amp;)" -->
<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#ae09869bfe894440cc586848bfa77ba62">homogeneous_transform</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply the transform. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d7d3be215e33884d0e74a8ec41ba10"></a><!-- doxytag: member="MGBPointSeq::dump_size" ref="a01d7d3be215e33884d0e74a8ec41ba10" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a01d7d3be215e33884d0e74a8ec41ba10">dump_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Functions, Calculate dump size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dbab239f2bac4b3cdbc0c981a6b404b"></a><!-- doxytag: member="MGBPointSeq::dump" ref="a0dbab239f2bac4b3cdbc0c981a6b404b" args="(MGOfstream &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a0dbab239f2bac4b3cdbc0c981a6b404b">dump</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89a872215296f4744a5643f82485842e"></a><!-- doxytag: member="MGBPointSeq::restore" ref="a89a872215296f4744a5643f82485842e" args="(MGIfstream &amp;)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a89a872215296f4744a5643f82485842e">restore</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore Function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23669e08ae9e6c150b0deb0d002fa39a"></a><!-- doxytag: member="MGBPointSeq::MGLBRep" ref="a23669e08ae9e6c150b0deb0d002fa39a" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a23669e08ae9e6c150b0deb0d002fa39a">MGLBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c74ab8db89c57468240dc0709fb6648"></a><!-- doxytag: member="MGBPointSeq::MGRLBRep" ref="a8c74ab8db89c57468240dc0709fb6648" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a8c74ab8db89c57468240dc0709fb6648">MGRLBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f9600f70ae9267289804768a6803339"></a><!-- doxytag: member="MGBPointSeq::operator+" ref="a1f9600f70ae9267289804768a6803339" args="(const MGVector &amp;v, const MGBPointSeq &amp;b)" -->
MGDECL friend <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a1f9600f70ae9267289804768a6803339">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">translation by a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a5291ccc9db6e23085532cee5c4df3326">operator*</a> (double scale, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BPointをスケーリングしてできるオブジェクトを生成する。 Generates a object by scaling.  <a href="#a5291ccc9db6e23085532cee5c4df3326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a35224007d39f5a2c2b8af0d2b6e3bf"></a><!-- doxytag: member="MGBPointSeq::operator&lt;&lt;" ref="a7a35224007d39f5a2c2b8af0d2b6e3bf" args="(std::ostream &amp;, const MGBPointSeq &amp;)" -->
MGDECL friend std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_b_point_seq.html#a7a35224007d39f5a2c2b8af0d2b6e3bf">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String stream Function. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines BPoint seq of a space dimension and of a capacity. </p>
<p><a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> is an array of world coordinates of a space dimension(any number), desined especially for <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> class's control polygon handling. Let n be a B-rep dimension(i.e., number of points of the control polygon), and sd be a space dimension, then <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> bp has the minimum area of n*sd. The subscription of <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> bp is 2 dimension as bp(i,j), 0&lt;=i&lt;n, and 0&lt;=j&lt;sd. If <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> can be considered as a Matrix of n by sd. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad5f4c114be3f95d36083a12544a3fda1"></a><!-- doxytag: member="MGBPointSeq::MGBPointSeq" ref="ad5f4c114be3f95d36083a12544a3fda1" args="(size_t capacity=0, size_t dim=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBPointSeq::MGBPointSeq </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dimensioning of <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> is MGBPointSeq(capacity,dim). </p>
<p>effective length will be set capacity(i.e. <a class="el" href="class_m_g_b_point_seq.html#a23607886b78cf7dadadbcc42a62a8ba8" title="Returns the actual size of Bpoint seq.">length()</a> will be capacity). </p>

</div>
</div>
<a class="anchor" id="a12e852a2f3d2a99979f44173fbdad27c"></a><!-- doxytag: member="MGBPointSeq::MGBPointSeq" ref="a12e852a2f3d2a99979f44173fbdad27c" args="(size_t dim, const MGBPointSeq &amp;old_brep, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBPointSeq::MGBPointSeq </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a> by copying original <a class="el" href="class_m_g_b_point_seq.html" title="Defines BPoint seq of a space dimension and of a capacity.">MGBPointSeq</a>, Can change the order of coordinates. </p>
<p>(*this)(start1,.) will be old_brep(start2,.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New Space Dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Origianl B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination start order to store. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source start order to retrieve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe9ebf714c5fc51af025fcfba376631e"></a><!-- doxytag: member="MGBPointSeq::MGBPointSeq" ref="afe9ebf714c5fc51af025fcfba376631e" args="(bool along_u, size_t m, const MGSPointSeq &amp;sp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBPointSeq::MGBPointSeq </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>along_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct by extracting one line data of sp along u or v direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>along_u</em>&nbsp;</td><td>indicates which direction make a line out of sp. if true, along u direction:sp(i,m,.) for i=0, ..., nu-1 makes the BPointSeq. if false, along v direction:sp(m,j,.) for j=0, ..., nv-1 makes the BPointSeq. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>index of u or v as above, acording to along_u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>Origianl SPoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad430a3ac42fb48d8fc23ba55f04ea230"></a><!-- doxytag: member="MGBPointSeq::MGBPointSeq" ref="ad430a3ac42fb48d8fc23ba55f04ea230" args="(size_t start_id, size_t num, const MGBPointSeq &amp;bp_old)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGBPointSeq::MGBPointSeq </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bp_old</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct by extracting sub interval of bp_old. </p>
<p>(*this)(0+i,.) will be bp_old(start_id+i,.) for i=0,...,num-1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_id</em>&nbsp;</td><td>Start id of bp_old </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>New length(of new BPoint) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bp_old</em>&nbsp;</td><td>Origianl BPoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab2307222798b99cc182129b9c0986ec9"></a><!-- doxytag: member="MGBPointSeq::average_plane" ref="ab2307222798b99cc182129b9c0986ec9" args="(MGPosition &amp;center, MGPlane &amp;plane, MGStraight &amp;line, double &amp;deviation) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGBPointSeq::average_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>deviation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compute an average plane of the point sequence. </p>
<p>Function's return value is: 1: Point seq is a point. 2: Point seq is on a line. 3: Plane is output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>center of point seq will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Plane will be output, when average_plane=3. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>Straight line will be output =2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>Maximum deviation from point, line, or plane will be output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cb2f76ed2d0e851c465d85e1a962cec"></a><!-- doxytag: member="MGBPointSeq::coordinate_exchange" ref="a0cb2f76ed2d0e851c465d85e1a962cec" args="(size_t j1, size_t j2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::coordinate_exchange </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange ordering of the coordinates. </p>
<p>Exchange coordinates (j1) and (j2). </p>

</div>
</div>
<a class="anchor" id="afdb61b68fe109705495b2a856bb0d370"></a><!-- doxytag: member="MGBPointSeq::homogeneous_transform" ref="afdb61b68fe109705495b2a856bb0d370" args="(double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::homogeneous_transform </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transformation of own for rational(MGRLBRep) Control Polygon. </p>
<p>Scaling. </p>

</div>
</div>
<a class="anchor" id="aa88009851b010eead36567faf4f2f171"></a><!-- doxytag: member="MGBPointSeq::insert_at" ref="aa88009851b010eead36567faf4f2f171" args="(size_t i, const MGVector &amp;vctr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::insert_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vctr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert vector data to this(i,j) 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>id of this which indicates the placement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vctr</em>&nbsp;</td><td>Input vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28413f9cea3fa3976a3ca86a7e6785e3"></a><!-- doxytag: member="MGBPointSeq::insert_at" ref="a28413f9cea3fa3976a3ca86a7e6785e3" args="(size_t i, const double *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::insert_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert array data[j] to this(i,j) 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>id of this which indicates the placement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Input data array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb5a62862ab9b962b81d42e9559959b9"></a><!-- doxytag: member="MGBPointSeq::non_homogeneous" ref="abb5a62862ab9b962b81d42e9559959b9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::non_homogeneous </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute non_homogeneous coordonate data without w coordinate element, assumed that this is homogeneous coordinate data, i.e., maximum space dimension element is w(weight) coordinate. </p>

</div>
</div>
<a class="anchor" id="a1846868f6c4ccbc82ba7ea4dd9015c37"></a><!-- doxytag: member="MGBPointSeq::operator!=" ref="a1846868f6c4ccbc82ba7ea4dd9015c37" args="(const MGBPointSeq &amp;brep) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGBPointSeq::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two BPointSeq if they are equal. </p>
<p>/Return true if not equal. </p>

</div>
</div>
<a class="anchor" id="af939fcad302a0bfe7862a9fce8b77d7c"></a><!-- doxytag: member="MGBPointSeq::operator*" ref="af939fcad302a0bfe7862a9fce8b77d7c" args="(const MGMatrix &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲線の変換を行いオブジェクトを生成する。 Generates an object by multiplying matrix to the original. </p>

</div>
</div>
<a class="anchor" id="a37f561fe10f75a6fb197d0857963ee70"></a><!-- doxytag: member="MGBPointSeq::operator*" ref="a37f561fe10f75a6fb197d0857963ee70" args="(const MGTransf &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲線のトランスフォームを行いオブジェクトを生成する。 Generates an object by multiplying transformation to the original. </p>

</div>
</div>
<a class="anchor" id="afd0e7c3df2ab84cc3ef56744f63b49f2"></a><!-- doxytag: member="MGBPointSeq::operator*" ref="afd0e7c3df2ab84cc3ef56744f63b49f2" args="(double scale) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケールで曲線の変換を行いオブジェクトを生成する。 Generates an object by multiplying scale to the original. </p>

</div>
</div>
<a class="anchor" id="aeffcf1ff59f4ce6b414e0423ad60b4f2"></a><!-- doxytag: member="MGBPointSeq::operator*=" ref="aeffcf1ff59f4ce6b414e0423ad60b4f2" args="(const MGMatrix &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲線の変換を行い自身の曲線とする。 Updates the object by multiplying matrix. </p>

</div>
</div>
<a class="anchor" id="a91264040f4277044279cf8a46f88755e"></a><!-- doxytag: member="MGBPointSeq::operator*=" ref="a91264040f4277044279cf8a46f88755e" args="(const MGTransf &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲線のトランスフォームを行い自身とする。 Updates the object by multiplying transformation. </p>

</div>
</div>
<a class="anchor" id="aada4d19840a7267e2f6a84d4bae03789"></a><!-- doxytag: member="MGBPointSeq::operator*=" ref="aada4d19840a7267e2f6a84d4bae03789" args="(double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケールで曲線の変換を行い自身の曲線とする。 Updates the object by multiplying scale. </p>

</div>
</div>
<a class="anchor" id="a732bb171afc0b769f71710d39991ce67"></a><!-- doxytag: member="MGBPointSeq::operator+" ref="a732bb171afc0b769f71710d39991ce67" args="(const MGVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲線の平行移動を行いオブジェクトを生成する。 Generates an object by translation. </p>

</div>
</div>
<a class="anchor" id="a40f34b593305365024f8d80e39d7f9c9"></a><!-- doxytag: member="MGBPointSeq::operator+=" ref="a40f34b593305365024f8d80e39d7f9c9" args="(const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与ベクトルだけ曲線を平行移動して自身とする。 Updates an object by translation. </p>

</div>
</div>
<a class="anchor" id="ac137d542ccc9807d6eaa643f0904339d"></a><!-- doxytag: member="MGBPointSeq::operator&#45;" ref="ac137d542ccc9807d6eaa643f0904339d" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲線の逆方向に平行移動を行いオブジェクトを生成する。 Generates an object by translation. </p>

</div>
</div>
<a class="anchor" id="ad57b2085a7b11b1e67f96b7c375fb8bb"></a><!-- doxytag: member="MGBPointSeq::operator&#45;=" ref="ad57b2085a7b11b1e67f96b7c375fb8bb" args="(const MGVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与ベクトルだけ曲線をマイナス方向に平行移動して自身とする。 Updates the object by translation. </p>

</div>
</div>
<a class="anchor" id="aba4a3e2c66ba765223fb38cfb75bcbeb"></a><!-- doxytag: member="MGBPointSeq::operator/" ref="aba4a3e2c66ba765223fb38cfb75bcbeb" args="(double scale) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> MGBPointSeq::operator/ </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケールで曲線の変換を行いオブジェクトを生成する。 Generates an object by multiplying scale to the original. </p>

</div>
</div>
<a class="anchor" id="a560d6015114c2619da983941a546235c"></a><!-- doxytag: member="MGBPointSeq::operator/=" ref="a560d6015114c2619da983941a546235c" args="(double scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a>&amp; MGBPointSeq::operator/= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケールで曲線の変換を行い自身の曲線とする。 Updates the object by multiplying scale. </p>

</div>
</div>
<a class="anchor" id="a9a60424c8f58eaf47a2951c0149b6c69"></a><!-- doxytag: member="MGBPointSeq::operator==" ref="a9a60424c8f58eaf47a2951c0149b6c69" args="(const MGBPointSeq &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGBPointSeq::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two BPointSeq if they are equal. </p>
<p>Return true if equal. </p>

</div>
</div>
<a class="anchor" id="a64278ec0c53d5925116501303819de91"></a><!-- doxytag: member="MGBPointSeq::planar" ref="a64278ec0c53d5925116501303819de91" args="(MGPlane &amp;plane, MGStraight &amp;line, MGPosition &amp;center) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGBPointSeq::planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if coefficients are planar. </p>
<p>Funtion's return value is; 0: Not planar, nor a point, nor straight line. 1: coefficients are within a point. 2: coefficients are a straight line. 3: coefficients are planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>When coefficients are not straight line nor a point, plane is returned, Even when not planar, plane nearest is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>When coefficients are a line, the line is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center</em>&nbsp;</td><td>Center of the coefficients is always returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeab6b41eb5ab55040eb93d9bb22d581a"></a><!-- doxytag: member="MGBPointSeq::point" ref="aeab6b41eb5ab55040eb93d9bb22d581a" args="(size_t i, size_t j, size_t sd, MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::point </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve sub data of i-th point of the BPointSeq. </p>
<p>That is, P(k)=(*this)(i,j+k) for k=0, ..., sd-1. </p>

</div>
</div>
<a class="anchor" id="ab6b9e7dfac101794d8ba06838226ba85"></a><!-- doxytag: member="MGBPointSeq::reshape" ref="ab6b9e7dfac101794d8ba06838226ba85" args="(size_t capacity, size_t start=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::reshape </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change capacity. </p>
<p>Change of sdim not allowed. reshape guarantees the original data BPoint(i,.) before invoking reshape will be stored in the new BPoint(start+i,.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>New capacity </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>To which place to store the original data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa308a6fc1c154dfeefbce5eff70c7ed4"></a><!-- doxytag: member="MGBPointSeq::resize" ref="aa308a6fc1c154dfeefbce5eff70c7ed4" args="(size_t sz, size_t dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize the array. </p>
<p>The result will contain garbages. m_capacity, m_sdim, and m_length will be set as m_capacity=sz, m_sdim=dim, m_length=sz. </p>

</div>
</div>
<a class="anchor" id="a04fd2903d48feda7463ec157d98ed2d6"></a><!-- doxytag: member="MGBPointSeq::store_at" ref="a04fd2903d48feda7463ec157d98ed2d6" args="(size_t i, const MGVector &amp;vctr, size_t to, size_t from, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store vector data vector(from+j) to this(i,to+j) for 0&lt;=j&lt;len. </p>
<p>When (form+j) or (to+j) reached to maximum space dimension id, next id becomes 0(form the start). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>id of this which indicates the placement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vctr</em>&nbsp;</td><td>Input vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>Indicates to where of this in the space dimension id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>Indicates from where of vector in the space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the data to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a312dd0a046687778dbe867a4db09aed5"></a><!-- doxytag: member="MGBPointSeq::store_at" ref="a312dd0a046687778dbe867a4db09aed5" args="(size_t i, const double *data, size_t to=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>to</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store data[j] to this(i,to+j) for 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>. </p>
<p>When (to+j) reached to maximum space dimension id, next id becomes 0(form the start). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>id of this which indicates the placement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Input data array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>Indicates to where of this in the space dimension id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdfbd883418853ce86e3a5fa96139b3a"></a><!-- doxytag: member="MGBPointSeq::store_at" ref="afdfbd883418853ce86e3a5fa96139b3a" args="(size_t i, const MGVector &amp;vctr, size_t to=0, size_t from=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGBPointSeq::store_at </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>to</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>from</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store vector data vector(from+j) to this(i,to+j) for 0&lt;=j&lt;<a class="el" href="class_m_g_b_point_seq.html#ac820de22609c82741b3f55c98fdd22d2" title="Returns the space dimension.">sdim()</a>. </p>
<p>When (form+j) or (to+j) reached to maximum space dimension id, next id becomes 0(form the start). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>id of this which indicates the placement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vctr</em>&nbsp;</td><td>Input vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>Indicates to where of this in the space dimension id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>Indicates from where of vector in the space dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5291ccc9db6e23085532cee5c4df3326"></a><!-- doxytag: member="MGBPointSeq::operator*" ref="a5291ccc9db6e23085532cee5c4df3326" args="(double scale, const MGBPointSeq &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>BPointをスケーリングしてできるオブジェクトを生成する。 Generates a object by scaling. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>BPointSeq.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:18 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

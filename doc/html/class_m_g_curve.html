<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGCurve Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGCurve Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGCurve" --><!-- doxytag: inherits="MGGeometry" -->
<p><a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a> is an abstract class which represents a whole curve.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Curve.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGCurve:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_curve__inherit__graph.png" border="0" usemap="#_m_g_curve_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_curve_inherit__map" id="_m_g_curve_inherit__map">
<area shape="rect" id="node11" href="class_m_g_b_sum_curve.html" title="Define MGBSumCurve Class(Boolean sum curve of three curves)." alt="" coords="692,5,801,35"/><area shape="rect" id="node13" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves." alt="" coords="679,59,815,88"/><area shape="rect" id="node15" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D." alt="" coords="705,112,788,141"/><area shape="rect" id="node17" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B&#45;SPline representation." alt="" coords="705,165,788,195"/><area shape="rect" id="node19" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B&#45;Representation." alt="" coords="701,219,792,248"/><area shape="rect" id="node21" href="class_m_g_straight.html" title="MGStraight is a curve of any space dimension, represent a straight line." alt="" coords="703,272,791,301"/><area shape="rect" id="node23" href="class_m_g_surf_curve.html" title="MGSurfCurve is a curve defined by a surface and its parameter space line represented..." alt="" coords="697,325,796,355"/><area shape="rect" id="node25" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range." alt="" coords="684,379,809,408"/><area shape="rect" id="node2" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="407,192,505,221"/><area shape="rect" id="node4" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="276,192,356,221"/><area shape="rect" id="node6" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="119,192,225,221"/><area shape="rect" id="node8" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="7,192,68,221"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGCurve:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_curve__coll__graph.png" border="0" usemap="#_m_g_curve_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_curve_coll__map" id="_m_g_curve_coll__map">
<area shape="rect" id="node2" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="212,501,311,531"/><area shape="rect" id="node4" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node6" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node12" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node8" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node10" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node15" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node18" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node20" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node22" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_curve-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c46d34915283e69d629f95ad1ddc2a7"></a><!-- doxytag: member="MGCurve::MGCurve" ref="a4c46d34915283e69d629f95ad1ddc2a7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a4c46d34915283e69d629f95ad1ddc2a7">MGCurve</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor(初期化なしでオブジェクトを作成する。). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2bfd584fa74c22c180e618757fdf094"></a><!-- doxytag: member="MGCurve::MGCurve" ref="ae2bfd584fa74c22c180e618757fdf094" args="(const MGCurve &amp;curve)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae2bfd584fa74c22c180e618757fdf094">MGCurve</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28b8070ed072d8acc5b3901acc77755c"></a><!-- doxytag: member="MGCurve::‾MGCurve" ref="a28b8070ed072d8acc5b3901acc77755c" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGCurve</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a8f7d7b83316e78bbd4f4cdc668eff615">operator=</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a8f7d7b83316e78bbd4f4cdc668eff615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3353899d0dac41109cc58f7da5937dfd"></a><!-- doxytag: member="MGCurve::operator+=" ref="a3353899d0dac41109cc58f7da5937dfd" args="(const MGVector &amp;v)=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a3353899d0dac41109cc58f7da5937dfd">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace7efae43bc2be739e0ab26bf442b43c"></a><!-- doxytag: member="MGCurve::operator&#45;=" ref="ace7efae43bc2be739e0ab26bf442b43c" args="(const MGVector &amp;v)=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10d6cf24b11459bb2d762e6551fc8f54"></a><!-- doxytag: member="MGCurve::operator*=" ref="a10d6cf24b11459bb2d762e6551fc8f54" args="(double scale)=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0abf59dba1a6b9eaffe326c44769212"></a><!-- doxytag: member="MGCurve::operator*=" ref="ae0abf59dba1a6b9eaffe326c44769212" args="(const MGMatrix &amp;mat)=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c17b3b2f5c1e39cccc5096544389dcb"></a><!-- doxytag: member="MGCurve::operator*=" ref="a4c17b3b2f5c1e39cccc5096544389dcb" args="(const MGTransf &amp;tr)=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87bfcfb3d9e26d7cd85da576148d8bde"></a><!-- doxytag: member="MGCurve::operator==" ref="a87bfcfb3d9e26d7cd85da576148d8bde" args="(const MGCompositeCurve &amp;crv) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a87bfcfb3d9e26d7cd85da576148d8bde">operator==</a> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;crv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662bc7a3566a5c1879fe46b54e1cae5e"></a><!-- doxytag: member="MGCurve::operator==" ref="a662bc7a3566a5c1879fe46b54e1cae5e" args="(const MGTrimmedCurve &amp;crv) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a> &amp;crv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74c8705ca62fb341daeaf3cba5c1b622"></a><!-- doxytag: member="MGCurve::operator==" ref="a74c8705ca62fb341daeaf3cba5c1b622" args="(const MGGel &amp;gel2) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a74c8705ca62fb341daeaf3cba5c1b622">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30f1872c52a8cf0a69375f2ef7a6670d"></a><!-- doxytag: member="MGCurve::operator&lt;" ref="a30f1872c52a8cf0a69375f2ef7a6670d" args="(const MGGel &amp;gel2) const =0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#adbe8bebba61623e88d0472e9e111ca23">arrow</a> (double t, <a class="el" href="class_m_g_position.html">MGPosition</a> data[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate arrow data of the tangent at the parameter value t of the curve.  <a href="#adbe8bebba61623e88d0472e9e111ca23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad553529eb25955542f06bcea46ad3b0f"></a><!-- doxytag: member="MGCurve::bdim" ref="ad553529eb25955542f06bcea46ad3b0f" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ad553529eb25955542f06bcea46ad3b0f">bdim</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a680d824802125a83533362f05ee84b71">box_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum box that includes the curve of parameter interval.  <a href="#a680d824802125a83533362f05ee84b71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aaf99eb4f391e2ebc5b31187f8dc4ff50">calc_div_num</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;interval) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate dividing Knots number for the initial approximation of the curve, used for precise approximation.  <a href="#aaf99eb4f391e2ebc5b31187f8dc4ff50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27fc6ab256cdcb0539ced2149811747"></a><!-- doxytag: member="MGCurve::center" ref="ae27fc6ab256cdcb0539ced2149811747" args="() const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae27fc6ab256cdcb0539ced2149811747">center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain ceter coordinate of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4a4a702b550c59c27ec45c54bdf8bcc"></a><!-- doxytag: member="MGCurve::center_param" ref="aa4a4a702b550c59c27ec45c54bdf8bcc" args="() const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aa4a4a702b550c59c27ec45c54bdf8bcc">center_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain ceter parameter value of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac83a24a002d65e6339859e51321fff57">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#ac83a24a002d65e6339859e51321fff57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a260ff34df53249e6887a09553f84058b">change_range</a> (double t1, double t2)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a260ff34df53249e6887a09553f84058b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae85e37def31262577515e70078fb92e9">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new geometry object by copying to newed area.  <a href="#ae85e37def31262577515e70078fb92e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeb5972287a927ab147c4bce0fc00d7b"></a><!-- doxytag: member="MGCurve::closest" ref="aeeb5972287a927ab147c4bce0fc00d7b" args="(const MGPosition &amp;point) const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aeeb5972287a927ab147c4bce0fc00d7b">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value of this curve from a point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac3f5d34bbb38d40e17437f23b299af25">closest2D</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point, double &amp;dist) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the point on the curve which is the intersection with x=point[0], or y=point[1] and the nearest point from point.  <a href="#ac3f5d34bbb38d40e17437f23b299af25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a6975d9151f7b8538c504b4216ac0a937">closest</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value pair of this curve and curve2.  <a href="#a6975d9151f7b8538c504b4216ac0a937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af93a0dae2fe9b1f6586856ebb03285c9"></a><!-- doxytag: member="MGCurve::cn_continuity" ref="af93a0dae2fe9b1f6586856ebb03285c9" args="(size_t n) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#af93a0dae2fe9b1f6586856ebb03285c9">cn_continuity</a> (size_t n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線がCn連続かどうか調べる LBRep以外はかならずtrueが返却される <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db6fa0b833aeeef34baf9ba8c51d984"></a><!-- doxytag: member="MGCurve::common" ref="a6db6fa0b833aeeef34baf9ba8c51d984" args="(const MGCurve &amp;curve2, std::vector&lt; double &gt; &amp;vecComSpan, MGCCisect_list &amp;isect) const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a6db6fa0b833aeeef34baf9ba8c51d984">common</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, std::vector&lt; double &gt; &amp;vecComSpan, <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> &amp;isect) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">関数名：common 目的：与えられた曲線と自身の共通部分があるかどうか調べる。 引数： const <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>&amp; curve2, (I/ ) 与えられる曲線 std::vector&lt;double&gt;&amp; vecComSpan ( /O) 共通部分のパラメータ範囲 4nの配列で、vecComSpan(4*i+0),vecComSpan(4*i+1)が自身のパラメータ範囲 (vecComSpan(4*i+0) &lt; vecComSpan(4*i+1))、 vecComSpan(4*i+2),vecComSpan(4*i+3)がcurve2のパラメータ範囲 <a class="el" href="class_m_g_c_cisect__list.html" title="MGCCisect_list defines linked list of MGCCisect.">MGCCisect_list</a>&amp; isect ( /O) 交点 戻り値： 3:交点も共通部分も求まった 2:交点のみが求まった 1:共通部分のみが求まった 0:交点も共通部分もなかった -1:共通エッジの収束計算エラー -2:共通エッジが４個以上求まった(のっていないと見なす) 追記： 曲線が共通かどうかの誤差にはline_zero()、をパラメータ範囲の収束計算の 誤差には、パラメータ範囲*rc_zero()を使用した <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a409e9ce8ca5c994f10edd1f2875bdcdf"></a><!-- doxytag: member="MGCurve::common" ref="a409e9ce8ca5c994f10edd1f2875bdcdf" args="(const MGCurve &amp;curve2, std::vector&lt; double &gt; &amp;vecComSpan) const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a409e9ce8ca5c994f10edd1f2875bdcdf">common</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, std::vector&lt; double &gt; &amp;vecComSpan) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">関数名：common 目的：与えられた曲線と自身の共通部分があるかどうか調べる。 引数： const <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>&amp; curve2, (I/ ) 与えられる曲線 std::vector&lt;double&gt;&amp; vecComSpan ( /O) 共通部分のパラメータ範囲 4nの配列で、vecComSpan(4*i+0),vecComSpan(4*i+1)が自身のパラメータ範囲 (vecComSpan(4*i+0) &lt; vecComSpan(4*i+1))、 vecComSpan(4*i+2),vecComSpan(4*i+3)がcurve2のパラメータ範囲 戻り値： 共通部分の数: 共通部分が求まった 0: 共通部分がなかった -1: 共通エッジの収束計算エラー -2: 共通エッジが４個以上求まった(のっていないと見なす) 追記： 曲線が共通かどうかの誤差にはline_zero()を、パラメータ範囲の収束計算の誤差には、 パラメータ範囲*rc_zero()を使用した <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae8c6cb11b641e5b6f596867672bfda66">coordinate_exchange</a> (size_t i, size_t j)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange ordering of the coordinates.  <a href="#ae8c6cb11b641e5b6f596867672bfda66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a9ef3806ddfd62edf9b7b9c59626caf5a">copy_as_nurbs</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy as a newed curve.  <a href="#a9ef3806ddfd62edf9b7b9c59626caf5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a84add0aaacbc189dd584dbf9f5670d99">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#a84add0aaacbc189dd584dbf9f5670d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a45bda2b85297af3d92a32f23e011682f">copy_limitted</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;prange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new curve object by copying to newed area, and limitting the parameter range to prange.  <a href="#a45bda2b85297af3d92a32f23e011682f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a60066999080cf603c811c6d448eed364">curvature</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curvature at the given point.  <a href="#a60066999080cf603c811c6d448eed364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905865edce3bea32ec3c176e300b4248"></a><!-- doxytag: member="MGCurve::curve" ref="a905865edce3bea32ec3c176e300b4248" args="()" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a905865edce3bea32ec3c176e300b4248">curve</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve pointer if this <a class="el" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element.">MGGel</a> is an <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>, else return null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2f7c750c4114fc6d53cb0d9c99843f"></a><!-- doxytag: member="MGCurve::curve" ref="adb2f7c750c4114fc6d53cb0d9c99843f" args="() const " -->
const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>curve</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a27b4724616d26b4b6aa076b010645a26">curvilinear_integral</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">線積分を求める。 Compute curvilinear integral of the 1st two coordinates.  <a href="#a27b4724616d26b4b6aa076b010645a26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad24a8195433819962666f99085ec67a4"></a><!-- doxytag: member="MGCurve::curvilinear_integral" ref="ad24a8195433819962666f99085ec67a4" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><b>curvilinear_integral</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62f723353549e5bba07de79c57a9cd14"></a><!-- doxytag: member="MGCurve::deriv_length" ref="a62f723353549e5bba07de79c57a9cd14" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a62f723353549e5bba07de79c57a9cd14">deriv_length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute mean length of 1st derivative vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ba1b7dbf118653720c6fa9386addcab"></a><!-- doxytag: member="MGCurve::direction" ref="a5ba1b7dbf118653720c6fa9386addcab" args="(const MGPosition &amp;param) const " -->
<a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a5ba1b7dbf118653720c6fa9386addcab">direction</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;param) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute direction unit vector of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a9172d83749d84dcc0245a96a296a6abb">direction</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return tangent vector at the given point.  <a href="#a9172d83749d84dcc0245a96a296a6abb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66c3157e0d6c212fb2efc90bfc504e39"></a><!-- doxytag: member="MGCurve::display_arrows" ref="a66c3157e0d6c212fb2efc90bfc504e39" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_arrows</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57133819ad454f6fcd2cb0cfd88d9846"></a><!-- doxytag: member="MGCurve::display_break_points" ref="a57133819ad454f6fcd2cb0cfd88d9846" args="() const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_break_points</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a736b00ca1d84ec5285aac7d081f6cd05">display_curvatures</a> (double scale, int density, bool use_radius) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a1ee0ed7b28c40b502d4eeec470368b4d">divide_multi</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;crv_list, int multiplicity=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide this curve at the designated knot multiplicity point.  <a href="#a1ee0ed7b28c40b502d4eeec470368b4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1f5dca721e647fe5e8b5e306ea9c634"></a><!-- doxytag: member="MGCurve::divide_number" ref="ae1f5dca721e647fe5e8b5e306ea9c634" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae1f5dca721e647fe5e8b5e306ea9c634">divide_number</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the a divide number for offset, intersection, or others. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a20497e172065788e673b771f018d90af">drawSE</a> (double span_length, double t0, double t1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a8973e25dfd474aad477a20505377b5c5">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw the object in wire mode, in the world coordinates.  <a href="#a8973e25dfd474aad477a20505377b5c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa8ffd1482bbf2f2290e156bc3c84bdb"></a><!-- doxytag: member="MGCurve::end_point" ref="aaa8ffd1482bbf2f2290e156bc3c84bdb" args="() const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aaa8ffd1482bbf2f2290e156bc3c84bdb">end_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return end point(終点を返却する). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#acbcbb8f812be257921ef63c71afdedcf">eval</a> (double, size_t nderiv=0, int left=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate n'th derivative data. n=0 means positional data evaluation.  <a href="#acbcbb8f812be257921ef63c71afdedcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a9ea3970501a3d9c681a38ff584018b41">eval_all</a> (double, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute position, 1st and 2nd derivatives.  <a href="#a9ea3970501a3d9c681a38ff584018b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#af1870e1105d7e44e856b362953479c38">eval_deriv</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute 1st derivative.  <a href="#af1870e1105d7e44e856b362953479c38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae6fced145414e82cf35d282f2aa64942">eval_discrete_deviation</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, std::vector&lt; <a class="el" href="class_m_g_position.html">MGPosition</a> &gt; &amp;sts, int npoint=20, double tolerance=0.1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate deviations of two curves(this and curve2) at npoint discrete points.  <a href="#ae6fced145414e82cf35d282f2aa64942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae23f4567458a4f215eaa4f692373cf5b">eval_line</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, <a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate line data at data point tau.  <a href="#ae23f4567458a4f215eaa4f692373cf5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a005668fa2dca670c5ff755c9bb06945d">eval_position</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute positional data.  <a href="#a005668fa2dca670c5ff755c9bb06945d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a4778716ba9e27346ef9edf2588d4cecf">evaluate</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;t, const size_t *nderiv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate n'th derivative data. n=0 means positional data evaluation.  <a href="#a4778716ba9e27346ef9edf2588d4cecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#af0e8206d530257d27910d0676ba0be01">extend</a> (double length, bool start=false)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrapolate this curve by an (approximate) chord length.  <a href="#af0e8206d530257d27910d0676ba0be01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aae683fe14cbb04567ad1ceabf7248c10">Frenet_frame2</a> (double t, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;V2, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;T, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;N, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;B) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Frenet_frame, curvature and torsion in 3D space.  <a href="#aae683fe14cbb04567ad1ceabf7248c10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aaf81e6285746563a80f4b6ecbe3eda17">Frenet_frame</a> (double t, <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;T, <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N, <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;B, double &amp;curvature, double &amp;torsion) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute Frenet_frame, curvature and torsion in 3D space.  <a href="#aaf81e6285746563a80f4b6ecbe3eda17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7bb80ff3ce43fa39ab6845885089770f">get_control_points</a> (<a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;cpoints) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts control points.  <a href="#a7bb80ff3ce43fa39ab6845885089770f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a86bd988df49b91d4576c1f5edeb0e181">has_same_direction_at</a> (double s, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this curve has the same direction with curve2 at the point s(of this) and t(of curve2).  <a href="#a86bd988df49b91d4576c1f5edeb0e181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae643f796eeecfd6515c13612edf23974"></a><!-- doxytag: member="MGCurve::identify_type" ref="ae643f796eeecfd6515c13612edf23974" args="() const =0" -->
virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae643f796eeecfd6515c13612edf23974">identify_type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31c1865989f3fa42596bd220623e228a"></a><!-- doxytag: member="MGCurve::in_range" ref="a31c1865989f3fa42596bd220623e228a" args="(double t) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a31c1865989f3fa42596bd220623e228a">in_range</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input parameter value is inside parameter range of the line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6c92e7d6a7111931406782ab0ec996"></a><!-- doxytag: member="MGCurve::in_range" ref="a4d6c92e7d6a7111931406782ab0ec996" args="(const MGPosition &amp;t) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a4d6c92e7d6a7111931406782ab0ec996">in_range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input parameter value is inside parameter range of the line. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7a84c8ee26b70733b258989c7e1aa3c1">intersect_brute_force</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Curve to curve intersection.  <a href="#a7a84c8ee26b70733b258989c7e1aa3c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#afe372918854a25e07bdfb526cbb3f8ad">intersect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Curve to curve intersection.  <a href="#afe372918854a25e07bdfb526cbb3f8ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a8b4c78d5172218a652ede1cb2ede258f">intersection</a> (const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;obj2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersections of two objects.  <a href="#a8b4c78d5172218a652ede1cb2ede258f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71b3cab1858509ee0245cdba79c1a6e8"></a><!-- doxytag: member="MGCurve::intersection" ref="a71b3cab1858509ee0245cdba79c1a6e8" args="(const MGCurve &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af652b983f98947dd182ffc45b3e5e2ba"></a><!-- doxytag: member="MGCurve::intersection" ref="af652b983f98947dd182ffc45b3e5e2ba" args="(const MGFSurface &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d3ccac3c2e875c1c16e68755fea4b99"></a><!-- doxytag: member="MGCurve::intersection" ref="a1d3ccac3c2e875c1c16e68755fea4b99" args="(const MGSurface &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0791c4246814f2d9914891a4a336af75"></a><!-- doxytag: member="MGCurve::intersection" ref="a0791c4246814f2d9914891a4a336af75" args="(const MGFace &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb7e69d5097409a52585e9ac6c2992cf"></a><!-- doxytag: member="MGCurve::intersection" ref="adb7e69d5097409a52585e9ac6c2992cf" args="(const MGShell &amp;obj2) const " -->
<a class="el" href="class_m_gisects.html">MGisects</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;obj2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b9f7dcb7cd8058134c137bd1fcb6f30"></a><!-- doxytag: member="MGCurve::intersect_dnum" ref="a9b9f7dcb7cd8058134c137bd1fcb6f30" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a9b9f7dcb7cd8058134c137bd1fcb6f30">intersect_dnum</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide divide number of curve span for function intersect. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b849dbdf79561c5a7c7e67902e608a"></a><!-- doxytag: member="MGCurve::intersect_with_plane" ref="a88b849dbdf79561c5a7c7e67902e608a" args="(const MGPlane &amp;surf) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a88b849dbdf79561c5a7c7e67902e608a">intersect_with_plane</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;surf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">intersections with a plane. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a379e4f21b3055c90d7f83897341cd7d8"></a><!-- doxytag: member="MGCurve::isect" ref="a379e4f21b3055c90d7f83897341cd7d8" args="(const MGCurve &amp;curve2) const =0" -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a379e4f21b3055c90d7f83897341cd7d8">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Curve and other geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4278fd8011555614f7b28d6f1fabed81"></a><!-- doxytag: member="MGCurve::isect" ref="a4278fd8011555614f7b28d6f1fabed81" args="(const MGStraight &amp;curve2) const =0" -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;curve2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaacffa124e71b096a550c3321f8e3902"></a><!-- doxytag: member="MGCurve::isect" ref="aaacffa124e71b096a550c3321f8e3902" args="(const MGRLBRep &amp;curve2) const " -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d45e4a2ddf41840907bdd327e9214fe"></a><!-- doxytag: member="MGCurve::isect" ref="a0d45e4a2ddf41840907bdd327e9214fe" args="(const MGEllipse &amp;curve2) const " -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7af91ed5547643f9647fdab72cd51a13"></a><!-- doxytag: member="MGCurve::isect" ref="a7af91ed5547643f9647fdab72cd51a13" args="(const MGLBRep &amp;curve2) const " -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643cd7b1d0b9eaed4e246b556cfbc2d6"></a><!-- doxytag: member="MGCurve::isect" ref="a643cd7b1d0b9eaed4e246b556cfbc2d6" args="(const MGSurfCurve &amp;curve2) const =0" -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56e2560dce73cb153cddeab76b888982"></a><!-- doxytag: member="MGCurve::isect" ref="a56e2560dce73cb153cddeab76b888982" args="(const MGBSumCurve &amp;curve2) const " -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed07600e247eb9ca4715a67a7745233f"></a><!-- doxytag: member="MGCurve::isect" ref="aed07600e247eb9ca4715a67a7745233f" args="(const MGTrimmedCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e6b63f9ecef22f8696f021f9ae7cf34"></a><!-- doxytag: member="MGCurve::isect" ref="a5e6b63f9ecef22f8696f021f9ae7cf34" args="(const MGCompositeCurve &amp;curve2) const " -->
<a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;curve2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47dc3cd201d6691e85aa8b6a515b7285"></a><!-- doxytag: member="MGCurve::isect" ref="a47dc3cd201d6691e85aa8b6a515b7285" args="(const MGSurface &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84d746624b65d25feeabd3433134fc8"></a><!-- doxytag: member="MGCurve::isect" ref="aa84d746624b65d25feeabd3433134fc8" args="(const MGPlane &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a09494bc6909c522bb402173758c9cc"></a><!-- doxytag: member="MGCurve::isect" ref="a9a09494bc6909c522bb402173758c9cc" args="(const MGSphere &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cae8da0c19930014add4ee155fb4910"></a><!-- doxytag: member="MGCurve::isect" ref="a9cae8da0c19930014add4ee155fb4910" args="(const MGCylinder &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa590e08ff5df12ad678108959fc65c7b"></a><!-- doxytag: member="MGCurve::isect" ref="aa590e08ff5df12ad678108959fc65c7b" args="(const MGSBRep &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac319966911640ce1f83590fbeee2623"></a><!-- doxytag: member="MGCurve::isect" ref="aac319966911640ce1f83590fbeee2623" args="(const MGRSBRep &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6565166879fd3ace446f47ec03fc514f"></a><!-- doxytag: member="MGCurve::isect" ref="a6565166879fd3ace446f47ec03fc514f" args="(const MGBSumSurf &amp;surf) const =0" -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;surf) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e002b99bd2ef99641b4a645876da2e9"></a><!-- doxytag: member="MGCurve::isect" ref="a3e002b99bd2ef99641b4a645876da2e9" args="(const MGFSurface &amp;fs) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &amp;fs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c6afbe1c791ef54810339a45fe69614"></a><!-- doxytag: member="MGCurve::isect" ref="a0c6afbe1c791ef54810339a45fe69614" args="(const MGFace &amp;) const " -->
virtual <a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac728a9d4a4bedbfb0a438cc40f356bdb"></a><!-- doxytag: member="MGCurve::isect" ref="ac728a9d4a4bedbfb0a438cc40f356bdb" args="(const MGShell &amp;shl) const " -->
<a class="el" href="class_m_g_c_fisect__vector.html">MGCFisect_vector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac728a9d4a4bedbfb0a438cc40f356bdb">isect</a> (const <a class="el" href="class_m_g_shell.html">MGShell</a> &amp;shl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of a shell and a curve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a8ca638854f8938e9c2c7f88afd71a682">isect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection point of 1D sub curve of original curve.  <a href="#a8ca638854f8938e9c2c7f88afd71a682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd121f04945ec87e06e9bcd316399ea4"></a><!-- doxytag: member="MGCurve::is_closed" ref="afd121f04945ec87e06e9bcd316399ea4" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#afd121f04945ec87e06e9bcd316399ea4">is_closed</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲線が閉曲線かどうかを返す Test if this is a closed curve; <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a84a92b42fe2946b772eb30081d2c5ad6">is_coplanar</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is co-planar with the 2nd curve curve2.  <a href="#a84a92b42fe2946b772eb30081d2c5ad6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad543c7f7bfa235db73cce3c148a26fc8"></a><!-- doxytag: member="MGCurve::is_startpoint_parameter" ref="ad543c7f7bfa235db73cce3c148a26fc8" args="(double t) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ad543c7f7bfa235db73cce3c148a26fc8">is_startpoint_parameter</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the input parameter t is the start point parameter or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab71e88b75055898307332e00dd939e79"></a><!-- doxytag: member="MGCurve::is_endpoint_parameter" ref="ab71e88b75055898307332e00dd939e79" args="(double t) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab71e88b75055898307332e00dd939e79">is_endpoint_parameter</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the input parameter t is the start point parameter or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a943dd7a986851b30f5e0473cf0cead5c">is_perpendicular</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the vector from P to this-&gt;eval(t) is perpendicular to the tangent of this curve at t.  <a href="#a943dd7a986851b30f5e0473cf0cead5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac8483acd59478145655b63787b46557a">is_linear</a> (<a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;straight) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is linear or not, that is, is straight or not.  <a href="#ac8483acd59478145655b63787b46557a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a3e6f96416ab574420cbed88ebfc414e9">is_planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this cure is planar or not.  <a href="#a3e6f96416ab574420cbed88ebfc414e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a625339525839a70c8224d621e2fbfa6e"></a><!-- doxytag: member="MGCurve::knot" ref="a625339525839a70c8224d621e2fbfa6e" args="(size_t i) const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a625339525839a70c8224d621e2fbfa6e">knot</a> (size_t i) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b0a611b67e7de7e6763de85a869eacc"></a><!-- doxytag: member="MGCurve::knot_vector" ref="a6b0a611b67e7de7e6763de85a869eacc" args="() const =0" -->
virtual const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a6b0a611b67e7de7e6763de85a869eacc">knot_vector</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector of the curve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac678277be215f7edddbe189c83ba48e3"></a><!-- doxytag: member="MGCurve::knot_vector" ref="ac678277be215f7edddbe189c83ba48e3" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac678277be215f7edddbe189c83ba48e3">knot_vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the knot vector of the curve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7d7c4dd68f29d059515a267023f50ddf">length</a> (double t1, double t2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cmpute curve length of the interval.  <a href="#a7d7c4dd68f29d059515a267023f50ddf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a1873bf48b6b84ba4e5c0b41fc5d10b18">length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute whole curve length.  <a href="#a1873bf48b6b84ba4e5c0b41fc5d10b18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac9db090d93e6b0a1e7f9c6b6d29e7c48">length_param</a> (double t, double len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse function of length.  <a href="#ac9db090d93e6b0a1e7f9c6b6d29e7c48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a4f5e376f184379038ebac06536962e32">limit</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;rng)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update this by limiting the parameter range of the curve.  <a href="#a4f5e376f184379038ebac06536962e32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17bf60236d91b8fa1cbd063088b2dfa8"></a><!-- doxytag: member="MGCurve::limit" ref="a17bf60236d91b8fa1cbd063088b2dfa8" args="(double t0, double t1)" -->
<a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>limit</b> (double t0, double t1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a9146803df0236ad78fff3bd0a4365"></a><!-- doxytag: member="MGCurve::manifold_dimension" ref="a38a9146803df0236ad78fff3bd0a4365" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a38a9146803df0236ad78fff3bd0a4365">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return manifold dimension, i.e. 0:point, 1:curve, 2:surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6b1d0deec00888135456a16962137bc"></a><!-- doxytag: member="MGCurve::negate" ref="aa6b1d0deec00888135456a16962137bc" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aa6b1d0deec00888135456a16962137bc">negate</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the curve direction(曲線の方向を反転する). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84da0ebaf5781b08a0cbb7edaa6b47c"></a><!-- doxytag: member="MGCurve::negate_param" ref="aa84da0ebaf5781b08a0cbb7edaa6b47c" args="(double t) const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aa84da0ebaf5781b08a0cbb7edaa6b47c">negate_param</a> (double t) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this curve is negated by "negate()". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ad9b41f61ca4c5f8ac61c21b1ae3d34dd">negate_transform</a> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;boundary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">virtual <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> negate_param(const MGPosition&amp; t)const;  <a href="#ad9b41f61ca4c5f8ac61c21b1ae3d34dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a04c8f0af36fd4efea083189ab3aaa7a7">offset</a> (double ofs_value, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 Offset of costant deviation from a curve.  <a href="#a04c8f0af36fd4efea083189ab3aaa7a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a904ef6006545f9056dedc9ea5578365a">offset</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;ofs_value_lb, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 Offset of variable deviation from a curve.  <a href="#a904ef6006545f9056dedc9ea5578365a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a857248909351f001fa13238bfb3452aa">offset_c2</a> (double ofs_value, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C2連続曲線の一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 costant offset curve of C2 continuous curve.  <a href="#a857248909351f001fa13238bfb3452aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a48dc1aea71c5b63db5495beac40fa59c">offset_c2</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;ofs_value_lb, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;norm_vector=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C2連続曲線の可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 valuable offset curveof C2 continuous curve.  <a href="#a48dc1aea71c5b63db5495beac40fa59c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a6ef7f48e2e0b1c72acc87270d80c097c">offset_div_num</a> (const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;interval) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">オフセットで使用する、あるパラメータ範囲の分割数を求める get the number of division for offset  <a href="#a6ef7f48e2e0b1c72acc87270d80c097c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ad2c08f169d6d447464d73d4d6b33ae1d">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if given point is on the curve or not.  <a href="#ad2c08f169d6d447464d73d4d6b33ae1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a0d08fe6d4d50fa8eb87340a424487850">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if given point is on the geometry or not.  <a href="#a0d08fe6d4d50fa8eb87340a424487850"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaedfb7d4914191ad41182305ff2c0603"></a><!-- doxytag: member="MGCurve::order" ref="aaedfb7d4914191ad41182305ff2c0603" args="() const =0" -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aaedfb7d4914191ad41182305ff2c0603">order</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the order. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a1f088f8d8160fe7ec3a293445476a839">param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter value of given point.  <a href="#a1f088f8d8160fe7ec3a293445476a839"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70cd58a92072d2a83d2bfde730edcf31"></a><!-- doxytag: member="MGCurve::param_e" ref="a70cd58a92072d2a83d2bfde730edcf31" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a70cd58a92072d2a83d2bfde730edcf31">param_e</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b4b643a7d484f0a5a7fa3af7c3c8fda"></a><!-- doxytag: member="MGCurve::param_error" ref="a7b4b643a7d484f0a5a7fa3af7c3c8fda" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7b4b643a7d484f0a5a7fa3af7c3c8fda">param_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter space error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab8d6aac48fea5813393870bcbd6a1e78">param_normalize</a> (double t) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize parameter value t to the nearest knot if their distance is within tolerance.  <a href="#ab8d6aac48fea5813393870bcbd6a1e78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0375b2565ed4e0e7ad0b882444555cad"></a><!-- doxytag: member="MGCurve::param_range" ref="a0375b2565ed4e0e7ad0b882444555cad" args="() const " -->
virtual <a class="el" href="class_m_g_interval.html">MGInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a0375b2565ed4e0e7ad0b882444555cad">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter range of the curve(パラメータ範囲を返す). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac8ce976810dad174fc1ab5a0e1c035c"></a><!-- doxytag: member="MGCurve::param_round_into_range" ref="aac8ce976810dad174fc1ab5a0e1c035c" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aac8ce976810dad174fc1ab5a0e1c035c">param_round_into_range</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round the parameter t into this parameter range. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f464a55daa4521e2d3707fead6f33b1"></a><!-- doxytag: member="MGCurve::parameter_range" ref="a5f464a55daa4521e2d3707fead6f33b1" args="() const " -->
<a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a5f464a55daa4521e2d3707fead6f33b1">parameter_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter range of the geometry(パラメータ範囲を返す). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5be462ccf254144893f48a843df60df"></a><!-- doxytag: member="MGCurve::param_s" ref="ab5be462ccf254144893f48a843df60df" args="() const =0" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab5be462ccf254144893f48a843df60df">param_s</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a32ff02a1e0058cc0fafb3976a84f2e"></a><!-- doxytag: member="MGCurve::param_se" ref="a0a32ff02a1e0058cc0fafb3976a84f2e" args="(double t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a0a32ff02a1e0058cc0fafb3976a84f2e">param_se</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting or ending parameter value that is nearer to the param t. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e7aa9c735cb0ffb587c2ae5d87e5136"></a><!-- doxytag: member="MGCurve::param_span" ref="a5e7aa9c735cb0ffb587c2ae5d87e5136" args="() const " -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a5e7aa9c735cb0ffb587c2ae5d87e5136">param_span</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter span length. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a57c9d6e7f929b0d77c75cc6417daba2b">part</a> (double t1, double t2, int multiple=0) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of this curve from parameter t1 to t2.  <a href="#a57c9d6e7f929b0d77c75cc6417daba2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a31249d89ab8ecc07a0d7f617f165df8a">perp_guess</a> (double t0, double t1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, double tg, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return perpendicular point from a point P, given guess starting paramter values.  <a href="#a31249d89ab8ecc07a0d7f617f165df8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab64b507359c80bcbb55550f2df8a7c62">perp_guess</a> (double s0, double s1, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve2, double t0, double t1, double sg, double tg, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;st) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return perpendicular points of two curves, given guess starting paramter values.  <a href="#ab64b507359c80bcbb55550f2df8a7c62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac4caa8d093daac4815df907eca6f1aaf">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p, double &amp;t, const double *g=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a foot point of the perpendicular line from point p to the curve.  <a href="#ac4caa8d093daac4815df907eca6f1aaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a045fa5b355613faf012be3107a035b25">perpendiculars</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the perpendicular points of this curve and the second one.  <a href="#a045fa5b355613faf012be3107a035b25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ad94d161f9e243e1a47bf0ebe7b5dcf29">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all foot points of the perpendicular line from point to the curve.  <a href="#ad94d161f9e243e1a47bf0ebe7b5dcf29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a0da4a6809840a951581a99174dbebbab">perps</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv2) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all the perpendicular points of this curve and the second one.  <a href="#a0da4a6809840a951581a99174dbebbab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a580fcb9bdd97800f44c0061214bb0f65"></a><!-- doxytag: member="MGCurve::perps" ref="a580fcb9bdd97800f44c0061214bb0f65" args="(const MGStraight &amp;crv2) const =0" -->
virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;crv2) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524da794c0360be50609b26c814f2c42"></a><!-- doxytag: member="MGCurve::perps" ref="a524da794c0360be50609b26c814f2c42" args="(const MGRLBRep &amp;crv2) const " -->
virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1e590d4ba365f2af60d58537b5dda50"></a><!-- doxytag: member="MGCurve::perps" ref="aa1e590d4ba365f2af60d58537b5dda50" args="(const MGEllipse &amp;crv2) const " -->
virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94d6a10865a66e6fdf2a23edc8b27884"></a><!-- doxytag: member="MGCurve::perps" ref="a94d6a10865a66e6fdf2a23edc8b27884" args="(const MGLBRep &amp;crv2) const " -->
virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe906e39e96610878ebafd46fcb2fab"></a><!-- doxytag: member="MGCurve::perps" ref="a6fe906e39e96610878ebafd46fcb2fab" args="(const MGSurfCurve &amp;crv2) const " -->
virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85e05278e063d594442384497ed68f53"></a><!-- doxytag: member="MGCurve::perps" ref="a85e05278e063d594442384497ed68f53" args="(const MGBSumCurve &amp;crv2) const " -->
virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7a7e570bbfa00f76e0bfa16041b36a4"></a><!-- doxytag: member="MGCurve::perps" ref="af7a7e570bbfa00f76e0bfa16041b36a4" args="(const MGCompositeCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_composite_curve.html">MGCompositeCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2293b93918edcb89d585bde66bb2e313"></a><!-- doxytag: member="MGCurve::perps" ref="a2293b93918edcb89d585bde66bb2e313" args="(const MGTrimmedCurve &amp;crv2) const " -->
<a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>perps</b> (const <a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a> &amp;crv2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae70f5c56705573c5269adff4a5560db8">pick_closest</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parameter value of the closest point from the straight to this object.  <a href="#ae70f5c56705573c5269adff4a5560db8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ae3222aad7951a48f0234984262e482b1">polygonize</a> (double error, <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lb2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate this curve by a polyline and output to lb2.  <a href="#ae3222aad7951a48f0234984262e482b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a2b95a3db43d8f03f6e8e4ad20d436acc">range</a> (double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round t into curve's parameter range.  <a href="#a2b95a3db43d8f03f6e8e4ad20d436acc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a4705f229587d733c65027c2a0e2a0d48">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round t into geometry's parameter range.  <a href="#a4705f229587d733c65027c2a0e2a0d48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab291e6df0064b00191413eb94a06e6c2">rebuild</a> (size_t order, double tol) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approcimate the curve by <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>.  <a href="#ab291e6df0064b00191413eb94a06e6c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aac3a1862056a9ea5e662e692f2fcebbb">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数(B表現曲線のみ) トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい Remove redundant knot, and reduce the b-rep dimension.  <a href="#aac3a1862056a9ea5e662e692f2fcebbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a9053f97237aa1dfd0f67131b9bd24755">rotate_self</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, double, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;=mgORIGIN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update curve by rotating around straight line.  <a href="#a9053f97237aa1dfd0f67131b9bd24755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2aee3fba31ba245bc9618baf27f8237"></a><!-- doxytag: member="MGCurve::sdim" ref="af2aee3fba31ba245bc9618baf27f8237" args="() const =0" -->
virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#af2aee3fba31ba245bc9618baf27f8237">sdim</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f61ac6fa8338427fd7a516c84a4f01b"></a><!-- doxytag: member="MGCurve::start_point" ref="a3f61ac6fa8338427fd7a516c84a4f01b" args="() const " -->
virtual <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a3f61ac6fa8338427fd7a516c84a4f01b">start_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return start point(始点を返却する). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab444253d2ae843173c03d0dc2c79e814">sweep</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sweep surface from crv.  <a href="#ab444253d2ae843173c03d0dc2c79e814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a214630fb495436c87ecb9de668676b05">tangent_guess</a> (double t0, double t1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, double tg, double &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return tangent point from a point P, given guess starting paramter tg.  <a href="#a214630fb495436c87ecb9de668676b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ab985414f5cb110a3a4c165db7e3957d5">trim_end</a> (double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the end part of this curve at the parameter t.  <a href="#ab985414f5cb110a3a4c165db7e3957d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a1974ea18a5ff89564b17c355c1da38c9">trim_start</a> (double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the start part of this curve at the parameter t.  <a href="#a1974ea18a5ff89564b17c355c1da38c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23f1534a8c49c1ca508e313088648113"></a><!-- doxytag: member="MGCurve::type" ref="a23f1534a8c49c1ca508e313088648113" args="() const =0" -->
virtual <a class="el" href="group___b_a_s_e.html#ga3d62deaa8540cbd7b222fb814f0a39a4">MGCURVE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a23f1534a8c49c1ca508e313088648113">type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve type(曲線のタイプを返す). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dd0795698c8dbd41ce5f76b0beabb20"></a><!-- doxytag: member="MGCurve::unlimit" ref="a7dd0795698c8dbd41ce5f76b0beabb20" args="()=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7dd0795698c8dbd41ce5f76b0beabb20">unlimit</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve(limitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0bc0f6f49e8698d2e70aee06f3b5a96"></a><!-- doxytag: member="MGCurve::unlimit_end" ref="ac0bc0f6f49e8698d2e70aee06f3b5a96" args="()=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac0bc0f6f49e8698d2e70aee06f3b5a96">unlimit_end</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the end point direction (終点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92948618bfb8d207a854fc1ce604921a"></a><!-- doxytag: member="MGCurve::unlimit_start" ref="a92948618bfb8d207a854fc1ce604921a" args="()=0" -->
virtual <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a92948618bfb8d207a854fc1ce604921a">unlimit_start</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlimit parameter range of the curve to the start point direction (始点方向にlimitをはずす). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538827e5527c142cfadb8dff92de2f4b"></a><!-- doxytag: member="MGCurve::out" ref="a538827e5527c142cfadb8dff92de2f4b" args="(std::ostream &amp;) const " -->
virtual std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a538827e5527c142cfadb8dff92de2f4b">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbc13eb60ce9c8ca8a89ab0eb0a65320"></a><!-- doxytag: member="MGCurve::ReadMembers" ref="adbc13eb60ce9c8ca8a89ab0eb0a65320" args="(MGIfstream &amp;buf)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#adbc13eb60ce9c8ca8a89ab0eb0a65320">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み出す関数 ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48d2579ca2f26e720556c2f2a58b11fd"></a><!-- doxytag: member="MGCurve::WriteMembers" ref="a48d2579ca2f26e720556c2f2a58b11fd" args="(MGOfstream &amp;buf) const " -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a48d2579ca2f26e720556c2f2a58b11fd">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7da60650ad1b0c4823eeb1c3ce8be722">intersect_1D</a> (double f, size_t coordinate=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">virtual std::vector&lt;MGInterval&gt; clip(const MGBox&amp;) const;  <a href="#a7da60650ad1b0c4823eeb1c3ce8be722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcc4347a95bb40b334f31a5a412e2054"></a><!-- doxytag: member="MGCurve::whoami" ref="abcc4347a95bb40b334f31a5a412e2054" args="() const " -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a16e03a405aa4898f8a54ae9aea1ec24c">approximate_as_LBRep</a> (<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lb, size_t order, size_t is, size_t ie) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate this curve as a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> curve from knot_vector[is] to [ie].  <a href="#a16e03a405aa4898f8a54ae9aea1ec24c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aa9f7b4809b57bde189218b9a8523d9e8">extrapolated_pp</a> (double tau, double dk, <a class="el" href="class_m_g_p_p_rep.html">MGPPRep</a> &amp;pp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain an extrapolated PP-Rep curve by the parameter value.  <a href="#aa9f7b4809b57bde189218b9a8523d9e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d6f5100174a6dd1f37c0fa0e5d77fbe"></a><!-- doxytag: member="MGCurve::isect_withC1LB" ref="a9d6f5100174a6dd1f37c0fa0e5d77fbe" args="(const MGLBRep &amp;curve2) const " -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a9d6f5100174a6dd1f37c0fa0e5d77fbe">isect_withC1LB</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersections with <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> curve2 that does not have C0 continuity in it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d9e1552e1ec5a37a9ee28dff31e8c14"></a><!-- doxytag: member="MGCurve::isect_with_noCompoSC" ref="a7d9e1552e1ec5a37a9ee28dff31e8c14" args="(const MGSurfCurve &amp;curve2) const " -->
virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a7d9e1552e1ec5a37a9ee28dff31e8c14">isect_with_noCompoSC</a> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect with SurfCurve whose m_curve is not a <a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a> of <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::auto_ptr&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac0d98232c1251692db526e28d65a6f7e">oneD</a> (const double g[4]) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve.  <a href="#ac0d98232c1251692db526e28d65a6f7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#afb9f54eddd1c94c33c2e7b2aa5b10baf">perps_withC1LB</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lbC1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perpendicular points with C1 conitnuity LBRep.  <a href="#afb9f54eddd1c94c33c2e7b2aa5b10baf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a95f80f0d0b2008400891b2bcc5418991">perps_with_noCompoSC</a> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perpendicular points with SurfCurve whose m_curve is not a <a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a> of <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>.  <a href="#a95f80f0d0b2008400891b2bcc5418991"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a725b3d0cda734e9590c48549b8f9cbed">perpsSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perpendicular points with straight.  <a href="#a725b3d0cda734e9590c48549b8f9cbed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3b0d0b5db589449e49181eba639d754"></a><!-- doxytag: member="MGCurve::update_mark" ref="af3b0d0b5db589449e49181eba639d754" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#af3b0d0b5db589449e49181eba639d754">update_mark</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark this as updated. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6e5cc99c9f14d029d61a74031ded4e"></a><!-- doxytag: member="MGCurve::MGFace" ref="a1f6e5cc99c9f14d029d61a74031ded4e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a1f6e5cc99c9f14d029d61a74031ded4e">MGFace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a443b939759230521058b7612c5bf583e"></a><!-- doxytag: member="MGCurve::MGFSurface" ref="a443b939759230521058b7612c5bf583e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a443b939759230521058b7612c5bf583e">MGFSurface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe000bc8a2d7a96c44aedb2bbe2f1280"></a><!-- doxytag: member="MGCurve::MGSurface" ref="afe000bc8a2d7a96c44aedb2bbe2f1280" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#afe000bc8a2d7a96c44aedb2bbe2f1280">MGSurface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23669e08ae9e6c150b0deb0d002fa39a"></a><!-- doxytag: member="MGCurve::MGLBRep" ref="a23669e08ae9e6c150b0deb0d002fa39a" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a23669e08ae9e6c150b0deb0d002fa39a">MGLBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa399b6986c6068c186823c189dbc558d"></a><!-- doxytag: member="MGCurve::MGTrimmedCurve" ref="aa399b6986c6068c186823c189dbc558d" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#aa399b6986c6068c186823c189dbc558d">MGTrimmedCurve</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663f1f5614262622b7e5ca59affbc1e0"></a><!-- doxytag: member="MGCurve::MGSurfCurve" ref="a663f1f5614262622b7e5ca59affbc1e0" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a663f1f5614262622b7e5ca59affbc1e0">MGSurfCurve</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad166666009a00ca3e427dc37da78f847"></a><!-- doxytag: member="MGCurve::MGCompositeCurve" ref="ad166666009a00ca3e427dc37da78f847" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ad166666009a00ca3e427dc37da78f847">MGCompositeCurve</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4cb027cb6b49a8cc72755ab176efa29"></a><!-- doxytag: member="MGCurve::MGBSumCurve" ref="ac4cb027cb6b49a8cc72755ab176efa29" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#ac4cb027cb6b49a8cc72755ab176efa29">MGBSumCurve</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bc762e3b91661ee5087fbf0ac37705d"></a><!-- doxytag: member="MGCurve::join" ref="a3bc762e3b91661ee5087fbf0ac37705d" args="(MGPvector&lt; MGCurve &gt; &amp;crvl, MGPvector&lt; MGCurve &gt; &amp;join_crvl)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_curve.html#a3bc762e3b91661ee5087fbf0ac37705d">join</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;crvl, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;join_crvl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">向きが同じB表現曲線リストを接続する(LBRep, RLBRep同士のみ)。join_crvlに接続した曲線リストが入る。 戻り値は、引数の曲線リストの向きが違うとき、同じB表現同士でなかったときfalseが返る。 <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a> is an abstract class which represents a whole curve. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a16e03a405aa4898f8a54ae9aea1ec24c"></a><!-- doxytag: member="MGCurve::approximate_as_LBRep" ref="a16e03a405aa4898f8a54ae9aea1ec24c" args="(MGLBRep &amp;lb, size_t order, size_t is, size_t ie) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::approximate_as_LBRep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate this curve as a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> curve from knot_vector[is] to [ie]. </p>
<p>This is an internal program of <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lb</em>&nbsp;</td><td>Approximated obrep will be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>new order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ie</em>&nbsp;</td><td>approximation parameter range, from lb.knot_vector()[is] to [ie]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbe8bebba61623e88d0472e9e111ca23"></a><!-- doxytag: member="MGCurve::arrow" ref="adbe8bebba61623e88d0472e9e111ca23" args="(double t, MGPosition data[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::arrow </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>[4]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate arrow data of the tangent at the parameter value t of the curve. </p>
<p>data[0] is the origin, data[1] is top of the arrow, data[2], [3] are two bottoms of arrowhead. </p>

</div>
</div>
<a class="anchor" id="a680d824802125a83533362f05ee84b71"></a><!-- doxytag: member="MGCurve::box_limitted" ref="a680d824802125a83533362f05ee84b71" args="(const MGInterval &amp;) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_box.html">MGBox</a> MGCurve::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return minimum box that includes the curve of parameter interval. </p>
<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a9855cecd927a6ec8de3287cd6ccb8c8b">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#aa5aea51fdbd510b2684306e5feb1c10d">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a0f6dd60b74f5bc68fd865dc021ffb5b9">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#acee9f498fd571b7d5b69ed293a321d7a">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a4513b9b24aaf53cecf6a2608a5b599ae">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a9723bad8d4fa0ba17ee9d7ded719a59a">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#abae5ee6b273ff49f0d17ab1ce446d6d1">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a72bb5a2e696fe6ac79fafec36ecbbea3">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aaf99eb4f391e2ebc5b31187f8dc4ff50"></a><!-- doxytag: member="MGCurve::calc_div_num" ref="aaf99eb4f391e2ebc5b31187f8dc4ff50" args="(const MGInterval &amp;interval) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::calc_div_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate dividing Knots number for the initial approximation of the curve, used for precise approximation. </p>
<p>分割数を求めるパラメータ範囲 </p>

</div>
</div>
<a class="anchor" id="ac83a24a002d65e6339859e51321fff57"></a><!-- doxytag: member="MGCurve::change_dimension" ref="ac83a24a002d65e6339859e51321fff57" args="(size_t sdim, size_t start1=0, size_t start2=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>&amp; MGCurve::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_geometry.html#abbaaeb53580ed0d3a19872a67cbe97ed">MGGeometry</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#ac28f824420c4d02bb8e607037e62e98c">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a856e0b3cf84cb6790ced42fc0e881e0e">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a7433c299d5ef3460d0b78ea1e7091982">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#af64766085003a6596bc9b8cf98605f8a">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a2b1980a4b10f69e1af0c6c638416fb78">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a61753bea79db2b29ff364989768e44d2">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a20d0e94970fdb99c4bc4e0e74162ad80">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a91950f44787d0e15ad909594efd20c49">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a260ff34df53249e6887a09553f84058b"></a><!-- doxytag: member="MGCurve::change_range" ref="a260ff34df53249e6887a09553f84058b" args="(double t1, double t2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::change_range </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#adc1d36b064c31d061d6edcf49ade7cc0">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a386f1dc34e78ee3641b09b46f69f09b6">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a0f3cbc528d7b7b7c9b22e731744ef021">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a0e8642500d4180053ce3dedca640b07d">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a1afea2f961097ac0a4e65bf572f39d28">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#afc83eb6f8f4de3b4b3e2d1f8ebc66210">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a52f63ba38da1cf5b54b2f05ffa000832">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a558bb70d2f84060ae0a82ffa556a868a">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ae85e37def31262577515e70078fb92e9"></a><!-- doxytag: member="MGCurve::clone" ref="ae85e37def31262577515e70078fb92e9" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCurve::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new geometry object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_geometry.html#acea9c1d930ea7d8f4a79c09645f9c36c">MGGeometry</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a3a7ccbf33efea4c9deac164b214a0109">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a9080da1dad5b9859e2c7713b172f7051">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a15506aae416fc587969212c88cb54908">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#aa270f3a8f68a723930bd3d515a2ebc5e">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#af0e21bb30673cd52a8f4549db6918b19">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a4eb1a77f9ba4d2e99b53869bcf3d1c09">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a1202dddbe3f9605281231eaec5554a4e">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#ace025fa60d76c2ef865847cd0aeb67c8">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a6975d9151f7b8538c504b4216ac0a937"></a><!-- doxytag: member="MGCurve::closest" ref="a6975d9151f7b8538c504b4216ac0a937" args="(const MGCurve &amp;curve2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGCurve::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value pair of this curve and curve2. </p>
<p><a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P of the function return contains this and curve2's parameter as: P(0)=this curve's parameter, P(1)=curve2's parameter value. </p>

</div>
</div>
<a class="anchor" id="ac3f5d34bbb38d40e17437f23b299af25"></a><!-- doxytag: member="MGCurve::closest2D" ref="ac3f5d34bbb38d40e17437f23b299af25" args="(const MGPosition &amp;point, double &amp;dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::closest2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the point on the curve which is the intersection with x=point[0], or y=point[1] and the nearest point from point. </p>
<p>If no intersection found, the nearer point parameter value out of start or end will be returned. </p>

</div>
</div>
<a class="anchor" id="ae8c6cb11b641e5b6f596867672bfda66"></a><!-- doxytag: member="MGCurve::coordinate_exchange" ref="ae8c6cb11b641e5b6f596867672bfda66" args="(size_t i, size_t j)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>&amp; MGCurve::coordinate_exchange </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exchange ordering of the coordinates. </p>
<p>Exchange coordinates (i) and (j). </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#afb6f4a421719e5a62ad90333ea880e9c">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a56bdf1853a0f1f6a66a6cab99144e058">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#acf8250c17c44468121fc8f4e29e09353">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a73b4f696ed0bc99cba99eee038d3ecd6">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a98a30b40e27d9b539c1d43d359c4fed2">MGRLBRep</a>, and <a class="el" href="class_m_g_straight.html#a4c294b066756c2c1560ec6d572110a85">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef3806ddfd62edf9b7b9c59626caf5a"></a><!-- doxytag: member="MGCurve::copy_as_nurbs" ref="a9ef3806ddfd62edf9b7b9c59626caf5a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCurve::copy_as_nurbs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy as a newed curve. </p>
<p>The new curve will be <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> or <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. When original curve was a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>, the new curve will be a <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a>. Otherwise, the new curve will be a <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. Returned object must be deleted. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#aa6cdc43c625294de65d8cf0d704f1627">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a8706fd7a2f9afe340744d24c78c3e86d">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a085a7533eb1b9385625b0a98d1ab8af7">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a29f023966dfe25e5cf3e73e416eabe8c">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#aa2c781b05b7d3c7bc34a1520013187f6">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a456090572924831ceefdf51925a0b6be">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a6dded4c59116e6370306e9266ac06210">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a802f00827d8296e64bcb567aabe792d2">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a84add0aaacbc189dd584dbf9f5670d99"></a><!-- doxytag: member="MGCurve::copy_change_dimension" ref="a84add0aaacbc189dd584dbf9f5670d99" args="(size_t sdim, size_t start1=0, size_t start2=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCurve::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_geometry.html#ad604d6dfa6e4ba9e7df49ac66ffb693a">MGGeometry</a>.</p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a696d312cf2f39f6c606b35b4d937848a">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#aa5b9e15a8c90226f8a6a8bf03947b8bd">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a8cf5668afef437ce38ade622359e02b6">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a5e1c277fe0de545fed252aa97ca3cb9e">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a70ca358a3433b03ec0bb968291aef239">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#ae20509f13f46988e8785a1eec50876ac">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#afae6a59074f725441ff54524d81a9590">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#adbb2053d6f7d9c7af5e223f602ab79a4">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a45bda2b85297af3d92a32f23e011682f"></a><!-- doxytag: member="MGCurve::copy_limitted" ref="a45bda2b85297af3d92a32f23e011682f" args="(const MGInterval &amp;prange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCurve::copy_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new curve object by copying to newed area, and limitting the parameter range to prange. </p>
<p>Returned is a newed object and must be deleted. </p>

<p>Reimplemented in <a class="el" href="class_m_g_l_b_rep.html#a4b7004b63812fae3664d115eb5cdcf30">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#ae19db276b94803492d1c8c78f4d8b1bd">MGRLBRep</a>, and <a class="el" href="class_m_g_trimmed_curve.html#af2d0b6e40009203d4d5192a88e49ba26">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a60066999080cf603c811c6d448eed364"></a><!-- doxytag: member="MGCurve::curvature" ref="a60066999080cf603c811c6d448eed364" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::curvature </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return curvature at the given point. </p>
<p>When the curve is 2D, curvature has sign. when 3D, curvature is always plus. 与えられた点における曲線の曲率を返却する。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_straight.html#a91b99a8c452e464003bc87efb4a33d95">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a27b4724616d26b4b6aa076b010645a26"></a><!-- doxytag: member="MGCurve::curvilinear_integral" ref="a27b4724616d26b4b6aa076b010645a26" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::curvilinear_integral </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>線積分を求める。 Compute curvilinear integral of the 1st two coordinates. </p>
<p>This integral can be used to compute area sorounded by the curve. Second form is from <a class="el" href="class_m_g_curve.html#ab5be462ccf254144893f48a843df60df" title="Return starting parameter value.">param_s()</a> to <a class="el" href="class_m_g_curve.html#a70cd58a92072d2a83d2bfde730edcf31" title="Return ending parameter value.">param_e()</a>; curvilinear_integral from t1 to t2 can be obtained by Integral of (x*dy-y*dx) about t, where curve is expressed by f(t)=(x(t),y(t)), dx=dx/dt, and dy=dy/dt. </p>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a468603ad144e943de392e2dae8f7d379">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a629c3f6cb9490d64faa2d877512f1208">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#adb7bd33a2f4ee8aab8331743b674f145">MGLBRep</a>, <a class="el" href="class_m_g_straight.html#ab0f3938f1f373c44b0bac5e63dbe3cc2">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a6b44a5c8c2a88bdba75999f0fdca52a7">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a9172d83749d84dcc0245a96a296a6abb"></a><!-- doxytag: member="MGCurve::direction" ref="a9172d83749d84dcc0245a96a296a6abb" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> MGCurve::direction </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return tangent vector at the given point. </p>
<p>与えられた点における曲線の接ベクトルを返す。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_straight.html#ab873daaf95bdc38d58b82a092dfb24d0">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a736b00ca1d84ec5285aac7d081f6cd05"></a><!-- doxytag: member="MGCurve::display_curvatures" ref="a736b00ca1d84ec5285aac7d081f6cd05" args="(double scale, int density, bool use_radius) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::display_curvatures </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>scaling of the graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>density</em>&nbsp;</td><td>densitiy of the graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_radius</em>&nbsp;</td><td>true:radius display, false:curvature display. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#a1448377a3ef066e03a682c1d857316c6">MGGel</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#aa61f977b457956d2ba99ac1a603cd9a0">MGCompositeCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a1ee0ed7b28c40b502d4eeec470368b4d"></a><!-- doxytag: member="MGCurve::divide_multi" ref="a1ee0ed7b28c40b502d4eeec470368b4d" args="(MGPvector&lt; MGCurve &gt; &amp;crv_list, int multiplicity=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::divide_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>crv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiplicity</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide this curve at the designated knot multiplicity point. </p>
<p>Function's return value is the number of the curves after divided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv_list</em>&nbsp;</td><td>divided curves will be appended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiplicity</em>&nbsp;</td><td>designates the multiplicity of the knot to divide at, When multiplicity&lt;=0, <a class="el" href="class_m_g_curve.html#aaedfb7d4914191ad41182305ff2c0603" title="Returns the order.">order()</a>-1 is assumed, When multiplicity&gt;=order(), <a class="el" href="class_m_g_curve.html#aaedfb7d4914191ad41182305ff2c0603" title="Returns the order.">order()</a> is assumed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a63f0d3b8aa9ce5cd260e54d2161e23cc">MGCompositeCurve</a>, <a class="el" href="class_m_g_l_b_rep.html#a17208cdf34fdaed0d3d9a797ed941f3e">MGLBRep</a>, and <a class="el" href="class_m_g_r_l_b_rep.html#a13bea2ebbe9e284031f5ad5f9e0ec0d3">MGRLBRep</a>.</p>

</div>
</div>
<a class="anchor" id="a20497e172065788e673b771f018d90af"></a><!-- doxytag: member="MGCurve::drawSE" ref="a20497e172065788e673b771f018d90af" args="(double span_length, double t0, double t1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::drawSE </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>Start parameter value of the curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>End parameter value of the curve, Draw will be performed from t0 to t1. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a17c6c44a4e4cb1edf26e5d3ff5165304">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a99b0bc2fe40e482a4fabcf17bccc533a">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a06e39ceec02ce365c5deadafa0043db7">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#abf9d2a88d59cf71c8c76d75f6f383541">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a22055e8b3763c66999630347e54b167e">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#ab9cd4f8cf4ba67ca32f98ea7fb4d9f8d">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8973e25dfd474aad477a20505377b5c5"></a><!-- doxytag: member="MGCurve::drawWire" ref="a8973e25dfd474aad477a20505377b5c5" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw the object in wire mode, in the world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_object.html#ad422cfd57a3a6daedd7762001cb04a8f">MGObject</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_g_straight.html#a08f75b7808bd60b15d622065e8e72484">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="acbcbb8f812be257921ef63c71afdedcf"></a><!-- doxytag: member="MGCurve::eval" ref="acbcbb8f812be257921ef63c71afdedcf" args="(double, size_t nderiv=0, int left=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_vector.html">MGVector</a> MGCurve::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate n'th derivative data. n=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of Derivative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>Left continuous(left=true) or right continuous(left=false). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a9e20432d368a39d7d68089a67e3efb75">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#ae70e0a06dd6e59b8847db4ad3804803d">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#acac237a8d8c3a9ac258735cf238c4aa6">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a64aed702de6ade8db7b4b1e2578959b5">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#ac892bfc228d273051f911216e68ce803">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a7295f9a24372d823c26520af325a062b">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#ac45702bbb7f8bc2fdef54f3f4d49d923">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a74ab42089dabfe27cd19ac469b8ee38b">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a9ea3970501a3d9c681a38ff584018b41"></a><!-- doxytag: member="MGCurve::eval_all" ref="a9ea3970501a3d9c681a38ff584018b41" args="(double, MGPosition &amp;, MGVector &amp;, MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute position, 1st and 2nd derivatives. </p>
<p>パラメータ値を与えて位置、一次微分値、二次微分値をもとめる。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_ellipse.html#a2f83fcc8c47bf772314c5c623d567bbc">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#af56dd48a49c5c5714271107d228595b7">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a0e3b290b0584debdf0b1664796eb7484">MGRLBRep</a>, and <a class="el" href="class_m_g_straight.html#a5955a3ba96883084c1441bc1a37d14fc">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="af1870e1105d7e44e856b362953479c38"></a><!-- doxytag: member="MGCurve::eval_deriv" ref="af1870e1105d7e44e856b362953479c38" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_vector.html">MGVector</a> MGCurve::eval_deriv </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute 1st derivative. </p>
<p>曲線上の与えられたパラメータ値における一次微分値をかえす。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_ellipse.html#aae7796e15604cd3e777ca6be29935206">MGEllipse</a>, and <a class="el" href="class_m_g_straight.html#a9b02e5eb640f292c629cbe850f19459a">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="ae6fced145414e82cf35d282f2aa64942"></a><!-- doxytag: member="MGCurve::eval_discrete_deviation" ref="ae6fced145414e82cf35d282f2aa64942" args="(const MGCurve &amp;curve2, std::vector&lt; MGPosition &gt; &amp;sts, int npoint=20, double tolerance=0.1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::eval_discrete_deviation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_m_g_position.html">MGPosition</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>npoint</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em> = <code>0.1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate deviations of two curves(this and curve2) at npoint discrete points. </p>
<p>(1)Search the common curve spans which have the distance within tolerance. (2)Compute the nearest points from npoint discrete points of this to curve2. Let sti=sts[i], then sti[0] is this curve's parameter value s, and sti[1] is the parameter value t of curve2 which is the nearest point from the point s. If this and curve2 have the minimum distance more than tolerance, sts.size()==1 and sts[0] is the minimum distance points of this and curve2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>npoint</em>&nbsp;</td><td>indicates how many discrete points be obtained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>tolerance to get two edge to compute deviation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae23f4567458a4f215eaa4f692373cf5b"></a><!-- doxytag: member="MGCurve::eval_line" ref="ae23f4567458a4f215eaa4f692373cf5b" args="(const MGNDDArray &amp;tau, MGBPointSeq &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::eval_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate line data at data point tau. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>Data points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Values evaluated. value(i,.)=eval(tau[i]); </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_l_b_rep.html#ae7d21e6ec98b243c7d804ada86235296">MGLBRep</a>.</p>

</div>
</div>
<a class="anchor" id="a005668fa2dca670c5ff755c9bb06945d"></a><!-- doxytag: member="MGCurve::eval_position" ref="a005668fa2dca670c5ff755c9bb06945d" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGCurve::eval_position </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute positional data. </p>
<p>与えられたパラメータ値に相当する自身上の点を返す。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_ellipse.html#ac75699928ee734689e2a9fe28bbbc85f">MGEllipse</a>, and <a class="el" href="class_m_g_straight.html#abe5f9a6f7131f398137703e8b2155ac3">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a4778716ba9e27346ef9edf2588d4cecf"></a><!-- doxytag: member="MGCurve::evaluate" ref="a4778716ba9e27346ef9edf2588d4cecf" args="(const MGPosition &amp;t, const size_t *nderiv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGCurve::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate n'th derivative data. n=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value. t's space dimension is geometry's manifold dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of derivative of i-th parameter in nderiv[i]. When nderiv=null, nderiv[i]=0 is assumed for all i. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_geometry.html#a3275ac1ad6972544394fc330b32c712e">MGGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="af0e8206d530257d27910d0676ba0be01"></a><!-- doxytag: member="MGCurve::extend" ref="af0e8206d530257d27910d0676ba0be01" args="(double length, bool start=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::extend </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate this curve by an (approximate) chord length. </p>
<p>The extrapolation is C2 continuous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>approximate chord length to extend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Flag of which point to extend, start or end point of the line. If start is true extend on the start point. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#aa07ecd6668c92b1786bf543393deb1c3">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a518c7815e70c63691305648cc0ab9eef">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a91b8d9443d9b514125755abdfde13ba4">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#aab8a998a09f65297cbb2c7a505cd85bf">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#af0b37e783673e32f09e422fbe14de441">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a7217ad5880babbd7443628d2ce4c466e">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#af6bbd7999697ab6fa97e206a15d98cde">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#af78508db8f81634122d77a42c9280fdc">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aa9f7b4809b57bde189218b9a8523d9e8"></a><!-- doxytag: member="MGCurve::extrapolated_pp" ref="aa9f7b4809b57bde189218b9a8523d9e8" args="(double tau, double dk, MGPPRep &amp;pp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::extrapolated_pp </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_p_p_rep.html">MGPPRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain an extrapolated PP-Rep curve by the parameter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tau</em>&nbsp;</td><td>The parameter value at the end of extended point, When tau&lt;<a class="el" href="class_m_g_curve.html#ab5be462ccf254144893f48a843df60df" title="Return starting parameter value.">param_s()</a>, extension will be done at the starting point, When tau&gt;<a class="el" href="class_m_g_curve.html#a70cd58a92072d2a83d2bfde730edcf31" title="Return ending parameter value.">param_e()</a>, extension will be done at the end point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at the connecting point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf81e6285746563a80f4b6ecbe3eda17"></a><!-- doxytag: member="MGCurve::Frenet_frame" ref="aaf81e6285746563a80f4b6ecbe3eda17" args="(double t, MGUnit_vector &amp;T, MGUnit_vector &amp;N, MGUnit_vector &amp;B, double &amp;curvature, double &amp;torsion) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::Frenet_frame </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>torsion</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute Frenet_frame, curvature and torsion in 3D space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Input parameter value(パラメータ値) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>Tangent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Principal Normal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Binormal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curvature</em>&nbsp;</td><td>Curvature is always &gt;=0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae683fe14cbb04567ad1ceabf7248c10"></a><!-- doxytag: member="MGCurve::Frenet_frame2" ref="aae683fe14cbb04567ad1ceabf7248c10" args="(double t, MGVector &amp;V2, MGVector &amp;T, MGVector &amp;N, MGVector &amp;B) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::Frenet_frame2 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute Frenet_frame, curvature and torsion in 3D space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Input parameter value(パラメータ値) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V2</em>&nbsp;</td><td>2nd derivative at t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>Tangent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Principal Normal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Binormal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bb80ff3ce43fa39ab6845885089770f"></a><!-- doxytag: member="MGCurve::get_control_points" ref="a7bb80ff3ce43fa39ab6845885089770f" args="(MGBPointSeq &amp;cpoints) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGCurve::get_control_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_b_point_seq.html">MGBPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cpoints</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts control points. </p>
<p>Fucntion's return value is true if control points was obtained, false if not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpoints</em>&nbsp;</td><td>Control points will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_l_b_rep.html#a00ab0426c3f95a7432acfee78f2fe1ad">MGLBRep</a>, and <a class="el" href="class_m_g_r_l_b_rep.html#a2db3d688dd1211a90d157782f56e355e">MGRLBRep</a>.</p>

</div>
</div>
<a class="anchor" id="a86bd988df49b91d4576c1f5edeb0e181"></a><!-- doxytag: member="MGCurve::has_same_direction_at" ref="a86bd988df49b91d4576c1f5edeb0e181" args="(double s, const MGCurve &amp;curve2, double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCurve::has_same_direction_at </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this curve has the same direction with curve2 at the point s(of this) and t(of curve2). </p>
<p>Function's return value is true if they have the same direction. "same direction" means their tangent vectors have the angle less than 90 degree. </p>

</div>
</div>
<a class="anchor" id="afe372918854a25e07bdfb526cbb3f8ad"></a><!-- doxytag: member="MGCurve::intersect" ref="afe372918854a25e07bdfb526cbb3f8ad" args="(const MGCurve &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> MGCurve::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Curve to curve intersection. </p>
<p>Caution***intersect can be used only for finite curve, i.e. parameter range of the computation is only from <a class="el" href="class_m_g_curve.html#ab5be462ccf254144893f48a843df60df" title="Return starting parameter value.">param_s()</a> to <a class="el" href="class_m_g_curve.html#a70cd58a92072d2a83d2bfde730edcf31" title="Return ending parameter value.">param_e()</a>. For example, intersect cannot be applied to infinite straight line. </p>

</div>
</div>
<a class="anchor" id="a7da60650ad1b0c4823eeb1c3ce8be722"></a><!-- doxytag: member="MGCurve::intersect_1D" ref="a7da60650ad1b0c4823eeb1c3ce8be722" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGCurve::intersect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>virtual std::vector&lt;MGInterval&gt; clip(const MGBox&amp;) const; </p>
<p>Compute intersection point of 1D sub curve of original curve. Parameter values of intersection point will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#acf017375394a888f602d6fe8c7b047c2">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#af9bda4e4adf08400df7962669a148a31">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a16ef0a29fb48cb4ace7a0c0447b857b3">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#aeccb25cc040074dfe3883585c6e2a523">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a1dd7889ac69c181a4eb0256bfdac3f55">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a31659addcc402955a924117dc0b4b2d3">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a7a84c8ee26b70733b258989c7e1aa3c1"></a><!-- doxytag: member="MGCurve::intersect_brute_force" ref="a7a84c8ee26b70733b258989c7e1aa3c1" args="(const MGCurve &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_cisect__list.html">MGCCisect_list</a> MGCurve::intersect_brute_force </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Curve to curve intersection. </p>
<p>Curve と Curve の交点を求める。 </p>

</div>
</div>
<a class="anchor" id="a8b4c78d5172218a652ede1cb2ede258f"></a><!-- doxytag: member="MGCurve::intersection" ref="a8b4c78d5172218a652ede1cb2ede258f" args="(const MGObject &amp;obj2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_gisects.html">MGisects</a> MGCurve::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_object.html">MGObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>obj2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersections of two objects. </p>
<p>Intersections are obtained from two objects, which are known using the <a class="el" href="class_m_gisects.html#af38c1dac073591a6405efb080957f094" title="Get the 1st object pointer of the i-th intersection.">MGisects::object1()</a> and object2(). NOTE**** When two objects' manifold dimension are the same, object1 is this object at the invocation of <a class="el" href="class_m_g_object.html#ad20afa7e5b85f49d80e53a2a9377438b" title="Compute the intersections of two objects.">MGObject::intersection()</a>, and object2 is the argument object. However, their manifold dimension are not the same, object1 is always the lower dimension's object and object2 is the higer dimension's object. </p>

<p>Implements <a class="el" href="class_m_g_object.html#ad20afa7e5b85f49d80e53a2a9377438b">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="a84a92b42fe2946b772eb30081d2c5ad6"></a><!-- doxytag: member="MGCurve::is_coplanar" ref="a84a92b42fe2946b772eb30081d2c5ad6" args="(const MGCurve &amp;curve2, MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGCurve::is_coplanar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is co-planar with the 2nd curve curve2. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is co-planar. Function's return value is true if co-planar. </p>

<p>Reimplemented in <a class="el" href="class_m_g_l_b_rep.html#a575c05dc1bb4919b9fa148b7e11fa216">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#af19428e9123d5a96e53aab4880b43413">MGRLBRep</a>, and <a class="el" href="class_m_g_straight.html#a1f4e3e9d087e17c920d4a72bd62e2142">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="ac8483acd59478145655b63787b46557a"></a><!-- doxytag: member="MGCurve::is_linear" ref="ac8483acd59478145655b63787b46557a" args="(MGStraight &amp;straight) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGCurve::is_linear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>straight</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is linear or not, that is, is straight or not. </p>
<p><a class="el" href="class_m_g_straight.html" title="MGStraight is a curve of any space dimension, represent a straight line.">MGStraight</a> expression will be out to straight if this is linear or not. Function's return value is true if linear. </p>

<p>Reimplemented in <a class="el" href="class_m_g_ellipse.html#a7f2ba248fb3216bb8422e7c819ffede9">MGEllipse</a>, and <a class="el" href="class_m_g_straight.html#a72d3fae507a3ca9a2fe553d625dfc60b">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a943dd7a986851b30f5e0473cf0cead5c"></a><!-- doxytag: member="MGCurve::is_perpendicular" ref="a943dd7a986851b30f5e0473cf0cead5c" args="(const MGPosition &amp;P, double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCurve::is_perpendicular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the vector from P to this-&gt;eval(t) is perpendicular to the tangent of this curve at t. </p>

</div>
</div>
<a class="anchor" id="a3e6f96416ab574420cbed88ebfc414e9"></a><!-- doxytag: member="MGCurve::is_planar" ref="a3e6f96416ab574420cbed88ebfc414e9" args="(MGPlane &amp;plane) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGCurve::is_planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this cure is planar or not. </p>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> expression will be out to plane if this is planar. Function's return value is true if planar. </p>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a90dab13643364ec1d650c7a43f5bedb1">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a62df31d96af72c2333bb60f9c8bb6d69">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a208ad049aa9bd9ef6c99c5085a22c479">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#abc88d73f88250959329b252198fb12b1">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a0cb65b02b9cab6374d5dccdae8d825b8">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a93cdbd771713d1e9c68700884016a487">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8ca638854f8938e9c2c7f88afd71a682"></a><!-- doxytag: member="MGCurve::isect_1D" ref="a8ca638854f8938e9c2c7f88afd71a682" args="(double f, size_t coordinate=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGCurve::isect_1D </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>coordinate</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute intersection point of 1D sub curve of original curve. </p>
<p>Parameter values of intersection point will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Coordinate value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordinate</em>&nbsp;</td><td>Coordinate kind of the data f(from 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d7c4dd68f29d059515a267023f50ddf"></a><!-- doxytag: member="MGCurve::length" ref="a7d7c4dd68f29d059515a267023f50ddf" args="(double t1, double t2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::length </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cmpute curve length of the interval. </p>
<p>If t1 is greater than t2, return negative value. 与えられたパラメータ値間の曲線の長さを返す。 パラメータが昇順で与えられたときは正値、降順のときは負値を返す。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a36b7c3ff5554deb40246556eece68e79">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#ac2c34ad9386b5de4a45ecdebe9ea9e2e">MGEllipse</a>, <a class="el" href="class_m_g_straight.html#a4746295c18fc1872b4e9a40c340a347a">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a1ca24fdc468d2cfaa60af177d2ebd922">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a1873bf48b6b84ba4e5c0b41fc5d10b18"></a><!-- doxytag: member="MGCurve::length" ref="a1873bf48b6b84ba4e5c0b41fc5d10b18" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute whole curve length. </p>
<p>If the curve is infinite, return -1. 自身の曲線が有界の場合、その曲線の距離を返却する。非有界の場 合はー１を返却をする。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a576dac2f6b30658123a818b2a8eff153">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a1cdf1c6a9a055aee3af48cac543304fe">MGEllipse</a>, and <a class="el" href="class_m_g_straight.html#a0ae80992f96b23e1fc18c27dae7d66fd">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="ac9db090d93e6b0a1e7f9c6b6d29e7c48"></a><!-- doxytag: member="MGCurve::length_param" ref="ac9db090d93e6b0a1e7f9c6b6d29e7c48" args="(double t, double len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::length_param </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverse function of length. </p>
<p>Compute the point that is away from the point t by length len. lengthの逆関数。指定パラメータtで示される点から指定距離len 曲線上に沿って離れた点を示すパラメータ値を返す。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_ellipse.html#a7ae14a26b603cb98eed616040a670dfe">MGEllipse</a>, <a class="el" href="class_m_g_straight.html#a935744a738d80e7cba00aec621f3f000">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a653d4f3b27dfe65d7d06501540bf0b7a">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a4f5e376f184379038ebac06536962e32"></a><!-- doxytag: member="MGCurve::limit" ref="a4f5e376f184379038ebac06536962e32" args="(const MGInterval &amp;rng)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>&amp; MGCurve::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rng</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update this by limiting the parameter range of the curve. </p>
<p>自身に指定したパラメータ範囲のｌｉｍｉｔをつける。 </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a54d3e5b2ac68d0f8276b16b46ad3c269">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a6b41bbe5be20ad5c7ed55133a986ec8f">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#ab4436d6be20ada9efd6a93d5799418d7">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a95e25747174e4b17949c4cd5a3a29494">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a9ba74256cfa8bd870e9c8471df266ebb">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a260adc9ed5590499f3eaf33ae3d7c1c7">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a5f23727f2a2de8bdd8dd27a2cfb41462">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#ace787348b77920dfbb42d257f18dbdbb">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad9b41f61ca4c5f8ac61c21b1ae3d34dd"></a><!-- doxytag: member="MGCurve::negate_transform" ref="ad9b41f61ca4c5f8ac61c21b1ae3d34dd" args="(MGGeometry &amp;boundary) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::negate_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_geometry.html">MGGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>virtual <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> negate_param(const MGPosition&amp; t)const; </p>
<p>Transform the coordinates of boundary of this geometry so that new coordinate of boundary is the same coordinate as the new one of this geometry after <a class="el" href="class_m_g_curve.html#aa6b1d0deec00888135456a16962137bc" title="Negate the curve direction(曲線の方向を反転する).">negate()</a> of this geometry is done. That is, boundary coordinates are parameter world of this geometry. </p>

<p>Implements <a class="el" href="class_m_g_geometry.html#a6f4368e291d4717a88f06eaa91611a78">MGGeometry</a>.</p>

</div>
</div>
<a class="anchor" id="a04c8f0af36fd4efea083189ab3aaa7a7"></a><!-- doxytag: member="MGCurve::offset" ref="a04c8f0af36fd4efea083189ab3aaa7a7" args="(double ofs_value, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGCurve::offset </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 Offset of costant deviation from a curve. </p>
<p>If the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#abafbfcc532a41f1baa23d931c5dd7e58">MGCompositeCurve</a>, and <a class="el" href="class_m_g_straight.html#ab197b21f8147d736d7c6618fed9bf4f6">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a904ef6006545f9056dedc9ea5578365a"></a><!-- doxytag: member="MGCurve::offset" ref="a904ef6006545f9056dedc9ea5578365a" args="(const MGLBRep &amp;ofs_value_lb, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGCurve::offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ofs_value_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線リストが返却される。 Offset of variable deviation from a curve. </p>
<p>If the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value_lb</em>&nbsp;</td><td>空間次元１の線B表現で示したオフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a8ae94ef9a2ffe4ac3d5464de109853f7">MGCompositeCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a857248909351f001fa13238bfb3452aa"></a><!-- doxytag: member="MGCurve::offset_c2" ref="a857248909351f001fa13238bfb3452aa" args="(double ofs_value, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> MGCurve::offset_c2 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C2連続曲線の一定オフセット関数 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 costant offset curve of C2 continuous curve. </p>
<p>if the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#ab153a2ed89bfde7a9081eb27cbdc2a30">MGCompositeCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a48dc1aea71c5b63db5495beac40fa59c"></a><!-- doxytag: member="MGCurve::offset_c2" ref="a48dc1aea71c5b63db5495beac40fa59c" args="(const MGLBRep &amp;ofs_value_lb, const MGVector &amp;norm_vector=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> MGCurve::offset_c2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ofs_value_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>norm_vector</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C2連続曲線の可変オフセット関数 オフセット量は空間次元1の線B表現で与えられる。 オフセット方向は、法線方向から見て入力曲線の進行方向左側を正とする。 法線ベクトルがヌルの場合、始点において曲率中心方向を正とする。ただし、曲率中心へ曲率半径以上のオフセット は行わない。トレランスはline_zero()を使用している。戻り値は、オフセット曲線が返却される。 valuable offset curveof C2 continuous curve. </p>
<p>if the norm_vector is given, the positive offset direction decide to left hand side from ahead, or the direction to center of curvature at start parameter. the offset value is less than radius of curvature. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value_lb</em>&nbsp;</td><td>空間次元１の線B表現で示したオフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>norm_vector</em>&nbsp;</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#acc36307fc9a9ed9a4993052ff4440d60">MGCompositeCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a6ef7f48e2e0b1c72acc87270d80c097c"></a><!-- doxytag: member="MGCurve::offset_div_num" ref="a6ef7f48e2e0b1c72acc87270d80c097c" args="(const MGInterval &amp;interval) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::offset_div_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>オフセットで使用する、あるパラメータ範囲の分割数を求める get the number of division for offset </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>分割数を求めるパラメータ範囲 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2c08f169d6d447464d73d4d6b33ae1d"></a><!-- doxytag: member="MGCurve::on" ref="ad2c08f169d6d447464d73d4d6b33ae1d" args="(const MGPosition &amp;point, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MGCurve::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if given point is on the curve or not. </p>
<p>If yes, return parameter value of the curve. Even if not, return nearest point's parameter t. 指定点が自身上にあるかを調べる。曲線上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Function's return value is &gt;0 if the point is on the curve, and 0 if the point is not on the curve. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>point(指定点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter of the curve(パラメータ) will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a084ec1ac18765a7efe299057101888d2">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a28139b3940e1956d394a0dc22c37ef20">MGEllipse</a>, and <a class="el" href="class_m_g_straight.html#ac2debde50e62999751a30e3432257040">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a0d08fe6d4d50fa8eb87340a424487850"></a><!-- doxytag: member="MGCurve::on" ref="a0d08fe6d4d50fa8eb87340a424487850" args="(const MGPosition &amp;P, MGPosition &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCurve::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if given point is on the geometry or not. </p>
<p>If yes, return parameter value of the geometry. Even if not, return nearest point's parameter. 指定点が自身上にあるかを調べる。曲線上にあれば，そのパラメーター値を， なくても最近傍点のパラメータ値を返す。 Function's return value is &gt;0 if the point is on the geometry, and 0 if the point is not on the geometry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter of the geometry(パラメータ) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0d98232c1251692db526e28d65a6f7e"></a><!-- doxytag: member="MGCurve::oneD" ref="ac0d98232c1251692db526e28d65a6f7e" args="(const double g[4]) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::auto_ptr&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGCurve::oneD </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>g</em>[4]</td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain so transformed 1D curve expression of this curve that f(t)={sum(xi(t)*g[i]) for i=0(x), 1(y), 2(z)}-g[3], where f(t) is the output of oneD and xi(t) is i-th coordinate expression of this curve. </p>
<p>This is used to compute intersections with a plane g[4]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>Plane expression(a,b,c,d) where ax+by+cz=d. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a1b8da88c78081afec033a9ea5c5cb2b3">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#ade5a13acfd3b6c9fcc280da56f76efb1">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a21460d5488d65ff3d0fed239898247b0">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#aafeddba9b7dda43198b56caa6cdf043c">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a5ade0e6171293ed3d4f2848934f767c1">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a241bb4521330a8af3ef5504b71b88a4f">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#ad38eda2874457c933bad5c9b3e5037f7">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#abc65beebd5cd00be335ebd44464d610f">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a8f7d7b83316e78bbd4f4cdc668eff615"></a><!-- doxytag: member="MGCurve::operator=" ref="a8f7d7b83316e78bbd4f4cdc668eff615" args="(const MGCurve &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>&amp; MGCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and geo2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a1f088f8d8160fe7ec3a293445476a839"></a><!-- doxytag: member="MGCurve::param" ref="a1f088f8d8160fe7ec3a293445476a839" args="(const MGPosition &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter value of given point. </p>
<p>自身の上の指定点を表すパラメータ値を返す。 If input point is not on the curve, return the nearest point on the curve. </p>

<p>Reimplemented in <a class="el" href="class_m_g_straight.html#aeaa63d871c3bda1d13ea95398a411358">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="ab8d6aac48fea5813393870bcbd6a1e78"></a><!-- doxytag: member="MGCurve::param_normalize" ref="ab8d6aac48fea5813393870bcbd6a1e78" args="(double t) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::param_normalize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize parameter value t to the nearest knot if their distance is within tolerance. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a8475b2d3e0487dc23d6f2a838ad4f75c">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a6776cd9d6a863e9a9dc76276456a7a4d">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#ad3f7e91fffbd3cdd1b1ea81b52f7857a">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#ad4f3d4bb0c4af552c4ca26c8838436c8">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a7cd7adeb85fef88b47ae7ad99de0d6f5">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a9d629ae682be0101b02b73aa6af25b6c">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#afddac85651b08feacb22a1aaa972c230">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a262c8df2a6e88483af8f4aef78661328">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a57c9d6e7f929b0d77c75cc6417daba2b"></a><!-- doxytag: member="MGCurve::part" ref="a57c9d6e7f929b0d77c75cc6417daba2b" args="(double t1, double t2, int multiple=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCurve::part </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of this curve from parameter t1 to t2. </p>
<p>Returned is the pointer to newed object, and so should be deleted by calling program, or memory leaked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a3a546747d3a7552a855128d982c5afef">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a61403250aa73926bc39f201c1d160da2">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a09bd219f1aec2091843b147514742e2d">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#affcc9c8f0476c88f73b96b75b7593a8c">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a18885b819cf4f01225b363fb5ae2a6b1">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a58c42f3e6283bce8e59fbb4e5f6a572f">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a5204bda65b8fe71f79d7d50f8b032b69">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#ab2a8f7d7a4e920ac4c363f3d27991e29">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ab64b507359c80bcbb55550f2df8a7c62"></a><!-- doxytag: member="MGCurve::perp_guess" ref="ab64b507359c80bcbb55550f2df8a7c62" args="(double s0, double s1, const MGCurve &amp;curve2, double t0, double t1, double sg, double tg, MGPosition &amp;st) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::perp_guess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>st</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return perpendicular points of two curves, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>parameter range of this. When s0&gt;=s1, no limit for this parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curve2</em>&nbsp;</td><td>2nd curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of curve2. When t0&gt;=t1, no limit for curve2 parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tg</em>&nbsp;</td><td>Guess parameter values of the two curves sg: this curve's parameter, tg:curve2's parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>perpendicular points' parameter values will be output. st(0): this curve's parameter, st(1):curve2's parameter. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#aa3b520111edea13098c37e59f2fca784">MGCompositeCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a31249d89ab8ecc07a0d7f617f165df8a"></a><!-- doxytag: member="MGCurve::perp_guess" ref="a31249d89ab8ecc07a0d7f617f165df8a" args="(double t0, double t1, const MGPosition &amp;P, double tg, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::perp_guess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return perpendicular point from a point P, given guess starting paramter values. </p>
<p>Function's return value is: perp_guess=true if perpendicular points obtained, perp_guess=false if perpendicular points not obtained, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of this, (t0&gt;=t1) indicates no range specified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tg</em>&nbsp;</td><td>Guess parameter values of this curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#acd3b0f1986340bbf61c71740c76fb124">MGCompositeCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ac4caa8d093daac4815df907eca6f1aaf"></a><!-- doxytag: member="MGCurve::perp_point" ref="ac4caa8d093daac4815df907eca6f1aaf" args="(const MGPosition &amp;p, double &amp;t, const double *g=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>g</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a foot point of the perpendicular line from point p to the curve. </p>
<p>If more than one points are found, return nearest one. 指定点からの自身への垂線の足とパラメータ値を返す。 Function's return value is if point is obtained(1) or not(0) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Point(指定点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter of the curve(パラメータ値) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>guess parameter value of line </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_ellipse.html#a44e7303d2204c576fc5fc2f9e99843e3">MGEllipse</a>, and <a class="el" href="class_m_g_straight.html#a00d5f21785d12a5abe373edfbc2b6b9b">MGStraight</a>.</p>

</div>
</div>
<a class="anchor" id="a045fa5b355613faf012be3107a035b25"></a><!-- doxytag: member="MGCurve::perpendiculars" ref="a045fa5b355613faf012be3107a035b25" args="(const MGCurve &amp;crv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCurve::perpendiculars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the perpendicular points of this curve and the second one. </p>
<p>That is, if f(s) and g(t) are the points of the two curves f and g, then obtains points where the following conditions are satisfied: fs*(f-g)=0. gt*(g-f)=0. Here fs and gt are 1st derivatives at s and t of f and g. NOTE 1 **** perpendiculars is general function of perps, used in perps. General users should use function perps, not perpendiculars, since perps is optimized for each curve type. NOTE 2 **** perpendiculars can not be used for infinite parameter range curve. <a class="el" href="class_m_g_curve.html#ab5be462ccf254144893f48a843df60df" title="Return starting parameter value.">param_s()</a> and <a class="el" href="class_m_g_curve.html#a70cd58a92072d2a83d2bfde730edcf31" title="Return ending parameter value.">param_e()</a> of both curves must return their finite parameter range. <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv's parameter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>The second curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0da4a6809840a951581a99174dbebbab"></a><!-- doxytag: member="MGCurve::perps" ref="a0da4a6809840a951581a99174dbebbab" args="(const MGCurve &amp;crv2) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCurve::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all the perpendicular points of this curve and the second one. </p>
<p>That is, if f(s) and g(t) are the points of the two curves f and g, then obtains points where the following conditions are satisfied: fs*(f-g)=0. gt*(g-f)=0. Here fs and gt are 1st derivatives at s and t of f and g. <a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=curve2's parameter value. </p>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#a219f3228802334adcbb753fa7ea3e0f8">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#a930789d4ab17ec5c96c22666d01ef018">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#ad5b20b0db0416decbd1b2c4f95544e73">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a8dfa8c81b1df7c836eb645b599c488e8">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a42d26d183568e3982302e94ce41a98a4">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a8409fc86835a8ba179fd2ad08026a841">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#aa13f42e1b4a62acc4331bba0139fb941">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a51a77a3714e1d38d5ea21951b0045a95">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad94d161f9e243e1a47bf0ebe7b5dcf29"></a><!-- doxytag: member="MGCurve::perps" ref="ad94d161f9e243e1a47bf0ebe7b5dcf29" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_c_param__list.html">MGCParam_list</a> MGCurve::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all foot points of the perpendicular line from point to the curve. </p>
<p>与ポイントから曲線へ下ろした垂線の足の，曲線のパラメータ値を すべて求める。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a17a7f0e2cf78fdba77d67a4db958c6ba">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a599280090297f336ab38e45476a9ebfd">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a5b90fc7c7164c39d3552f48eb801442a">MGLBRep</a>, <a class="el" href="class_m_g_straight.html#a6796ffebbdcfabb028e2e35069226e7b">MGStraight</a>, and <a class="el" href="class_m_g_trimmed_curve.html#a6316647ab809fce8d8464e1a41cc6407">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a95f80f0d0b2008400891b2bcc5418991"></a><!-- doxytag: member="MGCurve::perps_with_noCompoSC" ref="a95f80f0d0b2008400891b2bcc5418991" args="(const MGSurfCurve &amp;curve2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCurve::perps_with_noCompoSC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perpendicular points with SurfCurve whose m_curve is not a <a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a> of <a class="el" href="class_m_g_composite_curve.html" title="MGCompositeCurve is a composite of other leaf curves.">MGCompositeCurve</a>. </p>

</div>
</div>
<a class="anchor" id="afb9f54eddd1c94c33c2e7b2aa5b10baf"></a><!-- doxytag: member="MGCurve::perps_withC1LB" ref="afb9f54eddd1c94c33c2e7b2aa5b10baf" args="(const MGLBRep &amp;lbC1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCurve::perps_withC1LB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lbC1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perpendicular points with C1 conitnuity LBRep. </p>
<p><a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv's parameter value. </p>

</div>
</div>
<a class="anchor" id="a725b3d0cda734e9590c48549b8f9cbed"></a><!-- doxytag: member="MGCurve::perpsSl" ref="a725b3d0cda734e9590c48549b8f9cbed" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCurve::perpsSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perpendicular points with straight. </p>
<p><a class="el" href="class_m_g_position.html" title="Represent a positional data.">MGPosition</a> P in the <a class="el" href="class_m_g_position__list.html" title="MGPosition_list provides a list of Positions.">MGPosition_list</a> contains this and crv's parameter as: P(0)=this curve's parameter, P(1)=crv's parameter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sl</em>&nbsp;</td><td>The second curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae70f5c56705573c5269adff4a5560db8"></a><!-- doxytag: member="MGCurve::pick_closest" ref="ae70f5c56705573c5269adff4a5560db8" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_position.html">MGPosition</a> MGCurve::pick_closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parameter value of the closest point from the straight to this object. </p>
<p>sl is the eye projection line whose direction is from yon to hither, and if sl had multiple intersection points, The closest point to the eye will be selected. </p>

<p>Reimplemented from <a class="el" href="class_m_g_object.html#afad70053cb311ff1a2a7ab86b9a4e1a7">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="ae3222aad7951a48f0234984262e482b1"></a><!-- doxytag: member="MGCurve::polygonize" ref="ae3222aad7951a48f0234984262e482b1" args="(double error, MGLBRep &amp;lb2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::polygonize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lb2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate this curve by a polyline and output to lb2. </p>
<p>The tolerance of the approximation is error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>tolerance allowed for the approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lb2</em>&nbsp;</td><td>Obtained polyline will be output as an <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a> of order2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4705f229587d733c65027c2a0e2a0d48"></a><!-- doxytag: member="MGCurve::range" ref="a4705f229587d733c65027c2a0e2a0d48" args="(const MGPosition &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGCurve::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Round t into geometry's parameter range. </p>
<p>入力パラメータをパラメータ範囲でまるめて返却する。 t's space dimension is geometry's manifold dimension. </p>

</div>
</div>
<a class="anchor" id="a2b95a3db43d8f03f6e8e4ad20d436acc"></a><!-- doxytag: member="MGCurve::range" ref="a2b95a3db43d8f03f6e8e4ad20d436acc" args="(double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MGCurve::range </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Round t into curve's parameter range. </p>
<p>入力パラメータをパラメータ範囲でまるめて返却する。 </p>

<p>Reimplemented in <a class="el" href="class_m_g_straight.html#a44c9382dea7f1ec88a2034057469005c">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a0e047e9aef27f40a0a27996dadaabb21">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#ac816a2fe3019ac60bae4e7f5fa4b9520">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ab291e6df0064b00191413eb94a06e6c2"></a><!-- doxytag: member="MGCurve::rebuild" ref="ab291e6df0064b00191413eb94a06e6c2" args="(size_t order, double tol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&gt; MGCurve::rebuild </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approcimate the curve by <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. </p>
<p>The parameter of the original will not be changed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>order of the new <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>, must be &gt;=4. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>tolerance allowed for the approximation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac3a1862056a9ea5e662e692f2fcebbb"></a><!-- doxytag: member="MGCurve::remove_knot" ref="aac3a1862056a9ea5e662e692f2fcebbb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MGCurve::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数(B表現曲線のみ) トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい Remove redundant knot, and reduce the b-rep dimension. </p>
<p>The tolerance used is <a class="el" href="class_m_g_tolerance.html#a10b55492588f36f67c17352ef77ae08f" title="Return m_line_zero. m_line_zeroを返却する。.">MGTolerance::line_zero()</a>. </p>

<p>Reimplemented in <a class="el" href="class_m_g_composite_curve.html#a701310f7adc15b7b57062f7a63fa2d7c">MGCompositeCurve</a>, <a class="el" href="class_m_g_l_b_rep.html#ad554fd02a7252dcd87ceb0bb599cf6f1">MGLBRep</a>, and <a class="el" href="class_m_g_r_l_b_rep.html#afefcb8967b95d87d6fb3464c0c1441a4">MGRLBRep</a>.</p>

</div>
</div>
<a class="anchor" id="a9053f97237aa1dfd0f67131b9bd24755"></a><!-- doxytag: member="MGCurve::rotate_self" ref="a9053f97237aa1dfd0f67131b9bd24755" args="(const MGVector &amp;v, double, const MGPosition &amp;=mgORIGIN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_curve.html">MGCurve</a>&amp; MGCurve::rotate_self </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> = <code>mgORIGIN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update curve by rotating around straight line. </p>
<p>指定点を通る指定ベクトルを軸として回転させたものを自身とする。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Vector of the line to rotate around. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab444253d2ae843173c03d0dc2c79e814"></a><!-- doxytag: member="MGCurve::sweep" ref="ab444253d2ae843173c03d0dc2c79e814" args="(const MGUnit_vector &amp;uvec, double start_dist, double end_dist) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGCurve::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sweep surface from crv. </p>
<p>Returned is a newed <a class="el" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface.">MGSurface</a>, must be deleted. The sweep surface is defined as: This curve(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_m_g_b_sum_curve.html#ac4b07b149ab0b1f6de5a458fd9773608">MGBSumCurve</a>, <a class="el" href="class_m_g_composite_curve.html#af036bcf3358598d97dce155888e9d140">MGCompositeCurve</a>, <a class="el" href="class_m_g_ellipse.html#a81f8f23292e472dd3720b1612eea1b72">MGEllipse</a>, <a class="el" href="class_m_g_l_b_rep.html#a8371d4ab8811a7e0e55bfd75a36169ef">MGLBRep</a>, <a class="el" href="class_m_g_r_l_b_rep.html#a6b5168b1d7a6cbc610134ccdee172f57">MGRLBRep</a>, <a class="el" href="class_m_g_straight.html#a4cb6c9d2a32ef5e7c41e8769e01f5fbb">MGStraight</a>, <a class="el" href="class_m_g_surf_curve.html#a836eced4812339a9afd2e54334e186c5">MGSurfCurve</a>, and <a class="el" href="class_m_g_trimmed_curve.html#ab40ae1edd591f632658d82f0d1684113">MGTrimmedCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a214630fb495436c87ecb9de668676b05"></a><!-- doxytag: member="MGCurve::tangent_guess" ref="a214630fb495436c87ecb9de668676b05" args="(double t0, double t1, const MGPosition &amp;P, double tg, double &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MGCurve::tangent_guess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return tangent point from a point P, given guess starting paramter tg. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>parameter range of this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point(指定点) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tg</em>&nbsp;</td><td>Guess parameter values of the two curves </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Output parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab985414f5cb110a3a4c165db7e3957d5"></a><!-- doxytag: member="MGCurve::trim_end" ref="ab985414f5cb110a3a4c165db7e3957d5" args="(double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::trim_end </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the end part of this curve at the parameter t. </p>
<p>The new curve range is [start_of_original, t] t must be inside this parameter rage, else does nothing. </p>

</div>
</div>
<a class="anchor" id="a1974ea18a5ff89564b17c355c1da38c9"></a><!-- doxytag: member="MGCurve::trim_start" ref="a1974ea18a5ff89564b17c355c1da38c9" args="(double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCurve::trim_start </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the start part of this curve at the parameter t. </p>
<p>The new curve range is [t,end_of_original] t must be inside this parameter rage, else does nothing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Curve.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:20 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGSBRep Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGSBRep Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGSBRep" --><!-- doxytag: inherits="MGSurface" -->
<p>Defines Surface B-Representation, that is , B-Spline surface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;SBRep.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGSBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_s_b_rep__inherit__graph.png" border="0" usemap="#_m_g_s_b_rep_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_s_b_rep_inherit__map" id="_m_g_s_b_rep_inherit__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="76,315,161,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node12" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="132,237,225,267"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGSBRep:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_s_b_rep__coll__graph.png" border="0" usemap="#_m_g_s_b_rep_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_s_b_rep_coll__map" id="_m_g_s_b_rep_coll__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="288,581,373,611"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="192,501,291,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/><area shape="rect" id="node26" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="315,501,408,531"/><area shape="rect" id="node28" href="class_m_g_s_point_seq.html" title="Defines Spoint seq of a space dimension and of a size." alt="" coords="397,581,501,611"/><area shape="rect" id="node30" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="525,581,632,611"/><area shape="rect" id="node32" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="528,501,629,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_s_b_rep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52ab3577a5d419ac91a944bab41c37a"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="aa52ab3577a5d419ac91a944bab41c37a" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aa52ab3577a5d419ac91a944bab41c37a">MGSBRep</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor(dummy surface brep). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae2cfab6e59c69d6e41a6e00345e6320e">MGSBRep</a> (const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;vertex, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep by providing raw data of Surface B-Rep.  <a href="#ae2cfab6e59c69d6e41a6e00345e6320e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aa233ed383330d6b356e2f21ea8ba1aaa">MGSBRep</a> (const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;points, int &amp;error, unsigned orderu=4, unsigned orderv=4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep by intepolation from Point data only.  <a href="#aa233ed383330d6b356e2f21ea8ba1aaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#abb9d6fb73b6f4de241a4972f92cef425">MGSBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utau, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtau, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;points, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep of any order number by interpolation from data point, point data , and knot vector.  <a href="#abb9d6fb73b6f4de241a4972f92cef425"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a07264c114a9a64433b7df49154170860">MGSBRep</a> (const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;tp, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utau, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtau, const <a class="el" href="class_m_g_vector.html">MGVector</a> uvec[4], const <a class="el" href="class_m_g_vector.html">MGVector</a> vvec[4], const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;points, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep of order 4 by interpolation from Point data and tangent plane end condition.  <a href="#a07264c114a9a64433b7df49154170860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a9f2393f11fb89e9f950baba96b01b5dc">MGSBRep</a> (<a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;endc, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utaui, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtaui, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;value, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep of order 4 by interpolation from Point data and end condition.  <a href="#a9f2393f11fb89e9f950baba96b01b5dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a3b2fe3370a01af86f2636941f75ac534">MGSBRep</a> (<a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;endc, size_t orderu, size_t orderv, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utaui, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtaui, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;value, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep of specified order by interpolation from Point data and end condition.  <a href="#a3b2fe3370a01af86f2636941f75ac534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a63b3892dfd1c0e88631ec6b117a75a32">MGSBRep</a> (<a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;endc, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utaui, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtaui, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;value, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep by interpolation from Point data and end condition with knot vector.  <a href="#a63b3892dfd1c0e88631ec6b117a75a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a862a54c83ff988de52244cb379f92ad1">MGSBRep</a> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;lbrep, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep by sweep B-Rep and sweep length.  <a href="#a862a54c83ff988de52244cb379f92ad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a76f5fd41d5ecdd6e700e92dd6a01052a">MGSBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utau, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtau, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;value, size_t orderu=4, size_t orderv=4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep of specified order by interpolation from Point data.  <a href="#a76f5fd41d5ecdd6e700e92dd6a01052a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ab9fa5d6c88d7fb2a8bdcb59d6af096a7">MGSBRep</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;st, const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;uvec, double start_dist, double end_dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep by sweep Straight and sweep length.  <a href="#ab9fa5d6c88d7fb2a8bdcb59d6af096a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aaeb9ccea9077fd253b470606c43941ef">MGSBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;tau, const std::vector&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> * &gt; &amp;lines, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *deriS, const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *deriE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct Surface B-rep from lines and derivatives.  <a href="#aaeb9ccea9077fd253b470606c43941ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a4e49646f16d18dae445049f7db8b075c">MGSBRep</a> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;old_brep, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;ut, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;vt, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate an original B-Rep by a new knot configuration.  <a href="#a4e49646f16d18dae445049f7db8b075c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a538179d710af3b5a7b798e96a9aff963">MGSBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utau, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtau, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;points, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;weight)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain Surface B-Rep by Least square approximation.  <a href="#a538179d710af3b5a7b798e96a9aff963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a0b508f45bc7bde1668bb59e5c3f06abf">MGSBRep</a> (const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utau, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtau, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;points, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;dp, double deviation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain Surface B-Rep by Shoenberg and Reinch's smoothing function If dp(i,j,0) becomes bigger, deviation at (utau(i),vtau(j)) becomes bigger.  <a href="#a0b508f45bc7bde1668bb59e5c3f06abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ad92ae80201a885784c61ca75a4094e44">MGSBRep</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> *edge_crvl[4], const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;blendCrvU, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;blendCrvV, const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;tp, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">4本の境界線、ブレンド関数、接続面を与えて面を生成する。 境界線はvmin,umax,vmax,uminの順で、vmin,vmaxの向きをuminからumaxの方向に umin,umaxの向きをvminからvmaxの方向になっているものとする。境界線のノットベクトル をあわせるときの誤差はline_zero()を使用している。ブレンド曲線はパラメータ範囲0,1 で値域も0,1である。接続面(<a class="el" href="class_m_g_s_b_rep_t_p.html" title="Defines Tangent Plane Line B-Representation Class.">MGSBRepTP</a>)のパラメータ範囲は各境界線と同じとする。 エラーコード： 0: 正常終了 -1: 境界線がC1連続でなかった -2: 接続面のパラメータ範囲が境界線と違った -3: 境界線のノットベクトルをあわせられなかった -4: 接続面のパラメータ範囲を変更できなかった -5: 点列が求まらなかった -6: 端末条件が求まらなかった -7: 面が生成できなかった  <a href="#ad92ae80201a885784c61ca75a4094e44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#af468572253940b092b756e8c7b7dbd95">MGSBRep</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;edges, int &amp;error, const <a class="el" href="class_m_g_curve.html">MGCurve</a> *blendCrvU=0, const <a class="el" href="class_m_g_curve.html">MGCurve</a> *blendCrvV=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Easy to use version of the above constructor.  <a href="#af468572253940b092b756e8c7b7dbd95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a173e28454d181fe0e4885f1c1ec80f26">MGSBRep</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> *edge_crvl[4], const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;tp, int &amp;error, const double *alpha=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a85b452e7f68ba75e5537d819d521f2ec">MGSBRep</a> (bool along_u, const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;perimeters)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generalized ruled surface construction.  <a href="#a85b452e7f68ba75e5537d819d521f2ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a5007d5153cbd4247d4e1af19e7df4d2d">MGSBRep</a> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;old_brep, const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;uknots, const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;vknots)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new B-Rep by adding knots to an original B-Rep.  <a href="#a5007d5153cbd4247d4e1af19e7df4d2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a39ee6c2b8512978301756c55b45284b2">MGSBRep</a> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;brep1, int which1, int continuity, const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;brep2, int which2, int opposite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets new B-Rep by connecting two B-Rep to one.  <a href="#a39ee6c2b8512978301756c55b45284b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ac126c3e8dc53f49a8f5edcc94c3ddc6f">MGSBRep</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange, const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;old_brep, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain partial Surface B-Rep restricted by sub interval of u and v parameter range.  <a href="#ac126c3e8dc53f49a8f5edcc94c3ddc6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae316adba40f732c5b9d0d860875018af">MGSBRep</a> (size_t dim, const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;sbrep, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Surface B-Rep by changing space dimension and ordering of coordinates.  <a href="#ae316adba40f732c5b9d0d860875018af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#acbe6a5b647d9e870fd0ea9ea8915a29b">MGSBRep</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;prange)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Surface B-Rep (order = 2 ) from Plane and Parameter ranges.  <a href="#acbe6a5b647d9e870fd0ea9ea8915a29b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a9a48eb9f24d424c7fd45dfa0c2cc5395">MGSBRep</a> (const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;curves, bool direction_adjustment=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リブ曲線列から面を作成する 作成する面のノットベクトルはリブ曲線の向きをu,リブ列方向をvとする This constructor only generates <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> even if curves are <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> of the same knot configuration.  <a href="#a9a48eb9f24d424c7fd45dfa0c2cc5395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc9552b1617131ec66e285723093ec77"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="abc9552b1617131ec66e285723093ec77" args="(const MGPvector&lt; MGCurve &gt; &amp;curves, bool direction_adjustment=true)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGSBRep</b> (const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;curves, bool direction_adjustment=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a1e088e9f9ae5c1aa971908eca7eac2d4">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor ‾MGSBRep(); ///We can use default destructor.  <a href="#a1e088e9f9ae5c1aa971908eca7eac2d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cc9f0f6b104dfc5419bf1c81fd7b334"></a><!-- doxytag: member="MGSBRep::operator=" ref="a5cc9f0f6b104dfc5419bf1c81fd7b334" args="(const MGSBRep &amp;gel2)" -->
<a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aa2774cdadb18ad0b9880a3ff40c1269b">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面の平行移動を行いオブジェクトを生成する。 Translation.  <a href="#aa2774cdadb18ad0b9880a3ff40c1269b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#abf171e2171ed682c55620422757b83cc">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面の逆方向に平行移動を行いオブジェクトを生成する。 Translation.  <a href="#abf171e2171ed682c55620422757b83cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a59a263722c7ea8a4b52798cc88230838">operator*</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling.  <a href="#a59a263722c7ea8a4b52798cc88230838"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a17550f47fad56628bf20559872332192">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲面の変換を行いオブジェクトを生成する。 Matrix transformation.  <a href="#a17550f47fad56628bf20559872332192"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ad960da049c90ab3374af00f599a7f343">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換で曲面のトランスフォームを行いオブジェクトを生成する。 General transformation.  <a href="#ad960da049c90ab3374af00f599a7f343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1964fa36711ef7f34a6fc6cd8d89fad6"></a><!-- doxytag: member="MGSBRep::operator+=" ref="a1964fa36711ef7f34a6fc6cd8d89fad6" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a1964fa36711ef7f34a6fc6cd8d89fad6">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb50f641debe4f6b4d5cb958c76f9b9"></a><!-- doxytag: member="MGSBRep::operator&#45;=" ref="a6eb50f641debe4f6b4d5cb958c76f9b9" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ecb471ad62f4008271c83d40e03c5c0"></a><!-- doxytag: member="MGSBRep::operator*=" ref="a2ecb471ad62f4008271c83d40e03c5c0" args="(double scale)" -->
<a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4ca7d9711557c8c67845f58357cfa6d"></a><!-- doxytag: member="MGSBRep::operator*=" ref="ac4ca7d9711557c8c67845f58357cfa6d" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38bc0065bbeec53ddaa15047991098bb"></a><!-- doxytag: member="MGSBRep::operator*=" ref="a38bc0065bbeec53ddaa15047991098bb" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a810acef5c70bb306d8eb0f7469c6bc78"></a><!-- doxytag: member="MGSBRep::operator==" ref="a810acef5c70bb306d8eb0f7469c6bc78" args="(const MGSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a810acef5c70bb306d8eb0f7469c6bc78">operator==</a> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d36e9a6eae5bbad50143bc6248c3ed"></a><!-- doxytag: member="MGSBRep::operator&lt;" ref="aa7d36e9a6eae5bbad50143bc6248c3ed" args="(const MGSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6daa4b1d69f64ff859bb65f7595f256"></a><!-- doxytag: member="MGSBRep::operator==" ref="ae6daa4b1d69f64ff859bb65f7595f256" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae6daa4b1d69f64ff859bb65f7595f256">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cea35d92048fa0ab1253804715ac1b8"></a><!-- doxytag: member="MGSBRep::operator&lt;" ref="a4cea35d92048fa0ab1253804715ac1b8" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fba739924c87af0c2e9d30a2a5ca807"></a><!-- doxytag: member="MGSBRep::operator!=" ref="a1fba739924c87af0c2e9d30a2a5ca807" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a857b6cc60bba03294c195825183414f5"></a><!-- doxytag: member="MGSBRep::operator!=" ref="a857b6cc60bba03294c195825183414f5" args="(const MGSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63fd4e5648df7df7a91a90c3934bb895"></a><!-- doxytag: member="MGSBRep::operator==" ref="a63fd4e5648df7df7a91a90c3934bb895" args="(const MGRSBRep &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a018e6a13d0d677762c4619e5c5325d05">bdim_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身の曲面の全体の面積を返却する。 Compute total surface area.  <a href="#a018e6a13d0d677762c4619e5c5325d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd4c73ede074073440b592164d50854d"></a><!-- doxytag: member="MGSBRep::bdim_v" ref="acd4c73ede074073440b592164d50854d" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#acd4c73ede074073440b592164d50854d">bdim_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns B-Rep Dimension of v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26c91e103bee0635b22ff18eda1132fe"></a><!-- doxytag: member="MGSBRep::box_limitted" ref="a26c91e103bee0635b22ff18eda1132fe" args="(const MGBox &amp;uvrange) const " -->
<a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a26c91e103bee0635b22ff18eda1132fe">box_limitted</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute minimum box that includes the linitted parameter range surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a48f250dd11dac3e4d15120659bbdc784">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#a48f250dd11dac3e4d15120659bbdc784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ac7f399399a134367ee989fe1c4a3a791">change_range</a> (int is_u, double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#ac7f399399a134367ee989fe1c4a3a791"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894c6efa7320b3eeb8f4c2b8556fc666"></a><!-- doxytag: member="MGSBRep::coef" ref="a894c6efa7320b3eeb8f4c2b8556fc666" args="(size_t i, size_t j, size_t k)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a894c6efa7320b3eeb8f4c2b8556fc666">coef</a> (size_t i, size_t j, size_t k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef(left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc04237a742968777ef3c5e7321c908"></a><!-- doxytag: member="MGSBRep::coef" ref="a6fc04237a742968777ef3c5e7321c908" args="(size_t i, size_t j, size_t k) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a6fc04237a742968777ef3c5e7321c908">coef</a> (size_t i, size_t j, size_t k) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to (i,j)th element of coef(right-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb13226812b9f86bd1a61a02d55b7701"></a><!-- doxytag: member="MGSBRep::coef" ref="acb13226812b9f86bd1a61a02d55b7701" args="(size_t i, size_t j) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#acb13226812b9f86bd1a61a02d55b7701">coef</a> (size_t i, size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract (i,j,k) elements for 0&lt;=k&lt;<a class="el" href="class_m_g_s_b_rep.html#ae67beadf2c802223df6fd27bd1693394" title="Returns the space dimension.">sdim()</a> as a vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f66b1c019ad5c520939e16a41326904"></a><!-- doxytag: member="MGSBRep::coef_data" ref="a9f66b1c019ad5c520939e16a41326904" args="(size_t i=0, size_t j=0, size_t k=0) const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a9f66b1c019ad5c520939e16a41326904">coef_data</a> (size_t i=0, size_t j=0, size_t k=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the surface b-coef data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#af63746371dcafbbfae08fb13a5d271a7">continuity</a> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;brep2, int &amp;which1, int &amp;which2, int &amp;opposite, double &amp;ratio) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute continuity with brep2.  <a href="#af63746371dcafbbfae08fb13a5d271a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ad9f88bcf91d300945c3a2dc1e6c08d1f">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#ad9f88bcf91d300945c3a2dc1e6c08d1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#abb5372526064576308dcf992540bbfdb">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#abb5372526064576308dcf992540bbfdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37817534d08d7fd8da768cc69617e568"></a><!-- doxytag: member="MGSBRep::display_control_polygon" ref="a37817534d08d7fd8da768cc69617e568" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a37817534d08d7fd8da768cc69617e568">display_control_polygon</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display control polygons using mgGDL::MGDrawPointSeq(sp). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a8f34a9e4dcccaed411c7d90c106e4b82">divide_multi_knot</a> (<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt; &amp;srfl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uまたはv方向に折れ(マルチノット)があるとき面を分割する 戻り値は、分割数を返却する  <a href="#a8f34a9e4dcccaed411c7d90c106e4b82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a16d04d8d8da3f8068ee958c93a0f02a9">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous ndu'th and ndv'th derivative data.  <a href="#a16d04d8d8da3f8068ee958c93a0f02a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a4a84a30a177df8c06d2e692968f43323">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a4a84a30a177df8c06d2e692968f43323"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aeb2412bdf35040de594328cb89af4e36">eval_all</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#aeb2412bdf35040de594328cb89af4e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aab079a6e12665170ae36aaf3997129e7">eval_all</a> (double u, double v, size_t ndu, size_t ndv, double *deriv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate all of derivative data (d(i+j)f(u,v))/(du**i*dv**j), for 0&lt;=i&lt;=ndu and 0&lt;=j&lt;=ndv.  <a href="#aab079a6e12665170ae36aaf3997129e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1b2c8db2cd525cae19e6bb4ef90adde"></a><!-- doxytag: member="MGSBRep::exchange_uv" ref="aa1b2c8db2cd525cae19e6bb4ef90adde" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aa1b2c8db2cd525cae19e6bb4ef90adde">exchange_uv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange parameter u and v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a01ce7a44e3db215c5ae1522b094b864a">extend</a> (int perimeter, double param, double length, double dk=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original Surface by extrapolating the specified perimeter.  <a href="#a01ce7a44e3db215c5ae1522b094b864a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb0529daf68af082852e275595410a05"></a><!-- doxytag: member="MGSBRep::identify_type" ref="aeb0529daf68af082852e275595410a05" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aeb0529daf68af082852e275595410a05">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e0ffc8028472f4f93d3048fa26185ff"></a><!-- doxytag: member="MGSBRep::in_range" ref="a0e0ffc8028472f4f93d3048fa26185ff" args="(double u, double v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a0e0ffc8028472f4f93d3048fa26185ff">in_range</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input parameter value is inside parameter range of the surface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662372ecebade904738ca5e70e7d92dd"></a><!-- doxytag: member="MGSBRep::in_range" ref="a662372ecebade904738ca5e70e7d92dd" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af04359e1ff3f7abbf22e6721133c5a0e"></a><!-- doxytag: member="MGSBRep::isect" ref="af04359e1ff3f7abbf22e6721133c5a0e" args="(const MGCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#af04359e1ff3f7abbf22e6721133c5a0e">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Curve の交点を求める。 Compute curve and surface intersection point(s). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50ef42dc3a67c2366d8b519e118411ef"></a><!-- doxytag: member="MGSBRep::isect" ref="a50ef42dc3a67c2366d8b519e118411ef" args="(const MGStraight &amp;sl) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5753d1f840912b7e75ce968c328bcd5"></a><!-- doxytag: member="MGSBRep::isect" ref="ad5753d1f840912b7e75ce968c328bcd5" args="(const MGRLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3188fd231f0a15f6103ce45fc9037a6"></a><!-- doxytag: member="MGSBRep::isect" ref="af3188fd231f0a15f6103ce45fc9037a6" args="(const MGEllipse &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04621d326894dba335191a50fbc74f70"></a><!-- doxytag: member="MGSBRep::isect" ref="a04621d326894dba335191a50fbc74f70" args="(const MGLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae5ce4bdd8e4a9764ce98b71e12ffef"></a><!-- doxytag: member="MGSBRep::isect" ref="a7ae5ce4bdd8e4a9764ce98b71e12ffef" args="(const MGSurfCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6419f525a8a78142d1e9bdb5ecd91f80"></a><!-- doxytag: member="MGSBRep::isect" ref="a6419f525a8a78142d1e9bdb5ecd91f80" args="(const MGBSumCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a073cb00a4408a1a0708bea855a73786a">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Surface の交線を求める。 Surface and Surface intersection.  <a href="#a073cb00a4408a1a0708bea855a73786a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6311ab9eed686245fc176608ff3e189"></a><!-- doxytag: member="MGSBRep::isect" ref="aa6311ab9eed686245fc176608ff3e189" args="(const MGPlane &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9ebdbe5ffe5f182e54e8a8dfde588b3"></a><!-- doxytag: member="MGSBRep::isect" ref="af9ebdbe5ffe5f182e54e8a8dfde588b3" args="(const MGSphere &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bd6bd9a218eeb6935e9c18395fd7a67"></a><!-- doxytag: member="MGSBRep::isect" ref="a7bd6bd9a218eeb6935e9c18395fd7a67" args="(const MGCylinder &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a476671f6649733b748eb588c5c923bf7"></a><!-- doxytag: member="MGSBRep::isect" ref="a476671f6649733b748eb588c5c923bf7" args="(const MGSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae84cd84b8b3a373455d68fd92e38daf6"></a><!-- doxytag: member="MGSBRep::isect" ref="ae84cd84b8b3a373455d68fd92e38daf6" args="(const MGRSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15e848748f40d760d02202e6e816b1d"></a><!-- doxytag: member="MGSBRep::isect" ref="aa15e848748f40d760d02202e6e816b1d" args="(const MGBSumSurf &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c41d4348ab684cb57f61218367bd1e9"></a><!-- doxytag: member="MGSBRep::knot_u" ref="a0c41d4348ab684cb57f61218367bd1e9" args="(size_t i)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a0c41d4348ab684cb57f61218367bd1e9">knot_u</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot /////(right-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c74dcaec8faca3c6e88f6c75fb01cb0"></a><!-- doxytag: member="MGSBRep::knot_u" ref="a2c74dcaec8faca3c6e88f6c75fb01cb0" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a2c74dcaec8faca3c6e88f6c75fb01cb0">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of u knot ( left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6cbe408e7aa680553582ad654a3e17f"></a><!-- doxytag: member="MGSBRep::knot_v" ref="ae6cbe408e7aa680553582ad654a3e17f" args="(size_t i)" -->
double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae6cbe408e7aa680553582ad654a3e17f">knot_v</a> (size_t i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot ( left-hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a071caa29b72b67eebaa56896d99d817e"></a><!-- doxytag: member="MGSBRep::knot_v" ref="a071caa29b72b67eebaa56896d99d817e" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a071caa29b72b67eebaa56896d99d817e">knot_v</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot (right hand side version). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a482aeebb8a5a4afef9cf46502329ec8e"></a><!-- doxytag: member="MGSBRep::knot_data_u" ref="a482aeebb8a5a4afef9cf46502329ec8e" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a482aeebb8a5a4afef9cf46502329ec8e">knot_data_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the u knot vector data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70dcdfd399abe7cec3ad27e6647c1eac"></a><!-- doxytag: member="MGSBRep::knot_data_v" ref="a70dcdfd399abe7cec3ad27e6647c1eac" args="() const " -->
const double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a70dcdfd399abe7cec3ad27e6647c1eac">knot_data_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the v knot vector data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae393a975585bf512cb321ffe61550397"></a><!-- doxytag: member="MGSBRep::knot_vector_u" ref="ae393a975585bf512cb321ffe61550397" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae393a975585bf512cb321ffe61550397">knot_vector_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e37a49d46321be06d02835bf4fc021c"></a><!-- doxytag: member="MGSBRep::knot_vector_u" ref="a2e37a49d46321be06d02835bf4fc021c" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a103e302996b42fad4ff94053af32d0e5"></a><!-- doxytag: member="MGSBRep::knot_vector_v" ref="a103e302996b42fad4ff94053af32d0e5" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a103e302996b42fad4ff94053af32d0e5">knot_vector_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae030dd9bee24e317ae70263947c324f3"></a><!-- doxytag: member="MGSBRep::knot_vector_v" ref="ae030dd9bee24e317ae70263947c324f3" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a8ebd913bf938f6c5af66874066f38339">less_than</a> (size_t i, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two parameter values.  <a href="#a8ebd913bf938f6c5af66874066f38339"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#afa4fb57d74fb852dc9583c8f72ac02c0">limit</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自身に指定したパラメータ範囲のlimitをつける。 Update this by limitting the parameter range.  <a href="#afa4fb57d74fb852dc9583c8f72ac02c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#af6428cb8ecc8529e259097d4ff52b80d">move</a> (int move_kind_u, int move_kind_v, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;move_point_param, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;to_point, const <a class="el" href="class_m_g_position.html">MGPosition</a> fix_point[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original Surface by moving move_point to to_point.  <a href="#af6428cb8ecc8529e259097d4ff52b80d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ab4c0fe6bd2ca1ffac3f3241b7a4eeef9">negate</a> (int is_u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change direction of the surface.  <a href="#ab4c0fe6bd2ca1ffac3f3241b7a4eeef9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a5b8f6820b247df8d77802b08b73e4004">negate_param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int is_u=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this surface is negated by "negate()".  <a href="#a5b8f6820b247df8d77802b08b73e4004"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba62d612409e752770c07fc89eb2931a"></a><!-- doxytag: member="MGSBRep::order_u" ref="aba62d612409e752770c07fc89eb2931a" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aba62d612409e752770c07fc89eb2931a">order_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-Rep order(u-direction). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb79b10c4b7c23c91811d774f6d69c6"></a><!-- doxytag: member="MGSBRep::order_v" ref="a2fb79b10c4b7c23c91811d774f6d69c6" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a2fb79b10c4b7c23c91811d774f6d69c6">order_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-Rep order(v-direction). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44ae86809844d960490cbbe23915ec15"></a><!-- doxytag: member="MGSBRep::param_e" ref="a44ae86809844d960490cbbe23915ec15" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a44ae86809844d960490cbbe23915ec15">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c94d7d95be966690d228b0d5b3d448d"></a><!-- doxytag: member="MGSBRep::param_e_u" ref="a8c94d7d95be966690d228b0d5b3d448d" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a8c94d7d95be966690d228b0d5b3d448d">param_e_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b98be617b373191e3ac5afd452c59c"></a><!-- doxytag: member="MGSBRep::param_e_v" ref="a60b98be617b373191e3ac5afd452c59c" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae481076c37271c9835c1d138bda2d99a">parameter_curve</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter curve.  <a href="#ae481076c37271c9835c1d138bda2d99a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a445acc7ccbf12f84d9548f56b757a6eb">parameter_line</a> (int is_u, double x, unsigned nderiv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter line.  <a href="#a445acc7ccbf12f84d9548f56b757a6eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a6ab8517d3fb63eddcc8b1a8bb1545174">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range.  <a href="#a6ab8517d3fb63eddcc8b1a8bb1545174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af61f726ff7ed8b7235ae75ea8a79a493"></a><!-- doxytag: member="MGSBRep::param_s" ref="af61f726ff7ed8b7235ae75ea8a79a493" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#af61f726ff7ed8b7235ae75ea8a79a493">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35a01b152fcc2132185d6ea31298b959"></a><!-- doxytag: member="MGSBRep::param_s_u" ref="a35a01b152fcc2132185d6ea31298b959" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a35a01b152fcc2132185d6ea31298b959">param_s_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9413ef8e6fbf3d043f8a5b900775e0"></a><!-- doxytag: member="MGSBRep::param_s_v" ref="a8b9413ef8e6fbf3d043f8a5b900775e0" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a178ba8ec9ffc350fd488f3b4ed4301d8">part</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbx, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of the surface limitted by the parameter range uvbx.  <a href="#a178ba8ec9ffc350fd488f3b4ed4301d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a043b035bc6ab84bcc6fbd711b1848f7b">perimeter</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute perimeter line B-Rep.  <a href="#a043b035bc6ab84bcc6fbd711b1848f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a2fa92e4b8f76fb299d682d28b686713e">perimeter_curve</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve perimeter i of this surface.  <a href="#a2fa92e4b8f76fb299d682d28b686713e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeb0351b5bfcb5a13f32fc7db6dd6910"></a><!-- doxytag: member="MGSBRep::perimeter_num" ref="aaeb0351b5bfcb5a13f32fc7db6dd6910" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aaeb0351b5bfcb5a13f32fc7db6dd6910">perimeter_num</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many perimeters this surface has. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#acc3b9eeea7bf58fb69045e5bd6637923">planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, double &amp;deviation) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the surface is planar or not.  <a href="#acc3b9eeea7bf58fb69045e5bd6637923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aa032285269007009b16280e2365dd561">planar</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox, double tol, int *divideU=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if part of the surface is planar or not within the tolerance tol.  <a href="#aa032285269007009b16280e2365dd561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a86d52b54748f9b6e1813ccb2684c0534">reduce</a> (int is_u, int ndec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the B-Rep by decreasing B-Rep dimension by ndec.  <a href="#a86d52b54748f9b6e1813ccb2684c0534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a804bcebd682e36db2e110609e0795774">refine</a> (const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;uknot, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;vknot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change an original B-Rep to new one with subdivided knot configuration.  <a href="#a804bcebd682e36db2e110609e0795774"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#abde55a27be0c01339e3c0dd3738d260c">remove_knot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot.  <a href="#abde55a27be0c01339e3c0dd3738d260c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ab4147d7e5e38796a28aa6d449f647655">remove_knot_one</a> (double line0, size_t id, double &amp;tol, bool u_knot=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uノットを一つ削除する 関数の戻り値は削除したノットの数  <a href="#ab4147d7e5e38796a28aa6d449f647655"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67beadf2c802223df6fd27bd1693394"></a><!-- doxytag: member="MGSBRep::sdim" ref="ae67beadf2c802223df6fd27bd1693394" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ae67beadf2c802223df6fd27bd1693394">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a3a4d045515d9884c96c7c8e0d2e38920">shrink_to_knot</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbx, int multiple=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shrink this surface to the part limitted by the parameter range of uvbx.  <a href="#a3a4d045515d9884c96c7c8e0d2e38920"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f28c085a5a0382a091e08c8bc0a8d62"></a><!-- doxytag: member="MGSBRep::surface_bcoef" ref="a5f28c085a5a0382a091e08c8bc0a8d62" args="() const " -->
const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a5f28c085a5a0382a091e08c8bc0a8d62">surface_bcoef</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7889f98a83d5c17e37497f1aeeb71c49"></a><!-- doxytag: member="MGSBRep::surface_bcoef" ref="a7889f98a83d5c17e37497f1aeeb71c49" args="()" -->
<a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a7889f98a83d5c17e37497f1aeeb71c49">surface_bcoef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the B-coef's. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a8e958688c5c4c90faf0f7316c2968568">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute surface integral of the 1st two coordinates.  <a href="#a8e958688c5c4c90faf0f7316c2968568"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#aa9d16b43c4103c57098272404f4a114a">unlimit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ｌｉｍｉｔをはずす。 Unlimit the parameter range.  <a href="#aa9d16b43c4103c57098272404f4a114a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97f135be6907bcb48571ebecb6be5a51"></a><!-- doxytag: member="MGSBRep::out_to_IGES" ref="a97f135be6907bcb48571ebecb6be5a51" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a97f135be6907bcb48571ebecb6be5a51">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IGES output function. PD128(NURBS Surface). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a181fa54e5b88283689bc22e4fe7999"></a><!-- doxytag: member="MGSBRep::out" ref="a7a181fa54e5b88283689bc22e4fe7999" args="(std::ostream &amp;) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a7a181fa54e5b88283689bc22e4fe7999">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug Function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35ca494ce983d759107e546f573600f1"></a><!-- doxytag: member="MGSBRep::whoami" ref="a35ca494ce983d759107e546f573600f1" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a9c2124c50a7825444f437ac785221857">isectSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox=mgNULL_BOX) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Surface and a straight line.  <a href="#a9c2124c50a7825444f437ac785221857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1b42701ff1bea064186ba0b4d45d29f"></a><!-- doxytag: member="MGSBRep::ReadMembers" ref="af1b42701ff1bea064186ba0b4d45d29f" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#af1b42701ff1bea064186ba0b4d45d29f">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 戻り値boolは正常に読み出しが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac94690e87ffc482cf491c58ded10b744"></a><!-- doxytag: member="MGSBRep::WriteMembers" ref="ac94690e87ffc482cf491c58ded10b744" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ac94690e87ffc482cf491c58ded10b744">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 戻り値boolは正常に書き込みが出来ればtrue、失敗すればfalseになる ここでは処理対象となるデータメンバが無いので何も処理をしない。 <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe000bc8a2d7a96c44aedb2bbe2f1280"></a><!-- doxytag: member="MGSBRep::MGSurface" ref="afe000bc8a2d7a96c44aedb2bbe2f1280" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#afe000bc8a2d7a96c44aedb2bbe2f1280">MGSurface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34b42d89477ab4b7baff30f024b10b2d"></a><!-- doxytag: member="MGSBRep::MGRSBRep" ref="a34b42d89477ab4b7baff30f024b10b2d" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a34b42d89477ab4b7baff30f024b10b2d">MGRSBRep</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#a53e1bd22651d2cae915aef47079682e2">operator*</a> (double scale, const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;sb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling.  <a href="#a53e1bd22651d2cae915aef47079682e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_s_b_rep.html#ad9c41bfaeb9737623047492642f46607">build_SBRep_1direction</a> (<a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;endc, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;utaui, const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;vtaui, const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;value, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tu, const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;tv, <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;brep, int &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">build_SBRep_1direction constructs <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> brep, by interpolating only u-direction.  <a href="#ad9c41bfaeb9737623047492642f46607"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines Surface B-Representation, that is , B-Spline surface. </p>
<p><a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> is a tensor product surface representation of <a class="el" href="class_m_g_l_b_rep.html" title="MGLBRep is a class for B-SPline representation.">MGLBRep</a>. It has: (1) Surface control polygon <a class="el" href="class_m_g_s_point_seq.html" title="Defines Spoint seq of a space dimension and of a size.">MGSPointSeq</a> surface_bcoef. (2) U direciton knot vector <a class="el" href="class_m_g_knot_vector.html" title="Defines Knot vector of B-Representation.">MGKnotVector</a> uknot. (3) V direction knot vector <a class="el" href="class_m_g_knot_vector.html" title="Defines Knot vector of B-Representation.">MGKnotVector</a> vknot. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae2cfab6e59c69d6e41a6e00345e6320e"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="ae2cfab6e59c69d6e41a6e00345e6320e" args="(const MGSPointSeq &amp;vertex, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep by providing raw data of Surface B-Rep. </p>
<p>This is the fundamental constructor.***** </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>Control Vertex of Surface B-Rep </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa233ed383330d6b356e2f21ea8ba1aaa"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="aa233ed383330d6b356e2f21ea8ba1aaa" args="(const MGSPointSeq &amp;points, int &amp;error, unsigned orderu=4, unsigned orderv=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>orderu</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>orderv</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep by intepolation from Point data only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderu</em>&nbsp;</td><td>Order of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderv</em>&nbsp;</td><td>Order of v-direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb9d6fb73b6f4de241a4972f92cef425"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="abb9d6fb73b6f4de241a4972f92cef425" args="(const MGNDDArray &amp;utau, const MGNDDArray &amp;vtau, const MGSPointSeq &amp;points, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep of any order number by interpolation from data point, point data , and knot vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>utau</em>&nbsp;</td><td>Data point abscissa of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtau</em>&nbsp;</td><td>Data point abscissa of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07264c114a9a64433b7df49154170860"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a07264c114a9a64433b7df49154170860" args="(const MGSBRepTP &amp;tp, const MGNDDArray &amp;utau, const MGNDDArray &amp;vtau, const MGVector uvec[4], const MGVector vvec[4], const MGSPointSeq &amp;points, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td>
          <td class="paramname"> <em>uvec</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td>
          <td class="paramname"> <em>vvec</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep of order 4 by interpolation from Point data and tangent plane end condition. </p>
<p>Inner point must be homogeneous, should not include first derivative inf. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>Tangent Planeend condition of Tangent Plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>utau</em>&nbsp;</td><td>Data point of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtau</em>&nbsp;</td><td>Data point of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Tangent vector of u-direction for v=min and v=max boundary line. uvec[0], uvec[1]: start and end of v=min line uvec[2], uvec[3]: end and start of v=max line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vvec</em>&nbsp;</td><td>Tangent vector of v-direction for u=min and u=max boundary line. vvec[0]:start of u=min line, vvec[1]:start of u=max line vvec[2]: end of u=max line, vvec[3]: end of u=min. It is allowed that uvec[i] or vvec[j] is null vector(i.e. sdim==0). When this is the case, it means no inf provided about the tangent vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f2393f11fb89e9f950baba96b01b5dc"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a9f2393f11fb89e9f950baba96b01b5dc" args="(MGSBRepEndC &amp;endc, const MGNDDArray &amp;utaui, const MGNDDArray &amp;vtaui, const MGSPointSeq &amp;value, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep of order 4 by interpolation from Point data and end condition. </p>
<p>Inner point may include first derivative inf if the corresponding data points are multiple. For perimeters, utaui and vtaui do not have multiplicity. However, if utaui or vtaui has multiplicity at inner point, this means 1st derivative data is provided for the associated value, i.e.: If utaui has multiplicity 2 as utaui(i)=utaui(i+1), value(i,.,.) is 1st derivative along u direction at utaui(i) and value(i+1,.,.) is positional data at utaui(i)(=utaui(i+1)). If utaui has multiplicity 3 as utaui(i)=utaui(i+1)=utaui(i+2), value(i,.,.) is 1st derivative along u direction at utaui(i)- , value(i+1,.,.) is positional data at utaui(i)(=utaui(i+1)), value(i+2,.,.) is 1st derivative along u direction at utaui(i)+. Maximum multiplicity allowed is 3. About vtaui, the same. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endc</em>&nbsp;</td><td>Derivative Inf.end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>utaui</em>&nbsp;</td><td>Data point of u-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtaui</em>&nbsp;</td><td>Data point of v-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b2fe3370a01af86f2636941f75ac534"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a3b2fe3370a01af86f2636941f75ac534" args="(MGSBRepEndC &amp;endc, size_t orderu, size_t orderv, const MGNDDArray &amp;utaui, const MGNDDArray &amp;vtaui, const MGSPointSeq &amp;value, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>orderu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>orderv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep of specified order by interpolation from Point data and end condition. </p>
<p>Inner points must not include first derivative inf and the data points must not be multiple if the order is not 4. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endc</em>&nbsp;</td><td>Derivative Inf.end condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderv</em>&nbsp;</td><td>order along u or v direction, must be greater than or equal to 4. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>utaui</em>&nbsp;</td><td>Data point of u-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtaui</em>&nbsp;</td><td>Data point of v-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63b3892dfd1c0e88631ec6b117a75a32"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a63b3892dfd1c0e88631ec6b117a75a32" args="(MGSBRepEndC &amp;endc, const MGNDDArray &amp;utaui, const MGNDDArray &amp;vtaui, const MGSPointSeq &amp;value, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep by interpolation from Point data and end condition with knot vector. </p>
<p>This is a general version of: <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a>( ///Derivative Inf. <a class="el" href="class_m_g_s_b_rep_end_c.html" title="Defines End Condition of Surface B-Representation.">MGSBRepEndC</a>&amp; endc, ///end condition const <a class="el" href="class_m_g_n_d_d_array.html" title="Defines non-decreasing double data array.">MGNDDArray</a>&amp; utaui, ///Data point of u-direction of value const <a class="el" href="class_m_g_n_d_d_array.html" title="Defines non-decreasing double data array.">MGNDDArray</a>&amp; vtaui, ///Data point of v-direction of value const <a class="el" href="class_m_g_s_point_seq.html" title="Defines Spoint seq of a space dimension and of a size.">MGSPointSeq</a>&amp; value, ///Data point ordinate int &amp;error); ///Error flag. The difference is to provide or not knot vector tu and tv. (utaui(i),vtaui(j),value(i,j)) is one pair of data, for 0&lt;=i&lt;=utaui.lenght(), 0&lt;=j&lt;=vtaui.lenghth(). Knot vector tu and tv must satisfy Schoenberg-Whitney consdition, i.e. t(i)&lt;tau(i)&lt;t(i+k) for all i, where k=order. If not, error=2 will be returned. (t=tu, tau=utaui+multiplicity included at both ends according to endc, for udirection. About v, the same) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endc</em>&nbsp;</td><td>Derivative Inf and Knot Vectorend condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>utaui</em>&nbsp;</td><td>Data point of u-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtaui</em>&nbsp;</td><td>Data point of v-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a862a54c83ff988de52244cb379f92ad1"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a862a54c83ff988de52244cb379f92ad1" args="(const MGLBRep &amp;lbrep, const MGUnit_vector &amp;uvec, double start_dist, double end_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lbrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep by sweep B-Rep and sweep length. </p>
<p>The sweep surface is defined as: lbrep(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lbrep</em>&nbsp;</td><td>Sweep crv. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76f5fd41d5ecdd6e700e92dd6a01052a"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a76f5fd41d5ecdd6e700e92dd6a01052a" args="(const MGNDDArray &amp;utau, const MGNDDArray &amp;vtau, const MGSPointSeq &amp;value, size_t orderu=4, size_t orderv=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>orderu</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>orderv</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep of specified order by interpolation from Point data. </p>
<p>This is an easy-to-version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>utau</em>&nbsp;</td><td>Derivative Inf.Data point of u-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtau</em>&nbsp;</td><td>Data point of v-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderv</em>&nbsp;</td><td>order along u or v direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9fa5d6c88d7fb2a8bdcb59d6af096a7"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="ab9fa5d6c88d7fb2a8bdcb59d6af096a7" args="(const MGStraight &amp;st, const MGUnit_vector &amp;uvec, double start_dist, double end_dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>start_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>end_dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep by sweep Straight and sweep length. </p>
<p>The sweep surface is defined as: st(say c(t)) is the rail and the straight line segments from C(t)+start_dist*uvec to C(t)+end_dist*uvec are the generatrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>Sweep crv. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvec</em>&nbsp;</td><td>Sweep Direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_dist</em>&nbsp;</td><td>distance to start edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_dist</em>&nbsp;</td><td>distance to end edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaeb9ccea9077fd253b470606c43941ef"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="aaeb9ccea9077fd253b470606c43941ef" args="(const MGNDDArray &amp;tau, const std::vector&lt; MGLBRep * &gt; &amp;lines, const MGLBRep *deriS, const MGLBRep *deriE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *&nbsp;</td>
          <td class="paramname"> <em>deriS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> *&nbsp;</td>
          <td class="paramname"> <em>deriE</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct Surface B-rep from lines and derivatives. </p>
<p>Interpolation will be done only along one parameter direction, along v. tau provides data point sequence along v direction of surface (u,v) parameter configuration. deriS and deriE are used to provide the 1st derivative B-representation along the perimeter 0 and 2, may be null if 1st derivative B-rep is not provided. If derivative B-rep is provided, deriS and deriE must have the same knot configuration as the one of lines which makes u kont configuration of this surface (u,v) parameter. tau[i] is the parameter for lines[i]. </p>

</div>
</div>
<a class="anchor" id="a4e49646f16d18dae445049f7db8b075c"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a4e49646f16d18dae445049f7db8b075c" args="(const MGSBRep &amp;old_brep, const MGKnotVector &amp;ut, const MGKnotVector &amp;vt, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate an original B-Rep by a new knot configuration. </p>
<p>The new knot config must be inside the range of the original B-Rep parameter. However new knots may be coarse or fine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ut</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vt</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a538179d710af3b5a7b798e96a9aff963"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a538179d710af3b5a7b798e96a9aff963" args="(const MGNDDArray &amp;utau, const MGNDDArray &amp;vtau, const MGSPointSeq &amp;points, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv, const MGSPointSeq &amp;weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>weight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain Surface B-Rep by Least square approximation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>utau</em>&nbsp;</td><td>Data point abscissa of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtau</em>&nbsp;</td><td>Data point abscissa of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>Weight for each point(space dimension 1). weight(i,j,0) is the weight for points(i,j,.). When weight(i,j,0) is large compared with other weights, the deviation from the surface at (utau(i),vtau(j)) is small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b508f45bc7bde1668bb59e5c3f06abf"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a0b508f45bc7bde1668bb59e5c3f06abf" args="(const MGNDDArray &amp;utau, const MGNDDArray &amp;vtau, const MGSPointSeq &amp;points, const MGSPointSeq &amp;dp, double deviation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>deviation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain Surface B-Rep by Shoenberg and Reinch's smoothing function If dp(i,j,0) becomes bigger, deviation at (utau(i),vtau(j)) becomes bigger. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>utau</em>&nbsp;</td><td>Data point abscissa of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtau</em>&nbsp;</td><td>Data point abscissa of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>Point seq data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dp</em>&nbsp;</td><td>Error estimate for each point(space dimension 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>Mean deviation of each point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad92ae80201a885784c61ca75a4094e44"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="ad92ae80201a885784c61ca75a4094e44" args="(const MGCurve *edge_crvl[4], const MGCurve &amp;blendCrvU, const MGCurve &amp;blendCrvV, const MGSBRepTP &amp;tp, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>edge_crvl</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>blendCrvU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>blendCrvV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>4本の境界線、ブレンド関数、接続面を与えて面を生成する。 境界線はvmin,umax,vmax,uminの順で、vmin,vmaxの向きをuminからumaxの方向に umin,umaxの向きをvminからvmaxの方向になっているものとする。境界線のノットベクトル をあわせるときの誤差はline_zero()を使用している。ブレンド曲線はパラメータ範囲0,1 で値域も0,1である。接続面(<a class="el" href="class_m_g_s_b_rep_t_p.html" title="Defines Tangent Plane Line B-Representation Class.">MGSBRepTP</a>)のパラメータ範囲は各境界線と同じとする。 エラーコード： 0: 正常終了 -1: 境界線がC1連続でなかった -2: 接続面のパラメータ範囲が境界線と違った -3: 境界線のノットベクトルをあわせられなかった -4: 接続面のパラメータ範囲を変更できなかった -5: 点列が求まらなかった -6: 端末条件が求まらなかった -7: 面が生成できなかった </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge_crvl</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blendCrvU</em>&nbsp;</td><td>空間次元1のu方向のブレンド曲線(パラメータ、値域ともに0,1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blendCrvV</em>&nbsp;</td><td>空間次元1のv方向のブレンド曲線(パラメータ、値域ともに0,1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>接続面(パラメータ範囲は境界線と同じ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af468572253940b092b756e8c7b7dbd95"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="af468572253940b092b756e8c7b7dbd95" args="(MGPvector&lt; MGLBRep &gt; &amp;edges, int &amp;error, const MGCurve *blendCrvU=0, const MGCurve *blendCrvV=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>blendCrvU</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>blendCrvV</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Easy to use version of the above constructor. </p>
<p>When blendCCrvU,V were null, straight line from 0. to 1. will be used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edges</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコードが出力される（0:正常終了） </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blendCrvU</em>&nbsp;</td><td>空間次元1のu方向のブレンド曲線(パラメータ、値域ともに0,1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blendCrvV</em>&nbsp;</td><td>空間次元1のv方向のブレンド曲線(パラメータ、値域ともに0,1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a173e28454d181fe0e4885f1c1ec80f26"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a173e28454d181fe0e4885f1c1ec80f26" args="(const MGCurve *edge_crvl[4], const MGSBRepTP &amp;tp, int &amp;error, const double *alpha=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>edge_crvl</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep_t_p.html">MGSBRepTP</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>alpha</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge_crvl</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tp</em>&nbsp;</td><td>接続面(パラメータ範囲は境界線と同じ) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>derivative magnitude coefficients for perimeter i in alpha[i]. =1. is normal, if&lt;1., curvature will be made large, and if&gt;1. curvature will be made small. If alpha=null, all of the coefs are assumed to be 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85b452e7f68ba75e5537d819d521f2ec"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a85b452e7f68ba75e5537d819d521f2ec" args="(bool along_u, const MGPvector&lt; MGLBRep &gt; &amp;perimeters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>along_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>perimeters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generalized ruled surface construction. </p>
<p>Build a surface by ruled surface method. That is, costruct a surface by sliding the blending curve(a tie curve of the rails) of perimeters 3 and 1 along perimeter 0 and 2(0 and 2 make the rail). Or by sliding the blending curve of perimeter 0 and 2 along perimeter 3 and 1(3 and 1 make the rail). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>along_u</em>&nbsp;</td><td>indicates which perimeters make a rail. if true, perimeter 0 and 2, if false, perimeter 3 and 1 make rail. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perimeters</em>&nbsp;</td><td>境界線リスト(vmin,umax,vmax,uminの順,辺番号0,1,2,3の順) perimeters must be the same knot configuration along u(perimeter 0 and 2) and along v(perimeter 3 and1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5007d5153cbd4247d4e1af19e7df4d2d"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a5007d5153cbd4247d4e1af19e7df4d2d" args="(const MGSBRep &amp;old_brep, const MGKnotArray &amp;uknots, const MGKnotArray &amp;vknots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uknots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_array.html">MGKnotArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vknots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new B-Rep by adding knots to an original B-Rep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uknots</em>&nbsp;</td><td>Knots to add for u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vknots</em>&nbsp;</td><td>Knots to add for v-direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39ee6c2b8512978301756c55b45284b2"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a39ee6c2b8512978301756c55b45284b2" args="(const MGSBRep &amp;brep1, int which1, int continuity, const MGSBRep &amp;brep2, int which2, int opposite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>continuity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opposite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets new B-Rep by connecting two B-Rep to one. </p>
<p>The parameter (which1,continuity,which2,opposite) can be obtained by public function continuity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brep1</em>&nbsp;</td><td>B-Rep 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which1</em>&nbsp;</td><td>which perimeter of brep1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>continuity</em>&nbsp;</td><td>continuity. Must &gt;=0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>B-Rep 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which2</em>&nbsp;</td><td>which perimeter of brep2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opposite</em>&nbsp;</td><td>Input if parameter direction of which2 is the same as which1 along common edge. If opposite is true, the direction is opposite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac126c3e8dc53f49a8f5edcc94c3ddc6f"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="ac126c3e8dc53f49a8f5edcc94c3ddc6f" args="(const MGBox &amp;uvrange, const MGSBRep &amp;old_brep, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>old_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain partial Surface B-Rep restricted by sub interval of u and v parameter range. </p>
<p>If multiple==true(!=0), knot_u(i)=t1 and knot_u(n+i)=t2 for i=0,..., k-1 will be guaranteed. Here, n=bdim_u(), k=order_u(), t1=uvrange(0).low_point(), and t2=uvrange(0).high_point(). About knot_v(j), the same. Both u-range and v-range must be inside the range of old_brep. Gets new B-Rep by computing a part of the original. New one is exactly the same as the original except that it is partial. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvrange</em>&nbsp;</td><td>u and v parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_brep</em>&nbsp;</td><td>Original B-Rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae316adba40f732c5b9d0d860875018af"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="ae316adba40f732c5b9d0d860875018af" args="(size_t dim, const MGSBRep &amp;sbrep, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sbrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Surface B-Rep by changing space dimension and ordering of coordinates. </p>
<p>Source order of original Surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sbrep</em>&nbsp;</td><td>Original Surface B-rep. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new Surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbe6a5b647d9e870fd0ea9ea8915a29b"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="acbe6a5b647d9e870fd0ea9ea8915a29b" args="(const MGPlane &amp;plane, const MGBox &amp;prange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prange</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Surface B-Rep (order = 2 ) from Plane and Parameter ranges. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Original Plane </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prange</em>&nbsp;</td><td>parameter range of new Surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a48eb9f24d424c7fd45dfa0c2cc5395"></a><!-- doxytag: member="MGSBRep::MGSBRep" ref="a9a48eb9f24d424c7fd45dfa0c2cc5395" args="(const std::vector&lt; const MGCurve * &gt; &amp;curves, bool direction_adjustment=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGSBRep::MGSBRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_m_g_curve.html">MGCurve</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>direction_adjustment</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>リブ曲線列から面を作成する 作成する面のノットベクトルはリブ曲線の向きをu,リブ列方向をvとする This constructor only generates <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> even if curves are <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> of the same knot configuration. </p>
<p>To avoid this, use createSurfaceFromRibs() that generates <a class="el" href="class_m_g_r_s_b_rep.html" title="Defines Surface B-Representation of rational form.">MGRSBRep</a> when curves are <a class="el" href="class_m_g_r_l_b_rep.html" title="Defines Rational Line B-Representation.">MGRLBRep</a> of the same knot configuration. Let v0=start parameter value, v1=terminate parameter value along v, then v=v0 const parameter line is curves[0], and v=v1 const parameter line is curves[n-1], where n=curves.size(). n must be greater or equal to 2. When n==2, the surface is a ruled surface(that is, this-&gt;<a class="el" href="class_m_g_s_b_rep.html#aba62d612409e752770c07fc89eb2931a" title="Returns the B-Rep order(u-direction).">order_u()</a> is 2). When direction_adjustment=true, curves[i] directions are adjusted to line up to the same direciton as the curves[i-1]'s. When direction_adjustment=false, no curves of curves[i] are negated and the directions of curves[i] are the direcitons of ribs. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a018e6a13d0d677762c4619e5c5325d05"></a><!-- doxytag: member="MGSBRep::bdim_u" ref="a018e6a13d0d677762c4619e5c5325d05" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGSBRep::bdim_u </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身の曲面の全体の面積を返却する。 Compute total surface area. </p>
<p>double area () const; 与えられたパラメータ範囲の曲面の面積を返す。 Compute surface area limitted by parameter range box. double area(const MGBox&amp; box) const; Returns B-Rep Dimension of u. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a48f250dd11dac3e4d15120659bbdc784"></a><!-- doxytag: member="MGSBRep::change_dimension" ref="a48f250dd11dac3e4d15120659bbdc784" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ab37b86c29caed93258a98d7e70459d4e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f399399a134367ee989fe1c4a3a791"></a><!-- doxytag: member="MGSBRep::change_range" ref="ac7f399399a134367ee989fe1c4a3a791" args="(int is_u, double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::change_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, (t1,t2) are u-value. if not, v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a1d4365d58c465f916b2fb038ef896b2d">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f88bcf91d300945c3a2dc1e6c08d1f"></a><!-- doxytag: member="MGSBRep::clone" ref="ad9f88bcf91d300945c3a2dc1e6c08d1f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>* MGSBRep::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a55ce6580673b46480f6ae5a8d2117c17">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="af63746371dcafbbfae08fb13a5d271a7"></a><!-- doxytag: member="MGSBRep::continuity" ref="af63746371dcafbbfae08fb13a5d271a7" args="(const MGSBRep &amp;brep2, int &amp;which1, int &amp;which2, int &amp;opposite, double &amp;ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSBRep::continuity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>which1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>which2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>opposite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute continuity with brep2. </p>
<p>Function's return value is: -1: G(-1) continuity, i.e. two surfaces are discontinuous. 0: G0 continuity, i.e. two surfaces are connected, but tangents are discontinuous 1: G1 continuity, i.e. two surfaces are connected, and tangents are also continuous. 2: G2 continuity, i.e. two surfaces are connected, and tangents and curvatures are also continuous. Reuturn value is the continuity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>brep2</em>&nbsp;</td><td>Input second SBRep </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which1</em>&nbsp;</td><td>Outputs which perimeter(which1) of this is </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which2</em>&nbsp;</td><td>connected to which(which2) of brep2. These are valid only when continuity&gt;=0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opposite</em>&nbsp;</td><td>Outputs if parameter direction of which2 is the same as which1 along common edge. If opposite is true, the direction is opposite. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio</em>&nbsp;</td><td>Ratio of 1st derivatives of the two surfaces will be returned. ratio= d2/d1, where d1=1st deriv of this and d2=of brep2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb5372526064576308dcf992540bbfdb"></a><!-- doxytag: member="MGSBRep::copy_change_dimension" ref="abb5372526064576308dcf992540bbfdb" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>* MGSBRep::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a0cf87d2f42a919c9f5bc44cc406ea0fd">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8f34a9e4dcccaed411c7d90c106e4b82"></a><!-- doxytag: member="MGSBRep::divide_multi_knot" ref="a8f34a9e4dcccaed411c7d90c106e4b82" args="(MGPvector&lt; MGSurface &gt; &amp;srfl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSBRep::divide_multi_knot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srfl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>uまたはv方向に折れ(マルチノット)があるとき面を分割する 戻り値は、分割数を返却する </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srfl</em>&nbsp;</td><td>分割した曲面リスト </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a27fdd1ff58f14d6ee6691f711d3bd039">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a16d04d8d8da3f8068ee958c93a0f02a9"></a><!-- doxytag: member="MGSBRep::eval" ref="a16d04d8d8da3f8068ee958c93a0f02a9" args="(double u, double v, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGSBRep::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous ndu'th and ndv'th derivative data. </p>
<p>Function's return value is (d(ndu+ndv)f(u,v))/(du**ndu*dv**ndv). ndu=0 and ndv=0 means positional data evaluation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of Derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of Derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a4a84a30a177df8c06d2e692968f43323"></a><!-- doxytag: member="MGSBRep::eval" ref="a4a84a30a177df8c06d2e692968f43323" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGSBRep::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aeb2412bdf35040de594328cb89af4e36"></a><!-- doxytag: member="MGSBRep::eval_all" ref="aeb2412bdf35040de594328cb89af4e36" args="(double u, double v, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data and 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8153b4db02d3056377d79f43254d11e5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aab079a6e12665170ae36aaf3997129e7"></a><!-- doxytag: member="MGSBRep::eval_all" ref="aab079a6e12665170ae36aaf3997129e7" args="(double u, double v, size_t ndu, size_t ndv, double *deriv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSBRep::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>deriv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate all of derivative data (d(i+j)f(u,v))/(du**i*dv**j), for 0&lt;=i&lt;=ndu and 0&lt;=j&lt;=ndv. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of Derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of Derivative along v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deriv</em>&nbsp;</td><td>Output. (d(i+j)f(u,v))/(du**i*dv**j) in deriv[r+j*dim+i*(ndv+1)*dim] for 0&lt;=r&lt;dim=sdim(). for 0&lt;=i&lt;=ndu and 0&lt;=j&lt;=ndv. deriv is an array of deriv[ndu+1][ndv+1][r], (d(i+j)f(u,v))/(du**i*dv**j) is returned in deriv[i][j][r]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01ce7a44e3db215c5ae1522b094b864a"></a><!-- doxytag: member="MGSBRep::extend" ref="a01ce7a44e3db215c5ae1522b094b864a" args="(int perimeter, double param, double length, double dk=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>perimeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original Surface by extrapolating the specified perimeter. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. The extrapolation is done so that extrapolating length is "length" at the position of the parameter value "param" of the perimeter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perimeter</em>&nbsp;</td><td>perimeter number of the Surface. =0:v=min, =1:u=max, =2:v=max, =3:u=min. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of above perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend at the parameter param of the perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at extrapolation start point. When dk=0, curvature keeps same, i.e. dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point. (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ab52fd64da1afa26965f381962edf0f75">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a073cb00a4408a1a0708bea855a73786a"></a><!-- doxytag: member="MGSBRep::isect" ref="a073cb00a4408a1a0708bea855a73786a" args="(const MGSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGSBRep::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Surface の交線を求める。 Surface and Surface intersection. </p>
<p>Compute intersectio line(s) of two surface. Restriction:Currently if two surface do not have intersection on any of 4 perimeters, this function does not compute surface to surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a3d84645dc04d80bb2ff1df214f3a3b9b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9c2124c50a7825444f437ac785221857"></a><!-- doxytag: member="MGSBRep::isectSl" ref="a9c2124c50a7825444f437ac785221857" args="(const MGStraight &amp;sl, const MGBox &amp;uvbox=mgNULL_BOX) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGSBRep::isectSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em> = <code>mgNULL_BOX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Surface and a straight line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>indicates if this surface is restrictied to the parameter range of uvbox. If uvbox.is_null(), no restriction. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aa0bd5720dfdbf979fa89054b785014ce">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8ebd913bf938f6c5af66874066f38339"></a><!-- doxytag: member="MGSBRep::less_than" ref="a8ebd913bf938f6c5af66874066f38339" args="(size_t i, const MGPosition &amp;uv1, const MGPosition &amp;uv2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGSBRep::less_than </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two parameter values. </p>
<p>If uv1 is less than uv2, return true. Comparison is done after prjected to i-th perimeter of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv1</em>&nbsp;</td><td>perimeter number. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ae1325fe2f42237e3348d410e5de8c700">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="afa4fb57d74fb852dc9583c8f72ac02c0"></a><!-- doxytag: member="MGSBRep::limit" ref="afa4fb57d74fb852dc9583c8f72ac02c0" args="(const MGBox &amp;uvrange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>自身に指定したパラメータ範囲のlimitをつける。 Update this by limitting the parameter range. </p>
<p>uvrange is parameter value range of (umin, vmin) to (umax, vmax). </p>

</div>
</div>
<a class="anchor" id="af6428cb8ecc8529e259097d4ff52b80d"></a><!-- doxytag: member="MGSBRep::move" ref="af6428cb8ecc8529e259097d4ff52b80d" args="(int move_kind_u, int move_kind_v, const MGPosition &amp;move_point_param, const MGPosition &amp;to_point, const MGPosition fix_point[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::move </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>move_kind_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>move_kind_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>move_point_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>to_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td>
          <td class="paramname"> <em>fix_point</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original Surface by moving move_point to to_point. </p>
<p>fix_point can be applied according to move_kind. move_kind_u and _v mean as below for u and v direction: move_kind=1: Start and end perimeter of the surface are fixed. The surface is modified linearly so that move_point_param line is the maximum move. =2: The parameter line fix_point[0] is fixed and the other end of the move_point_param side is moved. In this case, maximum move is the end perimeter of the surface. =3: fix_point[0]&lt;move_point_param&lt;fix_point[1], and two parameter line fix_point[.] are fixed. The surface is modified linearly so that move_point_param point is the maximum move. otherwise: Two fix parameter line fix_point[.] are computed so that the modify range is the minimum. Other move is same as move_kind=3. Restriction: For the case move_kind=3, actual fix parameter line is wider than specified range. The range is the smallest one possible including fix_point[]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>move_kind_u</em>&nbsp;</td><td>Indicates how to move Surface for u direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>move_kind_v</em>&nbsp;</td><td>Indicates how to move Surface for v direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>move_point_param</em>&nbsp;</td><td>indicate object point to move by the (u,v) parameter value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to_point</em>&nbsp;</td><td>destination point(x,y,z coordinates) of the abve source point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fix_point</em>&nbsp;</td><td>(u,v) parameter value pair. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4c0fe6bd2ca1ffac3f3241b7a4eeef9"></a><!-- doxytag: member="MGSBRep::negate" ref="ab4c0fe6bd2ca1ffac3f3241b7a4eeef9" args="(int is_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSBRep::negate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change direction of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Negate along u-direction if is_u is ture, else along v-direction. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a5f1ebb47122de32a0f5702f160a51d2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a5b8f6820b247df8d77802b08b73e4004"></a><!-- doxytag: member="MGSBRep::negate_param" ref="a5b8f6820b247df8d77802b08b73e4004" args="(const MGPosition &amp;uv, int is_u=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGSBRep::negate_param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter value if this surface is negated by "negate()". </p>
<p>Negate along u-direction if is_u is ture, else along v-direction. </p>

</div>
</div>
<a class="anchor" id="a59a263722c7ea8a4b52798cc88230838"></a><!-- doxytag: member="MGSBRep::operator*" ref="a59a263722c7ea8a4b52798cc88230838" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> MGSBRep::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling. </p>

</div>
</div>
<a class="anchor" id="a17550f47fad56628bf20559872332192"></a><!-- doxytag: member="MGSBRep::operator*" ref="a17550f47fad56628bf20559872332192" args="(const MGMatrix &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> MGSBRep::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲面の変換を行いオブジェクトを生成する。 Matrix transformation. </p>

</div>
</div>
<a class="anchor" id="ad960da049c90ab3374af00f599a7f343"></a><!-- doxytag: member="MGSBRep::operator*" ref="ad960da049c90ab3374af00f599a7f343" args="(const MGTransf &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> MGSBRep::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換で曲面のトランスフォームを行いオブジェクトを生成する。 General transformation. </p>

</div>
</div>
<a class="anchor" id="aa2774cdadb18ad0b9880a3ff40c1269b"></a><!-- doxytag: member="MGSBRep::operator+" ref="aa2774cdadb18ad0b9880a3ff40c1269b" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> MGSBRep::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面の平行移動を行いオブジェクトを生成する。 Translation. </p>

</div>
</div>
<a class="anchor" id="abf171e2171ed682c55620422757b83cc"></a><!-- doxytag: member="MGSBRep::operator&#45;" ref="abf171e2171ed682c55620422757b83cc" args="(const MGVector &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> MGSBRep::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面の逆方向に平行移動を行いオブジェクトを生成する。 Translation. </p>

</div>
</div>
<a class="anchor" id="a1e088e9f9ae5c1aa971908eca7eac2d4"></a><!-- doxytag: member="MGSBRep::operator=" ref="a1e088e9f9ae5c1aa971908eca7eac2d4" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor ‾MGSBRep(); ///We can use default destructor. </p>
<p>Assignment. When the leaf object of this and srf2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a6ab8517d3fb63eddcc8b1a8bb1545174"></a><!-- doxytag: member="MGSBRep::param_range" ref="a6ab8517d3fb63eddcc8b1a8bb1545174" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGSBRep::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae481076c37271c9835c1d138bda2d99a"></a><!-- doxytag: member="MGSBRep::parameter_curve" ref="ae481076c37271c9835c1d138bda2d99a" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSBRep::parameter_curve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter curve. </p>
<p>Returned is newed area pointer, and must be freed by delete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a470c01ec42c6e71b6c34601cc558ec96">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a445acc7ccbf12f84d9548f56b757a6eb"></a><!-- doxytag: member="MGSBRep::parameter_line" ref="a445acc7ccbf12f84d9548f56b757a6eb" args="(int is_u, double x, unsigned nderiv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> MGSBRep::parameter_line </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderiv</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a178ba8ec9ffc350fd488f3b4ed4301d8"></a><!-- doxytag: member="MGSBRep::part" ref="a178ba8ec9ffc350fd488f3b4ed4301d8" args="(const MGBox &amp;uvbx, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>* MGSBRep::part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of the surface limitted by the parameter range uvbx. </p>
<p>uvbx(0) is the parameter (us,ue) and uvbx(1) is (vs,ve). That is u range is from us to ue , and so on. Retured is newed object, must be deleted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a7a924b141ca6ea037545953c5e00d682">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a043b035bc6ab84bcc6fbd711b1848f7b"></a><!-- doxytag: member="MGSBRep::perimeter" ref="a043b035bc6ab84bcc6fbd711b1848f7b" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> MGSBRep::perimeter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perimeter line B-Rep. </p>
<p>i is perimeter number: =0: v=min line, =1: u=max line, =2: v=max line, =3: u=min line perimeter_curve returs newed object, must be deleted. </p>

</div>
</div>
<a class="anchor" id="a2fa92e4b8f76fb299d682d28b686713e"></a><!-- doxytag: member="MGSBRep::perimeter_curve" ref="a2fa92e4b8f76fb299d682d28b686713e" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGSBRep::perimeter_curve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve perimeter i of this surface. </p>
<p>i must be &lt; <a class="el" href="class_m_g_s_b_rep.html#aaeb0351b5bfcb5a13f32fc7db6dd6910" title="Return how many perimeters this surface has.">perimeter_num()</a>. When <a class="el" href="class_m_g_s_b_rep.html#aaeb0351b5bfcb5a13f32fc7db6dd6910" title="Return how many perimeters this surface has.">perimeter_num()</a>==0, this function is undefined. Retured is newed object, must be deleted. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a57c8bffdb617cf4ff7c654e2b080200c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="acc3b9eeea7bf58fb69045e5bd6637923"></a><!-- doxytag: member="MGSBRep::planar" ref="acc3b9eeea7bf58fb69045e5bd6637923" args="(MGPlane &amp;plane, double &amp;deviation) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSBRep::planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>deviation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the surface is planar or not. </p>
<p>Returned is 0(false) if this is not planar, 1(true) if this is planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Plane that might be closest to this. Plane is always output even if not planar. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>maximum deviation of this from the output plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa032285269007009b16280e2365dd561"></a><!-- doxytag: member="MGSBRep::planar" ref="aa032285269007009b16280e2365dd561" args="(const MGBox &amp;uvbox, double tol, int *divideU=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSBRep::planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>divideU</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if part of the surface is planar or not within the tolerance tol. </p>
<p>The part of the surface is input by the surface parameter range uvbox. Returned is 0(false) if this is not planar, 1(true) if planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>This surface parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>maximum deviation allowed to regard the sub surface as a plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>divideU</em>&nbsp;</td><td>Direction to subdivide will be output, if this was not planar, =1: u direction, =0: v direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86d52b54748f9b6e1813ccb2684c0534"></a><!-- doxytag: member="MGSBRep::reduce" ref="a86d52b54748f9b6e1813ccb2684c0534" args="(int is_u, int ndec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSBRep::reduce </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the B-Rep by decreasing B-Rep dimension by ndec. </p>
<p>This is an approximation of the origimal B-Rep. Return value is error flag. Number of B-rep dimension to decrease </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, reduce b-rep dimension of u-direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a804bcebd682e36db2e110609e0795774"></a><!-- doxytag: member="MGSBRep::refine" ref="a804bcebd682e36db2e110609e0795774" args="(const MGKnotVector &amp;uknot, const MGKnotVector &amp;vknot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a>&amp; MGSBRep::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uknot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vknot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change an original B-Rep to new one with subdivided knot configuration. </p>
<p>Knots t must be subdivided knots. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uknot</em>&nbsp;</td><td>new knot of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vknot</em>&nbsp;</td><td>new knot of v-direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abde55a27be0c01339e3c0dd3738d260c"></a><!-- doxytag: member="MGSBRep::remove_knot" ref="abde55a27be0c01339e3c0dd3738d260c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSBRep::remove_knot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ノット削除関数 トレランスはline_zeroを使用する。元のノットが細かいものほど削除しやすい removal knot. </p>
<p>line_zero tolerance is used. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a168a7c2b0732dc2d6e4f534371e4b12b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab4147d7e5e38796a28aa6d449f647655"></a><!-- doxytag: member="MGSBRep::remove_knot_one" ref="ab4147d7e5e38796a28aa6d449f647655" args="(double line0, size_t id, double &amp;tol, bool u_knot=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGSBRep::remove_knot_one </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>line0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>u_knot</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>uノットを一つ削除する 関数の戻り値は削除したノットの数 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line0</em>&nbsp;</td><td>Tolerance allowed for the knot removal. When line0&lt;=0., removal will be done uncoditionally. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>削除しようとするノットの番号 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>削除後の誤差が出力される </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u_knot</em>&nbsp;</td><td>削除対象が（u,v)のいずれのknot vectorかを入力する =trueのとき、u-knot_vectorを削除 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a4d045515d9884c96c7c8e0d2e38920"></a><!-- doxytag: member="MGSBRep::shrink_to_knot" ref="a3a4d045515d9884c96c7c8e0d2e38920" args="(const MGBox &amp;uvbx, int multiple=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGSBRep::shrink_to_knot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shrink this surface to the part limitted by the parameter range of uvbx. </p>
<p>New parameter range uvbx2 is so determined that uvbx2 is the smallest box tha includes uvbx, and all of the u or v values of uvbx2 is one of the values of u or v knots of the surface knotvector. uvbx(0) is the parameter (us,ue) and uvbx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a7bb84fd8e6434c9eabccd05675ddf2b5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8e958688c5c4c90faf0f7316c2968568"></a><!-- doxytag: member="MGSBRep::type" ref="a8e958688c5c4c90faf0f7316c2968568" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a> MGSBRep::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute surface integral of the 1st two coordinates. </p>
<p>(面積分）を求める。 This integral can be used to compute volume sorounded by the surface. double surface_integral(const MGBox&amp;) const; 曲面のタイプをを返す。 Return the surface type. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a83ad0b3f99b05d775a1d4d7352baf9d0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aa9d16b43c4103c57098272404f4a114a"></a><!-- doxytag: member="MGSBRep::unlimit" ref="aa9d16b43c4103c57098272404f4a114a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>&amp; MGSBRep::unlimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ｌｉｍｉｔをはずす。 Unlimit the parameter range. </p>
<p>Return the same. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ad9c41bfaeb9737623047492642f46607"></a><!-- doxytag: member="MGSBRep::build_SBRep_1direction" ref="ad9c41bfaeb9737623047492642f46607" args="(MGSBRepEndC &amp;endc, const MGNDDArray &amp;utaui, const MGNDDArray &amp;vtaui, const MGSPointSeq &amp;value, const MGKnotVector &amp;tu, const MGKnotVector &amp;tv, MGSBRep &amp;brep, int &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void build_SBRep_1direction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep_end_c.html">MGSBRepEndC</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>utaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_n_d_d_array.html">MGNDDArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vtaui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_point_seq.html">MGSPointSeq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>build_SBRep_1direction constructs <a class="el" href="class_m_g_s_b_rep.html" title="Defines Surface B-Representation, that is , B-Spline surface.">MGSBRep</a> brep, by interpolating only u-direction. </p>
<p>Input (utaui, tu) will make brep's v direction parameter, and (vtaui, tv) will make udirection parameter. That is, u and v will be exchanged for output brep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endc</em>&nbsp;</td><td>Derivative Inf and Knot Vectorend condition, only perimeter 3 and 1 are used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>utaui</em>&nbsp;</td><td>Data point of u-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vtaui</em>&nbsp;</td><td>Data point of v-direction of value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Data point ordinate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tu</em>&nbsp;</td><td>knot vector of u-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>knot vector of v-direction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brep</em>&nbsp;</td><td>constructed b-rep will be output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>Error flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53e1bd22651d2cae915aef47079682e2"></a><!-- doxytag: member="MGSBRep::operator*" ref="a53e1bd22651d2cae915aef47079682e2" args="(double scale, const MGSBRep &amp;sb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられたスケーリングで曲面の変換を行いオブジェクトを生成する。 Scaling. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SBRep.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:28 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

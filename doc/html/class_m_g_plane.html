<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGPlane Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGPlane Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGPlane" --><!-- doxytag: inherits="MGSurface" -->
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> is infinite plane in 3D space.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Plane.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGPlane:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_plane__inherit__graph.png" border="0" usemap="#_m_g_plane_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_plane_inherit__map" id="_m_g_plane_inherit__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="76,315,161,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node12" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="132,237,225,267"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGPlane:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_plane__coll__graph.png" border="0" usemap="#_m_g_plane_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_plane_coll__map" id="_m_g_plane_coll__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="289,600,375,629"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="192,501,291,531"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="167,405,247,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="163,85,269,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="72,181,149,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="185,5,247,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="55,293,167,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="5,85,139,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="271,405,337,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="263,293,345,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="265,181,343,211"/><area shape="rect" id="node26" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="315,501,408,531"/><area shape="rect" id="node28" href="class_m_g_unit__vector.html" title="Define a unit vector, is a MGVector." alt="" coords="499,600,605,629"/><area shape="rect" id="node30" href="class_m_g_vector.html" title="Vector of a general n space dimension." alt="" coords="512,501,592,531"/><area shape="rect" id="node32" href="class_m_g_position.html" title="Represent a positional data." alt="" coords="629,600,720,629"/><area shape="rect" id="node36" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="744,600,851,629"/><area shape="rect" id="node38" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="747,501,848,531"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_plane-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a265eab7b265ae5fb8d702f470254f1dc"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a265eab7b265ae5fb8d702f470254f1dc" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a265eab7b265ae5fb8d702f470254f1dc">MGPlane</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor 初期化なしで平面を生成する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7606808ae765ffc5d80c85b5e891e7e7"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a7606808ae765ffc5d80c85b5e891e7e7" args="(const MGPlane &amp;pl)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7606808ae765ffc5d80c85b5e891e7e7">MGPlane</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#adcd1ae7cca0f0a30eab5831c860f31d5">MGPlane</a> (size_t dim, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a plane by changing this space dimension or ordering the coordinates.  <a href="#adcd1ae7cca0f0a30eab5831c860f31d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ab820270b2e69801a35dc857bb40bcb8d">MGPlane</a> (const double g[4], const double *root_point=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a plane from the coefficients of the plane equation.  <a href="#ab820270b2e69801a35dc857bb40bcb8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a60f8ee8550af76f41a20d93e64fc51c0">MGPlane</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, double d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plane from normal of the plane and the distance from the origin(0,0,0).  <a href="#a60f8ee8550af76f41a20d93e64fc51c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a2c62177affe4908105ff39b66e9c63a8">MGPlane</a> (const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;normal, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plane from a point on the plane and the normal.  <a href="#a2c62177affe4908105ff39b66e9c63a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ab022bc97db4f61f0b3ba0dfbba6cd98a">MGPlane</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;st, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plane from a point and a straight line on the plane.  <a href="#ab022bc97db4f61f0b3ba0dfbba6cd98a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a829c6819136a845e8ff1921fd4a5eda7">MGPlane</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;uderiv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vderiv, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;origin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plane from a point on the plane, u and v direction vector of the plane.  <a href="#a829c6819136a845e8ff1921fd4a5eda7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a4cf68a03545f6b58053dcbee949a701d">MGPlane</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane1, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane2, double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a plane by interpolating two planes.  <a href="#a4cf68a03545f6b58053dcbee949a701d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c8a1eeb05928f11954605f6a37412a"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a17c8a1eeb05928f11954605f6a37412a" args="(const MGPosition &amp;P1, const MGPosition &amp;P2, const MGPosition &amp;P3)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a17c8a1eeb05928f11954605f6a37412a">MGPlane</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P1, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P2, const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a plane from three points on the plane. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2f885cd162aa0fd113af3121e5599cf"></a><!-- doxytag: member="MGPlane::‾MGPlane" ref="ae2f885cd162aa0fd113af3121e5599cf" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGPlane</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7e9f0a2fc9dc7b8564415fa4eaacc6eb">operator=</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#a7e9f0a2fc9dc7b8564415fa4eaacc6eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae967805737971f6827cc3155e0093a0d"></a><!-- doxytag: member="MGPlane::operator=" ref="ae967805737971f6827cc3155e0093a0d" args="(const MGGel &amp;gel2)" -->
<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abccba7db7e2e73d1766a34301cad493f"></a><!-- doxytag: member="MGPlane::operator+" ref="abccba7db7e2e73d1766a34301cad493f" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#abccba7db7e2e73d1766a34301cad493f">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation object construction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac81cf8531bfbe91d6f0217c35eb8fd8a"></a><!-- doxytag: member="MGPlane::operator&#45;" ref="ac81cf8531bfbe91d6f0217c35eb8fd8a" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d650c2fdaad7951e8f0cbd5547820e2"></a><!-- doxytag: member="MGPlane::operator*" ref="a4d650c2fdaad7951e8f0cbd5547820e2" args="(double scale) const " -->
<a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc056e552ec83602c293b0f4b9393cfe"></a><!-- doxytag: member="MGPlane::operator*" ref="afc056e552ec83602c293b0f4b9393cfe" args="(const MGMatrix &amp;mat) const " -->
<a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25f0e3530526b46417cb07c9794f25fe"></a><!-- doxytag: member="MGPlane::operator*" ref="a25f0e3530526b46417cb07c9794f25fe" args="(const MGTransf &amp;tr) const " -->
<a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d95b2a2e602977f4afaf420f2751cf3"></a><!-- doxytag: member="MGPlane::operator+=" ref="a0d95b2a2e602977f4afaf420f2751cf3" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a0d95b2a2e602977f4afaf420f2751cf3">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8f8ddd616d74857c309ba5302e13cb6"></a><!-- doxytag: member="MGPlane::operator&#45;=" ref="af8f8ddd616d74857c309ba5302e13cb6" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6428ebf664ddfda22afb9b0908420eb"></a><!-- doxytag: member="MGPlane::operator*=" ref="aa6428ebf664ddfda22afb9b0908420eb" args="(double scale)" -->
<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88fc841568e15ef1544245f262570ca0"></a><!-- doxytag: member="MGPlane::operator*=" ref="a88fc841568e15ef1544245f262570ca0" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22d7e23c5845ff7ce0649c26564ae99b"></a><!-- doxytag: member="MGPlane::operator*=" ref="a22d7e23c5845ff7ce0649c26564ae99b" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a493a41bf90f6780d0727cf8fe36cb080"></a><!-- doxytag: member="MGPlane::operator==" ref="a493a41bf90f6780d0727cf8fe36cb080" args="(const MGPlane &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a493a41bf90f6780d0727cf8fe36cb080">operator==</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a389bdb59bf1011530dbb4032663e5978"></a><!-- doxytag: member="MGPlane::operator==" ref="a389bdb59bf1011530dbb4032663e5978" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a389bdb59bf1011530dbb4032663e5978">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a712c3ad1b0b488e1be59e5e15373e1d8"></a><!-- doxytag: member="MGPlane::operator&lt;" ref="a712c3ad1b0b488e1be59e5e15373e1d8" args="(const MGPlane &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa45b75eb0e207df66df65f2ec51cad88"></a><!-- doxytag: member="MGPlane::operator&lt;" ref="aa45b75eb0e207df66df65f2ec51cad88" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96a2be759ef71348d9f6ae01fb4cfdf6"></a><!-- doxytag: member="MGPlane::operator!=" ref="a96a2be759ef71348d9f6ae01fb4cfdf6" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43f58b388abe9972013ba7a85822592c"></a><!-- doxytag: member="MGPlane::operator!=" ref="a43f58b388abe9972013ba7a85822592c" args="(const MGPlane &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3511fc75e57a4faeae6c15c92a1f739a"></a><!-- doxytag: member="MGPlane::out_to_IGES" ref="a3511fc75e57a4faeae6c15c92a1f739a" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a3511fc75e57a4faeae6c15c92a1f739a">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output to IGES stream file(=PD190). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a3dc6b6b7794d8a4c9938f809e2586140">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output function.  <a href="#a3dc6b6b7794d8a4c9938f809e2586140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ac0ee0ee1889bc2717a970f651c981c"></a><!-- doxytag: member="MGPlane::abcd" ref="a3ac0ee0ee1889bc2717a970f651c981c" args="(double g[4]) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a3ac0ee0ee1889bc2717a970f651c981c">abcd</a> (double g[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets parameters(a,b,c,d) of the plane expression a*x+b*y+c*z=d. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a5595ea90c345ce3009b7d0be473d14d9">box_limitted</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">g[.]=(a,b,c,d)  <a href="#a5595ea90c345ce3009b7d0be473d14d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a300783387eefbbe6ef3a66f55b3cd939"></a><!-- doxytag: member="MGPlane::center" ref="a300783387eefbbe6ef3a66f55b3cd939" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a300783387eefbbe6ef3a66f55b3cd939">center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain ceter coordinate of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#aaeb166ed17532baea4386dceba1051cb">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#aaeb166ed17532baea4386dceba1051cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7312b8fb5aa59fdfa6ab2812bdb7769b">change_range</a> (int is_u, double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#a7312b8fb5aa59fdfa6ab2812bdb7769b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a4a947f099c9866e3d76fd6e80fd0296b">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value (u,v) of this surface from a point.  <a href="#a4a947f099c9866e3d76fd6e80fd0296b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_plane.html">MGPlane</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7729fdc314d7712e734c83fef8d3771a">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#a7729fdc314d7712e734c83fef8d3771a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_plane.html">MGPlane</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a873b6bfe59240fa8b47b0a2b49ceca64">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#a873b6bfe59240fa8b47b0a2b49ceca64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b256b4966d12f90b8868139debe3f8"></a><!-- doxytag: member="MGPlane::display_arrows" ref="a25b256b4966d12f90b8868139debe3f8" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>display_arrows</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a5b6790079b9b0fcf46aab684445c5571">distance</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the distace between plane and the origin(0,0,0).  <a href="#a5b6790079b9b0fcf46aab684445c5571"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a94aed127360b556a84d1f0b4e7463bee">distance</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the distace between plane and the point.  <a href="#a94aed127360b556a84d1f0b4e7463bee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ab17eaa929a4de9e645dc2fd0347c9390">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#ab17eaa929a4de9e645dc2fd0347c9390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a21a3c06b62d7fe006910e06ccadcde44">make_display_list_to_hilight</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a display list without color of this gel.  <a href="#a21a3c06b62d7fe006910e06ccadcde44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a21c6e4cd6c4ce3efd2d1dfe98f043a04">shade</a> (double span_length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shade the object in world coordinates.  <a href="#a21c6e4cd6c4ce3efd2d1dfe98f043a04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a349a162d7e65af4e52a6d049b069f665">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a349a162d7e65af4e52a6d049b069f665"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a1b246aa1ff1ae915cf8fc068dac5ab74">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a1b246aa1ff1ae915cf8fc068dac5ab74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ab70c9f241d5ba4cf9478c14badf441ca">eval_all</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#ab70c9f241d5ba4cf9478c14badf441ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1cee328598589d289ff8b9cd2e6c067"></a><!-- doxytag: member="MGPlane::exchange_uv" ref="ae1cee328598589d289ff8b9cd2e6c067" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ae1cee328598589d289ff8b9cd2e6c067">exchange_uv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange parameter u and v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb99862470bcccbc85e223cf5cfeb9a9"></a><!-- doxytag: member="MGPlane::identify_type" ref="abb99862470bcccbc85e223cf5cfeb9a9" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#abb99862470bcccbc85e223cf5cfeb9a9">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a978d361627a5252e4edc7ca0ba01db9a"></a><!-- doxytag: member="MGPlane::in_range" ref="a978d361627a5252e4edc7ca0ba01db9a" args="(double u, double v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a978d361627a5252e4edc7ca0ba01db9a">in_range</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is in the range of the FSurface parameter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64a811e10c8deb2ae96cb0153c4b1f04"></a><!-- doxytag: member="MGPlane::in_range" ref="a64a811e10c8deb2ae96cb0153c4b1f04" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#abb208080371da1602dab7534e32cb1e2">intersect_dnum_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess.  <a href="#abb208080371da1602dab7534e32cb1e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c075a7b9b72d822c1fe819dd5be9983"></a><!-- doxytag: member="MGPlane::intersect_dnum_v" ref="a4c075a7b9b72d822c1fe819dd5be9983" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersect_dnum_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a9b70cedfd398991ce61f109e37243e74">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Curve の交点を求める。 Compute intesection of Plane and Curve.  <a href="#a9b70cedfd398991ce61f109e37243e74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36573990ee6b089832991f3da81dce9b"></a><!-- doxytag: member="MGPlane::isect" ref="a36573990ee6b089832991f3da81dce9b" args="(const MGStraight &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a30efbc9b6c7bb9a6a221bcff399e52"></a><!-- doxytag: member="MGPlane::isect" ref="a7a30efbc9b6c7bb9a6a221bcff399e52" args="(const MGRLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca926ec05e7b0adb89c55023967a6fde"></a><!-- doxytag: member="MGPlane::isect" ref="aca926ec05e7b0adb89c55023967a6fde" args="(const MGEllipse &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fcbf27b6693f5a0f2d2a2809e61a9fc"></a><!-- doxytag: member="MGPlane::isect" ref="a7fcbf27b6693f5a0f2d2a2809e61a9fc" args="(const MGLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5edb1cda33381237eb99b519d9bcab29"></a><!-- doxytag: member="MGPlane::isect" ref="a5edb1cda33381237eb99b519d9bcab29" args="(const MGSurfCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2376c172b8d51b1d640877a2d904a8ab"></a><!-- doxytag: member="MGPlane::isect" ref="a2376c172b8d51b1d640877a2d904a8ab" args="(const MGBSumCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#aa90e899199c61534667d233a977c4da3">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Surface の交線を求める。 Surface and Surface intersection.  <a href="#aa90e899199c61534667d233a977c4da3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b5b6af50427864ca6920586f6cef82"></a><!-- doxytag: member="MGPlane::isect" ref="ab8b5b6af50427864ca6920586f6cef82" args="(const MGPlane &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7084043b8a07fc1f4370639cdf9f7b18"></a><!-- doxytag: member="MGPlane::isect" ref="a7084043b8a07fc1f4370639cdf9f7b18" args="(const MGSphere &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5393127d08c180a8805aba93fb0aa998"></a><!-- doxytag: member="MGPlane::isect" ref="a5393127d08c180a8805aba93fb0aa998" args="(const MGCylinder &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b7d617f640bc48eb3c2a9e02ab62b83"></a><!-- doxytag: member="MGPlane::isect" ref="a2b7d617f640bc48eb3c2a9e02ab62b83" args="(const MGSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e682dc6ae494a311debcb4c34cabb0"></a><!-- doxytag: member="MGPlane::isect" ref="a20e682dc6ae494a311debcb4c34cabb0" args="(const MGRSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a701bb9e98189d78571c00d2c2001444f"></a><!-- doxytag: member="MGPlane::isect" ref="a701bb9e98189d78571c00d2c2001444f" args="(const MGBSumSurf &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a09008f5c225c6dfcfbcf94741619a1ff">isect_startHPL</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uvuv_startIn, <a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;uvuv_list, const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;sf2, <a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;ssi, MGPosition_list::iterator &amp;uvuv_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isect_startHPL compute one intersection line of two surfaces, this and sf2, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2).  <a href="#a09008f5c225c6dfcfbcf94741619a1ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a462fef7c343051721c4c837266ca434b"></a><!-- doxytag: member="MGPlane::knot_u" ref="a462fef7c343051721c4c837266ca434b" args="(size_t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a462fef7c343051721c4c837266ca434b">knot_u</a> (size_t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return knot value of (infinite-minus, infinite-plus). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac70043d9fbe1f3120c32b68619c9ec78"></a><!-- doxytag: member="MGPlane::knot_v" ref="ac70043d9fbe1f3120c32b68619c9ec78" args="(size_t) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ac70043d9fbe1f3120c32b68619c9ec78">knot_v</a> (size_t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8281c1349e8a78567aefd788eb23e2d"></a><!-- doxytag: member="MGPlane::knot_vector_u" ref="af8281c1349e8a78567aefd788eb23e2d" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#af8281c1349e8a78567aefd788eb23e2d">knot_vector_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7adbe11c21802ffd032535a5ec4a6923"></a><!-- doxytag: member="MGPlane::knot_vector_u" ref="a7adbe11c21802ffd032535a5ec4a6923" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05db36d8497f935569375514920682d0"></a><!-- doxytag: member="MGPlane::knot_vector_v" ref="a05db36d8497f935569375514920682d0" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a05db36d8497f935569375514920682d0">knot_vector_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a302e2a8efd5f8f634566087e112b58cc"></a><!-- doxytag: member="MGPlane::knot_vector_v" ref="a302e2a8efd5f8f634566087e112b58cc" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a29eb89702cc18bdd6dff7f1e27f2201b">negate</a> (int is_u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the normal of the plane,平面を反転する。ノーマルを逆方向にする.  <a href="#a29eb89702cc18bdd6dff7f1e27f2201b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ae0524440c0d77dff0fde164a95eb85a9">negate_param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int is_u=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this surface is negated by "negate()".  <a href="#ae0524440c0d77dff0fde164a95eb85a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d2b9fb2269b942eddd7f2cad6ec4dcb"></a><!-- doxytag: member="MGPlane::normal" ref="a7d2b9fb2269b942eddd7f2cad6ec4dcb" args="(double u, double v) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7d2b9fb2269b942eddd7f2cad6ec4dcb">normal</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the normal of the plane, 平面の法線を返却する. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73dc5232647ccff3aaaffa49ec327b70"></a><!-- doxytag: member="MGPlane::normal" ref="a73dc5232647ccff3aaaffa49ec327b70" args="(const MGPosition &amp;uv) const " -->
<a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a73dc5232647ccff3aaaffa49ec327b70">normal</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute normal vector(not unit) at uv. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af663aa03b522ff139766f4574603c2d3"></a><!-- doxytag: member="MGPlane::normal" ref="af663aa03b522ff139766f4574603c2d3" args="() const " -->
const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>normal</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ad8634bd9e251baf5fa41260c57af151e">offset_c1</a> (double ofs_value, int &amp;error) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface offset.  <a href="#ad8634bd9e251baf5fa41260c57af151e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a0f7db9945820d263ddbd4150a8aaafa9">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a point is on the plane.  <a href="#a0f7db9945820d263ddbd4150a8aaafa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a5e57c1ce7722e2d66cfe07bfae5fe662">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;puv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた誤差内で点が面上にあるかどうかテストする。 Test if point P is ont the surface or not.  <a href="#a5e57c1ce7722e2d66cfe07bfae5fe662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a9bba827b5a88be6ec96daec2d677a4ec">on</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a straight line is on the plane.  <a href="#a9bba827b5a88be6ec96daec2d677a4ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a626af4d4de5e4c8fca9d020c48458e6d">on_a_perimeter</a> (double &amp;u, double &amp;v, size_t &amp;perim_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is parameter value on a perimeter of the surface.  <a href="#a626af4d4de5e4c8fca9d020c48458e6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a9a7b1bc1ab5972f2c58777dfca7f3467">on_the_perimeter</a> (size_t perim_num, double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is on the perimeter perim_num.  <a href="#a9a7b1bc1ab5972f2c58777dfca7f3467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#afde3cc0a9d49c580798e3cb8be0ef8bf">param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return plane parameter value of a point on the plane.  <a href="#afde3cc0a9d49c580798e3cb8be0ef8bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7be5f0705250ce4d70648c33f41c0212"></a><!-- doxytag: member="MGPlane::param_error" ref="a7be5f0705250ce4d70648c33f41c0212" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7be5f0705250ce4d70648c33f41c0212">param_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter space error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b5d27a2d994a037f3a9aab960c22aa5"></a><!-- doxytag: member="MGPlane::param_error_u" ref="a6b5d27a2d994a037f3a9aab960c22aa5" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_error_u</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b851aaa99bb6dc8f28beb65e1a280b0"></a><!-- doxytag: member="MGPlane::param_error_v" ref="a7b851aaa99bb6dc8f28beb65e1a280b0" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_error_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a481df7c7760d2de5b6abb911f8d3a0f0"></a><!-- doxytag: member="MGPlane::param_e_u" ref="a481df7c7760d2de5b6abb911f8d3a0f0" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a481df7c7760d2de5b6abb911f8d3a0f0">param_e_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a342ef3add6650cdc03844008b5257aa7"></a><!-- doxytag: member="MGPlane::param_e_v" ref="a342ef3add6650cdc03844008b5257aa7" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ad01034704a0cdb64e7bb3e1530389b33">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range of the plane(Infinite box).  <a href="#ad01034704a0cdb64e7bb3e1530389b33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ac2b7c181aaa9fe1e4043ee467e3cbb"></a><!-- doxytag: member="MGPlane::param_s_u" ref="a5ac2b7c181aaa9fe1e4043ee467e3cbb" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a5ac2b7c181aaa9fe1e4043ee467e3cbb">param_s_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33e86f79616ed19c3514982079677990"></a><!-- doxytag: member="MGPlane::param_s_v" ref="a33e86f79616ed19c3514982079677990" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a28554194a15e2c6d712bfcaf5ed43a55">parameter_curve</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter curve.  <a href="#a28554194a15e2c6d712bfcaf5ed43a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a822b1bbcfcbc9deaabd4b74d09f71f4f">part</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbx, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of the surface limitted by the parameter range bx.  <a href="#a822b1bbcfcbc9deaabd4b74d09f71f4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a2a495af4be0561cbd09e45aff78641cb">perimeter_curve</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i must be &lt; <a class="el" href="class_m_g_plane.html#a3c8e6f3479d91e3c9a05c2b9c282ac77" title="Return how many perimeters this surface has.">perimeter_num()</a>.  <a href="#a2a495af4be0561cbd09e45aff78641cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c8e6f3479d91e3c9a05c2b9c282ac77"></a><!-- doxytag: member="MGPlane::perimeter_num" ref="a3c8e6f3479d91e3c9a05c2b9c282ac77" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a3c8e6f3479d91e3c9a05c2b9c282ac77">perimeter_num</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many perimeters this surface has. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#aebfbacfeb0dd57e22c8c20b4196c9261">perimeter_uv</a> (unsigned i, double t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct perimeter (u,v) parameter position.  <a href="#aebfbacfeb0dd57e22c8c20b4196c9261"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a14e8bdacc9586ab1981f1d0ca1abb632">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, const <a class="el" href="class_m_g_position.html">MGPosition</a> *uvguess=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた点にもっとも近い面上の点を返却する。パラメ ータ値も返却する。 Return the nearest point of the plane from P.  <a href="#a14e8bdacc9586ab1981f1d0ca1abb632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a12dddf55a74e756d3d0de147e930e694">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all(actually one) foots of perpendicular straight lines from P.  <a href="#a12dddf55a74e756d3d0de147e930e694"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a735d8d28d88cc330a43ce6b184296201">planar</a> (<a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;plane, double &amp;deviation) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the surface is planar or not.  <a href="#a735d8d28d88cc330a43ce6b184296201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a0a15673f3a20b592d404e2c3fa40456c">planar</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox, double tol, int *divideU=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if part of the surface is planar or not within the tolerance tol.  <a href="#a0a15673f3a20b592d404e2c3fa40456c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a9e03edbc435b5770d8314fb06d51b3a7">project</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv_uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める.  <a href="#a9e03edbc435b5770d8314fb06d51b3a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a64acf2aed4563362b4f63c38b4c77ef8">project</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv_uv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec=mgNULL_VEC) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a830ba3065209fb0a1c281162b07fe9bd">project</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;vec_crv, const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;vec=mgNULL_VEC) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める.  <a href="#a830ba3065209fb0a1c281162b07fe9bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#aefe8f7187ede379cb7528bef93a111a0">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力パラメータをパラメータ範囲でまるめて返却する.  <a href="#aefe8f7187ede379cb7528bef93a111a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#gaaab2ed6df6bc2f3b1f99a0df77b7c1a9">MGPSRELATION</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a73af9dc47329892f37909bbec0a86f4d">relation</a> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;, <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた平面との関係を返す.  <a href="#a73af9dc47329892f37909bbec0a86f4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#gaaab2ed6df6bc2f3b1f99a0df77b7c1a9">MGPSRELATION</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#acc68c2c72de9dc430ff5a871126ed8d1">relation</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;, <a class="el" href="class_m_g_c_sisect.html">MGCSisect</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた直線との関係を返す。 Relation between plane and straight line.  <a href="#acc68c2c72de9dc430ff5a871126ed8d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a8afaba342f195eab3d3448ddd37ccdd4">root_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">平面のパラメータ表現の起点を返却する。 Return root point of the plane.  <a href="#a8afaba342f195eab3d3448ddd37ccdd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b2b98cb43d4abc5d229a3b8abcb765f"></a><!-- doxytag: member="MGPlane::sdim" ref="a3b2b98cb43d4abc5d229a3b8abcb765f" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a3b2b98cb43d4abc5d229a3b8abcb765f">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a98581c81192065133fa2c26253c152ce">skeleton</a> (int density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain boundary and main parameter lines of the FSurface.  <a href="#a98581c81192065133fa2c26253c152ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1531683b736a40cf951c1088464c3e4d"></a><!-- doxytag: member="MGPlane::skeleton_at_knots" ref="a1531683b736a40cf951c1088464c3e4d" args="() const " -->
<a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a1531683b736a40cf951c1088464c3e4d">skeleton_at_knots</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the parameter curves at knots of u and v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a10de314e84981bdcc18a049b917e9d73">split</a> (double param, bool is_u, <a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;surfaces) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">split this fsurface at the parameter param.  <a href="#a10de314e84981bdcc18a049b917e9d73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a340c1e5493ce45c2c33dded8fcfa0798">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面タイプを返却する。 Return surface type of the plane.  <a href="#a340c1e5493ce45c2c33dded8fcfa0798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a9aad3737827a102351567bbd2723ae85">u_deriv</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">平面のパラメータ表現のｕ方向を返却する。 Return u-direction vector of the plane.  <a href="#a9aad3737827a102351567bbd2723ae85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a25803f218ee8689f6aaa2132ff9b9f4b">v_deriv</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">平面のパラメータ表現のｖ方向を返却する。 Return v-direction vector of the plane.  <a href="#a25803f218ee8689f6aaa2132ff9b9f4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a7af6a6605c67a02d6a15c15e5563d2f8">uv</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;p) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">点を平面に投影した点の平面のパラメータ表現(u,v)を求める。 Return uv parameter of the point projected from point p to the plane.  <a href="#a7af6a6605c67a02d6a15c15e5563d2f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#ad8fec1fb924fd776813da0cc4acdbad0">uv</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vectorを平面に投影したVectorの平面のパラメータ表現(u,v)を求める。 Return uv parameter of the point projected from point p to the plane.  <a href="#ad8fec1fb924fd776813da0cc4acdbad0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa088d4defeb3118bc342cc031c1427d5"></a><!-- doxytag: member="MGPlane::whoami" ref="aa088d4defeb3118bc342cc031c1427d5" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a52a1a74215b08614718cf316a5ff3d2d">flat</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox, double tol, int &amp;direction, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the surface is flat or not within the parameter value rectangle of uvbox.  <a href="#a52a1a74215b08614718cf316a5ff3d2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a58dc228df8c9b7f20161efec6b6cf5c8">flat_tess</a> (double u0, double u1, double v0, double v1, double tol, bool &amp;direction) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the surface is flat or not within the parameter value rectangle of uvbox.  <a href="#a58dc228df8c9b7f20161efec6b6cf5c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#adfac271e291026f76b585fdd496c0153">isectSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox=mgNULL_BOX) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Surface and a straight line.  <a href="#adfac271e291026f76b585fdd496c0153"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97b2b874590600e2f28a70cf8f4e7fd2"></a><!-- doxytag: member="MGPlane::ReadMembers" ref="a97b2b874590600e2f28a70cf8f4e7fd2" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a97b2b874590600e2f28a70cf8f4e7fd2">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39a73bd8f15c18abc8e1f3fc6d6ce1f8"></a><!-- doxytag: member="MGPlane::WriteMembers" ref="a39a73bd8f15c18abc8e1f3fc6d6ce1f8" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_plane.html#a39a73bd8f15c18abc8e1f3fc6d6ce1f8">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a367a20bc598829b38eb6f1fe1659f54a"></a><!-- doxytag: member="MGPlane::operator+" ref="a367a20bc598829b38eb6f1fe1659f54a" args="(const MGVector &amp;v, const MGPlane &amp;pl)" -->
MGDECL friend <a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bc81579b9d8905aa6fa2ff371875b9b"></a><!-- doxytag: member="MGPlane::operator*" ref="a6bc81579b9d8905aa6fa2ff371875b9b" args="(double scale, const MGPlane &amp;pl)" -->
MGDECL friend <a class="el" href="class_m_g_plane.html">MGPlane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double scale, const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;pl)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_plane.html" title="MGPlane is infinite plane in 3D space.">MGPlane</a> is infinite plane in 3D space. </p>
<p>Using orthonormal two vector m_uderiv and m_vderiv in 3D space, plane function f(u,v)= m_root_point + u*m_uderiv + v*m_vderiv, where u and v are two parameter of surface representation. MGPlaneクラスは３次元空間における平面を表すクラスである。 MGPlaneクラスでは以下のようなパラメータ表現を使用します。 Point(u,v) = m_root_point + u * m_uderiv + v * m_vderiv </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adcd1ae7cca0f0a30eab5831c860f31d5"></a><!-- doxytag: member="MGPlane::MGPlane" ref="adcd1ae7cca0f0a30eab5831c860f31d5" args="(size_t dim, const MGPlane &amp;plane, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a plane by changing this space dimension or ordering the coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Original Plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new Surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of original Surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab820270b2e69801a35dc857bb40bcb8d"></a><!-- doxytag: member="MGPlane::MGPlane" ref="ab820270b2e69801a35dc857bb40bcb8d" args="(const double g[4], const double *root_point=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>g</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>root_point</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a plane from the coefficients of the plane equation. </p>
<p>a*x+b*y+c*z=d. Coefficients a,b,c,d are provided by double array g[4]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>coefficients g[0]=a, b=g[1], c=g[2], d=g[3]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_point</em>&nbsp;</td><td>When root_point!=0, root_point[.] are (x,y,z) values of the root point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60f8ee8550af76f41a20d93e64fc51c0"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a60f8ee8550af76f41a20d93e64fc51c0" args="(const MGUnit_vector &amp;normal, double d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plane from normal of the plane and the distance from the origin(0,0,0). </p>
<p>平面のノーマルと平面の原点からの距離を指定して面を生成する. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>Normal of the plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>distance from origin of the plane. When normal=(a,b,c,....), d=a*x+b*y+c*z+.... . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c62177affe4908105ff39b66e9c63a8"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a2c62177affe4908105ff39b66e9c63a8" args="(const MGUnit_vector &amp;normal, const MGPosition &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plane from a point on the plane and the normal. </p>
<p>点と平面のノーマルを指定して面を生成する。 </p>

</div>
</div>
<a class="anchor" id="ab022bc97db4f61f0b3ba0dfbba6cd98a"></a><!-- doxytag: member="MGPlane::MGPlane" ref="ab022bc97db4f61f0b3ba0dfbba6cd98a" args="(const MGStraight &amp;st, const MGPosition &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plane from a point and a straight line on the plane. </p>
<p>直線と直線に乗らない点を指定して面を生成する。 </p>

</div>
</div>
<a class="anchor" id="a829c6819136a845e8ff1921fd4a5eda7"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a829c6819136a845e8ff1921fd4a5eda7" args="(const MGVector &amp;uderiv, const MGVector &amp;vderiv, const MGPosition &amp;origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uderiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vderiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plane from a point on the plane, u and v direction vector of the plane. </p>
<p>点、ｕ方向、ｖ方向を指定して面を生成する。 This is the fundamental constructor.***** </p>

</div>
</div>
<a class="anchor" id="a4cf68a03545f6b58053dcbee949a701d"></a><!-- doxytag: member="MGPlane::MGPlane" ref="a4cf68a03545f6b58053dcbee949a701d" args="(const MGPlane &amp;plane1, const MGPlane &amp;plane2, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGPlane::MGPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a plane by interpolating two planes. </p>
<p>If two planes intersect, interpolation is rotation around the intersection line. If two planes are parallel, interpolation is parallel move. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Input ratio. When t=0, the plane will be plane1, When t=1, the plane will be plane2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5595ea90c345ce3009b7d0be473d14d9"></a><!-- doxytag: member="MGPlane::box_limitted" ref="a5595ea90c345ce3009b7d0be473d14d9" args="(const MGBox &amp;uvrange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGPlane::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>g[.]=(a,b,c,d) </p>
<p>Box that includes limitted plane by box. 入力のパラメータ範囲の曲線部分を囲むボックスを返す。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvrange</em>&nbsp;</td><td>Parameter Range of the surface. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a9182844563218c392ef526d29e5bfb7e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aaeb166ed17532baea4386dceba1051cb"></a><!-- doxytag: member="MGPlane::change_dimension" ref="aaeb166ed17532baea4386dceba1051cb" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_plane.html">MGPlane</a>&amp; MGPlane::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ab37b86c29caed93258a98d7e70459d4e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7312b8fb5aa59fdfa6ab2812bdb7769b"></a><!-- doxytag: member="MGPlane::change_range" ref="a7312b8fb5aa59fdfa6ab2812bdb7769b" args="(int is_u, double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_plane.html">MGPlane</a>&amp; MGPlane::change_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, (t1,t2) are u-value. if not, v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a1d4365d58c465f916b2fb038ef896b2d">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7729fdc314d7712e734c83fef8d3771a"></a><!-- doxytag: member="MGPlane::clone" ref="a7729fdc314d7712e734c83fef8d3771a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_plane.html">MGPlane</a>* MGPlane::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a55ce6580673b46480f6ae5a8d2117c17">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a4a947f099c9866e3d76fd6e80fd0296b"></a><!-- doxytag: member="MGPlane::closest" ref="a4a947f099c9866e3d76fd6e80fd0296b" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPlane::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value (u,v) of this surface from a point. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a968d690be2c0009a282ac74085b95422">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a873b6bfe59240fa8b47b0a2b49ceca64"></a><!-- doxytag: member="MGPlane::copy_change_dimension" ref="a873b6bfe59240fa8b47b0a2b49ceca64" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_plane.html">MGPlane</a>* MGPlane::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a0cf87d2f42a919c9f5bc44cc406ea0fd">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a94aed127360b556a84d1f0b4e7463bee"></a><!-- doxytag: member="MGPlane::distance" ref="a94aed127360b556a84d1f0b4e7463bee" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGPlane::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the distace between plane and the point. </p>
<p>与えられた点との距離を返却する。 </p>

</div>
</div>
<a class="anchor" id="a5b6790079b9b0fcf46aab684445c5571"></a><!-- doxytag: member="MGPlane::distance" ref="a5b6790079b9b0fcf46aab684445c5571" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGPlane::distance </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the distace between plane and the origin(0,0,0). </p>
<p>原点との距離を返却する。 </p>

</div>
</div>
<a class="anchor" id="ab17eaa929a4de9e645dc2fd0347c9390"></a><!-- doxytag: member="MGPlane::drawWire" ref="ab17eaa929a4de9e645dc2fd0347c9390" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPlane::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ad43e101de71052301de2cc8c7e4405ef">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a349a162d7e65af4e52a6d049b069f665"></a><!-- doxytag: member="MGPlane::eval" ref="a349a162d7e65af4e52a6d049b069f665" args="(double u, double v, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGPlane::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a1b246aa1ff1ae915cf8fc068dac5ab74"></a><!-- doxytag: member="MGPlane::eval" ref="a1b246aa1ff1ae915cf8fc068dac5ab74" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGPlane::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab70c9f241d5ba4cf9478c14badf441ca"></a><!-- doxytag: member="MGPlane::eval_all" ref="ab70c9f241d5ba4cf9478c14badf441ca" args="(double u, double v, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPlane::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data, 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8153b4db02d3056377d79f43254d11e5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a52a1a74215b08614718cf316a5ff3d2d"></a><!-- doxytag: member="MGPlane::flat" ref="a52a1a74215b08614718cf316a5ff3d2d" args="(const MGBox &amp;uvbox, double tol, int &amp;direction, MGPosition &amp;P, MGUnit_vector &amp;N) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::flat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the surface is flat or not within the parameter value rectangle of uvbox. </p>
<p>Function's return value is: true: if the surface is flat false: if the surface is not falt. When this is not falt, the direction that indicates which direction the surface should be divided will be output. the flatness is tested only approximately. This is for exclusive use of <a class="el" href="class_m_g_plane.html#a735d8d28d88cc330a43ce6b184296201" title="Test if the surface is planar or not.">planar()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>Tolerance allowed to regard flat (Allowed distance from a plane). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>1: u-direction is more non flat, 0: v-direction is more non flat. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Position of the flat plane will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Normal of the flat plane will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a6cce2a79bd519568b05467e302274bba">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a58dc228df8c9b7f20161efec6b6cf5c8"></a><!-- doxytag: member="MGPlane::flat_tess" ref="a58dc228df8c9b7f20161efec6b6cf5c8" args="(double u0, double u1, double v0, double v1, double tol, bool &amp;direction) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::flat_tess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the surface is flat or not within the parameter value rectangle of uvbox. </p>
<p>Function's return value is: true: if the surface is flat false: if the surface is not falt. When this is not falt, the direction that indicates which direction the surface should be divided will be output. This is the same as flat except that this does not have the arguments P, N. the flatness is tested only approximately. This is for exclusive use of tessellation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u1</em>&nbsp;</td><td>u range from u0 to u1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>v range from v0 to v1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>Tolerance allowed to regart flat (Allowed distance from a plane). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>1: u-direction is more non flat, 0: v-direction is more non flat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb208080371da1602dab7534e32cb1e2"></a><!-- doxytag: member="MGPlane::intersect_dnum_u" ref="abb208080371da1602dab7534e32cb1e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGPlane::intersect_dnum_u </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#adeee48dc794aa404bce3dc81b9679cfb">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9b70cedfd398991ce61f109e37243e74"></a><!-- doxytag: member="MGPlane::isect" ref="a9b70cedfd398991ce61f109e37243e74" args="(const MGCurve &amp;curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGPlane::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Curve の交点を求める。 Compute intesection of Plane and Curve. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a97fecbc27841cd336e1b26d2e64c2bf0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aa90e899199c61534667d233a977c4da3"></a><!-- doxytag: member="MGPlane::isect" ref="aa90e899199c61534667d233a977c4da3" args="(const MGSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGPlane::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Surface の交線を求める。 Surface and Surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a3d84645dc04d80bb2ff1df214f3a3b9b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a09008f5c225c6dfcfbcf94741619a1ff"></a><!-- doxytag: member="MGPlane::isect_startHPL" ref="a09008f5c225c6dfcfbcf94741619a1ff" args="(const MGPosition &amp;uvuv_startIn, MGPosition_list &amp;uvuv_list, const MGSurface &amp;sf2, MGSSisect &amp;ssi, MGPosition_list::iterator &amp;uvuv_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::isect_startHPL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_s_sisect.html">MGSSisect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ssi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MGPosition_list::iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>uvuv_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>isect_startHPL compute one intersection line of two surfaces, this and sf2, given starting intersetion point uvuv((u1,v1) of this and (u2,v2) of sf2). </p>
<p>isect_startHPL halts the computation when intersection reached to a boundary of this or sf2, or reached to one of the points in uvuv_list. The function's return value is: =0: Intersection was not obtained. !=0: Intersection was obtained as follows: =1: End point is a point on a perimeter of one of the surfaces. =3: End point is one of boundary points in uvuv_list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvuv_startIn</em>&nbsp;</td><td>Starting point of the intersection line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_list</em>&nbsp;</td><td>isect_startHPL will halt when ip reached one of the point in uvuv_list. isect_startHPL does not change uvuv_list(actually uvuv_list is const). uvuv's space dimension is at least 4, and the first 2 is (u,v) of this and the next 2 is (u,v) of sf2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sf2</em>&nbsp;</td><td>2nd surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssi</em>&nbsp;</td><td>Surface-surface intersection line will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvuv_id</em>&nbsp;</td><td>When the end point of ip was one of the points of uvuv_list, that is, when the function's return value was 3, uvuv_list's iterator of the point will be returned, When the end point was not a point of uvuv_list, end() of uvuv_list will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfac271e291026f76b585fdd496c0153"></a><!-- doxytag: member="MGPlane::isectSl" ref="adfac271e291026f76b585fdd496c0153" args="(const MGStraight &amp;sl, const MGBox &amp;uvbox=mgNULL_BOX) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGPlane::isectSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em> = <code>mgNULL_BOX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Surface and a straight line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>indicates if this surface is restrictied to the parameter range of uvbox. If uvbox.is_null(), no restriction. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aa0bd5720dfdbf979fa89054b785014ce">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a21a3c06b62d7fe006910e06ccadcde44"></a><!-- doxytag: member="MGPlane::make_display_list_to_hilight" ref="a21a3c06b62d7fe006910e06ccadcde44" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGPlane::make_display_list_to_hilight </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a display list without color of this gel. </p>
<p>Return is the display list name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>span length to approximate by polyline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ad98eb8a83bc79f4b4883953ea3545c0e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a29eb89702cc18bdd6dff7f1e27f2201b"></a><!-- doxytag: member="MGPlane::negate" ref="a29eb89702cc18bdd6dff7f1e27f2201b" args="(int is_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPlane::negate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate the normal of the plane,平面を反転する。ノーマルを逆方向にする. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Negate along u-direction if is_u is ture, else along v-direction. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a5f1ebb47122de32a0f5702f160a51d2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae0524440c0d77dff0fde164a95eb85a9"></a><!-- doxytag: member="MGPlane::negate_param" ref="ae0524440c0d77dff0fde164a95eb85a9" args="(const MGPosition &amp;uv, int is_u=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPlane::negate_param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter value if this surface is negated by "negate()". </p>
<p>Negate along u-direction if is_u is ture, else along v-direction. </p>

</div>
</div>
<a class="anchor" id="ad8634bd9e251baf5fa41260c57af151e"></a><!-- doxytag: member="MGPlane::offset_c1" ref="ad8634bd9e251baf5fa41260c57af151e" args="(double ofs_value, int &amp;error) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGPlane::offset_c1 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface offset. </p>
<p>positive offset value is offset normal direction. the radius of curvature is larger than offset value.line_zero() is used. C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。トレランスはline_zero()を使用している。 戻り値は、オフセット面のオートポインターが返却される。 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード 0:成功 -1:面におれがある -2:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ae2dab410e24064b16318be2f56d2246c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a0f7db9945820d263ddbd4150a8aaafa9"></a><!-- doxytag: member="MGPlane::on" ref="a0f7db9945820d263ddbd4150a8aaafa9" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a point is on the plane. </p>
<p>If on the plane, return true. 指定点が面上にあるか調べる。（面上ならばtrue）. </p>

</div>
</div>
<a class="anchor" id="a5e57c1ce7722e2d66cfe07bfae5fe662"></a><!-- doxytag: member="MGPlane::on" ref="a5e57c1ce7722e2d66cfe07bfae5fe662" args="(const MGPosition &amp;point, MGPosition &amp;puv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた誤差内で点が面上にあるかどうかテストする。 Test if point P is ont the surface or not. </p>
<p>Even if P is not on the surface, return parameter of the nearest point of the surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>A point to test 指定点. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a409507f5dcc86cab92e3448529a94196">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9bba827b5a88be6ec96daec2d677a4ec"></a><!-- doxytag: member="MGPlane::on" ref="a9bba827b5a88be6ec96daec2d677a4ec" args="(const MGStraight &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a straight line is on the plane. </p>
<p>Return true if on. 直線が平面上にあるか調べる。（平面上ならばtrue） </p>

</div>
</div>
<a class="anchor" id="a626af4d4de5e4c8fca9d020c48458e6d"></a><!-- doxytag: member="MGPlane::on_a_perimeter" ref="a626af4d4de5e4c8fca9d020c48458e6d" args="(double &amp;u, double &amp;v, size_t &amp;perim_num) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::on_a_perimeter </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is parameter value on a perimeter of the surface. </p>
<p>If u or v is on a perimeter, (u,v) will be updated to the perimeter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returns true, the perimete rnumber is output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a6f773b2759f1b0c66b20ed8888aae990">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9a7b1bc1ab5972f2c58777dfca7f3467"></a><!-- doxytag: member="MGPlane::on_the_perimeter" ref="a9a7b1bc1ab5972f2c58777dfca7f3467" args="(size_t perim_num, double u, double v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGPlane::on_the_perimeter </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>perim_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is on the perimeter perim_num. </p>
<p>If u or v is on a perimeter, true will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>a perimete number is input. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a2b61d4bf8d30ee128a81c96ac4e9beb9">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a7e9f0a2fc9dc7b8564415fa4eaacc6eb"></a><!-- doxytag: member="MGPlane::operator=" ref="a7e9f0a2fc9dc7b8564415fa4eaacc6eb" args="(const MGPlane &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_plane.html">MGPlane</a>&amp; MGPlane::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and srf2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="a3dc6b6b7794d8a4c9938f809e2586140"></a><!-- doxytag: member="MGPlane::out" ref="a3dc6b6b7794d8a4c9938f809e2586140" args="(std::ostream &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; MGPlane::out </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output function. </p>
<p>Output to ostream メンバデータを標準出力に出力する。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a484f8cc1c250c5b52fb960b1fda5bb54">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="afde3cc0a9d49c580798e3cb8be0ef8bf"></a><!-- doxytag: member="MGPlane::param" ref="afde3cc0a9d49c580798e3cb8be0ef8bf" args="(const MGPosition &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPlane::param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return plane parameter value of a point on the plane. </p>
<p>If input point is not on the plane, returned is the nearest point parameter of the plane. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a423bee27e6e375739359ff13ca2c73c2">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad01034704a0cdb64e7bb3e1530389b33"></a><!-- doxytag: member="MGPlane::param_range" ref="ad01034704a0cdb64e7bb3e1530389b33" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGPlane::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range of the plane(Infinite box). </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a28554194a15e2c6d712bfcaf5ed43a55"></a><!-- doxytag: member="MGPlane::parameter_curve" ref="a28554194a15e2c6d712bfcaf5ed43a55" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGPlane::parameter_curve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter curve. </p>
<p>Returned is newed area pointer, and must be freed by delete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a470c01ec42c6e71b6c34601cc558ec96">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a822b1bbcfcbc9deaabd4b74d09f71f4f"></a><!-- doxytag: member="MGPlane::part" ref="a822b1bbcfcbc9deaabd4b74d09f71f4f" args="(const MGBox &amp;uvbx, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_surface.html">MGSurface</a>* MGPlane::part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of the surface limitted by the parameter range bx. </p>
<p>bx(0) is the parameter (us,ue) and bx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a7a924b141ca6ea037545953c5e00d682">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a2a495af4be0561cbd09e45aff78641cb"></a><!-- doxytag: member="MGPlane::perimeter_curve" ref="a2a495af4be0561cbd09e45aff78641cb" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGPlane::perimeter_curve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>i must be &lt; <a class="el" href="class_m_g_plane.html#a3c8e6f3479d91e3c9a05c2b9c282ac77" title="Return how many perimeters this surface has.">perimeter_num()</a>. </p>
<p>When <a class="el" href="class_m_g_plane.html#a3c8e6f3479d91e3c9a05c2b9c282ac77" title="Return how many perimeters this surface has.">perimeter_num()</a>==0, this function is undefined. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a57c8bffdb617cf4ff7c654e2b080200c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aebfbacfeb0dd57e22c8c20b4196c9261"></a><!-- doxytag: member="MGPlane::perimeter_uv" ref="aebfbacfeb0dd57e22c8c20b4196c9261" args="(unsigned i, double t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPlane::perimeter_uv </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct perimeter (u,v) parameter position. </p>
<p>i is perimeter number: =0: v=min line, =1: u=max line, =2: v=max line, =3: u=min line t is perimeter parameter line's parameter value of u or v. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a83e100c532a4bb82f22ec00066993e02">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a14e8bdacc9586ab1981f1d0ca1abb632"></a><!-- doxytag: member="MGPlane::perp_point" ref="a14e8bdacc9586ab1981f1d0ca1abb632" args="(const MGPosition &amp;P, MGPosition &amp;uv, const MGPosition *uvguess=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td>
          <td class="paramname"> <em>uvguess</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた点にもっとも近い面上の点を返却する。パラメ ータ値も返却する。 Return the nearest point of the plane from P. </p>
<p>Function's return value is always true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>与えられた点. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the plane will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ac94884f1674a06f476c417511a93eb2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a12dddf55a74e756d3d0de147e930e694"></a><!-- doxytag: member="MGPlane::perps" ref="a12dddf55a74e756d3d0de147e930e694" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGPlane::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return all(actually one) foots of perpendicular straight lines from P. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point of a space(指定点). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aed36001c59550de9c2054564844c638f">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a0a15673f3a20b592d404e2c3fa40456c"></a><!-- doxytag: member="MGPlane::planar" ref="a0a15673f3a20b592d404e2c3fa40456c" args="(const MGBox &amp;uvbox, double tol, int *divideU=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>divideU</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if part of the surface is planar or not within the tolerance tol. </p>
<p>The part of the surface is input by the surface parameter range uvbox. Returned is 0(false) if this is not planar, 1(true) if planar. For plane, planar always returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>This surface parameter range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>maximum deviation allowed to regard the sub surface as a plane. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>divideU</em>&nbsp;</td><td>Direction to subdivide will be output, if this was not planar, =1: u direction, =0: v direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a735d8d28d88cc330a43ce6b184296201"></a><!-- doxytag: member="MGPlane::planar" ref="a735d8d28d88cc330a43ce6b184296201" args="(MGPlane &amp;plane, double &amp;deviation) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::planar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>deviation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the surface is planar or not. </p>
<p>Returned is 0(false) if this is not planar, 1(true) if this planar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Plane that might be closest to this. Plane is always output even if not planar. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviation</em>&nbsp;</td><td>maximum deviation of this from the output plane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e03edbc435b5770d8314fb06d51b3a7"></a><!-- doxytag: member="MGPlane::project" ref="a9e03edbc435b5770d8314fb06d51b3a7" args="(const MGCurve &amp;crv, MGPvector&lt; MGCurve &gt; &amp;vec_crv_uv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv_uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める. </p>
<p>投影曲線は面上のパラメータ曲線と3次元曲線としてそれぞれ順番に、 vec_crv_uv, vec_crvに格納される。 uv曲線のトレランスはrc_zero()を、3次元曲線はline_zero()をそれぞれ使用している。 get perpendicular or vector projection curve list. uv projection curves are put into vec_crv_uv(rc_zero() is used), 3d projection curves are put into vec_crv(line_zero() is used) respectively. 引数： const <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>&amp; crv, (I/ ) given curve. <a class="el" href="class_m_g_pvector.html">MGPvector&lt;MGCurve&gt;</a>&amp; vec_crv_uv, ( /O) uv projection curve. <a class="el" href="class_m_g_pvector.html">MGPvector&lt;MGCurve&gt;</a>&amp; vec_crv, ( /O) 3d projection curve. const <a class="el" href="class_m_g_vector.html" title="Vector of a general n space dimension.">MGVector</a>&amp; vec=mgNULL_VEC (I/ ) projection vector. 戻り値： 投影曲線の数: 投影曲線が求まった 0: 投影曲線が求まらなかった -1: 内部処理エラー -2: 収束処理エラー（収束しなかった） 追記：引数vecが与えられないとき、面直投影する。 Obtain the projected curve of a curve onto the surface. The direction of the projection is along the vector vec if the vec is not NULL, and normal to the surface if the vec is NULL. Output of 'project' is two kind of curves: one is general world coordinate curves('vec_crv'), and the other is (u,v) curves of the parameter space of the surfaces(vec_crv_uv). vec_crv_uv.size() is equal to vec_crv.size(). Let the size be n, then (vec_crv_uv[i], vec_crv[i]) is one pair for 0&lt;=i&lt;n. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>given curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv_uv</em>&nbsp;</td><td>uv projection curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv</em>&nbsp;</td><td>3d projection curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>projection vector, if vec = NULL then calculate perpendicular project. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#affc560a90dfcc2d65c31737d8c82abfc">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a64acf2aed4563362b4f63c38b4c77ef8"></a><!-- doxytag: member="MGPlane::project" ref="a64acf2aed4563362b4f63c38b4c77ef8" args="(const MGStraight &amp;sl, MGPvector&lt; MGCurve &gt; &amp;vec_crv_uv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv_uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sl</em>&nbsp;</td><td>given curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv_uv</em>&nbsp;</td><td>uv projection curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv</em>&nbsp;</td><td>3d projection curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>projection vector, if vec = NULL then calculate perpendicular project. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a830ba3065209fb0a1c281162b07fe9bd"></a><!-- doxytag: member="MGPlane::project" ref="a830ba3065209fb0a1c281162b07fe9bd" args="(const MGCurve &amp;crv, MGPvector&lt; MGCurve &gt; &amp;vec_crv, const MGVector &amp;vec=mgNULL_VEC) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGPlane::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_curve.html">MGCurve</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec_crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em> = <code>mgNULL_VEC</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた曲線を自身に面直またはベクトル投影して曲線リストを求める. </p>
<p>投影曲線は3次元曲線としてvec_crvに格納される。 3次元曲線のtoleranceはline_zero()を使用している。 get perpendicular or vector projection curve list. 3d projection curves are put into vec_crv(line_zero() is used). 引数： const <a class="el" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve.">MGCurve</a>&amp; crv, (I/ ) given curve. <a class="el" href="class_m_g_pvector.html">MGPvector&lt;MGCurve&gt;</a>&amp; vec_crv, ( /O) 3d projection curve. const <a class="el" href="class_m_g_vector.html" title="Vector of a general n space dimension.">MGVector</a>&amp; vec=mgNULL_VEC (I/ ) projection vector. 戻り値： 投影曲線の数: 投影曲線が求まった 0: 投影曲線が求まらなかった -1: 内部処理エラー -2: 収束処理エラー（収束しなかった） 追記：引数vecが与えられないとき、面直投影する。 Obtain the projected curve of a curve onto the surface. The direction of the projection is along the vector vec if the vec is not NULL, and normal to the surface if the vec is NULL. Output of 'project' is general world coordinate curves('vec_crv') </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>crv</em>&nbsp;</td><td>given curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_crv</em>&nbsp;</td><td>3d projection curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>projection vector, if vec = NULL then calculate perpendicular project. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#ae69e0eb803f2f7c70c75ef7ea0fdf2e5">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aefe8f7187ede379cb7528bef93a111a0"></a><!-- doxytag: member="MGPlane::range" ref="aefe8f7187ede379cb7528bef93a111a0" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPlane::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力パラメータをパラメータ範囲でまるめて返却する. </p>
<p>Round the input uv into parameter range of the plane, return the same value as input. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8966c7e15642175de66afee13234dfc5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a73af9dc47329892f37909bbec0a86f4d"></a><!-- doxytag: member="MGPlane::relation" ref="a73af9dc47329892f37909bbec0a86f4d" args="(const MGPlane &amp;, MGStraight &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#gaaab2ed6df6bc2f3b1f99a0df77b7c1a9">MGPSRELATION</a> MGPlane::relation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた平面との関係を返す. </p>
<p>Relation of two planes. </p>

</div>
</div>
<a class="anchor" id="acc68c2c72de9dc430ff5a871126ed8d1"></a><!-- doxytag: member="MGPlane::relation" ref="acc68c2c72de9dc430ff5a871126ed8d1" args="(const MGStraight &amp;, MGCSisect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#gaaab2ed6df6bc2f3b1f99a0df77b7c1a9">MGPSRELATION</a> MGPlane::relation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_c_sisect.html">MGCSisect</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた直線との関係を返す。 Relation between plane and straight line. </p>

</div>
</div>
<a class="anchor" id="a8afaba342f195eab3d3448ddd37ccdd4"></a><!-- doxytag: member="MGPlane::root_point" ref="a8afaba342f195eab3d3448ddd37ccdd4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_position.html">MGPosition</a>&amp; MGPlane::root_point </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>平面のパラメータ表現の起点を返却する。 Return root point of the plane. </p>

</div>
</div>
<a class="anchor" id="a21c6e4cd6c4ce3efd2d1dfe98f043a04"></a><!-- doxytag: member="MGPlane::shade" ref="a21c6e4cd6c4ce3efd2d1dfe98f043a04" args="(double span_length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPlane::shade </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shade the object in world coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a55206c783635934aa4bcd2f3231a2a1a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a98581c81192065133fa2c26253c152ce"></a><!-- doxytag: member="MGPlane::skeleton" ref="a98581c81192065133fa2c26253c152ce" args="(int density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt;<a class="el" href="class_m_g_curve.html">MGCurve</a>&gt; MGPlane::skeleton </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>density</em> = <code>1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain boundary and main parameter lines of the FSurface. </p>
<p>skeleton includes boundary() and inner parameter lines. density indicates how many inner parameter lines are necessary for both u and v directions. </p>

<p>Reimplemented from <a class="el" href="class_m_g_f_surface.html#a24ce3062df19bd896a864d54826a2ab2">MGFSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a10de314e84981bdcc18a049b917e9d73"></a><!-- doxytag: member="MGPlane::split" ref="a10de314e84981bdcc18a049b917e9d73" args="(double param, bool is_u, MGPvector&lt; MGFSurface &gt; &amp;surfaces) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGPlane::split </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_pvector.html">MGPvector</a>&lt; <a class="el" href="class_m_g_f_surface.html">MGFSurface</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>surfaces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>split this fsurface at the parameter param. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of this fsurface. if is_u is true, param is u-value, else v-value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>indicates if param is u or v of the surface parameter (u,v). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>surfaces</em>&nbsp;</td><td>splitted surfaces will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aa42207d63b66cb594cf5329597657eec">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a340c1e5493ce45c2c33dded8fcfa0798"></a><!-- doxytag: member="MGPlane::type" ref="a340c1e5493ce45c2c33dded8fcfa0798" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a> MGPlane::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面タイプを返却する。 Return surface type of the plane. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a83ad0b3f99b05d775a1d4d7352baf9d0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9aad3737827a102351567bbd2723ae85"></a><!-- doxytag: member="MGPlane::u_deriv" ref="a9aad3737827a102351567bbd2723ae85" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGPlane::u_deriv </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>平面のパラメータ表現のｕ方向を返却する。 Return u-direction vector of the plane. </p>

</div>
</div>
<a class="anchor" id="ad8fec1fb924fd776813da0cc4acdbad0"></a><!-- doxytag: member="MGPlane::uv" ref="ad8fec1fb924fd776813da0cc4acdbad0" args="(const MGVector &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGPlane::uv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vectorを平面に投影したVectorの平面のパラメータ表現(u,v)を求める。 Return uv parameter of the point projected from point p to the plane. </p>
<p>p is the end of the vector v originated from the <a class="el" href="class_m_g_plane.html#a8afaba342f195eab3d3448ddd37ccdd4" title="平面のパラメータ表現の起点を返却する。 Return root point of the...">root_point()</a>. </p>

</div>
</div>
<a class="anchor" id="a7af6a6605c67a02d6a15c15e5563d2f8"></a><!-- doxytag: member="MGPlane::uv" ref="a7af6a6605c67a02d6a15c15e5563d2f8" args="(const MGPosition &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGPlane::uv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>点を平面に投影した点の平面のパラメータ表現(u,v)を求める。 Return uv parameter of the point projected from point p to the plane. </p>

</div>
</div>
<a class="anchor" id="a25803f218ee8689f6aaa2132ff9b9f4b"></a><!-- doxytag: member="MGPlane::v_deriv" ref="a25803f218ee8689f6aaa2132ff9b9f4b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_vector.html">MGVector</a>&amp; MGPlane::v_deriv </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>平面のパラメータ表現のｖ方向を返却する。 Return v-direction vector of the plane. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Plane.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:27 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

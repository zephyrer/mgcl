<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGCylinder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGCylinder Class Reference<br/>
<small>
[<a class="el" href="group___g_e_o.html">Geometry (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGCylinder" --><!-- doxytag: inherits="MGSurface" -->
<p><a class="el" href="class_m_g_cylinder.html" title="MGCylinder is a Cylinder in 3D space.">MGCylinder</a> is a Cylinder in 3D space.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Cylinder.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGCylinder:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_cylinder__inherit__graph.png" border="0" usemap="#_m_g_cylinder_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_cylinder_inherit__map" id="_m_g_cylinder_inherit__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="76,315,161,344"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="9,237,108,267"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/><area shape="rect" id="node12" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="132,237,225,267"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGCylinder:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_cylinder__coll__graph.png" border="0" usemap="#_m_g_cylinder_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_cylinder_coll__map" id="_m_g_cylinder_coll__map">
<area shape="rect" id="node2" href="class_m_g_surface.html" title="MGSurface is an abstract class of 3D surface." alt="" coords="13,616,99,645"/><area shape="rect" id="node4" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="299,517,397,547"/><area shape="rect" id="node30" href="class_m_g_curve.html" title="MGCurve is an abstract class which represents a whole curve." alt="" coords="304,616,379,645"/><area shape="rect" id="node6" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="308,405,388,435"/><area shape="rect" id="node8" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="257,85,364,115"/><area shape="rect" id="node14" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="365,181,443,211"/><area shape="rect" id="node10" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="280,5,341,35"/><area shape="rect" id="node12" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="348,293,460,323"/><area shape="rect" id="node17" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="388,85,521,115"/><area shape="rect" id="node20" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="209,405,276,435"/><area shape="rect" id="node22" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="180,293,263,323"/><area shape="rect" id="node24" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="129,181,207,211"/><area shape="rect" id="node28" href="class_m_g_straight.html" title="MGStraight is a curve of any space dimension, represent a straight line." alt="" coords="232,715,320,744"/><area shape="rect" id="node26" href="class_m_g_f_surface.html" title="Define MGFSurface Class." alt="" coords="5,517,99,547"/><area shape="rect" id="node43" href="class_m_g_ellipse.html" title="MGEllipse is a class to define an ellipse of 2D or 3D." alt="" coords="444,715,527,744"/><area shape="rect" id="node33" href="class_m_g_position.html" title="Represent a positional data." alt="" coords="519,616,609,645"/><area shape="rect" id="node35" href="class_m_g_vector.html" title="Vector of a general n space dimension." alt="" coords="575,517,655,547"/><area shape="rect" id="node46" href="class_m_g_unit__vector.html" title="Define a unit vector, is a MGVector." alt="" coords="711,616,817,645"/><area shape="rect" id="node39" href="class_m_g_knot_vector.html" title="Defines Knot vector of B&#45;Representation." alt="" coords="173,616,280,645"/><area shape="rect" id="node41" href="class_m_g_n_d_d_array.html" title="Defines non&#45;decreasing double data array." alt="" coords="173,517,275,547"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_cylinder-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4018b6a9def2f339914b452221ac74a0"></a><!-- doxytag: member="MGCylinder::MGCylinder" ref="a4018b6a9def2f339914b452221ac74a0" args="(void)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a4018b6a9def2f339914b452221ac74a0">MGCylinder</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Void constructor 初期化なしで柱面を生成する。. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a10889a4a2a8443d7bc3ba50511ca78cc">MGCylinder</a> (size_t dim, const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;cyl, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a Cylinder by changing this space dimension or ordering the coordinates.  <a href="#a10889a4a2a8443d7bc3ba50511ca78cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#af7b19730b3312e84ae42feff7896dcf0">MGCylinder</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;bottom, const <a class="el" href="class_m_g_vector.html">MGVector</a> axis, double radius, bool outgoing=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a cylinder of whole circle whose bottom center is bottom and top center is bottom+axis.  <a href="#af7b19730b3312e84ae42feff7896dcf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a758bfe71d707fdcca31925238d860bba">MGCylinder</a> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;ellipse, const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;axis)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cylinder from an ellipse and the axis straight line.  <a href="#a758bfe71d707fdcca31925238d860bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a0066fa000f6dd64f0e8a15274d7215e4">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor//////////////// ‾MGCylinder();.  <a href="#a0066fa000f6dd64f0e8a15274d7215e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40ed1af3155c57098628a420f0092aee"></a><!-- doxytag: member="MGCylinder::operator=" ref="a40ed1af3155c57098628a420f0092aee" args="(const MGCylinder &amp;gel2)" -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2f87e0385dae1851cfc13f0d48a752"></a><!-- doxytag: member="MGCylinder::operator+" ref="aeb2f87e0385dae1851cfc13f0d48a752" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#aeb2f87e0385dae1851cfc13f0d48a752">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translation of the Cylinder. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7abb2cce3244a2b94c272c411dfdc7cc"></a><!-- doxytag: member="MGCylinder::operator&#45;" ref="a7abb2cce3244a2b94c272c411dfdc7cc" args="(const MGVector &amp;) const " -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a7abb2cce3244a2b94c272c411dfdc7cc">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translation of the Cylinder. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ade3698ce12ef33614e4058d36a0520cb">operator*</a> (double) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">柱面のスケーリングを行い，柱面を作成する。 Scaling of the Cylinder by a double.  <a href="#ade3698ce12ef33614e4058d36a0520cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c723847aef4d1dcb55dae373a4e71d1"></a><!-- doxytag: member="MGCylinder::operator*" ref="a4c723847aef4d1dcb55dae373a4e71d1" args="(const MGMatrix &amp;) const " -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a4c723847aef4d1dcb55dae373a4e71d1">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the Cylinder by a matrix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa157e3a7b242a9f0b603e20c51d744b5"></a><!-- doxytag: member="MGCylinder::operator*" ref="aa157e3a7b242a9f0b603e20c51d744b5" args="(const MGTransf &amp;) const " -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#aa157e3a7b242a9f0b603e20c51d744b5">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transformation of the Cylinder by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad68731aeca764d95c5a611cbcd4a3279"></a><!-- doxytag: member="MGCylinder::operator+=" ref="ad68731aeca764d95c5a611cbcd4a3279" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ad68731aeca764d95c5a611cbcd4a3279">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba398f4e4955a8d51def81363522ab5c"></a><!-- doxytag: member="MGCylinder::operator&#45;=" ref="aba398f4e4955a8d51def81363522ab5c" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a37d5c9a1d510414216b25e5c8ce1b9"></a><!-- doxytag: member="MGCylinder::operator*=" ref="a9a37d5c9a1d510414216b25e5c8ce1b9" args="(double scale)" -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b80c20e35e60c89b11b193044e257f4"></a><!-- doxytag: member="MGCylinder::operator*=" ref="a9b80c20e35e60c89b11b193044e257f4" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa40b6e225b229c36076c933bf2919208"></a><!-- doxytag: member="MGCylinder::operator*=" ref="aa40b6e225b229c36076c933bf2919208" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7880563745419f42ec15c48fb95e706"></a><!-- doxytag: member="MGCylinder::operator==" ref="af7880563745419f42ec15c48fb95e706" args="(const MGCylinder &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#af7880563745419f42ec15c48fb95e706">operator==</a> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two curves. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c23c84e550406f2acdefb60ecee0de2"></a><!-- doxytag: member="MGCylinder::operator==" ref="a2c23c84e550406f2acdefb60ecee0de2" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a2c23c84e550406f2acdefb60ecee0de2">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66569daa9e5fbd02ab3a0de0b7d4caa3"></a><!-- doxytag: member="MGCylinder::operator&lt;" ref="a66569daa9e5fbd02ab3a0de0b7d4caa3" args="(const MGCylinder &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0fa640d3d27c8c4e2358587fd434b12"></a><!-- doxytag: member="MGCylinder::operator&lt;" ref="af0fa640d3d27c8c4e2358587fd434b12" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a796ee03c683a9cb9af75d45d04c6427d"></a><!-- doxytag: member="MGCylinder::operator!=" ref="a796ee03c683a9cb9af75d45d04c6427d" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c69e411551045c00918ca9ae40234a3"></a><!-- doxytag: member="MGCylinder::operator!=" ref="a6c69e411551045c00918ca9ae40234a3" args="(const MGCylinder &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ba9292796414fb0a7c757a328be2ef8"></a><!-- doxytag: member="MGCylinder::out_to_IGES" ref="a6ba9292796414fb0a7c757a328be2ef8" args="(MGIgesOfstream &amp;igesfile, int SubordinateEntitySwitch=0) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a6ba9292796414fb0a7c757a328be2ef8">out_to_IGES</a> (<a class="el" href="class_m_g_iges_ofstream.html">MGIgesOfstream</a> &amp;igesfile, int SubordinateEntitySwitch=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output to IGES stream file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ac6d0b4dfc027284e03fadff31d8675f5">out</a> (std::ostream &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug function デバッグ関数//////////// Output function.  <a href="#ac6d0b4dfc027284e03fadff31d8675f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a5e77dceb2626130499376407219b4e52">box_limitted</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvrange) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Box that includes limitted Cylinder by box.  <a href="#a5e77dceb2626130499376407219b4e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6f6623bf780f72316fce33ac1094029"></a><!-- doxytag: member="MGCylinder::center" ref="ad6f6623bf780f72316fce33ac1094029" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ad6f6623bf780f72316fce33ac1094029">center</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain ceter coordinate of the geometry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a917a1dd67813d56274904d95980e084b">change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changing this object's space dimension.  <a href="#a917a1dd67813d56274904d95980e084b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#abadaa0513dbecebf7f5c58c094394be8">change_range</a> (int is_u, double t1, double t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change parameter range, be able to change the direction by providing t1 greater than t2.  <a href="#abadaa0513dbecebf7f5c58c094394be8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a8cfc205e727c9d77cb3c393a4bdf925d">closest</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the closest point parameter value (u,v) of this surface from a point.  <a href="#a8cfc205e727c9d77cb3c393a4bdf925d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a6cc82d0d57aa40f004bf559b0b665104">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by copying to newed area.  <a href="#a6cc82d0d57aa40f004bf559b0b665104"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ae9a4a39c77ce36e80743cdc3ebb456f7">copy_change_dimension</a> (size_t sdim, size_t start1=0, size_t start2=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct new surface object by changing the original object's space dimension.  <a href="#ae9a4a39c77ce36e80743cdc3ebb456f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a95a2666dcb61d8293385c07c51048a61">distance</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた点との距離を返却する。 Return the distace between Cylinder and the point.  <a href="#a95a2666dcb61d8293385c07c51048a61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a151bc0f63249fe878740eb16e5d7c457">eval</a> (double u, double v, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a151bc0f63249fe878740eb16e5d7c457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a6288008dc36129da70f17870a05a5902">eval</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, size_t ndu=0, size_t ndv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate surface data.  <a href="#a6288008dc36129da70f17870a05a5902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a30f4773f6bc7ecc496527b3dbcbecd32">eval_all</a> (double u, double v, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#a30f4773f6bc7ecc496527b3dbcbecd32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a9fa0d2966629c8a0532fde91477ffbb6">eval_all</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;f, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuv, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fuu, <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;fvv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate right continuous surface data.  <a href="#a9fa0d2966629c8a0532fde91477ffbb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44cff3eeddb6ecb843e60e9d3e7a46fc"></a><!-- doxytag: member="MGCylinder::exchange_uv" ref="a44cff3eeddb6ecb843e60e9d3e7a46fc" args="()" -->
<a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a44cff3eeddb6ecb843e60e9d3e7a46fc">exchange_uv</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange parameter u and v. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#add30aac7fbdc06eedbb880369c861168">extend</a> (int perimeter, double param, double length, double dk=0.)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify the original Surface by extrapolating the specified perimeter.  <a href="#add30aac7fbdc06eedbb880369c861168"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae9f999c2d1b0210b6f559547751a28c"></a><!-- doxytag: member="MGCylinder::identify_type" ref="aae9f999c2d1b0210b6f559547751a28c" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#aae9f999c2d1b0210b6f559547751a28c">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return This object's typeID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92a8d00e2f5ff58cbc968d11f99ddedf"></a><!-- doxytag: member="MGCylinder::in_range" ref="a92a8d00e2f5ff58cbc968d11f99ddedf" args="(double u, double v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a92a8d00e2f5ff58cbc968d11f99ddedf">in_range</a> (double u, double v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if parameter value (u,v) is in the range of the FSurface parameter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1923f48e5361390df750f672751e7573"></a><!-- doxytag: member="MGCylinder::in_range" ref="a1923f48e5361390df750f672751e7573" args="(const MGPosition &amp;uv) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>in_range</b> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a397f3a462ee330902fa56a2c6d13b0d8">intersect_dnum_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess.  <a href="#a397f3a462ee330902fa56a2c6d13b0d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67f5075e1213325628971a93095d80b"></a><!-- doxytag: member="MGCylinder::intersect_dnum_v" ref="ae67f5075e1213325628971a93095d80b" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>intersect_dnum_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a3edf03eba31701f680b557bdc68726a1">isect</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;curve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Curve の交点を求める。 Compute intesection of Cylinder and Curve.  <a href="#a3edf03eba31701f680b557bdc68726a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb5f0860693c4b99343c896854093a17"></a><!-- doxytag: member="MGCylinder::isect" ref="aeb5f0860693c4b99343c896854093a17" args="(const MGStraight &amp;line) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;line) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4670d685dc878ee4543f075677d75c5b"></a><!-- doxytag: member="MGCylinder::isect" ref="a4670d685dc878ee4543f075677d75c5b" args="(const MGRLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_l_b_rep.html">MGRLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0d4a7dca4fa2de098462f97c594dc2"></a><!-- doxytag: member="MGCylinder::isect" ref="a9d0d4a7dca4fa2de098462f97c594dc2" args="(const MGEllipse &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b59dbcb910641cf156772a364b1620f"></a><!-- doxytag: member="MGCylinder::isect" ref="a2b59dbcb910641cf156772a364b1620f" args="(const MGLBRep &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_l_b_rep.html">MGLBRep</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa240de027ddfbd5a812ee6d1580b7117"></a><!-- doxytag: member="MGCylinder::isect" ref="aa240de027ddfbd5a812ee6d1580b7117" args="(const MGSurfCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_surf_curve.html">MGSurfCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7efe56bf9c126fa31597445530844fb0"></a><!-- doxytag: member="MGCylinder::isect" ref="a7efe56bf9c126fa31597445530844fb0" args="(const MGBSumCurve &amp;curve) const " -->
<a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_curve.html">MGBSumCurve</a> &amp;curve) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a233473e7e409c76ab8b3547363d4c3a6">isect</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;srf2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface と Surface の交線を求める。 Surface and Surface intersection.  <a href="#a233473e7e409c76ab8b3547363d4c3a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aece24c0b2c2be4a7d34025e564817758"></a><!-- doxytag: member="MGCylinder::isect" ref="aece24c0b2c2be4a7d34025e564817758" args="(const MGPlane &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_plane.html">MGPlane</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908360c34a322108c4020a0ea96ef10d"></a><!-- doxytag: member="MGCylinder::isect" ref="a908360c34a322108c4020a0ea96ef10d" args="(const MGSphere &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_sphere.html">MGSphere</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98ded83c4ff6fa81d2f3542abd91c95c"></a><!-- doxytag: member="MGCylinder::isect" ref="a98ded83c4ff6fa81d2f3542abd91c95c" args="(const MGCylinder &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52223d8081a72e830ec587ec9668fdd5"></a><!-- doxytag: member="MGCylinder::isect" ref="a52223d8081a72e830ec587ec9668fdd5" args="(const MGSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_s_b_rep.html">MGSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d5fffbf9749df796a34fcfc5fbb82aa"></a><!-- doxytag: member="MGCylinder::isect" ref="a7d5fffbf9749df796a34fcfc5fbb82aa" args="(const MGRSBRep &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_r_s_b_rep.html">MGRSBRep</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d57ede234a9d3844d52776686755d7"></a><!-- doxytag: member="MGCylinder::isect" ref="ab2d57ede234a9d3844d52776686755d7" args="(const MGBSumSurf &amp;srf2) const " -->
<a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>isect</b> (const <a class="el" href="class_m_g_b_sum_surf.html">MGBSumSurf</a> &amp;srf2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1b6623e05e1483cfb83a7ecfb225fd6"></a><!-- doxytag: member="MGCylinder::knot_u" ref="ab1b6623e05e1483cfb83a7ecfb225fd6" args="(size_t i) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ab1b6623e05e1483cfb83a7ecfb225fd6">knot_u</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return knot value of (infinite-minus, infinite-plus). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfac0a0b8ae69c5bbcefc6a7e32bc417"></a><!-- doxytag: member="MGCylinder::knot_v" ref="acfac0a0b8ae69c5bbcefc6a7e32bc417" args="(size_t j) const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#acfac0a0b8ae69c5bbcefc6a7e32bc417">knot_v</a> (size_t j) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to i-th element of v knot. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01a1221846f30c00050e5c559d8cb08b"></a><!-- doxytag: member="MGCylinder::knot_vector_u" ref="a01a1221846f30c00050e5c559d8cb08b" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a01a1221846f30c00050e5c559d8cb08b">knot_vector_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the u knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dcb42a75aacaca4e3db62f8194b77f9"></a><!-- doxytag: member="MGCylinder::knot_vector_u" ref="a8dcb42a75aacaca4e3db62f8194b77f9" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_u</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab549295b37b8f912275a612a77a1e681"></a><!-- doxytag: member="MGCylinder::knot_vector_v" ref="ab549295b37b8f912275a612a77a1e681" args="() const " -->
const <a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ab549295b37b8f912275a612a77a1e681">knot_vector_v</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the v knot vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c366d055c9ca1fbc1eb870969d36c87"></a><!-- doxytag: member="MGCylinder::knot_vector_v" ref="a0c366d055c9ca1fbc1eb870969d36c87" args="()" -->
<a class="el" href="class_m_g_knot_vector.html">MGKnotVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>knot_vector_v</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ad5b5d393e7163edbd896e30a8fc4468c">negate</a> (int is_u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">柱面を反転する。ノーマルを逆方向にする。 Negate the normal of the Cylinder.  <a href="#ad5b5d393e7163edbd896e30a8fc4468c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a62d144592e0bd75aa02dcf13d857b41c">negate_param</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, int is_u=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter value if this surface is negated by "negate()".  <a href="#a62d144592e0bd75aa02dcf13d857b41c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4961971a52f2172ab173f68de3182efa"></a><!-- doxytag: member="MGCylinder::ellipse" ref="a4961971a52f2172ab173f68de3182efa" args="() const " -->
const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a4961971a52f2172ab173f68de3182efa">ellipse</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the normal of the Cylinder. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2ffd834a1be97ac5429e322089d3df"></a><!-- doxytag: member="MGCylinder::axis" ref="a6c2ffd834a1be97ac5429e322089d3df" args="() const " -->
const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>axis</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="class_m_g_surface.html">MGSurface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ab8001901de0d336274a825f1ec0505e2">offset_c1</a> (double ofs_value, int &amp;error) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。トレランスはline_zero()を使用している。 戻り値は、オフセット面のオートポインターが返却される。 Surface offset.  <a href="#ab8001901de0d336274a825f1ec0505e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a3b9680f36113090ae96029b2714f1bec">on</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;point, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;puv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定点が面上にあるか調べる。（面上ならばtrue） Test if a point is on the Cylinder.  <a href="#a3b9680f36113090ae96029b2714f1bec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a04414ee9c8cf9e6d48952922c0fae42f">on_a_perimeter</a> (double &amp;u, double &amp;v, size_t &amp;perim_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if input (u,v) is parameter value on a perimeter of the surface.  <a href="#a04414ee9c8cf9e6d48952922c0fae42f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6690994fccdd1a202cf7aefc0be6af"></a><!-- doxytag: member="MGCylinder::param_error" ref="aed6690994fccdd1a202cf7aefc0be6af" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#aed6690994fccdd1a202cf7aefc0be6af">param_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain parameter space error. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa129468f7abce0bb7a277c5770a4dba7"></a><!-- doxytag: member="MGCylinder::param_e_u" ref="aa129468f7abce0bb7a277c5770a4dba7" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#aa129468f7abce0bb7a277c5770a4dba7">param_e_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return ending parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ca4abefb06e3ce10c92db4c6647650a"></a><!-- doxytag: member="MGCylinder::param_e_v" ref="a7ca4abefb06e3ce10c92db4c6647650a" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_e_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_box.html">MGBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a94e4819a42abd37f1caa2fd0962476df">param_range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パラメータ範囲を返す。 Return parameter range of the Cylinder(Infinite box).  <a href="#a94e4819a42abd37f1caa2fd0962476df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ee8c2a961194f8a20c144f519d6224d"></a><!-- doxytag: member="MGCylinder::param_s_u" ref="a0ee8c2a961194f8a20c144f519d6224d" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a0ee8c2a961194f8a20c144f519d6224d">param_s_u</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return starting parameter value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f122296dba878e4238f4e91b0df12f"></a><!-- doxytag: member="MGCylinder::param_s_v" ref="a95f122296dba878e4238f4e91b0df12f" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>param_s_v</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ab9a3647d2c9fef4f562a6983021f7e91">parameter_curve</a> (int is_u, double x) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parameter curve.  <a href="#ab9a3647d2c9fef4f562a6983021f7e91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a9482d2f0f4a0e94c09db142411f597fd">part</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;bx, int multiple=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute part of the surface limitted by the parameter range bx.  <a href="#a9482d2f0f4a0e94c09db142411f597fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ad2c8465ddc2a6643409df28908cdbde9">perimeter_curve</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">i must be &lt; <a class="el" href="class_m_g_cylinder.html#a0d83ff86049d69b5511221522447d99f" title="Return how many perimeters this surface has.">perimeter_num()</a>.  <a href="#ad2c8465ddc2a6643409df28908cdbde9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d83ff86049d69b5511221522447d99f"></a><!-- doxytag: member="MGCylinder::perimeter_num" ref="a0d83ff86049d69b5511221522447d99f" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a0d83ff86049d69b5511221522447d99f">perimeter_num</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return how many perimeters this surface has. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#af2afc495f138ff58e03088e847236d5f">perp_point</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv, const <a class="el" href="class_m_g_position.html">MGPosition</a> *uvguess=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた点にもっとも近い面上の点を返却する。パラメ ータ値も返却する。 Return the nearest point of the Cylinder from P.  <a href="#af2afc495f138ff58e03088e847236d5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a38776f8959055ad54283c6be587bc1e5">perps</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all(actually one) foots of perpendicular straight lines from P.  <a href="#a38776f8959055ad54283c6be587bc1e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a2e0654da4bfe2b9d45ae86c1c4a8a842">range</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;uv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">入力パラメータをパラメータ範囲でまるめて返却する。 Round the input uv into parameter range of the Cylinder, return the same value as input.  <a href="#a2e0654da4bfe2b9d45ae86c1c4a8a842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea94a11b03d6ea5dfd9f55603c47d37"></a><!-- doxytag: member="MGCylinder::sdim" ref="a8ea94a11b03d6ea5dfd9f55603c47d37" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a8ea94a11b03d6ea5dfd9f55603c47d37">sdim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the space dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a23195f906d946b4a68a8b46aff07f092">type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">曲面タイプを返却する。 Return surface type of the Cylinder.  <a href="#a23195f906d946b4a68a8b46aff07f092"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ace4057429c8d64c9679e06367b018550">flat</a> (const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox, double tol, int &amp;direction, <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, <a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;N) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the surface is flat or not within the parameter value rectangle of uvbox.  <a href="#ace4057429c8d64c9679e06367b018550"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a6b7865485510dac75700adf3a9aedebe">flat_tess</a> (double u0, double u1, double v0, double v1, double tol, bool &amp;direction, double max_edge_len) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the same as flat except that this does not have the arguments P, N.  <a href="#a6b7865485510dac75700adf3a9aedebe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a8ce7bdd2f254cd4d835f182aa55825da">isectSl</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl, const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;uvbox=mgNULL_BOX) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersection of Surface and a straight line.  <a href="#a8ce7bdd2f254cd4d835f182aa55825da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a3180f1cbffdd9f72c6cdd77065404842">vrange</a> (const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;P, double &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the v parameter value of the neareast point from the point P to the axis.  <a href="#a3180f1cbffdd9f72c6cdd77065404842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae370b63797c976bf324ef4d3917eabd1"></a><!-- doxytag: member="MGCylinder::ReadMembers" ref="ae370b63797c976bf324ef4d3917eabd1" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#ae370b63797c976bf324ef4d3917eabd1">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを読み込む関数 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acafdf1443f8aab9f83c5e0b7fbf9ce85"></a><!-- doxytag: member="MGCylinder::WriteMembers" ref="acafdf1443f8aab9f83c5e0b7fbf9ce85" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#acafdf1443f8aab9f83c5e0b7fbf9ce85">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メンバデータを書き込む関数 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134a123cb853e0ebc37c26d5a72f3c6d"></a><!-- doxytag: member="MGCylinder::whoami" ref="a134a123cb853e0ebc37c26d5a72f3c6d" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2048f5e5d337bb84df4a8aedb3b94c0d"></a><!-- doxytag: member="MGCylinder::operator+" ref="a2048f5e5d337bb84df4a8aedb3b94c0d" args="(const MGVector &amp;v, const MGCylinder &amp;cyl)" -->
MGDECL friend <a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v, const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;cyl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e88ee06140088c6c7d7cc756829ab34"></a><!-- doxytag: member="MGCylinder::operator*" ref="a2e88ee06140088c6c7d7cc756829ab34" args="(double scale, const MGCylinder &amp;cyl)" -->
MGDECL friend <a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_cylinder.html#a2e88ee06140088c6c7d7cc756829ab34">operator*</a> (double scale, const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;cyl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling of the Cylinder by a double. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_cylinder.html" title="MGCylinder is a Cylinder in 3D space.">MGCylinder</a> is a Cylinder in 3D space. </p>
<p>Cylinder is expressed by an ellipse and a straight line. Cylinder function f(u,v) = m_ellipse(u) + m_axis(v), where u and v are two parameter of surface representation. Here, m_axis is a straight line whose root point is the origin. MGCylinderクラスは３次元空間における円筒面を表すクラスである。 MGCylinderクラスでは以下のようなパラメータ表現を使用します。 f(u,v) = m_ellipse(u) + m_axis(v); </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a10889a4a2a8443d7bc3ba50511ca78cc"></a><!-- doxytag: member="MGCylinder::MGCylinder" ref="a10889a4a2a8443d7bc3ba50511ca78cc" args="(size_t dim, const MGCylinder &amp;cyl, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCylinder::MGCylinder </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_cylinder.html">MGCylinder</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cyl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a Cylinder by changing this space dimension or ordering the coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td>New space dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cyl</em>&nbsp;</td><td>Original Cylinder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new Surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of original Surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7b19730b3312e84ae42feff7896dcf0"></a><!-- doxytag: member="MGCylinder::MGCylinder" ref="af7b19730b3312e84ae42feff7896dcf0" args="(const MGPosition &amp;bottom, const MGVector axis, double radius, bool outgoing=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCylinder::MGCylinder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>outgoing</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a cylinder of whole circle whose bottom center is bottom and top center is bottom+axis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bottom</em>&nbsp;</td><td>Location on axis to position the cylinder defines zero v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>The axis vector for the cylinder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>The radius of the cylinder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outgoing</em>&nbsp;</td><td>Indicates if the surface normal is going to outside of the cylinder(true) or inside(false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a758bfe71d707fdcca31925238d860bba"></a><!-- doxytag: member="MGCylinder::MGCylinder" ref="a758bfe71d707fdcca31925238d860bba" args="(const MGEllipse &amp;ellipse, const MGStraight &amp;axis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGCylinder::MGCylinder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_ellipse.html">MGEllipse</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ellipse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cylinder from an ellipse and the axis straight line. </p>
<p>When axis'es start point is not ellipse's center, axis'esstart point will be set to the center. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ellipse</em>&nbsp;</td><td>ellispe of the cylinder </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>axis of the cylinder. axis's root point will be neglected, always be set as the origin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5e77dceb2626130499376407219b4e52"></a><!-- doxytag: member="MGCylinder::box_limitted" ref="a5e77dceb2626130499376407219b4e52" args="(const MGBox &amp;uvrange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGCylinder::box_limitted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvrange</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力のパラメータ範囲の曲線部分を囲むボックスを返す。 Box that includes limitted Cylinder by box. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvrange</em>&nbsp;</td><td>Parameter Range of the surface. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a9182844563218c392ef526d29e5bfb7e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a917a1dd67813d56274904d95980e084b"></a><!-- doxytag: member="MGCylinder::change_dimension" ref="a917a1dd67813d56274904d95980e084b" args="(size_t sdim, size_t start1=0, size_t start2=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&amp; MGCylinder::change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changing this object's space dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ab37b86c29caed93258a98d7e70459d4e">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="abadaa0513dbecebf7f5c58c094394be8"></a><!-- doxytag: member="MGCylinder::change_range" ref="abadaa0513dbecebf7f5c58c094394be8" args="(int is_u, double t1, double t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&amp; MGCylinder::change_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change parameter range, be able to change the direction by providing t1 greater than t2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>if true, (t1,t2) are u-value. if not, v. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>Parameter value for the start of original. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>Parameter value for the end of original. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a1d4365d58c465f916b2fb038ef896b2d">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6cc82d0d57aa40f004bf559b0b665104"></a><!-- doxytag: member="MGCylinder::clone" ref="a6cc82d0d57aa40f004bf559b0b665104" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>* MGCylinder::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by copying to newed area. </p>
<p>User must delete this copied object by "delete". </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a55ce6580673b46480f6ae5a8d2117c17">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8cfc205e727c9d77cb3c393a4bdf925d"></a><!-- doxytag: member="MGCylinder::closest" ref="a8cfc205e727c9d77cb3c393a4bdf925d" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGCylinder::closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the closest point parameter value (u,v) of this surface from a point. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a968d690be2c0009a282ac74085b95422">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a4a39c77ce36e80743cdc3ebb456f7"></a><!-- doxytag: member="MGCylinder::copy_change_dimension" ref="ae9a4a39c77ce36e80743cdc3ebb456f7" args="(size_t sdim, size_t start1=0, size_t start2=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>* MGCylinder::copy_change_dimension </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start2</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct new surface object by changing the original object's space dimension. </p>
<p>User must delete this copied object by "delete". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdim</em>&nbsp;</td><td>new space dimension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start1</em>&nbsp;</td><td>Destination order of new line. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start2</em>&nbsp;</td><td>Source order of this line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a0cf87d2f42a919c9f5bc44cc406ea0fd">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a95a2666dcb61d8293385c07c51048a61"></a><!-- doxytag: member="MGCylinder::distance" ref="a95a2666dcb61d8293385c07c51048a61" args="(const MGPosition &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGCylinder::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた点との距離を返却する。 Return the distace between Cylinder and the point. </p>

</div>
</div>
<a class="anchor" id="a151bc0f63249fe878740eb16e5d7c457"></a><!-- doxytag: member="MGCylinder::eval" ref="a151bc0f63249fe878740eb16e5d7c457" args="(double u, double v, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGCylinder::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#ada7939e987d1f90d7c765b63b07b8533">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6288008dc36129da70f17870a05a5902"></a><!-- doxytag: member="MGCylinder::eval" ref="a6288008dc36129da70f17870a05a5902" args="(const MGPosition &amp;uv, size_t ndu=0, size_t ndv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGCylinder::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndu</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ndv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate surface data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndu</em>&nbsp;</td><td>Order of derivative along u. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ndv</em>&nbsp;</td><td>Order of derivative along v. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aafe04bb26aae4194f9c477ccdf900e27">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9fa0d2966629c8a0532fde91477ffbb6"></a><!-- doxytag: member="MGCylinder::eval_all" ref="a9fa0d2966629c8a0532fde91477ffbb6" args="(const MGPosition &amp;uv, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCylinder::eval_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data, 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8ce3c2446526c5961f70b998c37e4b30">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a30f4773f6bc7ecc496527b3dbcbecd32"></a><!-- doxytag: member="MGCylinder::eval_all" ref="a30f4773f6bc7ecc496527b3dbcbecd32" args="(double u, double v, MGPosition &amp;f, MGVector &amp;fu, MGVector &amp;fv, MGVector &amp;fuv, MGVector &amp;fuu, MGVector &amp;fvv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCylinder::eval_all </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fuu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_vector.html">MGVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fvv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate right continuous surface data. </p>
<p>Evaluate all positional data, 1st and 2nd derivatives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Parameter value of the surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Positional data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fu</em>&nbsp;</td><td>df(u,v)/du </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>df/dv </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuv</em>&nbsp;</td><td>d**2f/(du*dv) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuu</em>&nbsp;</td><td>d**2f/(du**2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fvv</em>&nbsp;</td><td>d**2f/(dv**2) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8153b4db02d3056377d79f43254d11e5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="add30aac7fbdc06eedbb880369c861168"></a><!-- doxytag: member="MGCylinder::extend" ref="add30aac7fbdc06eedbb880369c861168" args="(int perimeter, double param, double length, double dk=0.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&amp; MGCylinder::extend </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>perimeter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dk</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify the original Surface by extrapolating the specified perimeter. </p>
<p>The extrapolation is C2 continuous if the order &gt;=4. The extrapolation is done so that extrapolating length is "length" at the position of the parameter value "param" of the perimeter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>perimeter</em>&nbsp;</td><td>perimeter number of the Surface. =0:v=min, =1:u=max, =2:v=max, =3:u=min. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>parameter value of above perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>chord length to extend at the parameter param of the perimeter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dk</em>&nbsp;</td><td>Coefficient of how curvature should vary at extrapolation start point. When dk=0, curvature keeps same, i.e. dK/dS=0. When dk=1, curvature becomes zero at length extrapolated point, i.e. dK/dS=-K/length at extrapolation start point, (S=parameter of arc length, K=Curvature at start point) That is, when dk reaches to 1 from 0, curve changes to flat. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ab52fd64da1afa26965f381962edf0f75">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ace4057429c8d64c9679e06367b018550"></a><!-- doxytag: member="MGCylinder::flat" ref="ace4057429c8d64c9679e06367b018550" args="(const MGBox &amp;uvbox, double tol, int &amp;direction, MGPosition &amp;P, MGUnit_vector &amp;N) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCylinder::flat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_unit__vector.html">MGUnit_vector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the surface is flat or not within the parameter value rectangle of uvbox. </p>
<p>Function's return value is: true: if the surface is flat false: if the surface is not falt. When this is not falt, the direction that indicates which direction the surface should be divided will be output. the flatness is tested only approximately. This is for exclusive use of planar(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>Tolerance allowed to regart flat (Allowed distance from a Cylinder). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>1: u-direction is more non flat. 0: v-direction is more non flat. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Position of the flat Cylinder will be output. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Normal of the flat Cylinder will be output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a6cce2a79bd519568b05467e302274bba">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6b7865485510dac75700adf3a9aedebe"></a><!-- doxytag: member="MGCylinder::flat_tess" ref="a6b7865485510dac75700adf3a9aedebe" args="(double u0, double u1, double v0, double v1, double tol, bool &amp;direction, double max_edge_len) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCylinder::flat_tess </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max_edge_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the same as flat except that this does not have the arguments P, N. </p>
<p>the flatness is tested only approximately. This is for exclusive use of tessellation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u1</em>&nbsp;</td><td>u range from u0 to u1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>v range from v0 to v1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>Tolerance allowed to regart flat (Allowed distance from a Cylinder). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>1: u-direction is more non flat. 0: v-direction is more non flat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a397f3a462ee330902fa56a2c6d13b0d8"></a><!-- doxytag: member="MGCylinder::intersect_dnum_u" ref="a397f3a462ee330902fa56a2c6d13b0d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MGCylinder::intersect_dnum_u </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The following two function will be used in perps or isect to decide how many division of the surface along u or v direction should be applied before using perp_guess or isect_guess. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#adeee48dc794aa404bce3dc81b9679cfb">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a3edf03eba31701f680b557bdc68726a1"></a><!-- doxytag: member="MGCylinder::isect" ref="a3edf03eba31701f680b557bdc68726a1" args="(const MGCurve &amp;curve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGCylinder::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curve</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Curve の交点を求める。 Compute intesection of Cylinder and Curve. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a97fecbc27841cd336e1b26d2e64c2bf0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a233473e7e409c76ab8b3547363d4c3a6"></a><!-- doxytag: member="MGCylinder::isect" ref="a233473e7e409c76ab8b3547363d4c3a6" args="(const MGSurface &amp;srf2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_s_sisect__list.html">MGSSisect_list</a> MGCylinder::isect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srf2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface と Surface の交線を求める。 Surface and Surface intersection. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a3d84645dc04d80bb2ff1df214f3a3b9b">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce7bdd2f254cd4d835f182aa55825da"></a><!-- doxytag: member="MGCylinder::isectSl" ref="a8ce7bdd2f254cd4d835f182aa55825da" args="(const MGStraight &amp;sl, const MGBox &amp;uvbox=mgNULL_BOX) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_c_sisect__list.html">MGCSisect_list</a> MGCylinder::isectSl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvbox</em> = <code>mgNULL_BOX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersection of Surface and a straight line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uvbox</em>&nbsp;</td><td>indicates if this surface is restrictied to the parameter range of uvbox. If uvbox.is_null(), no restriction. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aa0bd5720dfdbf979fa89054b785014ce">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b5d393e7163edbd896e30a8fc4468c"></a><!-- doxytag: member="MGCylinder::negate" ref="ad5b5d393e7163edbd896e30a8fc4468c" args="(int is_u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGCylinder::negate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>柱面を反転する。ノーマルを逆方向にする。 Negate the normal of the Cylinder. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Negate along u-direction if is_u is ture, else along v-direction. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a5f1ebb47122de32a0f5702f160a51d2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a62d144592e0bd75aa02dcf13d857b41c"></a><!-- doxytag: member="MGCylinder::negate_param" ref="a62d144592e0bd75aa02dcf13d857b41c" args="(const MGPosition &amp;uv, int is_u=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGCylinder::negate_param </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain parameter value if this surface is negated by "negate()". </p>
<p>Negate along u-direction if is_u is ture, else along v-direction. </p>

</div>
</div>
<a class="anchor" id="ab8001901de0d336274a825f1ec0505e2"></a><!-- doxytag: member="MGCylinder::offset_c1" ref="ab8001901de0d336274a825f1ec0505e2" args="(double ofs_value, int &amp;error) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="class_m_g_surface.html">MGSurface</a>&gt; MGCylinder::offset_c1 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ofs_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C1連続曲面の一定オフセット関数 オフセット方向は、ノーマル方向を正とする。トレランスはline_zero()を使用している。 戻り値は、オフセット面のオートポインターが返却される。 Surface offset. </p>
<p>positive offset value is offset normal direction. the radius of curvature must be larger than offset value. line_zero() is used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofs_value</em>&nbsp;</td><td>オフセット量 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>エラーコード 0:成功 -1:面におれがある -2:曲率半径以上のオフセット不可 -3:面生成コンストラクタエラー </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ae2dab410e24064b16318be2f56d2246c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a3b9680f36113090ae96029b2714f1bec"></a><!-- doxytag: member="MGCylinder::on" ref="a3b9680f36113090ae96029b2714f1bec" args="(const MGPosition &amp;point, MGPosition &amp;puv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCylinder::on </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>puv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定点が面上にあるか調べる。（面上ならばtrue） Test if a point is on the Cylinder. </p>
<p>If on the Cylinder, return true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>A point to test 指定点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>puv</em>&nbsp;</td><td>Parameter value of the Cylinder will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a409507f5dcc86cab92e3448529a94196">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a04414ee9c8cf9e6d48952922c0fae42f"></a><!-- doxytag: member="MGCylinder::on_a_perimeter" ref="a04414ee9c8cf9e6d48952922c0fae42f" args="(double &amp;u, double &amp;v, size_t &amp;perim_num) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGCylinder::on_a_perimeter </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>perim_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if input (u,v) is parameter value on a perimeter of the surface. </p>
<p>If u or v is on a perimeter, (u,v) will be updated to the perimeter value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Surface parameter (u,v) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perim_num</em>&nbsp;</td><td>if function returns true, the perimete rnumber is output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a6f773b2759f1b0c66b20ed8888aae990">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ade3698ce12ef33614e4058d36a0520cb"></a><!-- doxytag: member="MGCylinder::operator*" ref="ade3698ce12ef33614e4058d36a0520cb" args="(double) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a> MGCylinder::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>柱面のスケーリングを行い，柱面を作成する。 Scaling of the Cylinder by a double. </p>

</div>
</div>
<a class="anchor" id="a0066fa000f6dd64f0e8a15274d7215e4"></a><!-- doxytag: member="MGCylinder::operator=" ref="a0066fa000f6dd64f0e8a15274d7215e4" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>&amp; MGCylinder::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor//////////////// ‾MGCylinder();. </p>
<p>Assignment. When the leaf object of this and srf2 are not equal, this assignment does nothing. </p>

</div>
</div>
<a class="anchor" id="ac6d0b4dfc027284e03fadff31d8675f5"></a><!-- doxytag: member="MGCylinder::out" ref="ac6d0b4dfc027284e03fadff31d8675f5" args="(std::ostream &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; MGCylinder::out </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug function デバッグ関数//////////// Output function. </p>
<p>Output to ostream メンバデータを標準出力に出力する。 </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a484f8cc1c250c5b52fb960b1fda5bb54">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a94e4819a42abd37f1caa2fd0962476df"></a><!-- doxytag: member="MGCylinder::param_range" ref="a94e4819a42abd37f1caa2fd0962476df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_box.html">MGBox</a> MGCylinder::param_range </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パラメータ範囲を返す。 Return parameter range of the Cylinder(Infinite box). </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a1f667e5368e55f075f7dcf4cd052a4dc">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab9a3647d2c9fef4f562a6983021f7e91"></a><!-- doxytag: member="MGCylinder::parameter_curve" ref="ab9a3647d2c9fef4f562a6983021f7e91" args="(int is_u, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCylinder::parameter_curve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parameter curve. </p>
<p>Returned is newed area pointer, and must be freed by delete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_u</em>&nbsp;</td><td>Indicates x is u-value if is_u is true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Parameter value. The value is u or v according to is_u. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a470c01ec42c6e71b6c34601cc558ec96">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a9482d2f0f4a0e94c09db142411f597fd"></a><!-- doxytag: member="MGCylinder::part" ref="a9482d2f0f4a0e94c09db142411f597fd" args="(const MGBox &amp;bx, int multiple=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cylinder.html">MGCylinder</a>* MGCylinder::part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multiple</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute part of the surface limitted by the parameter range bx. </p>
<p>bx(0) is the parameter (us,ue) and bx(1) is (vs,ve). That is u range is from us to ue , and so on. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>multiple</em>&nbsp;</td><td>Indicates if start and end knot multiplicities are necessary. =0:unnecessary, !=0:necessary. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_surface.html#a7a924b141ca6ea037545953c5e00d682">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c8465ddc2a6643409df28908cdbde9"></a><!-- doxytag: member="MGCylinder::perimeter_curve" ref="ad2c8465ddc2a6643409df28908cdbde9" args="(size_t i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGCylinder::perimeter_curve </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>i must be &lt; <a class="el" href="class_m_g_cylinder.html#a0d83ff86049d69b5511221522447d99f" title="Return how many perimeters this surface has.">perimeter_num()</a>. </p>
<p>When <a class="el" href="class_m_g_cylinder.html#a0d83ff86049d69b5511221522447d99f" title="Return how many perimeters this surface has.">perimeter_num()</a>==0, this function is undefined. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a57c8bffdb617cf4ff7c654e2b080200c">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="af2afc495f138ff58e03088e847236d5f"></a><!-- doxytag: member="MGCylinder::perp_point" ref="af2afc495f138ff58e03088e847236d5f" args="(const MGPosition &amp;P, MGPosition &amp;uv, const MGPosition *uvguess=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGCylinder::perp_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> *&nbsp;</td>
          <td class="paramname"> <em>uvguess</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた点にもっとも近い面上の点を返却する。パラメ ータ値も返却する。 Return the nearest point of the Cylinder from P. </p>
<p>Function's return value is always true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>与えられた点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>Parameter value of the Cylinder will be output </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvguess</em>&nbsp;</td><td>guess </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#ac94884f1674a06f476c417511a93eb2a">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a38776f8959055ad54283c6be587bc1e5"></a><!-- doxytag: member="MGCylinder::perps" ref="a38776f8959055ad54283c6be587bc1e5" args="(const MGPosition &amp;P) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position__list.html">MGPosition_list</a> MGCylinder::perps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return all(actually one) foots of perpendicular straight lines from P. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>P</em>&nbsp;</td><td>Point of a space(指定点) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#aed36001c59550de9c2054564844c638f">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a2e0654da4bfe2b9d45ae86c1c4a8a842"></a><!-- doxytag: member="MGCylinder::range" ref="a2e0654da4bfe2b9d45ae86c1c4a8a842" args="(const MGPosition &amp;uv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGCylinder::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>入力パラメータをパラメータ範囲でまるめて返却する。 Round the input uv into parameter range of the Cylinder, return the same value as input. </p>

<p>Reimplemented from <a class="el" href="class_m_g_surface.html#a8966c7e15642175de66afee13234dfc5">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a23195f906d946b4a68a8b46aff07f092"></a><!-- doxytag: member="MGCylinder::type" ref="a23195f906d946b4a68a8b46aff07f092" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_a_s_e.html#ga98345dd7f44f81e6d9923305603f4034">MGSURFACE_TYPE</a> MGCylinder::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>曲面タイプを返却する。 Return surface type of the Cylinder. </p>

<p>Implements <a class="el" href="class_m_g_surface.html#a83ad0b3f99b05d775a1d4d7352baf9d0">MGSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a3180f1cbffdd9f72c6cdd77065404842"></a><!-- doxytag: member="MGCylinder::vrange" ref="a3180f1cbffdd9f72c6cdd77065404842" args="(const MGPosition &amp;P, double &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGCylinder::vrange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_position.html">MGPosition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the v parameter value of the neareast point from the point P to the axis. </p>
<p>Function's return value is if the parameter value v is in the range of this cylinder: -1: below the range, 0:in the range, 1:above the range. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Cylinder.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:20 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>

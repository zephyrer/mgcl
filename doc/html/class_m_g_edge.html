<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MGCL: MGEdge Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.0 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>MGEdge Class Reference<br/>
<small>
[<a class="el" href="group___t_o_p_o.html">Topology (sub) classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGEdge" --><!-- doxytag: inherits="MGCellNB" -->
<p><a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a> is an instance of <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a>, represents a boundary element of 2D manifold.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Edge.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MGEdge:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_edge__inherit__graph.png" border="0" usemap="#_m_g_edge_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_g_edge_inherit__map" id="_m_g_edge_inherit__map">
<area shape="rect" id="node2" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="17,392,100,421"/><area shape="rect" id="node4" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="12,315,105,344"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="12,237,105,267"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="19,160,99,189"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="5,83,112,112"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="28,5,89,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MGEdge:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_g_edge__coll__graph.png" border="0" usemap="#_m_g_edge_coll__map" alt="Collaboration graph"/></div>
<map name="_m_g_edge_coll__map" id="_m_g_edge_coll__map">
<area shape="rect" id="node36" href="class_m_g_p_vertex.html" title="MGPVertex is a parameter cell of the manifold dimension 0." alt="" coords="235,853,325,883"/><area shape="rect" id="node2" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries)." alt="" coords="155,677,237,707"/><area shape="rect" id="node4" href="class_m_g_cell_base.html" title="A CellBase includes only a binder cell pointer if exists." alt="" coords="268,581,361,611"/><area shape="rect" id="node6" href="class_m_g_topology.html" title="MGTopology is an abstract class which represents a whole Topology, Complex, Cell..." alt="" coords="215,485,308,515"/><area shape="rect" id="node32" href="class_m_g_complex.html" title="MGComplex is a container of parameter cells and binder cells." alt="" coords="144,581,237,611"/><area shape="rect" id="node8" href="class_m_g_object.html" title="MGObject is an abstract class which represents a whole geometry and a topology." alt="" coords="153,373,233,403"/><area shape="rect" id="node23" href="class_m_g_geometry.html" title="MGGeometry is an abstract class which represents a whole geometry." alt="" coords="21,581,120,611"/><area shape="rect" id="node10" href="class_m_g_attribed_gel.html" title="MGAttribedGel is an abstract class which provides function interfaces of MGGroup..." alt="" coords="231,85,337,115"/><area shape="rect" id="node16" href="class_m_g_group.html" title="MGGroup is a class which constains MGGel elements." alt="" coords="140,181,217,211"/><area shape="rect" id="node12" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element." alt="" coords="253,5,315,35"/><area shape="rect" id="node14" href="class_m_g_appearance.html" title="MGAppearance is a class to contain MGGLAttrib objects." alt="" coords="123,261,235,291"/><area shape="rect" id="node19" href="class_m_g_plist.html" title="MGPlist\&lt; MGGel \&gt;" alt="" coords="73,85,207,115"/><area shape="rect" id="node26" href="class_m_g_box.html" title="Defines Box of any space dimendion." alt="" coords="13,485,80,515"/><area shape="rect" id="node28" href="class_m_g_interval.html" title="Interval of 1 dimension, i.e." alt="" coords="5,373,88,403"/><area shape="rect" id="node30" href="class_m_g_e_real.html" title="MGEReal is extended real number, i.e., it includes minus infinite and plus infinite..." alt="" coords="8,261,85,291"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_m_g_edge-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6755d0e2dbc45f8397c41ac95a3bc5"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a5b6755d0e2dbc45f8397c41ac95a3bc5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a5b6755d0e2dbc45f8397c41ac95a3bc5">MGEdge</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">void constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8166e0b45967a74a167c03bb937cff47"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a8166e0b45967a74a167c03bb937cff47" args="(const MGEdge &amp;e, bool copy_boundary=true, bool no_binder=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a8166e0b45967a74a167c03bb937cff47">MGEdge</a> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;e, bool copy_boundary=true, bool no_binder=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a88dcaa55ed2e2c8b35d914656d109665">MGEdge</a> (<a class="el" href="class_m_g_geometry.html">MGGeometry</a> *geo, <a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *boundaries[2], <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *binder)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fundamental constructor.  <a href="#a88dcaa55ed2e2c8b35d914656d109665"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a34876629fe2a3878c816e86360fed75a">MGEdge</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an edge of a boundary that has active start and end vertex if the curve is not infinite straight line.  <a href="#a34876629fe2a3878c816e86360fed75a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa8afd363009d1714f3aa87516389b56"></a><!-- doxytag: member="MGEdge::MGEdge" ref="aaa8afd363009d1714f3aa87516389b56" args="(MGCurve *crv)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGEdge</b> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *crv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a712b71b9311b8a39ab69cc22441475c3">MGEdge</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;crv, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an edge of a boundary(MGBoundary1D that has active start and end vertex).  <a href="#a712b71b9311b8a39ab69cc22441475c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851ab740312350f8d19fa95e1bed44e5"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a851ab740312350f8d19fa95e1bed44e5" args="(MGCurve *crv, const MGInterval &amp;range)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MGEdge</b> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *crv, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6e63192c94cc6b5ee01777f28639717c">MGEdge</a> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;surf, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;pcrv, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;prange, const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;wcrv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an edge with a binder of a boundary (MGBoundary1D that has active start and end vertex).  <a href="#a6e63192c94cc6b5ee01777f28639717c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8955ba626a96b9b6dc0adf4c66db19d9"></a><!-- doxytag: member="MGEdge::‾MGEdge" ref="a8955ba626a96b9b6dc0adf4c66db19d9" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>‾MGEdge</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ae09de1b977437d24048c0994cb21d3c4">operator=</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#ae09de1b977437d24048c0994cb21d3c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2f63e83a3611f19e88bc1070b04a72a"></a><!-- doxytag: member="MGEdge::operator=" ref="ad2f63e83a3611f19e88bc1070b04a72a" args="(const MGEdge &amp;gel2)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;gel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76fdbee25d9a59d6377f5e1db9ded3e5"></a><!-- doxytag: member="MGEdge::operator+" ref="a76fdbee25d9a59d6377f5e1db9ded3e5" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a76fdbee25d9a59d6377f5e1db9ded3e5">operator+</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Edge に平行移動を行ないオブジェクトを生成する。 Translation of the Edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d2709617fd1153e6e5ab9e7b4f466e0"></a><!-- doxytag: member="MGEdge::operator&#45;" ref="a0d2709617fd1153e6e5ab9e7b4f466e0" args="(const MGVector &amp;v) const " -->
<a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a0d2709617fd1153e6e5ab9e7b4f466e0">operator-</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Edgeに逆方向の平行移動を行ないオブジェクトを生成する。 Translation of the Edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a2353ed0c4f197582148a72ed40c3c2a9">operator*</a> (double s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Edgeのスケーリングを行い，Edgeを作成する。 Scaling of the Edge by a double.  <a href="#a2353ed0c4f197582148a72ed40c3c2a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a1ee074ac60d994b3f306f49d6394d806">operator*</a> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換でEdgeの変換を行い，Edgeを作成する。 Transformation of the Edge by a matrix.  <a href="#a1ee074ac60d994b3f306f49d6394d806"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a5791b0f24dd013195dc6bab3d202d28d">operator*</a> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">与えられた変換によってトランスフォームをおこないEdgeを生成する。 Transformation of the Edge by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>.  <a href="#a5791b0f24dd013195dc6bab3d202d28d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ae518a0a33d1d3120872bdf5ffea60ad7">operator/</a> (double s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double.  <a href="#ae518a0a33d1d3120872bdf5ffea60ad7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54f6a036c80826b4484a604242cfb98"></a><!-- doxytag: member="MGEdge::operator==" ref="ab54f6a036c80826b4484a604242cfb98" args="(const MGEdge &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ab54f6a036c80826b4484a604242cfb98">operator==</a> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison of two objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91e6420ba7d7f0217903b9083f1fbb26"></a><!-- doxytag: member="MGEdge::operator==" ref="a91e6420ba7d7f0217903b9083f1fbb26" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a91e6420ba7d7f0217903b9083f1fbb26">operator==</a> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae7d4c080980ab64e52352e139ca3c82"></a><!-- doxytag: member="MGEdge::operator&lt;" ref="aae7d4c080980ab64e52352e139ca3c82" args="(const MGEdge &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0552f3b3345b504ddc4e88d51a52cc6"></a><!-- doxytag: member="MGEdge::operator&lt;" ref="af0552f3b3345b504ddc4e88d51a52cc6" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a861514443ce89091c5d10055639a8e65"></a><!-- doxytag: member="MGEdge::operator!=" ref="a861514443ce89091c5d10055639a8e65" args="(const MGGel &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26982bc1928682b1dc60495f3af9a0e6"></a><!-- doxytag: member="MGEdge::operator!=" ref="a26982bc1928682b1dc60495f3af9a0e6" args="(const MGEdge &amp;gel2) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;gel2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77bbd24459f3b64f0157a34bc85af5dd"></a><!-- doxytag: member="MGEdge::operator+=" ref="a77bbd24459f3b64f0157a34bc85af5dd" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a77bbd24459f3b64f0157a34bc85af5dd">operator+=</a> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object transformation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefde893337fbfc3ad6b622e41f7d9b18"></a><!-- doxytag: member="MGEdge::operator&#45;=" ref="aefde893337fbfc3ad6b622e41f7d9b18" args="(const MGVector &amp;v)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_g_vector.html">MGVector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4daed3e4b9f2dde10ed63be25bcfb7f0"></a><!-- doxytag: member="MGEdge::operator*=" ref="a4daed3e4b9f2dde10ed63be25bcfb7f0" args="(double scale)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72b3e6111edfeecca775097008134190"></a><!-- doxytag: member="MGEdge::operator*=" ref="a72b3e6111edfeecca775097008134190" args="(const MGMatrix &amp;mat)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29c5a260518b2564675361da59b10d36"></a><!-- doxytag: member="MGEdge::operator*=" ref="a29c5a260518b2564675361da59b10d36" args="(const MGTransf &amp;tr)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;tr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d38f4abf956597b73eef5e794c5ad06"></a><!-- doxytag: member="MGEdge::out" ref="a0d38f4abf956597b73eef5e794c5ad06" args="(std::ostream &amp;ostrm) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a0d38f4abf956597b73eef5e794c5ad06">out</a> (std::ostream &amp;ostrm) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output virtual function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4faee9d33a0619115d3fbda34e840a"></a><!-- doxytag: member="MGEdge::active_end" ref="a3f4faee9d33a0619115d3fbda34e840a" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a3f4faee9d33a0619115d3fbda34e840a">active_end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if active at start or end. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb44b7be44e47e308b2bcb294adb985f"></a><!-- doxytag: member="MGEdge::active_start" ref="afb44b7be44e47e308b2bcb294adb985f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>active_start</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ad58d5333797ae50cee07bd70efd132e1">aft_edge</a> (bool at_end=true, size_t *vertexID=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get after edge in the loop sequence.  <a href="#ad58d5333797ae50cee07bd70efd132e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3780129f328dfe3785552f5d37c69800"></a><!-- doxytag: member="MGEdge::aft_edge" ref="a3780129f328dfe3785552f5d37c69800" args="(bool at_end=true, size_t *vertexID=0)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>aft_edge</b> (bool at_end=true, size_t *vertexID=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a0c64768e38b2b73f1bf5ac52ebbda2fe">binder_edge</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain binder edge pointer.  <a href="#a0c64768e38b2b73f1bf5ac52ebbda2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a7b41d7d870250589306f2a2a73ba9"></a><!-- doxytag: member="MGEdge::box" ref="ae8a7b41d7d870250589306f2a2a73ba9" args="() const " -->
const <a class="el" href="class_m_g_box.html">MGBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ae8a7b41d7d870250589306f2a2a73ba9">box</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the box of the cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83805b99c408fe1eb43e930a7e6ca854"></a><!-- doxytag: member="MGEdge::center_param" ref="a83805b99c408fe1eb43e930a7e6ca854" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a83805b99c408fe1eb43e930a7e6ca854">center_param</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the center parameter value of this cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ad8dfd4989ed01e50881d370b1d04c500">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of the cell.  <a href="#ad8dfd4989ed01e50881d370b1d04c500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acba374e06b1a133432b5f124bd7364ec"></a><!-- doxytag: member="MGEdge::clone_without_boundaries" ref="acba374e06b1a133432b5f124bd7364ec" args="() const " -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#acba374e06b1a133432b5f124bd7364ec">clone_without_boundaries</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_m_g_edge.html#acba374e06b1a133432b5f124bd7364ec" title="clone_without_boundaries() does not copy the binder cell relation.">clone_without_boundaries()</a> does not copy the binder cell relation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ac5147563d819e99edf797704e24a119c">clone_binder</a> (const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;e) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a clone of this(this is a binder), and set binder and parameter cell relation between the new binder and the parameter cell e.  <a href="#ac5147563d819e99edf797704e24a119c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a05dda7333388d9dc1d20217fccc6333d">compute_continuity</a> (const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;edge2, double diatance[7], double tangent[4], double normal[4]) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the continuities between this edge(edge1) and the edge2.  <a href="#a05dda7333388d9dc1d20217fccc6333d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a2958030143e6e7cf5692590edeb521a9">connect</a> (<a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;cell2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect this edge to cell2(is a MGEdge).  <a href="#a2958030143e6e7cf5692590edeb521a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6de291ae0073905a44b82b99cd3c848"></a><!-- doxytag: member="MGEdge::connect" ref="ae6de291ae0073905a44b82b99cd3c848" args="(MGEdge &amp;cell2)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>connect</b> (<a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;cell2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ab8a8166a31346ead53f4873ed0584040">connect_at_id</a> (size_t id1, <a class="el" href="class_m_g_edge.html">MGEdge</a> *e2, size_t id2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the start(id1=0) or end(id1=1) of this to the start(id2=0) or the end(id2=1) of e2.  <a href="#ab8a8166a31346ead53f4873ed0584040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a3f24516e41d8ae9044acd5a2842646c0">base_curve</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve pointer of this edge.  <a href="#a3f24516e41d8ae9044acd5a2842646c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62cdf1bab56b0a35eea17bdf15d85333"></a><!-- doxytag: member="MGEdge::base_curve" ref="a62cdf1bab56b0a35eea17bdf15d85333" args="() const " -->
const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>base_curve</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6cbaa12d1df339b2e21fb079530af874">curve_limitted</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return curve pointer cut by start and end parameter range.  <a href="#a6cbaa12d1df339b2e21fb079530af874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6be5364e6752dc91f5648a945f13ca61">disconnect_at_id</a> (size_t id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect the start(id=0) or end(id=1) neighbourhood relation.  <a href="#a6be5364e6752dc91f5648a945f13ca61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#afb94f7b43fe67893f7abed3a0e60ef38">drawWire</a> (double span_length, int line_density=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D curve in world coordinates.  <a href="#afb94f7b43fe67893f7abed3a0e60ef38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a9253719a9561c73748a14e69659b2988">draw3DVertex</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw 3D point(vertex) in world coordinates.  <a href="#a9253719a9561c73748a14e69659b2988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c51b231260d061aecd685158cab55de"></a><!-- doxytag: member="MGEdge::end_point" ref="a7c51b231260d061aecd685158cab55de" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a7c51b231260d061aecd685158cab55de">end_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the end point of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#abc40def87eb21012321f9006aca0c984">eval</a> (double t, size_t nderiv=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the nderiv's derivative at parameter t.  <a href="#abc40def87eb21012321f9006aca0c984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_vector.html">MGVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ac90e09aadd66158ead380a9481a09f04">eval_star</a> (double t, size_t nderi=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the star curves of the edge at the point t.  <a href="#ac90e09aadd66158ead380a9481a09f04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a8a4ec4196e32253e8137d236deb85280">equal_direction_to_binder</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if SurfCurve of the edge has equal direction to binder edge's direction.  <a href="#a8a4ec4196e32253e8137d236deb85280"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7583a034cae73ee4d851cbb308baf398"></a><!-- doxytag: member="MGEdge::face" ref="a7583a034cae73ee4d851cbb308baf398" args="() const " -->
const <a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a7583a034cae73ee4d851cbb308baf398">face</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the star face pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a685a5ec62d17b8c9712bc907544d7852"></a><!-- doxytag: member="MGEdge::face" ref="a685a5ec62d17b8c9712bc907544d7852" args="()" -->
<a class="el" href="class_m_g_face.html">MGFace</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a685a5ec62d17b8c9712bc907544d7852">face</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a> pointer if this <a class="el" href="class_m_g_gel.html" title="MGGel is an abstract class which represents a group element.">MGGel</a> is an <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>, else return null. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac97776b5d36d84e30fb71eef558d9bd6"></a><!-- doxytag: member="MGEdge::first_partner" ref="ac97776b5d36d84e30fb71eef558d9bd6" args="() const " -->
const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ac97776b5d36d84e30fb71eef558d9bd6">first_partner</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the 1st partner edge of this edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e806e43c9f2c721d8a8c98d21d3f965"></a><!-- doxytag: member="MGEdge::free_end_neighbourhood" ref="a5e806e43c9f2c721d8a8c98d21d3f965" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a5e806e43c9f2c721d8a8c98d21d3f965">free_end_neighbourhood</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free neighbourhood relationship at the end of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#acf8beb3a515962deebd4ee95d9f625e7">free_neighbourhood</a> (size_t i, size_t j=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free neighbourhood relation at j-th boundary's i-th pcell of this cell.  <a href="#acf8beb3a515962deebd4ee95d9f625e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a883c3529e3a6d4cf19559efafe1647d4"></a><!-- doxytag: member="MGEdge::free_start_neighbourhood" ref="a883c3529e3a6d4cf19559efafe1647d4" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a883c3529e3a6d4cf19559efafe1647d4">free_start_neighbourhood</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free neighbourhood relationship at the start of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4330e208849409940293bbd6eb6824e"></a><!-- doxytag: member="MGEdge::identify_type" ref="aa4330e208849409940293bbd6eb6824e" args="() const " -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#aa4330e208849409940293bbd6eb6824e">identify_type</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Object's type ID (TID). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a7d3c778fb13a70cf4795f308f3fdbbad">is_connected_and_same_direction</a> (bool start, const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;edge2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this edge's start point(when start=true) and edge2 is connected and their directions are the same.  <a href="#a7d3c778fb13a70cf4795f308f3fdbbad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a18ed4b400c5e88e39618e705ed4bfe85">is_free</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if this is a free edge.  <a href="#a18ed4b400c5e88e39618e705ed4bfe85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#abf2448ac34b4b24c70fca922f2695102">join</a> (bool start, <a class="el" href="class_m_g_edge.html">MGEdge</a> *e2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect this and e2.  <a href="#abf2448ac34b4b24c70fca922f2695102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30ebd5502889e25a3d824990f09a9809"></a><!-- doxytag: member="MGEdge::loop" ref="a30ebd5502889e25a3d824990f09a9809" args="() const " -->
const <a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a30ebd5502889e25a3d824990f09a9809">loop</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parent loop pointer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f0c7e5085d01dfe3d45017b7603a62d"></a><!-- doxytag: member="MGEdge::loop" ref="a8f0c7e5085d01dfe3d45017b7603a62d" args="()" -->
<a class="el" href="class_m_g_loop.html">MGLoop</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>loop</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a0eabd833117726c0626b47062d7961f1">make_binder</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a binder cell of this parameter cell.  <a href="#a0eabd833117726c0626b47062d7961f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6f7f2801e22972e8c3afa35c9eb37662">make_binder_with_curve</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a binder associated with the world curve rep.  <a href="#a6f7f2801e22972e8c3afa35c9eb37662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8eb0e51e89dfc8d587dd37be3b2e453"></a><!-- doxytag: member="MGEdge::manifold_dimension" ref="aa8eb0e51e89dfc8d587dd37be3b2e453" args="() const " -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#aa8eb0e51e89dfc8d587dd37be3b2e453">manifold_dimension</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain manifold dimension. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bd7e76cd3e392223941c53b3f685d45"></a><!-- doxytag: member="MGEdge::member_partner_edge" ref="a4bd7e76cd3e392223941c53b3f685d45" args="(size_t i) const " -->
const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a4bd7e76cd3e392223941c53b3f685d45">member_partner_edge</a> (size_t i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the i-th member partner edge. This must be a binder edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#aa13ae1fe3657c56272b748c141928028">mid_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the mid point of this edge.  <a href="#aa13ae1fe3657c56272b748c141928028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac04097b1b9b528b872993868b557a853"></a><!-- doxytag: member="MGEdge::negate" ref="ac04097b1b9b528b872993868b557a853" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ac04097b1b9b528b872993868b557a853">negate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate the direction of the cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a5441a5a5d2697bcf6d1c6bab5fd1c2fb">neighbours</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain all the neighbours.  <a href="#a5441a5a5d2697bcf6d1c6bab5fd1c2fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a593bdc204c61a038469896f5a563bd0a"></a><!-- doxytag: member="MGEdge::on_surface_perimeter" ref="a593bdc204c61a038469896f5a563bd0a" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a593bdc204c61a038469896f5a563bd0a">on_surface_perimeter</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the edge is a part of a surface perimeter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8df95f7798a067f6f8abc04a4e273e"></a><!-- doxytag: member="MGEdge::on_surface_perimeter" ref="a2d8df95f7798a067f6f8abc04a4e273e" args="(const MGFace &amp;f) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>on_surface_perimeter</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;f) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2a8ea75059f0229db4e0d1b90cdc3dd"></a><!-- doxytag: member="MGEdge::on_surface_perimeter" ref="ab2a8ea75059f0229db4e0d1b90cdc3dd" args="(const MGSurface &amp;sf) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>on_surface_perimeter</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;sf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1087e0439e0d019404f8d595346c5c2"></a><!-- doxytag: member="MGEdge::parameter_error" ref="af1087e0439e0d019404f8d595346c5c2" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#af1087e0439e0d019404f8d595346c5c2">parameter_error</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return parameter space error of the cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6cb2592c4774c36eafe2e3a701c13848">param_bcell</a> (double tp, const double *guess=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the parameter of the binder edge's curve that represent the same point as sp.  <a href="#a6cb2592c4774c36eafe2e3a701c13848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#af4ff5e1c9740f77faac5b172188a0d36">param_pcell</a> (double tb, const double *guess=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This must be a parameter edge.  <a href="#af4ff5e1c9740f77faac5b172188a0d36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8846714f1c24f69cd5719d50a2ffa2a7"></a><!-- doxytag: member="MGEdge::param_e" ref="a8846714f1c24f69cd5719d50a2ffa2a7" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a8846714f1c24f69cd5719d50a2ffa2a7">param_e</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain end parameter value of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30c3397d98f60a2a7e9e37a96bb819c5"></a><!-- doxytag: member="MGEdge::param_s" ref="a30c3397d98f60a2a7e9e37a96bb819c5" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a30c3397d98f60a2a7e9e37a96bb819c5">param_s</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain start parameter value of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="class_m_g_edge.html">MGEdge</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a0215b00885e975948025fdd2baf42ff0">partner_edges</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain partner edges.  <a href="#a0215b00885e975948025fdd2baf42ff0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a43fd002f18b63b5f45dd00e7c9dbb5d5">pick_closest</a> (const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;sl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parameter value of the closest point from the straight to this object.  <a href="#a43fd002f18b63b5f45dd00e7c9dbb5d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a0a7db48c748912d5eb6d19a71bb344bc">polygonize</a> (double error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate the parameter edge by a polyline and replace this edge expression by the polyline.  <a href="#a0a7db48c748912d5eb6d19a71bb344bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a5ca590ed1b9bd945621e579d670d2603">pre_edge</a> (bool at_start=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get previous edge in the loop sequence.  <a href="#a5ca590ed1b9bd945621e579d670d2603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4cfd21416ec4d62e81c18bb80969d9a"></a><!-- doxytag: member="MGEdge::pre_edge" ref="ae4cfd21416ec4d62e81c18bb80969d9a" args="(bool at_start=true)" -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pre_edge</b> (bool at_start=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a300e86f0516f7cc502b71a89dd3d3d55"></a><!-- doxytag: member="MGEdge::range" ref="a300e86f0516f7cc502b71a89dd3d3d55" args="() const " -->
<a class="el" href="class_m_g_interval.html">MGInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a300e86f0516f7cc502b71a89dd3d3d55">range</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get parameter range of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a022ee59817f4e33bc1bb2f69b2ccfe83">set_binder_edge</a> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;wcrv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set binder cell edge to this parameter cell.  <a href="#a022ee59817f4e33bc1bb2f69b2ccfe83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a769e54e95c8312a8d6ca05203ec4ff66"></a><!-- doxytag: member="MGEdge::set_binder_edge" ref="a769e54e95c8312a8d6ca05203ec4ff66" args="(const MGCurve &amp;wcrv, const MGInterval &amp;range) const " -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_binder_edge</b> (const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;wcrv, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#aebc48c3c8e57174184f31d051f05500e">set_binder_edge</a> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *wcrv) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These forms give the ownership of wcrv to the edge.  <a href="#aebc48c3c8e57174184f31d051f05500e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73baadad20df329a186dfe026b5bfed0"></a><!-- doxytag: member="MGEdge::set_binder_edge" ref="a73baadad20df329a186dfe026b5bfed0" args="(MGCurve *wcrv, const MGInterval &amp;range) const " -->
<a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_binder_edge</b> (<a class="el" href="class_m_g_curve.html">MGCurve</a> *wcrv, const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;range) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca5f11fdc6fb86b82f3aeb448d2c3024"></a><!-- doxytag: member="MGEdge::set_end" ref="aca5f11fdc6fb86b82f3aeb448d2c3024" args="(double t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#aca5f11fdc6fb86b82f3aeb448d2c3024">set_end</a> (double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set start point(boundary) data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a79bdedcfbfa7e01c90e41fa7a253270b">set_start</a> (double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter value of the start point.  <a href="#a79bdedcfbfa7e01c90e41fa7a253270b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a260157cf1c33565f7f315e86877158bd">set_i_th_binder</a> (size_t i, <a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> &amp;binder) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter value of the start point.  <a href="#a260157cf1c33565f7f315e86877158bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_g_surface.html">MGSurface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#af5dfea419abb78abf95eca2544565ce8">star_surface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain star surface.  <a href="#af5dfea419abb78abf95eca2544565ce8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab72fb07f06a185735f455c3defe6da7c"></a><!-- doxytag: member="MGEdge::start_point" ref="ab72fb07f06a185735f455c3defe6da7c" args="() const " -->
<a class="el" href="class_m_g_position.html">MGPosition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ab72fb07f06a185735f455c3defe6da7c">start_point</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the end point of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ad515b7ace21bf08de7d2364db5d43e68">surface_perimeter</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the perimeter number where this edge is on.  <a href="#ad515b7ace21bf08de7d2364db5d43e68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f12fd45315320231b9568919c9c83a"></a><!-- doxytag: member="MGEdge::surface_perimeter" ref="af2f12fd45315320231b9568919c9c83a" args="(const MGSurface &amp;sf) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>surface_perimeter</b> (const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;sf) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d2d92b0fd085be49373c7748ad4e89f"></a><!-- doxytag: member="MGEdge::surface_perimeter" ref="a2d2d92b0fd085be49373c7748ad4e89f" args="(const MGFace &amp;face) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>surface_perimeter</b> (const <a class="el" href="class_m_g_face.html">MGFace</a> &amp;face) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a84576730fceb7791766e7ec552c34e2e">trim</a> (double t, bool start)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the edge at parameter t.  <a href="#a84576730fceb7791766e7ec552c34e2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c918731d9c0125e53a7e2dbfcf14a46"></a><!-- doxytag: member="MGEdge::trimmed_curve" ref="a6c918731d9c0125e53a7e2dbfcf14a46" args="() const " -->
<a class="el" href="class_m_g_trimmed_curve.html">MGTrimmedCurve</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6c918731d9c0125e53a7e2dbfcf14a46">trimmed_curve</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get trimmed curve representation of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04617d239ce9cfb0d3b2214d8f42b0b"></a><!-- doxytag: member="MGEdge::vertex" ref="aa04617d239ce9cfb0d3b2214d8f42b0b" args="(size_t id) const " -->
const <a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#aa04617d239ce9cfb0d3b2214d8f42b0b">vertex</a> (size_t id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the vertex at the start or end. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f2815451518e2d0c33722121d93a7ab"></a><!-- doxytag: member="MGEdge::vertex_start" ref="a7f2815451518e2d0c33722121d93a7ab" args="() const " -->
const <a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vertex_start</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79684882064508cb59cb357d4f20ada0"></a><!-- doxytag: member="MGEdge::vertex_end" ref="a79684882064508cb59cb357d4f20ada0" args="() const " -->
const <a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vertex_end</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b1dd2e272e65e1f1b79c0e2191f1d07"></a><!-- doxytag: member="MGEdge::vertex" ref="a8b1dd2e272e65e1f1b79c0e2191f1d07" args="(size_t id)" -->
<a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vertex</b> (size_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad687e751857db4a6ac401c1a93799168"></a><!-- doxytag: member="MGEdge::vertex_start" ref="ad687e751857db4a6ac401c1a93799168" args="()" -->
<a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vertex_start</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50482568b6167314c01263dbb7fd5455"></a><!-- doxytag: member="MGEdge::vertex_end" ref="a50482568b6167314c01263dbb7fd5455" args="()" -->
<a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>vertex_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a9d4f3ee4298e00a65b057eba735608b5">world_curve</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return world curve pointer of this edge.  <a href="#a9d4f3ee4298e00a65b057eba735608b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a950a7f593d69e58334b03f31c25b16c8"></a><!-- doxytag: member="MGEdge::world_curve" ref="a950a7f593d69e58334b03f31c25b16c8" args="() const " -->
const <a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>world_curve</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1ca145c4e55ab400936bc85d0221d11"></a><!-- doxytag: member="MGEdge::whoami" ref="ab1ca145c4e55ab400936bc85d0221d11" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>whoami</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c22aa4b2611db2948f677e953ca620"></a><!-- doxytag: member="MGEdge::ReadMembers" ref="ab3c22aa4b2611db2948f677e953ca620" args="(MGIfstream &amp;buf)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ab3c22aa4b2611db2948f677e953ca620">ReadMembers</a> (<a class="el" href="class_m_g_ifstream.html">MGIfstream</a> &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read Object's member data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f07e76955e3b16b3abc1daf8632559d"></a><!-- doxytag: member="MGEdge::WriteMembers" ref="a6f07e76955e3b16b3abc1daf8632559d" args="(MGOfstream &amp;buf) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a6f07e76955e3b16b3abc1daf8632559d">WriteMembers</a> (<a class="el" href="class_m_g_ofstream.html">MGOfstream</a> &amp;buf) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write Object's Member Data. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6e5cc99c9f14d029d61a74031ded4e"></a><!-- doxytag: member="MGEdge::MGFace" ref="a1f6e5cc99c9f14d029d61a74031ded4e" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a1f6e5cc99c9f14d029d61a74031ded4e">MGFace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8a6ab50a7e8c359511c444e72c0bcb4"></a><!-- doxytag: member="MGEdge::MGLoop" ref="ad8a6ab50a7e8c359511c444e72c0bcb4" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#ad8a6ab50a7e8c359511c444e72c0bcb4">MGLoop</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MGDECL friend <a class="el" href="class_m_g_edge.html">MGEdge</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_g_edge.html#a7cfefbc0e7fe8f6c6ca35539e390ea04">operator*</a> (double s, const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Edgeのスケーリングを行い，Edgeを作成する。 Scaling of the Edge by a double.  <a href="#a7cfefbc0e7fe8f6c6ca35539e390ea04"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a> is an instance of <a class="el" href="class_m_g_cell_n_b.html" title="CellNB is a cell without boundaries(No Boundaries).">MGCellNB</a>, represents a boundary element of 2D manifold. </p>
<p><a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a> constitues an <a class="el" href="class_m_g_loop.html" title="MGLoop is a boundary of a face, a boundary of 2D manifold cell.">MGLoop</a> that is a boundary of <a class="el" href="class_m_g_face.html" title="MGFace is a trimmed surface.">MGFace</a>. <a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a> can be a parameter cell or a binder cell. The coordinates of a parameter cell <a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a> is (u,v) surface parameter, and the ones of binder cell <a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a> is (x,y,z) of the world. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a88dcaa55ed2e2c8b35d914656d109665"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a88dcaa55ed2e2c8b35d914656d109665" args="(MGGeometry *geo, MGPVertex *boundaries[2], MGCellNB *binder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEdge::MGEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_geometry.html">MGGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>geo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_p_vertex.html">MGPVertex</a> *&nbsp;</td>
          <td class="paramname"> <em>boundaries</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a> *&nbsp;</td>
          <td class="paramname"> <em>binder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fundamental constructor. </p>
<p>Construct an edge from geometry of manifold dimension 1. The constructor takes the ownership of geo and MGPVertex* in boundaries. </p>

</div>
</div>
<a class="anchor" id="a34876629fe2a3878c816e86360fed75a"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a34876629fe2a3878c816e86360fed75a" args="(const MGCurve &amp;crv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEdge::MGEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make an edge of a boundary that has active start and end vertex if the curve is not infinite straight line. </p>
<p>The second form that input MGCurve* takes the ownership of the crv into the <a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a>, must not delete the object and the object must be newed one. </p>

</div>
</div>
<a class="anchor" id="a712b71b9311b8a39ab69cc22441475c3"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a712b71b9311b8a39ab69cc22441475c3" args="(const MGCurve &amp;crv, const MGInterval &amp;range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEdge::MGEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>crv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make an edge of a boundary(MGBoundary1D that has active start and end vertex). </p>
<p>range is the parameter range of crv. The second form that input MGCurve* takes the ownership of the crv into the <a class="el" href="class_m_g_edge.html" title="MGEdge is an instance of MGCellNB, represents a boundary element of 2D manifold.">MGEdge</a>, must not delete the object and the object must be newed one. </p>

</div>
</div>
<a class="anchor" id="a6e63192c94cc6b5ee01777f28639717c"></a><!-- doxytag: member="MGEdge::MGEdge" ref="a6e63192c94cc6b5ee01777f28639717c" args="(const MGSurface &amp;surf, const MGCurve &amp;pcrv, const MGInterval &amp;prange, const MGCurve &amp;wcrv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGEdge::MGEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_surface.html">MGSurface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>surf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pcrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_interval.html">MGInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wcrv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make an edge with a binder of a boundary (MGBoundary1D that has active start and end vertex). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surf</em>&nbsp;</td><td>Parent surface of which this edge makes a boundary </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcrv</em>&nbsp;</td><td>Parameter curve of the surface surf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prange</em>&nbsp;</td><td>param range of pcrv. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wcrv</em>&nbsp;</td><td>World coordinate curve of the surface surf. wcrv will be trimmed by prange of pcrv. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad58d5333797ae50cee07bd70efd132e1"></a><!-- doxytag: member="MGEdge::aft_edge" ref="ad58d5333797ae50cee07bd70efd132e1" args="(bool at_end=true, size_t *vertexID=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::aft_edge </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>at_end</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>vertexID</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get after edge in the loop sequence. </p>
<p>The aft_edge is the first neighbour edge. </p>

</div>
</div>
<a class="anchor" id="a3f24516e41d8ae9044acd5a2842646c0"></a><!-- doxytag: member="MGEdge::base_curve" ref="a3f24516e41d8ae9044acd5a2842646c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGEdge::base_curve </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return curve pointer of this edge. </p>
<p>Null when this does not have geometry. The expression is of parameter space of face. </p>

</div>
</div>
<a class="anchor" id="a0c64768e38b2b73f1bf5ac52ebbda2fe"></a><!-- doxytag: member="MGEdge::binder_edge" ref="a0c64768e38b2b73f1bf5ac52ebbda2fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::binder_edge </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain binder edge pointer. </p>
<p>Null when this does not have binder. </p>

</div>
</div>
<a class="anchor" id="ad8dfd4989ed01e50881d370b1d04c500"></a><!-- doxytag: member="MGEdge::clone" ref="ad8dfd4989ed01e50881d370b1d04c500" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of the cell. </p>
<p><a class="el" href="class_m_g_edge.html#ad8dfd4989ed01e50881d370b1d04c500" title="Make a clone of the cell.">clone()</a> does not copy the binder cell relation. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a735842331fa8e53bdc26fee5d50df7ab">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="ac5147563d819e99edf797704e24a119c"></a><!-- doxytag: member="MGEdge::clone_binder" ref="ac5147563d819e99edf797704e24a119c" args="(const MGCellBase &amp;e) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::clone_binder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a clone of this(this is a binder), and set binder and parameter cell relation between the new binder and the parameter cell e. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#ac17dacc0a49fb6084ab04736f31d99b9">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a05dda7333388d9dc1d20217fccc6333d"></a><!-- doxytag: member="MGEdge::compute_continuity" ref="a05dda7333388d9dc1d20217fccc6333d" args="(const MGEdge &amp;edge2, double diatance[7], double tangent[4], double normal[4]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::compute_continuity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>diatance</em>[7], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tangent</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>normal</em>[4]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the continuities between this edge(edge1) and the edge2. </p>
<p>This edge and edge2 must be parameter edges of each face. In distance, tangent, and normal, the following output will be set: distance[0-6] as: [0] edge1's curve parameter that has the maximum distance with edge2. [1] edge2's curve parameter that has the maximum distance with edge1. [2] the evaluated maximum distance between edge1 and edge2 at distance[0] and [1] [3] edge1's curve parameter that has the minimum distance with edge2. [4] edge2's curve parameter that has the minimum distance with edge1. [5] the evaluated minimum distance between edge1 and edge2 at distance[3] and [4] [6] mean distance between edge1 and edge2. tangent[0-3] as: [0] edge1's curve parameter that has the maximum tangent difference with edge2. [1] edge2's curve parameter that has the maximum tangent difference with edge1. [2] the evaluated maximum tangent difference between edge1 and edge2 at tangent[0] and [1]. [3] mean tangent difference between edge1 and edge2. normal[0-3] as: [0] edge1's curve parameter that has the maximum normal difference with edge2. [1] edge2's curve parameter that has the maximum normal difference with edge1. [2] the evaluated maximum normal difference between edge1 and edge2 at normal[0] and [1]. [3] mean normal difference between edge1 and edge2. </p>

</div>
</div>
<a class="anchor" id="a2958030143e6e7cf5692590edeb521a9"></a><!-- doxytag: member="MGEdge::connect" ref="a2958030143e6e7cf5692590edeb521a9" args="(MGCellBase &amp;cell2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_cell_base.html">MGCellBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cell2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect this edge to cell2(is a MGEdge). </p>
<p>Both edges are parameter edges of faces. This cell is a pcell of a boundary of a higher manifold dimension's cell A, and cell2 is also is a pcell of a boundary of another cell B. That is, this cell is a part of a boundary of cell A, and cell2 is a part of a boundary of cell B. If cell A's manifold dimension is n, then this cell's manifold dimension is n-1. B's manifold dimension is same as A's. and cell2's manifold dimension is n-1. </p>

<p>Reimplemented from <a class="el" href="class_m_g_cell_base.html#ac513d5b66d8f9c12c962e082e9ee8016">MGCellBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a8166a31346ead53f4873ed0584040"></a><!-- doxytag: member="MGEdge::connect_at_id" ref="ab8a8166a31346ead53f4873ed0584040" args="(size_t id1, MGEdge *e2, size_t id2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::connect_at_id </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td>
          <td class="paramname"> <em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect the start(id1=0) or end(id1=1) of this to the start(id2=0) or the end(id2=1) of e2. </p>
<p>If both edges of this and e2 are members of a complex, they must be the same. e2 must be a newed object, and the owneship is transfered to the system. </p>

</div>
</div>
<a class="anchor" id="a6cbaa12d1df339b2e21fb079530af874"></a><!-- doxytag: member="MGEdge::curve_limitted" ref="a6cbaa12d1df339b2e21fb079530af874" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGEdge::curve_limitted </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return curve pointer cut by start and end parameter range. </p>
<p>Output is newed curve object, must be deleted. Null when this does not have geometry. The expression is of parameter space of face if this is parameter edge of a face. <a class="el" href="class_m_g_edge.html#a6cbaa12d1df339b2e21fb079530af874" title="Return curve pointer cut by start and end parameter range.">curve_limitted()</a> does not return <a class="el" href="class_m_g_trimmed_curve.html" title="MGTrimmedCurve is a part of original curve that has limitted parameter range.">MGTrimmedCurve</a>, returns real curve. </p>

</div>
</div>
<a class="anchor" id="a6be5364e6752dc91f5648a945f13ca61"></a><!-- doxytag: member="MGEdge::disconnect_at_id" ref="a6be5364e6752dc91f5648a945f13ca61" args="(size_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::disconnect_at_id </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the start(id=0) or end(id=1) neighbourhood relation. </p>
<p>disconnect does not free membership of this edge from its parent complex. </p>

</div>
</div>
<a class="anchor" id="a9253719a9561c73748a14e69659b2988"></a><!-- doxytag: member="MGEdge::draw3DVertex" ref="a9253719a9561c73748a14e69659b2988" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::draw3DVertex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D point(vertex) in world coordinates. </p>
<p>The object is converted to point(s) and is drawn. This is valid only for topology objects or <a class="el" href="class_m_g_point.html" title="MGPoint represents one dimensional manifold, a point in a space.">MGPoint</a>. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a893bb5e4f0fcfe2bab43b413a9b57d53">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="afb94f7b43fe67893f7abed3a0e60ef38"></a><!-- doxytag: member="MGEdge::drawWire" ref="afb94f7b43fe67893f7abed3a0e60ef38" args="(double span_length, int line_density=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::drawWire </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>span_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_density</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw 3D curve in world coordinates. </p>
<p>The object is converted to curve(s) and is drawn. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>span_length</em>&nbsp;</td><td>Line segment span length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_density</em>&nbsp;</td><td>line density to draw a surface in wire mode. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_m_g_object.html#ad422cfd57a3a6daedd7762001cb04a8f">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="a8a4ec4196e32253e8137d236deb85280"></a><!-- doxytag: member="MGEdge::equal_direction_to_binder" ref="a8a4ec4196e32253e8137d236deb85280" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEdge::equal_direction_to_binder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if SurfCurve of the edge has equal direction to binder edge's direction. </p>
<p>Returned is true if eaual, false if not. </p>

</div>
</div>
<a class="anchor" id="abc40def87eb21012321f9006aca0c984"></a><!-- doxytag: member="MGEdge::eval" ref="abc40def87eb21012321f9006aca0c984" args="(double t, size_t nderiv=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGEdge::eval </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderiv</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the nderiv's derivative at parameter t. </p>
<p>Evaluate of the curve's data. </p>

</div>
</div>
<a class="anchor" id="ac90e09aadd66158ead380a9481a09f04"></a><!-- doxytag: member="MGEdge::eval_star" ref="ac90e09aadd66158ead380a9481a09f04" args="(double t, size_t nderi=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_vector.html">MGVector</a> MGEdge::eval_star </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nderi</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the star curves of the edge at the point t. </p>
<p>When nderi=0, get a position of the surface at the boundary point t. The star curve is SurfCurve(face's surface, edge's curve). (The star curve has the same world coordinate with the binder curve's, but their direction may be opposite. The star curve has always the same direction as the loop.) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Parameter value of this parameter edge's curve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nderi</em>&nbsp;</td><td>Order of derivative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf8beb3a515962deebd4ee95d9f625e7"></a><!-- doxytag: member="MGEdge::free_neighbourhood" ref="acf8beb3a515962deebd4ee95d9f625e7" args="(size_t i, size_t j=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::free_neighbourhood </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>j</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free neighbourhood relation at j-th boundary's i-th pcell of this cell. </p>
<p>If start, j=0. If end, j=1. i must be always 0, since one boundary has only one cell. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#ab9878c2f88db479bdfd799de6201e1aa">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a7d3c778fb13a70cf4795f308f3fdbbad"></a><!-- doxytag: member="MGEdge::is_connected_and_same_direction" ref="a7d3c778fb13a70cf4795f308f3fdbbad" args="(bool start, const MGEdge &amp;edge2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEdge::is_connected_and_same_direction </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this edge's start point(when start=true) and edge2 is connected and their directions are the same. </p>
<p>When start=false, this edge's end point is tested. </p>

</div>
</div>
<a class="anchor" id="a18ed4b400c5e88e39618e705ed4bfe85"></a><!-- doxytag: member="MGEdge::is_free" ref="a18ed4b400c5e88e39618e705ed4bfe85" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MGEdge::is_free </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if this is a free edge. </p>
<p>Free edges are ones that do not have partner edges. </p>

</div>
</div>
<a class="anchor" id="abf2448ac34b4b24c70fca922f2695102"></a><!-- doxytag: member="MGEdge::join" ref="abf2448ac34b4b24c70fca922f2695102" args="(bool start, MGEdge *e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::join </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_edge.html">MGEdge</a> *&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect this and e2. </p>
<p>If start==true, start of this edge to end of e2; If start==false, end of this edge to start of e2; e2 must be a newed object, and the ownership is transfered to the system. </p>

</div>
</div>
<a class="anchor" id="a0eabd833117726c0626b47062d7961f1"></a><!-- doxytag: member="MGEdge::make_binder" ref="a0eabd833117726c0626b47062d7961f1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>* MGEdge::make_binder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a binder cell of this parameter cell. </p>
<p>Returned is the binder pointer generated by new. The binder has no geometry, only has binder and parameter cell relationship. </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a660e0dcb574bbd92a34075412ea8c9bb">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a6f7f2801e22972e8c3afa35c9eb37662"></a><!-- doxytag: member="MGEdge::make_binder_with_curve" ref="a6f7f2801e22972e8c3afa35c9eb37662" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::make_binder_with_curve </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a binder associated with the world curve rep. </p>
<p>Returned is the binder edge pointer. If the parameter edge had already the binder, make_binder_with_curve only returns the pointer. This edge must be a member of a loop that is a boundary of a face. </p>

</div>
</div>
<a class="anchor" id="aa13ae1fe3657c56272b748c141928028"></a><!-- doxytag: member="MGEdge::mid_point" ref="aa13ae1fe3657c56272b748c141928028" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGEdge::mid_point </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the mid point of this edge. </p>
<p>Mid point is the point of the paramete mid=(<a class="el" href="class_m_g_edge.html#a30c3397d98f60a2a7e9e37a96bb819c5" title="Obtain start parameter value of the edge.">param_s()</a>+param_e())*.5 </p>

</div>
</div>
<a class="anchor" id="a5441a5a5d2697bcf6d1c6bab5fd1c2fb"></a><!-- doxytag: member="MGEdge::neighbours" ref="a5441a5a5d2697bcf6d1c6bab5fd1c2fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="class_m_g_cell_n_b.html">MGCellNB</a>*&gt; MGEdge::neighbours </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain all the neighbours. </p>
<p>The neighbours do not contain this cell except when this cell is connected to this cell itself(closed cell). </p>

<p>Implements <a class="el" href="class_m_g_cell_n_b.html#a7b2d010eda4c20b53714e3341abde288">MGCellNB</a>.</p>

</div>
</div>
<a class="anchor" id="a5791b0f24dd013195dc6bab3d202d28d"></a><!-- doxytag: member="MGEdge::operator*" ref="a5791b0f24dd013195dc6bab3d202d28d" args="(const MGTransf &amp;tr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a> MGEdge::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_transf.html">MGTransf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換によってトランスフォームをおこないEdgeを生成する。 Transformation of the Edge by a <a class="el" href="class_m_g_transf.html" title="MGTransf represents a transformation of a space dimension.">MGTransf</a>. </p>

</div>
</div>
<a class="anchor" id="a2353ed0c4f197582148a72ed40c3c2a9"></a><!-- doxytag: member="MGEdge::operator*" ref="a2353ed0c4f197582148a72ed40c3c2a9" args="(double s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a> MGEdge::operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Edgeのスケーリングを行い，Edgeを作成する。 Scaling of the Edge by a double. </p>

</div>
</div>
<a class="anchor" id="a1ee074ac60d994b3f306f49d6394d806"></a><!-- doxytag: member="MGEdge::operator*" ref="a1ee074ac60d994b3f306f49d6394d806" args="(const MGMatrix &amp;mat) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a> MGEdge::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_matrix.html">MGMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>与えられた変換でEdgeの変換を行い，Edgeを作成する。 Transformation of the Edge by a matrix. </p>

</div>
</div>
<a class="anchor" id="ae518a0a33d1d3120872bdf5ffea60ad7"></a><!-- doxytag: member="MGEdge::operator/" ref="ae518a0a33d1d3120872bdf5ffea60ad7" args="(double s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a> MGEdge::operator/ </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complexのスケーリングを行い，Complexを作成する。 Scaling of the Complex by a double. </p>

</div>
</div>
<a class="anchor" id="ae09de1b977437d24048c0994cb21d3c4"></a><!-- doxytag: member="MGEdge::operator=" ref="ae09de1b977437d24048c0994cb21d3c4" args="(const MGGel &amp;gel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>&amp; MGEdge::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_gel.html">MGGel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gel2</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment. </p>
<p>When the leaf object of this and cell2 are not equal, this assignment does nothing. does not change binder and partner relation, does not change parent complex. </p>

<p>Reimplemented from <a class="el" href="class_m_g_gel.html#aab85ddb270fa73853e46437c2ff85df7">MGGel</a>.</p>

</div>
</div>
<a class="anchor" id="a6cb2592c4774c36eafe2e3a701c13848"></a><!-- doxytag: member="MGEdge::param_bcell" ref="a6cb2592c4774c36eafe2e3a701c13848" args="(double tp, const double *guess=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEdge::param_bcell </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>guess</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the parameter of the binder edge's curve that represent the same point as sp. </p>
<p>sp is a parameter value of this parameter edge. Let S() is the star(surface) of this edge, and fp() is the curve of this cell which is a boundary of S(). And fb() is the binder curve of this edge. Then S(fp(sp))=fb(param_bcell(sp)). This is a parameter edge and have the binder, and the parameter sp is a parameter of this cell's curve. If this does not have a binder, return -1. </p>

</div>
</div>
<a class="anchor" id="af4ff5e1c9740f77faac5b172188a0d36"></a><!-- doxytag: member="MGEdge::param_pcell" ref="af4ff5e1c9740f77faac5b172188a0d36" args="(double tb, const double *guess=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MGEdge::param_pcell </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>guess</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This must be a parameter edge. </p>
<p>Obtain the parameter of this parameter edge's curve that represent the same point as the binder edge's paramter tb. Let S() is the star(surface) of this edge, and fp() is the curve of this cell which is a boundary of S(). And fb() is the binder curve. Then S(fp(param_pcell(tb)))=fb(tb). This edge must have the binder edge, and the parameter tb is the parameter of the binder edge's curve. If this does not have a binder, return -1. </p>

</div>
</div>
<a class="anchor" id="a0215b00885e975948025fdd2baf42ff0"></a><!-- doxytag: member="MGEdge::partner_edges" ref="a0215b00885e975948025fdd2baf42ff0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="class_m_g_edge.html">MGEdge</a>*&gt; MGEdge::partner_edges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain partner edges. </p>
<p>Partners represent same world's(same cell's parameter) coordinates. Parameter edges' partners are parameter edges. Binder edges' partners are binder edges. The partners do not include this edge except when star cell is connected to the star cell itself(closed only by the star cell). </p>

</div>
</div>
<a class="anchor" id="a43fd002f18b63b5f45dd00e7c9dbb5d5"></a><!-- doxytag: member="MGEdge::pick_closest" ref="a43fd002f18b63b5f45dd00e7c9dbb5d5" args="(const MGStraight &amp;sl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_position.html">MGPosition</a> MGEdge::pick_closest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_straight.html">MGStraight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parameter value of the closest point from the straight to this object. </p>
<p>sl is the eye projection line whose direction is from yon to hither, and if sl had multiple intersection points, The closest point to the eye will be selected. </p>

<p>Reimplemented from <a class="el" href="class_m_g_object.html#afad70053cb311ff1a2a7ab86b9a4e1a7">MGObject</a>.</p>

</div>
</div>
<a class="anchor" id="a0a7db48c748912d5eb6d19a71bb344bc"></a><!-- doxytag: member="MGEdge::polygonize" ref="a0a7db48c748912d5eb6d19a71bb344bc" args="(double error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::polygonize </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>error</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximate the parameter edge by a polyline and replace this edge expression by the polyline. </p>
<p>Polyline approximation is so done that the correspoinding binder edge can be appximated by the polyline connecting each binder edge's point that corresponds to the each this edge's point. (1) This must be a parameter cell edge. (2) This edge must be a member of a loop which is a boundary of a face. (3) If this edge did not have a binder edge, polygonize generates the binder edge. (The tolerance used to generate the binder is <a class="el" href="class_m_g_tolerance.html#a10b55492588f36f67c17352ef77ae08f" title="Return m_line_zero. m_line_zeroを返却する。.">MGTolerance::line_zero()</a>, not input error.) Input error is tolerance allowed between the polygon and the original curve. </p>

</div>
</div>
<a class="anchor" id="a5ca590ed1b9bd945621e579d670d2603"></a><!-- doxytag: member="MGEdge::pre_edge" ref="a5ca590ed1b9bd945621e579d670d2603" args="(bool at_start=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::pre_edge </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>at_start</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get previous edge in the loop sequence. </p>
<p>The pre_edge is the first neighbour edge. </p>

</div>
</div>
<a class="anchor" id="aebc48c3c8e57174184f31d051f05500e"></a><!-- doxytag: member="MGEdge::set_binder_edge" ref="aebc48c3c8e57174184f31d051f05500e" args="(MGCurve *wcrv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::set_binder_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_g_curve.html">MGCurve</a> *&nbsp;</td>
          <td class="paramname"> <em>wcrv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These forms give the ownership of wcrv to the edge. </p>
<p>That is, wcrv must be newed one and users must not delete it. Others are same as above "set_binder_edge(const MGCurve&amp; wcrv)" form. Function return value is the binder's pointer generated. </p>

</div>
</div>
<a class="anchor" id="a022ee59817f4e33bc1bb2f69b2ccfe83"></a><!-- doxytag: member="MGEdge::set_binder_edge" ref="a022ee59817f4e33bc1bb2f69b2ccfe83" args="(const MGCurve &amp;wcrv) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_edge.html">MGEdge</a>* MGEdge::set_binder_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_g_curve.html">MGCurve</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>wcrv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set binder cell edge to this parameter cell. </p>
<p>This curve's coordinates are of parameter space of a face. And input crv's coordinates are world coordinate of the face. range is the parameter range of wcrv. Parameter range of the wcrv is from start to end of the wcrv when no range is specified. Function return value is the binder's pointer generated. </p>

</div>
</div>
<a class="anchor" id="a260157cf1c33565f7f315e86877158bd"></a><!-- doxytag: member="MGEdge::set_i_th_binder" ref="a260157cf1c33565f7f315e86877158bd" args="(size_t i, MGBVertex &amp;binder) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::set_i_th_binder </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_g_b_vertex.html">MGBVertex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>binder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parameter value of the start point. </p>
<p>Set binder relation to m_vertex[i]. i is 0 for the start of the edge, and is 1 for the end. </p>

</div>
</div>
<a class="anchor" id="a79bdedcfbfa7e01c90e41fa7a253270b"></a><!-- doxytag: member="MGEdge::set_start" ref="a79bdedcfbfa7e01c90e41fa7a253270b" args="(double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::set_start </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parameter value of the start point. </p>
<p>Set start point(boundary) data. </p>

</div>
</div>
<a class="anchor" id="af5dfea419abb78abf95eca2544565ce8"></a><!-- doxytag: member="MGEdge::star_surface" ref="af5dfea419abb78abf95eca2544565ce8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_g_surface.html">MGSurface</a>* MGEdge::star_surface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain star surface. </p>
<p>Star cell of this must be a face. If not, return null. If does not have star surface, returns null. </p>

</div>
</div>
<a class="anchor" id="ad515b7ace21bf08de7d2364db5d43e68"></a><!-- doxytag: member="MGEdge::surface_perimeter" ref="ad515b7ace21bf08de7d2364db5d43e68" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MGEdge::surface_perimeter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the perimeter number where this edge is on. </p>
<p>If this is not on any perimeter, -1 will be returned. </p>

</div>
</div>
<a class="anchor" id="a84576730fceb7791766e7ec552c34e2e"></a><!-- doxytag: member="MGEdge::trim" ref="a84576730fceb7791766e7ec552c34e2e" args="(double t, bool start)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MGEdge::trim </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trim the edge at parameter t. </p>
<p>When start=true, trim start, and the result is from t to end. When start=false, trim end, and the result is from start to t. </p>

</div>
</div>
<a class="anchor" id="a9d4f3ee4298e00a65b057eba735608b5"></a><!-- doxytag: member="MGEdge::world_curve" ref="a9d4f3ee4298e00a65b057eba735608b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_g_curve.html">MGCurve</a>* MGEdge::world_curve </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return world curve pointer of this edge. </p>
<p>That is, curve pointer of this edge's binder edge. May be null when no binder, or the binder does not have an extent. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a7cfefbc0e7fe8f6c6ca35539e390ea04"></a><!-- doxytag: member="MGEdge::operator*" ref="a7cfefbc0e7fe8f6c6ca35539e390ea04" args="(double s, const MGEdge &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MGDECL friend <a class="el" href="class_m_g_edge.html">MGEdge</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_g_edge.html">MGEdge</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Edgeのスケーリングを行い，Edgeを作成する。 Scaling of the Edge by a double. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Edge.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 12 2011 10:43:20 for MGCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.0 </small></address>
</body>
</html>
